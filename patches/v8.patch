Only in nw/v8: .git
diff -r -u --color up/v8/BUILD.gn nw/v8/BUILD.gn
--- up/v8/BUILD.gn	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/BUILD.gn	2025-05-14 18:41:13.300904227 +0000
@@ -54,7 +54,7 @@
   v8_deprecation_warnings = true
 
   # Enable compiler warnings when using V8_DEPRECATE_SOON apis.
-  v8_imminent_deprecation_warnings = true
+  v8_imminent_deprecation_warnings = false
 
   # Embeds the given script into the snapshot.
   v8_embed_script = ""
@@ -324,9 +324,9 @@
                                arm_control_flow_integrity != "none")
 
   # Enable heap reservation of size 4GB. Only possible for 64bit archs.
-  cppgc_enable_caged_heap =
-      v8_current_cpu == "x64" || v8_current_cpu == "arm64" ||
-      v8_current_cpu == "loong64" || v8_current_cpu == "riscv64"
+  cppgc_enable_caged_heap = false
+  #    v8_current_cpu == "x64" || v8_current_cpu == "arm64" ||
+  #    v8_current_cpu == "loong64" || v8_current_cpu == "riscv64"
 
   # Enables additional heap verification phases and checks.
   cppgc_enable_verify_heap = ""
@@ -340,7 +340,7 @@
 
   # Enable the V8 sandbox.
   # Sets -DV8_ENABLE_SANDBOX.
-  v8_enable_sandbox = ""
+  v8_enable_sandbox = false
 
   # Enable leaptiering
   v8_enable_leaptiering = true
@@ -378,7 +378,7 @@
   v8_enable_map_packing = false
 
   # Allow for JS promise hooks (instead of just C++).
-  v8_enable_javascript_promise_hooks = false
+  v8_enable_javascript_promise_hooks = true
 
   # Allow embedder data to be saved on continuations. Used to support
   # TaskAttribution and `scheduler.yield()`.
@@ -399,7 +399,7 @@
   # Enable legacy mode for ScriptOrModule's lifetime. By default it's a
   # temporary object, if enabled it will be kept alive by the parent Script.
   # This is only used by nodejs.
-  v8_scriptormodule_legacy_lifetime = false
+  v8_scriptormodule_legacy_lifetime = true
 
   # WebAssembly interpreter (DrumBrake)  build flag.
   v8_enable_drumbrake = false
@@ -858,7 +858,7 @@
 
 config("internal_config") {
   defines = []
-
+  cflags = []
   # Only targets in this file and its subdirs can depend on this.
   visibility = [ "./*" ]
 
@@ -871,7 +871,8 @@
 
   if (is_component_build) {
     defines += [ "BUILDING_V8_SHARED_PRIVATE" ]
-  } else if (v8_expose_public_symbols) {
+  } #else if (v8_expose_public_symbols) {
+  if (true) {
     defines += [ "BUILDING_V8_SHARED" ]
   }
 
@@ -880,6 +881,10 @@
       libs = [ "atomic" ]
     }
   }
+
+  if (is_win) {
+    cflags += [ "/Zc:dllexportInlines-" ]
+  }
 }
 
 # Should be applied to all targets that write trace events.
@@ -896,14 +901,14 @@
 # This config should be applied to code using the libplatform.
 config("libplatform_config") {
   include_dirs = [ "include" ]
-  if (is_component_build) {
+  if (false) {
     defines = [ "USING_V8_PLATFORM_SHARED" ]
   }
 }
 
 # This config should be applied to code using the libbase.
 config("libbase_config") {
-  if (is_component_build) {
+  if (false) {
     defines = [ "USING_V8_BASE_SHARED" ]
   }
   libs = []
@@ -951,7 +956,10 @@
     defines += [
       "USING_V8_SHARED",
       "USING_V8_SHARED_PRIVATE",
+      "V8_SHARED", "USING_V8_PLATFORM_SHARED"
     ]
+  } else {
+    defines += [ "V8_SHARED" ]
   }
 
   if (current_cpu == "riscv64" || current_cpu == "riscv32") {
@@ -1125,7 +1133,7 @@
   # Pointer compression regresses binary size on Fuchsia by about 300K.
   # However, the change improves Oilpan memory by 15-20% (2-4% of PMF),
   # which is beneficial for memory-impoverished platforms.
-  cppgc_enable_pointer_compression = true
+  cppgc_enable_pointer_compression = false
 }
 if (cppgc_enable_young_generation) {
   enabled_external_cppgc_defines += [ "CPPGC_YOUNG_GENERATION" ]
@@ -2943,6 +2951,8 @@
   visibility = [
     ":*",
     "test/cctest:*",
+    "//tools/v8_context_snapshot:*",
+    "//chrome:*",
   ]
 
   allow_circular_includes_from = [ ":torque_generated_initializers" ]
@@ -6473,7 +6483,8 @@
   ]
 }
 
-v8_component("v8_libbase") {
+v8_static_lib("v8_libbase") {
+
   sources = [
     "src/base/abort-mode.cc",
     "src/base/abort-mode.h",
@@ -6641,7 +6652,7 @@
 
   defines = []
 
-  if (is_component_build) {
+  if (false) {
     defines = [ "BUILDING_V8_BASE_SHARED" ]
   }
 
@@ -6805,7 +6816,7 @@
   }
 }
 
-v8_component("v8_libplatform") {
+v8_static_lib("v8_libplatform") {
   sources = [
     "include/libplatform/libplatform-export.h",
     "include/libplatform/libplatform.h",
@@ -6838,7 +6849,7 @@
 
   configs = [ ":internal_config_base" ]
 
-  if (is_component_build) {
+  if (true) {
     defines = [ "BUILDING_V8_PLATFORM_SHARED" ]
   }
 
@@ -7283,6 +7294,25 @@
 ###############################################################################
 # Executables
 #
+v8_executable("nwjc") {
+
+    sources = [
+      "src/nwjc.cc",
+    ]
+
+    configs = [
+      ":internal_config",
+    ]
+
+    deps = [
+      ":v8_base",
+      ":v8_libplatform",
+      ":v8_libbase",
+      ":v8_snapshot",
+      ":v8_initializers",
+      "//build/win:default_exe_manifest",
+    ]
+}
 
 if (current_toolchain == v8_generator_toolchain) {
   v8_executable("bytecode_builtins_list_generator") {
diff -r -u --color up/v8/gni/v8.gni nw/v8/gni/v8.gni
--- up/v8/gni/v8.gni	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/gni/v8.gni	2025-05-14 18:41:13.302904232 +0000
@@ -209,7 +209,7 @@
 # Chromium is configured to use the perfetto client library, v8 should also
 # use perfetto for tracing.
 if (build_with_chromium) {
-  v8_use_perfetto = true
+  v8_use_perfetto = false
 }
 
 # Includes profiles to optimize builtins if
@@ -362,6 +362,15 @@
   }
 }
 
+template("v8_static_lib") {
+  static_library(target_name) {
+    forward_variables_from(invoker, "*", [ "configs" ])
+    configs += invoker.configs
+    configs -= v8_remove_configs
+    configs += v8_add_configs
+  }
+}
+
 template("v8_executable") {
   if (is_ios) {
     import("//build/config/ios/rules.gni")
Only in nw/v8: gypfiles
diff -r -u --color up/v8/include/libplatform/v8-tracing.h nw/v8/include/libplatform/v8-tracing.h
--- up/v8/include/libplatform/v8-tracing.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/libplatform/v8-tracing.h	2025-05-14 18:41:13.306904243 +0000
@@ -33,7 +33,7 @@
 
 const int kTraceMaxNumArgs = 2;
 
-class V8_PLATFORM_EXPORT TraceObject {
+class V8_EXPORT TraceObject {
  public:
   union ArgValue {
     uint64_t as_uint;
@@ -44,7 +44,7 @@
   };
 
   TraceObject() = default;
-  ~TraceObject();
+  ~TraceObject() { delete[] parameter_copy_storage_; }
   void Initialize(
       char phase, const uint8_t* category_enabled_flag, const char* name,
       const char* scope, uint64_t id, uint64_t bind_id, int num_args,
diff -r -u --color up/v8/include/v8-array-buffer.h nw/v8/include/v8-array-buffer.h
--- up/v8/include/v8-array-buffer.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8-array-buffer.h	2025-05-14 18:41:13.306904243 +0000
@@ -181,7 +181,8 @@
      * while kReservation is for larger allocations with the ability to set
      * access permissions.
      */
-    enum class AllocationMode { kNormal, kReservation };
+    enum class AllocationMode { kNormal, kReservation, kNodeJS };
+    virtual void Free(void* data, size_t length, AllocationMode mode);
 
     /**
      * Returns page allocator used by this Allocator instance.
@@ -268,6 +269,8 @@
    */
   static Local<ArrayBuffer> New(Isolate* isolate,
                                 std::shared_ptr<BackingStore> backing_store);
+  static Local<ArrayBuffer> NewNode(Isolate* isolate,
+                                std::shared_ptr<BackingStore> backing_store);
 
   /**
    * Returns a new standalone BackingStore that is allocated using the array
@@ -339,6 +342,8 @@
       "ok).")
   void Detach();
 
+  void set_nodejs(bool);
+
   /**
    * Detaches this ArrayBuffer and all its views (typed arrays).
    * Detaching sets the byte length of the buffer and all typed arrays to zero,
diff -r -u --color up/v8/include/v8-debug.h nw/v8/include/v8-debug.h
--- up/v8/include/v8-debug.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8-debug.h	2025-05-14 18:41:13.307904246 +0000
@@ -136,6 +136,8 @@
     kDetailed = kOverview | kIsEval | kIsConstructor | kScriptNameOrSourceURL
   };
 
+  V8_DEPRECATED("Use Isolate version")
+                Local<StackFrame> GetFrame(uint32_t index) const;
   /**
    * Returns the (unique) ID of this stack trace.
    */
diff -r -u --color up/v8/include/v8-initialization.h nw/v8/include/v8-initialization.h
--- up/v8/include/v8-initialization.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8-initialization.h	2025-05-14 18:41:13.308904248 +0000
@@ -174,6 +174,7 @@
    */
   static bool InitializeICUDefaultLocation(const char* exec_path,
                                            const char* icu_data_file = nullptr);
+  static void* RawICUData();
 
   /**
    * Initialize the external startup data. The embedder only needs to
diff -r -u --color up/v8/include/v8-isolate.h nw/v8/include/v8-isolate.h
--- up/v8/include/v8-isolate.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8-isolate.h	2025-05-14 18:41:13.308904248 +0000
@@ -273,6 +273,7 @@
  */
 class V8_EXPORT Isolate {
  public:
+  ArrayBuffer::Allocator* array_buffer_allocator();
   /**
    * Initial configuration parameters for a new Isolate.
    */
@@ -361,6 +362,7 @@
     CppHeap* cpp_heap = nullptr;
   };
 
+  void SetArrayBufferAllocatorShared(std::shared_ptr<ArrayBuffer::Allocator> allocator);
   /**
    * Stack-allocated class which sets the isolate for all operations
    * executed within a local scope.
@@ -1187,6 +1189,28 @@
    */
   void SetEmbedderRootsHandler(EmbedderRootsHandler* handler);
 
+  /**
+   * Attaches a managed C++ heap as an extension to the JavaScript heap. The
+   * embedder maintains ownership of the CppHeap. At most one C++ heap can be
+   * attached to V8.
+   *
+   * Multi-threaded use requires the use of v8::Locker/v8::Unlocker, see
+   * CppHeap.
+   *
+   * If a CppHeap is set via CreateParams, then this call is a noop.
+   */
+  V8_DEPRECATED("Set the heap on Isolate creation using CreateParams instead.")
+  void AttachCppHeap(CppHeap*);
+
+  /**
+   * Detaches a managed C++ heap if one was attached using `AttachCppHeap()`.
+   *
+   * If a CppHeap is set via CreateParams, then this call is a noop.
+   */
+  V8_DEPRECATED(
+      "The CppHeap gets detached automatically during Isolate tear down.")
+  void DetachCppHeap();
+
   using ReleaseCppHeapCallback = void (*)(std::unique_ptr<CppHeap>);
 
   /**
diff -r -u --color up/v8/include/v8-platform.h nw/v8/include/v8-platform.h
--- up/v8/include/v8-platform.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8-platform.h	2025-05-14 18:41:13.309904251 +0000
@@ -1383,6 +1383,7 @@
       TaskPriority priority, std::unique_ptr<Task> task,
       double delay_in_seconds, const SourceLocation& location) = 0;
 };
+void V8_EXPORT SetTLSPlatform(Platform* platform);
 
 }  // namespace v8
 
diff -r -u --color up/v8/include/v8-primitive-object.h nw/v8/include/v8-primitive-object.h
--- up/v8/include/v8-primitive-object.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8-primitive-object.h	2025-05-14 18:41:13.309904251 +0000
@@ -78,6 +78,8 @@
  */
 class V8_EXPORT StringObject : public Object {
  public:
+  V8_DEPRECATED("Use Isolate* version") static
+                       Local<Value> New(Local<String> value);
   static Local<Value> New(Isolate* isolate, Local<String> value);
 
   Local<String> ValueOf() const;
diff -r -u --color up/v8/include/v8-primitive.h nw/v8/include/v8-primitive.h
--- up/v8/include/v8-primitive.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8-primitive.h	2025-05-14 18:41:13.309904251 +0000
@@ -69,6 +69,9 @@
     return reinterpret_cast<PrimitiveArray*>(data);
   }
 
+  V8_DEPRECATED("Use Isolate version")
+                void Set(int index, Local<Primitive> item);
+  V8_DEPRECATED("Use Isolate version") Local<Primitive> Get(int index);
  private:
   static void CheckCast(Data* obj);
 };
@@ -140,6 +143,8 @@
    * Returns the number of bytes in the UTF-8 encoded
    * representation of this string.
    */
+  V8_DEPRECATED("Use Isolate version instead") int Utf8Length() const;
+
   V8_DEPRECATED("Use Utf8LengthV2 instead.")
   int Utf8Length(Isolate* isolate) const;
 
@@ -203,10 +208,17 @@
   V8_DEPRECATED("Use WriteV2 instead.")
   int Write(Isolate* isolate, uint16_t* buffer, int start = 0, int length = -1,
             int options = NO_OPTIONS) const;
+  V8_DEPRECATED("Use Isolate* version")
+                int Write(uint16_t* buffer, int start = 0, int length = -1,
+                          int options = NO_OPTIONS) const;
   // One byte characters.
   V8_DEPRECATED("Use WriteOneByteV2 instead.")
   int WriteOneByte(Isolate* isolate, uint8_t* buffer, int start = 0,
                    int length = -1, int options = NO_OPTIONS) const;
+  V8_DEPRECATED("Use Isolate* version")
+                int WriteOneByte(uint8_t* buffer, int start = 0,
+                                 int length = -1, int options = NO_OPTIONS)
+                    const;
   // UTF-8 encoded characters.
   V8_DEPRECATED("Use WriteUtf8V2 instead.")
   int WriteUtf8(Isolate* isolate, char* buffer, int length = -1,
@@ -266,6 +278,10 @@
                      int flags = WriteFlags::kNone,
                      size_t* processed_characters_return = nullptr) const;
 
+  V8_DEPRECATED("Use Isolate* version")
+                int WriteUtf8(char* buffer, int length = -1,
+                              int* nchars_ref = NULL, int options = NO_OPTIONS)
+                    const;
   /**
    * A zero length string.
    */
@@ -555,6 +571,9 @@
   static Local<String> Concat(Isolate* isolate, Local<String> left,
                               Local<String> right);
 
+  V8_DEPRECATED("Use Isolate* version") static
+                       Local<String> Concat(Local<String> left,
+                                            Local<String> right);
   /**
    * Creates a new external string using the data defined in the given
    * resource. When the external string is no longer live on V8's heap the
@@ -647,6 +666,8 @@
    */
   class V8_EXPORT Utf8Value {
    public:
+   V8_DEPRECATED("Use Isolate version")
+                  explicit Utf8Value(Local<v8::Value> obj);
     Utf8Value(Isolate* isolate, Local<v8::Value> obj,
               WriteOptions options = REPLACE_INVALID_UTF8);
     ~Utf8Value();
@@ -678,6 +699,7 @@
     V8_DEPRECATE_SOON(
         "Prefer using String::ValueView if you can, or string->Write to a "
         "buffer if you cannot.")
+   V8_DEPRECATED("Use Isolate version") explicit Value(Local<v8::Value> obj);
     Value(Isolate* isolate, Local<v8::Value> obj);
     ~Value();
     uint16_t* operator*() { return str_; }
diff -r -u --color up/v8/include/v8-script.h nw/v8/include/v8-script.h
--- up/v8/include/v8-script.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8-script.h	2025-05-14 18:41:13.310904254 +0000
@@ -757,6 +757,7 @@
       CompileOptions options = kNoCompileOptions,
       NoCacheReason no_cache_reason = kNoCacheNoReason);
 
+  static MaybeLocal<Module> CompileModuleWithCache(Isolate* isolate, Source* source);
   /**
    * Returns a task which streams script data into V8, or NULL if the script
    * cannot be streamed. The user is responsible for running the task on a
@@ -947,6 +948,9 @@
   return reinterpret_cast<Module*>(data);
 }
 
+void V8_EXPORT FixSourceNWBin(Isolate* v8_isolate, Local<UnboundScript> script);
+void V8_EXPORT FixSourceNWBin(Isolate* v8_isolate, Local<Module> module);
+
 }  // namespace v8
 
 #endif  // INCLUDE_V8_SCRIPT_H_
diff -r -u --color up/v8/include/v8-value.h nw/v8/include/v8-value.h
--- up/v8/include/v8-value.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8-value.h	2025-05-14 18:41:13.311904256 +0000
@@ -436,6 +436,10 @@
    */
   Local<Boolean> ToBoolean(Isolate* isolate) const;
 
+  V8_DEPRECATED("Use maybe version") Local<Boolean> ToBoolean() const;
+  V8_DEPRECATED("Use maybe version") Local<String> ToString() const;
+  V8_DEPRECATED("Use maybe version") Local<Object> ToObject() const;
+  V8_DEPRECATED("Use maybe version") Local<Integer> ToInteger() const;
   /**
    * Attempts to convert a string to an array index.
    * Returns an empty handle if the conversion fails.
@@ -457,7 +461,14 @@
   /** Returns the equivalent of `ToInt32()->Value()`. */
   V8_WARN_UNUSED_RESULT Maybe<int32_t> Int32Value(Local<Context> context) const;
 
+  V8_DEPRECATED("Use maybe version") bool BooleanValue() const;
+  V8_DEPRECATED("Use maybe version") double NumberValue() const;
+  V8_DEPRECATED("Use maybe version") int64_t IntegerValue() const;
+  V8_DEPRECATED("Use maybe version") uint32_t Uint32Value() const;
+  V8_DEPRECATED("Use maybe version") int32_t Int32Value() const;
+
   /** JS == */
+  V8_DEPRECATED("Use maybe version") bool Equals(Local<Value> that) const;
   V8_WARN_UNUSED_RESULT Maybe<bool> Equals(Local<Context> context,
                                            Local<Value> that) const;
   bool StrictEquals(Local<Value> that) const;
diff -r -u --color up/v8/include/v8-wasm.h nw/v8/include/v8-wasm.h
--- up/v8/include/v8-wasm.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8-wasm.h	2025-05-14 18:41:13.311904256 +0000
@@ -122,6 +122,9 @@
   static void CheckCast(Value* obj);
 };
 
+V8_DEPRECATED("Use WasmModuleObject")
+              typedef WasmModuleObject WasmCompiledModule;
+
 /**
  * The V8 interface for WebAssembly streaming compilation. When streaming
  * compilation is initiated, V8 passes a {WasmStreaming} object to the embedder
diff -r -u --color up/v8/include/v8config.h nw/v8/include/v8config.h
--- up/v8/include/v8config.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/include/v8config.h	2025-05-14 18:41:13.311904256 +0000
@@ -385,7 +385,7 @@
          && !defined(_WIN32)))                         /* not on windows */    \
      && !defined(COMPONENT_BUILD)                      /* no component build */\
      && __clang_major__ >= 17                          /* clang >= 17 */
-# define V8_HAS_ATTRIBUTE_PRESERVE_MOST (__has_attribute(preserve_most))
+//# define V8_HAS_ATTRIBUTE_PRESERVE_MOST (__has_attribute(preserve_most))
 #endif
 # define V8_HAS_ATTRIBUTE_VISIBILITY (__has_attribute(visibility))
 # define V8_HAS_ATTRIBUTE_WARN_UNUSED_RESULT \
diff -r -u --color up/v8/src/api/api.cc nw/v8/src/api/api.cc
--- up/v8/src/api/api.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/api/api.cc	2025-05-14 18:41:13.315904267 +0000
@@ -188,6 +188,31 @@
 namespace v8 {
 
 static OOMErrorCallback g_oom_error_callback = nullptr;
+namespace {
+
+// TODO(delphick): Remove this completely when the deprecated functions that use
+// it are removed.
+// DO NOT USE THIS IN NEW CODE!
+i::Isolate* UnsafeIsolateFromHeapObject(i::Handle<i::HeapObject> obj) {
+  // Use MemoryChunk directly instead of Isolate::FromWritableHeapObject to
+  // temporarily allow isolate access from read-only space objects.
+  i::MemoryChunkMetadata* chunk = i::MemoryChunkMetadata::FromHeapObject(*obj);
+  return chunk->heap()->isolate();
+}
+
+// TODO(delphick): Remove this completely when the deprecated functions that use
+// it are removed.
+// DO NOT USE THIS IN NEW CODE!
+Local<Context> UnsafeContextFromHeapObject(i::Handle<i::Object> obj) {
+  // Use MemoryChunk directly instead of Isolate::FromWritableHeapObject to
+  // temporarily allow isolate access from read-only space objects.
+  i::MemoryChunkMetadata* chunk =
+    i::MemoryChunkMetadata::FromHeapObject(i::Cast<i::HeapObject>(*obj));
+  return reinterpret_cast<Isolate*>(chunk->heap()->isolate())
+      ->GetCurrentContext();
+}
+
+}  // namespace
 
 static ScriptOrigin GetScriptOriginForScript(
     i::Isolate* i_isolate, i::DirectHandle<i::Script> script) {
@@ -301,6 +326,11 @@
   i::V8::SetSnapshotBlob(snapshot_blob);
 }
 
+void v8::ArrayBuffer::Allocator::Free(void* data, size_t length,
+                                      AllocationMode mode) {
+  UNIMPLEMENTED();
+}
+
 namespace {
 
 #ifdef V8_ENABLE_SANDBOX
@@ -2067,6 +2097,12 @@
   array->set(index, *Utils::OpenDirectHandle(*item));
 }
 
+void PrimitiveArray::Set(int index, Local<Primitive> item) {
+  i::Handle<i::FixedArray> array = Utils::OpenHandle(this);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(array);
+  Set(reinterpret_cast<Isolate*>(isolate), index, item);
+}
+
 Local<Primitive> PrimitiveArray::Get(Isolate* v8_isolate, int index) {
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
   auto array = Utils::OpenDirectHandle(this);
@@ -2119,6 +2155,12 @@
       i::direct_handle(self->import_attributes(), i_isolate));
 }
 
+Local<Primitive> PrimitiveArray::Get(int index) {
+  i::Handle<i::FixedArray> array = Utils::OpenHandle(this);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(array);
+  return Get(reinterpret_cast<Isolate*>(isolate), index);
+}
+
 Module::Status Module::GetStatus() const {
   auto self = Utils::OpenDirectHandle(this);
   switch (self->status()) {
@@ -2478,6 +2520,21 @@
   return ToApiHandle<Module>(i_isolate->factory()->NewSourceTextModule(shared));
 }
 
+MaybeLocal<Module> ScriptCompiler::CompileModuleWithCache(Isolate* isolate,
+                                                          Source* source) {
+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
+
+  Utils::ApiCheck(source->GetResourceOptions().IsModule(),
+                  "v8::ScriptCompiler::CompileModule",
+                  "Invalid ScriptOrigin: is_module must be true");
+  auto maybe = CompileUnboundInternal(isolate, source, kConsumeCodeCache, kNoCacheNoReason);
+  Local<UnboundScript> unbound;
+  if (!maybe.ToLocal(&unbound)) return MaybeLocal<Module>();
+
+  i::Handle<i::SharedFunctionInfo> shared = Utils::OpenHandle(*unbound);
+  return ToApiHandle<Module>(i_isolate->factory()->NewSourceTextModule(shared));
+}
+
 // static
 V8_WARN_UNUSED_RESULT MaybeLocal<Function> ScriptCompiler::CompileFunction(
     Local<Context> v8_context, Source* source, size_t arguments_count,
@@ -3067,6 +3124,11 @@
       i::direct_handle(self->get(index), i_isolate));
 }
 
+Local<StackFrame> StackTrace::GetFrame(uint32_t index) const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return GetFrame(reinterpret_cast<Isolate*>(isolate), index);
+}
+
 int StackTrace::GetFrameCount() const {
   auto self = Utils::OpenDirectHandle(this);
   return self->length();
@@ -3097,8 +3159,8 @@
   i::Isolate* i_isolate = self->GetIsolate();
   i::DirectHandle<i::Script> script(self->script(), i_isolate);
   i::Script::PositionInfo info;
-  CHECK(i::Script::GetPositionInfo(
-      script, i::StackFrameInfo::GetSourcePosition(self), &info));
+  i::Script::GetPositionInfo(
+     script, i::StackFrameInfo::GetSourcePosition(self), &info);
   if (script->HasSourceURLComment()) {
     info.line -= script->line_offset();
     if (info.line == 0) {
@@ -3488,6 +3550,25 @@
 
 // --- D a t a ---
 
+Local<Boolean> Value::ToBoolean() const {
+  return ToBoolean(Isolate::GetCurrent());
+}
+
+Local<String> Value::ToString() const {
+  return ToString(Isolate::GetCurrent()->GetCurrentContext())
+      .FromMaybe(Local<String>());
+}
+
+Local<Object> Value::ToObject() const {
+  return ToObject(Isolate::GetCurrent()->GetCurrentContext())
+      .FromMaybe(Local<Object>());
+}
+
+Local<Integer> Value::ToInteger() const {
+  return ToInteger(Isolate::GetCurrent()->GetCurrentContext())
+      .FromMaybe(Local<Integer>());
+}
+
 bool Value::FullIsUndefined() const {
   bool result = i::IsUndefined(*Utils::OpenDirectHandle(this));
   DCHECK_EQ(result, QuickIsUndefined());
@@ -4169,6 +4250,15 @@
                   "Value is not a RegExp");
 }
 
+bool Value::BooleanValue() const {
+  auto obj = Utils::OpenHandle(this);
+  if (i::IsSmi(*obj)) return *obj != i::Smi::zero();
+  DCHECK(obj->IsHeapObject());
+  i::Isolate* isolate =
+      UnsafeIsolateFromHeapObject(i::Cast<i::HeapObject>(obj));
+  return i::Object::BooleanValue(*obj, isolate);
+}
+
 Maybe<double> Value::NumberValue(Local<Context> context) const {
   auto obj = Utils::OpenDirectHandle(this);
   if (i::IsNumber(*obj)) {
@@ -4182,6 +4272,13 @@
   return Just(i::Object::NumberValue(*num));
 }
 
+double Value::NumberValue() const {
+  auto obj = Utils::OpenHandle(this);
+  if (i::IsNumber(*obj)) return i::Object::NumberValue(*obj);
+  return NumberValue(UnsafeContextFromHeapObject(obj))
+      .FromMaybe(std::numeric_limits<double>::quiet_NaN());
+}
+
 Maybe<int64_t> Value::IntegerValue(Local<Context> context) const {
   auto obj = Utils::OpenDirectHandle(this);
   if (i::IsNumber(*obj)) {
@@ -4195,6 +4292,18 @@
   return Just(NumberToInt64(*num));
 }
 
+int64_t Value::IntegerValue() const {
+  auto obj = Utils::OpenHandle(this);
+  if (i::IsNumber(*obj)) {
+    if (i::IsSmi(*obj)) {
+      return i::Smi::ToInt(*obj);
+    } else {
+      return static_cast<int64_t>(i::Object::NumberValue(*obj));
+    }
+  }
+  return IntegerValue(UnsafeContextFromHeapObject(obj)).FromMaybe(0);
+}
+
 Maybe<int32_t> Value::Int32Value(Local<Context> context) const {
   auto obj = Utils::OpenDirectHandle(this);
   if (i::IsNumber(*obj)) return Just(NumberToInt32(*obj));
@@ -4208,6 +4317,12 @@
                                 i::Cast<i::HeapNumber>(*num)->value()));
 }
 
+int32_t Value::Int32Value() const {
+  auto obj = Utils::OpenHandle(this);
+  if (i::IsNumber(*obj)) return NumberToInt32(*obj);
+  return Int32Value(UnsafeContextFromHeapObject(obj)).FromMaybe(0);
+}
+
 Maybe<uint32_t> Value::Uint32Value(Local<Context> context) const {
   auto obj = Utils::OpenDirectHandle(this);
   if (i::IsNumber(*obj)) return Just(NumberToUint32(*obj));
@@ -4221,6 +4336,12 @@
                                 i::Cast<i::HeapNumber>(*num)->value()));
 }
 
+uint32_t Value::Uint32Value() const {
+  auto obj = Utils::OpenHandle(this);
+  if (i::IsNumber(*obj)) return NumberToUint32(*obj);
+  return Uint32Value(UnsafeContextFromHeapObject(obj)).FromMaybe(0);
+}
+
 MaybeLocal<Uint32> Value::ToArrayIndex(Local<Context> context) const {
   auto self = Utils::OpenDirectHandle(this);
   if (i::IsSmi(*self)) {
@@ -4256,6 +4377,20 @@
   return result;
 }
 
+bool Value::Equals(Local<Value> that) const {
+  auto self = Utils::OpenHandle(this);
+  auto other = Utils::OpenHandle(*that);
+  if (i::IsSmi(*self) && i::IsSmi(*other)) {
+    return i::Object::NumberValue(*self) == i::Object::NumberValue(*other);
+  }
+  if (IsJSObject(*self) && IsJSObject(*other)) {
+    return *self == *other;
+  }
+  auto heap_object = i::IsSmi(*self) ? other : self;
+  auto context = UnsafeContextFromHeapObject(heap_object);
+  return Equals(context, that).FromMaybe(false);
+}
+
 bool Value::StrictEquals(Local<Value> that) const {
   auto self = Utils::OpenDirectHandle(this);
   auto other = Utils::OpenDirectHandle(*that);
@@ -5758,6 +5893,11 @@
   return helper.Check(*str);
 }
 
+int String::Utf8Length() const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return Utf8Length(reinterpret_cast<Isolate*>(isolate));
+}
+
 int String::Utf8Length(Isolate* v8_isolate) const {
   auto str = Utils::OpenDirectHandle(this);
   str = i::String::Flatten(reinterpret_cast<i::Isolate*>(v8_isolate), str);
@@ -5915,6 +6055,7 @@
 }
 }  // anonymous namespace
 
+
 int String::WriteUtf8(Isolate* v8_isolate, char* buffer, int capacity,
                       int* nchars_ref, int options) const {
   auto str = Utils::OpenDirectHandle(this);
@@ -5933,6 +6074,14 @@
   }
 }
 
+int String::WriteUtf8(char* buffer, int capacity, int* nchars_ref,
+                      int options) const {
+  i::Handle<i::String> str = Utils::OpenHandle(this);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(str);
+  return WriteUtf8(reinterpret_cast<Isolate*>(isolate), buffer, capacity,
+                   nchars_ref, options);
+}
+
 template <typename CharType>
 static inline int WriteHelper(i::Isolate* i_isolate, const String* string,
                               CharType* buffer, int start, int length,
@@ -5954,12 +6103,23 @@
   return write_length;
 }
 
+int String::WriteOneByte(uint8_t* buffer, int start, int length,
+                         int options) const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return WriteHelper(isolate, this, buffer, start, length, options);
+}
+
 int String::WriteOneByte(Isolate* v8_isolate, uint8_t* buffer, int start,
                          int length, int options) const {
   return WriteHelper(reinterpret_cast<i::Isolate*>(v8_isolate), this, buffer,
                      start, length, options);
 }
 
+int String::Write(uint16_t* buffer, int start, int length, int options) const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return WriteHelper(isolate, this, buffer, start, length, options);
+}
+
 int String::Write(Isolate* v8_isolate, uint16_t* buffer, int start, int length,
                   int options) const {
   return WriteHelper(reinterpret_cast<i::Isolate*>(v8_isolate), this, buffer,
@@ -6579,6 +6739,10 @@
   return i::InitializeICUDefaultLocation(exec_path, icu_data_file);
 }
 
+void* v8::V8::RawICUData() {
+  return i::RawICUData();
+}
+
 void v8::V8::InitializeExternalStartupData(const char* directory_path) {
   i::InitializeExternalStartupData(directory_path);
 }
@@ -7673,6 +7837,12 @@
   return Utils::ToLocal(result);
 }
 
+Local<String> v8::String::Concat(Local<String> left, Local<String> right) {
+  i::Handle<i::String> left_string = Utils::OpenHandle(*left);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(left_string);
+  return Concat(reinterpret_cast<Isolate*>(isolate), left, right);
+}
+
 MaybeLocal<String> v8::String::NewExternalTwoByte(
     Isolate* v8_isolate, v8::String::ExternalStringResource* resource) {
   CHECK(resource && resource->data());
@@ -7968,6 +8138,12 @@
   return i::IsTrue(js_primitive_wrapper->value(), i_isolate);
 }
 
+Local<v8::Value> v8::StringObject::New(Local<String> value) {
+  i::Handle<i::String> string = Utils::OpenHandle(*value);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(string);
+  return New(reinterpret_cast<Isolate*>(isolate), value);
+}
+
 Local<v8::Value> v8::StringObject::New(Isolate* v8_isolate,
                                        Local<String> value) {
   auto string = Utils::OpenDirectHandle(*value);
@@ -9202,6 +9378,25 @@
       static_cast<v8::BackingStore*>(backing_store.release()));
 }
 
+Local<ArrayBuffer> v8::ArrayBuffer::NewNode(
+    Isolate* isolate, std::shared_ptr<BackingStore> backing_store) {
+  CHECK_IMPLIES(backing_store->ByteLength() != 0,
+                backing_store->Data() != nullptr);
+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
+  API_RCS_SCOPE(i_isolate, ArrayBuffer, New);
+  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
+  std::shared_ptr<i::BackingStore> i_backing_store(
+      ToInternal(std::move(backing_store)));
+  Utils::ApiCheck(
+      !i_backing_store->is_shared(), "v8_ArrayBuffer_New",
+      "Cannot construct ArrayBuffer with a BackingStore of SharedArrayBuffer");
+  i_backing_store->set_nodejs(true);
+  i::Handle<i::JSArrayBuffer> obj =
+      i_isolate->factory()->NewJSArrayBuffer(std::move(i_backing_store));
+  obj->set_is_node_js(true);
+  return Utils::ToLocal(obj);
+}
+
 Local<ArrayBuffer> v8::ArrayBufferView::Buffer() {
   auto obj = Utils::OpenDirectHandle(this);
   i::Isolate* i_isolate = obj->GetIsolate();
@@ -9797,6 +9992,11 @@
   i_isolate->ClearKeptObjects();
 }
 
+ArrayBuffer::Allocator* Isolate::array_buffer_allocator() {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  return isolate->array_buffer_allocator();
+}
+
 v8::Local<v8::Context> Isolate::GetCurrentContext() {
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(this);
   i::Tagged<i::Context> context = i_isolate->context();
@@ -9912,6 +10112,16 @@
   i_isolate->heap()->SetEmbedderRootsHandler(handler);
 }
 
+void Isolate::AttachCppHeap(CppHeap* cpp_heap) {
+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(this);
+  i_isolate->heap()->AttachCppHeap(cpp_heap);
+}
+
+void Isolate::DetachCppHeap() {
+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(this);
+  i_isolate->heap()->DetachCppHeap();
+}
+
 CppHeap* Isolate::GetCppHeap() const {
   const i::Isolate* i_isolate = reinterpret_cast<const i::Isolate*>(this);
   return i_isolate->heap()->cpp_heap();
@@ -10024,6 +10234,13 @@
 
 Isolate::CreateParams::~CreateParams() = default;
 
+void Isolate::SetArrayBufferAllocatorShared(
+                                            std::shared_ptr<ArrayBuffer::Allocator> allocator) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  CHECK_EQ(allocator.get(), isolate->array_buffer_allocator());
+  isolate->set_array_buffer_allocator_shared(std::move(allocator));
+}
+
 // static
 // This is separate so that tests can provide a different |isolate|.
 void Isolate::Initialize(Isolate* v8_isolate,
@@ -11105,6 +11322,9 @@
   return microtask_queue->IsRunningMicrotasks();
 }
 
+String::Utf8Value::Utf8Value(v8::Local<v8::Value> obj)
+  : Utf8Value(Isolate::GetCurrent(), obj) {}
+
 String::Utf8Value::Utf8Value(v8::Isolate* v8_isolate, v8::Local<v8::Value> obj,
                              WriteOptions options)
     : str_(nullptr), length_(0) {
@@ -11126,6 +11346,9 @@
 
 String::Utf8Value::~Utf8Value() { i::DeleteArray(str_); }
 
+String::Value::Value(v8::Local<v8::Value> obj)
+  : Value(Isolate::GetCurrent(), obj) {}
+
 String::Value::Value(v8::Isolate* v8_isolate, v8::Local<v8::Value> obj)
     : str_(nullptr), length_(0) {
   if (obj.IsEmpty()) return;
@@ -12042,6 +12265,29 @@
 }
 #endif  // !V8_ENABLE_WEBASSEMBLY
 
+void SetTLSPlatform(Platform* platform) {
+  i::V8::SetTLSPlatform(platform);
+}
+
+void FixSourceNWBin(Isolate* v8_isolate, Local<UnboundScript> script) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  i::Handle<i::HeapObject> obj =
+    i::Cast<i::HeapObject>(v8::Utils::OpenHandle(*script));
+  i::Handle<i::SharedFunctionInfo>
+    function_info(i::Cast<i::SharedFunctionInfo>(*obj), isolate);
+  i::Handle<i::Script> iscript(i::Cast<i::Script>(function_info->script()),
+                              isolate);
+  iscript->set_source(i::ReadOnlyRoots(isolate).undefined_value());
+}
+
+void FixSourceNWBin(Isolate* v8_isolate, Local<Module> module) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  i::Handle<i::SourceTextModule> obj =
+    i::Cast<i::SourceTextModule>(v8::Utils::OpenHandle(*module));
+  i::Handle<i::Script> iscript(i::Cast<i::Script>(obj->GetScript()), isolate);
+  iscript->set_source(i::ReadOnlyRoots(isolate).undefined_value());
+}
+
 namespace internal {
 
 const size_t HandleScopeImplementer::kEnteredContextsOffset =
diff -r -u --color up/v8/src/codegen/compiler.cc nw/v8/src/codegen/compiler.cc
--- up/v8/src/codegen/compiler.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/codegen/compiler.cc	2025-05-14 18:41:13.369904413 +0000
@@ -3958,7 +3958,9 @@
     maybe_script = lookup_result.script();
     maybe_result = lookup_result.toplevel_sfi();
     is_compiled_scope = lookup_result.is_compiled_scope();
-    if (!maybe_result.is_null()) {
+    //NWJS#5168: will hit previous cache, use 0 source_length trick to
+    //bypass and try to consume cache
+    if (!maybe_result.is_null() && source->length()) {
       compile_timer.set_hit_isolate_cache();
     } else if (can_consume_code_cache) {
       compile_timer.set_consuming_code_cache();
diff -r -u --color up/v8/src/common/thread-local-storage.h nw/v8/src/common/thread-local-storage.h
--- up/v8/src/common/thread-local-storage.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/common/thread-local-storage.h	2025-05-14 18:41:13.392904475 +0000
@@ -7,7 +7,7 @@
 
 #include "include/v8config.h"
 
-#if defined(COMPONENT_BUILD) || defined(V8_TLS_USED_IN_LIBRARY)
+#if 1 //defined(COMPONENT_BUILD) || defined(V8_TLS_USED_IN_LIBRARY)
 #define V8_TLS_LIBRARY_MODE 1
 #else
 #define V8_TLS_LIBRARY_MODE 0
diff -r -u --color up/v8/src/debug/debug-scopes.cc nw/v8/src/debug/debug-scopes.cc
--- up/v8/src/debug/debug-scopes.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/debug/debug-scopes.cc	2025-05-14 18:41:13.453904640 +0000
@@ -313,7 +313,10 @@
   info_ = std::make_unique<ParseInfo>(isolate_, flags, &compile_state,
                                       reusable_compile_state_.get());
 
-  const bool parse_result =
+  bool has_source_code = shared_info->HasSourceCode();
+  bool parse_result = false;
+  if (has_source_code)
+    parse_result =
       flags.is_toplevel()
           ? parsing::ParseProgram(info_.get(), script, maybe_outer_scope,
                                   isolate_, parsing::ReportStatisticsMode::kNo)
diff -r -u --color up/v8/src/flags/flag-definitions.h nw/v8/src/flags/flag-definitions.h
--- up/v8/src/flags/flag-definitions.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/flags/flag-definitions.h	2025-05-14 18:41:13.478904708 +0000
@@ -2719,7 +2719,7 @@
     "Always move prototype transitions to the front of the tree")
 
 // parser.cc
-DEFINE_BOOL(allow_natives_syntax, false, "allow natives syntax")
+DEFINE_BOOL(allow_natives_syntax, true, "allow natives syntax")
 DEFINE_BOOL(allow_natives_for_differential_fuzzing, false,
             "allow only natives explicitly allowlisted for differential "
             "fuzzers")
@@ -3109,6 +3109,7 @@
             "and shipped")
 
 // Slow histograms are also enabled via --dump-counters in d8.
+DEFINE_BOOL(nw_module, false, "Whether the input file is a module")
 DEFINE_BOOL(slow_histograms, false,
             "Enable slow histograms with more overhead.")
 
diff -r -u --color up/v8/src/heap/cppgc-js/cpp-heap.cc nw/v8/src/heap/cppgc-js/cpp-heap.cc
--- up/v8/src/heap/cppgc-js/cpp-heap.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/heap/cppgc-js/cpp-heap.cc	2025-05-14 18:41:13.483904722 +0000
@@ -513,6 +513,11 @@
 }
 
 CppHeap::~CppHeap() {
+  if (isolate_) {
+    // TODO(ahaas): Delete this code once `v8::Isolate::DetachCppHeap` has been
+    // deleted.
+    isolate_->heap()->DetachCppHeap();
+  }
   Terminate();
 }
 
diff -r -u --color up/v8/src/heap/heap.cc nw/v8/src/heap/heap.cc
--- up/v8/src/heap/heap.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/heap/heap.cc	2025-05-14 18:41:13.493904749 +0000
@@ -6056,6 +6056,21 @@
   cpp_heap_ = cpp_heap;
 }
 
+void Heap::DetachCppHeap() {
+  // The API function should be a noop in case a CppHeap was passed on Isolate
+  // creation.
+  if (owning_cpp_heap_) {
+    return;
+  }
+
+  // The CppHeap may have been detached already.
+  if (!cpp_heap_) return;
+
+  CppHeap::From(cpp_heap_)->StartDetachingIsolate();
+  CppHeap::From(cpp_heap_)->DetachIsolate();
+  cpp_heap_ = nullptr;
+}
+
 std::optional<StackState> Heap::overridden_stack_state() const {
   if (!embedder_stack_state_origin_) return {};
   return embedder_stack_state_;
diff -r -u --color up/v8/src/heap/heap.h nw/v8/src/heap/heap.h
--- up/v8/src/heap/heap.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/heap/heap.h	2025-05-14 18:41:13.494904751 +0000
@@ -1107,6 +1107,9 @@
   // Unified heap (C++) support. ===============================================
   // ===========================================================================
 
+  V8_EXPORT_PRIVATE void AttachCppHeap(v8::CppHeap* cpp_heap);
+  V8_EXPORT_PRIVATE void DetachCppHeap();
+
   v8::CppHeap* cpp_heap() const { return cpp_heap_; }
 
   std::optional<StackState> overridden_stack_state() const;
@@ -1648,8 +1651,6 @@
  private:
   class AllocationTrackerForDebugging;
 
-  void AttachCppHeap(v8::CppHeap* cpp_heap);
-
   using ExternalStringTableUpdaterCallback =
       Tagged<String> (*)(Heap* heap, FullObjectSlot pointer);
 
diff -r -u --color up/v8/src/heap/marking-visitor-inl.h nw/v8/src/heap/marking-visitor-inl.h
--- up/v8/src/heap/marking-visitor-inl.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/heap/marking-visitor-inl.h	2025-05-14 18:41:13.497904760 +0000
@@ -458,6 +458,13 @@
     return false;
   }
 
+  Tagged<Object> script_obj = sfi->script();
+  if (!i::IsUndefined(script_obj)) {
+    Tagged<Script> script = i::Cast<Script>(script_obj);
+    if (i::IsUndefined(script->source()))
+      return false;
+  }
+
   return IsBytecodeArray(data);
 }
 
diff -r -u --color up/v8/src/init/icu_util.cc nw/v8/src/init/icu_util.cc
--- up/v8/src/init/icu_util.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/init/icu_util.cc	2025-05-14 18:41:13.508904789 +0000
@@ -36,6 +36,10 @@
 }  // namespace
 #endif
 
+void* RawICUData() {
+  return (void*)g_icu_data_ptr;
+}
+
 bool InitializeICUDefaultLocation(const char* exec_path,
                                   const char* icu_data_file) {
 #if !defined(V8_INTL_SUPPORT)
diff -r -u --color up/v8/src/init/icu_util.h nw/v8/src/init/icu_util.h
--- up/v8/src/init/icu_util.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/init/icu_util.h	2025-05-14 18:41:13.508904789 +0000
@@ -18,6 +18,8 @@
 bool InitializeICUDefaultLocation(const char* exec_path,
                                   const char* icu_data_file);
 
+void* RawICUData();
+
 }  // namespace internal
 }  // namespace v8
 
diff -r -u --color up/v8/src/init/startup-data-util.cc nw/v8/src/init/startup-data-util.cc
--- up/v8/src/init/startup-data-util.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/init/startup-data-util.cc	2025-05-14 18:41:13.508904789 +0000
@@ -77,10 +77,23 @@
 
 void InitializeExternalStartupData(const char* directory_path) {
 #ifdef V8_USE_EXTERNAL_STARTUP_DATA
+#if 0
   const char* snapshot_name = "snapshot_blob.bin";
   std::unique_ptr<char[]> snapshot =
       base::RelativePath(directory_path, snapshot_name);
   LoadFromFile(snapshot.get());
+#endif
+#ifdef __APPLE__
+#if V8_TARGET_ARCH_X64
+  const char* snapshot_name = "v8_context_snapshot.x86_64.bin";
+#else
+  const char* snapshot_name = "v8_context_snapshot.arm64.bin";
+#endif
+#else
+  const char* snapshot_name = "v8_context_snapshot.bin";
+#endif
+  std::unique_ptr<char[]> snapshot = base::RelativePath(directory_path, snapshot_name);
+  LoadFromFile(snapshot.get());
 #endif  // V8_USE_EXTERNAL_STARTUP_DATA
 }
 
diff -r -u --color up/v8/src/init/v8.cc nw/v8/src/init/v8.cc
--- up/v8/src/init/v8.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/init/v8.cc	2025-05-14 18:41:13.508904789 +0000
@@ -100,11 +100,20 @@
 #endif
 
 // static
+base::Thread::LocalStorageKey platform_tls_key_;
+void V8::SetTLSPlatform(v8::Platform* platform) {
+  base::Thread::SetThreadLocal(platform_tls_key_, platform);
+}
+
 void V8::InitializePlatform(v8::Platform* platform) {
   AdvanceStartupState(V8StartupState::kPlatformInitializing);
   CHECK(!platform_);
   CHECK_NOT_NULL(platform);
   platform_ = platform;
+
+  platform_tls_key_ = base::Thread::CreateThreadLocalKey();
+  base::Thread::SetThreadLocal(platform_tls_key_, platform);
+
   v8::base::SetPrintStackTrace(platform_->GetStackTracePrinter());
   v8::tracing::TracingCategoryObserver::SetUp();
 #if defined(V8_ENABLE_ETW_STACK_WALKING)
@@ -219,7 +228,6 @@
 #endif
   IsolateGroup::InitializeOncePerProcess();
   Isolate::InitializeOncePerProcess();
-
 #if defined(USE_SIMULATOR)
   Simulator::InitializeOncePerProcess();
 #endif
@@ -280,7 +288,11 @@
 }
 
 v8::Platform* V8::GetCurrentPlatform() {
-  v8::Platform* platform = reinterpret_cast<v8::Platform*>(
+  v8::Platform* platform;
+  platform = reinterpret_cast<v8::Platform*>(base::Thread::GetThreadLocal(platform_tls_key_));
+  if (platform)
+    return platform;
+  platform = reinterpret_cast<v8::Platform*>(
       base::Relaxed_Load(reinterpret_cast<base::AtomicWord*>(&platform_)));
   DCHECK(platform);
   return platform;
diff -r -u --color up/v8/src/init/v8.h nw/v8/src/init/v8.h
--- up/v8/src/init/v8.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/init/v8.h	2025-05-14 18:41:13.508904789 +0000
@@ -42,6 +42,7 @@
   [[noreturn]] V8_EXPORT_PRIVATE static void FatalProcessOutOfMemory(
       Isolate* isolate, const char* location, const char* detail);
 
+  static void SetTLSPlatform(v8::Platform* platform);
   static void InitializePlatform(v8::Platform* platform);
   V8_EXPORT_PRIVATE static void InitializePlatformForTesting(
       v8::Platform* platform);
diff -r -u --color up/v8/src/inspector/v8-heap-profiler-agent-impl.cc nw/v8/src/inspector/v8-heap-profiler-agent-impl.cc
--- up/v8/src/inspector/v8-heap-profiler-agent-impl.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/inspector/v8-heap-profiler-agent-impl.cc	2025-05-14 18:41:13.511904797 +0000
@@ -390,6 +390,15 @@
     progress.reset(new HeapSnapshotProgress(&m_frontend));
 
   GlobalObjectNameResolver resolver(m_session);
+#ifdef __APPLE__
+    // exit the context we entered in g_uv_runloop_once or taking
+    // snapshot will fail.
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    v8::HandleScope handle_scope(isolate);
+    v8::Local<v8::Context> context = isolate->GetEnteredOrMicrotaskContext();
+    if (!context.IsEmpty())
+      context->Exit();
+#endif
   v8::HeapProfiler::HeapSnapshotOptions options;
   options.global_object_name_resolver = &resolver;
   options.control = progress.get();
@@ -406,6 +415,10 @@
           : v8::HeapProfiler::NumericsMode::kHideNumericValues;
   options.stack_state = stackState;
   const v8::HeapSnapshot* snapshot = profiler->TakeHeapSnapshot(options);
+#ifdef __APPLE__
+    if (!context.IsEmpty())
+      context->Enter();
+#endif
   if (!snapshot) return Response::ServerError("Failed to take heap snapshot");
   HeapSnapshotOutputStream stream(&m_frontend);
   snapshot->Serialize(&stream);
diff -r -u --color up/v8/src/inspector/v8-stack-trace-impl.cc nw/v8/src/inspector/v8-stack-trace-impl.cc
--- up/v8/src/inspector/v8-stack-trace-impl.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/inspector/v8-stack-trace-impl.cc	2025-05-14 18:41:13.512904800 +0000
@@ -164,8 +164,8 @@
       m_lineNumber(lineNumber),
       m_columnNumber(columnNumber),
       m_hasSourceURLComment(hasSourceURLComment) {
-  DCHECK_NE(v8::Message::kNoLineNumberInfo, m_lineNumber + 1);
-  DCHECK_NE(v8::Message::kNoColumnInfo, m_columnNumber + 1);
+  //DCHECK_NE(v8::Message::kNoLineNumberInfo, m_lineNumber + 1);
+  //DCHECK_NE(v8::Message::kNoColumnInfo, m_columnNumber + 1);
 }
 
 const String16& StackFrame::functionName() const { return m_functionName; }
diff -r -u --color up/v8/src/libplatform/tracing/trace-object.cc nw/v8/src/libplatform/tracing/trace-object.cc
--- up/v8/src/libplatform/tracing/trace-object.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/libplatform/tracing/trace-object.cc	2025-05-14 18:41:13.519904819 +0000
@@ -99,7 +99,7 @@
   }
 }
 
-TraceObject::~TraceObject() { delete[] parameter_copy_storage_; }
+//TraceObject::~TraceObject() { delete[] parameter_copy_storage_; }
 
 void TraceObject::UpdateDuration(int64_t timestamp, int64_t cpu_timestamp) {
   duration_ = timestamp - ts_;
Only in nw/v8/src: nwjc.cc
diff -r -u --color up/v8/src/objects/backing-store.cc nw/v8/src/objects/backing-store.cc
--- up/v8/src/objects/backing-store.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/objects/backing-store.cc	2025-05-14 18:41:13.534904859 +0000
@@ -105,7 +105,7 @@
       max_byte_length_(max_byte_length),
       byte_capacity_(byte_capacity),
       id_(next_backing_store_id_.fetch_add(1)),
-      page_allocator_(page_allocator) {
+      page_allocator_(page_allocator), is_nodejs_(false) {
   // TODO(v8:11111): RAB / GSAB - Wasm integration.
   DCHECK_IMPLIES(is_wasm_memory64, is_wasm_memory);
   DCHECK_IMPLIES(has_guard_regions, is_wasm_memory);
@@ -190,6 +190,16 @@
     return;
   }
 
+  if (is_nodejs_) {
+    // JSArrayBuffer backing store. Deallocate through the embedder's allocator.
+    auto allocator = reinterpret_cast<v8::ArrayBuffer::Allocator*>(
+        get_v8_api_array_buffer_allocator());
+    TRACE_BS("BSn:free   bs=%p mem=%p (length=%zu, capacity=%zu)\n", this,
+             buffer_start_, byte_length(), byte_capacity_);
+    allocator->Free(buffer_start_, byte_length_, v8::ArrayBuffer::Allocator::AllocationMode::kNodeJS);
+    return;
+  }
+
   // JSArrayBuffer backing store. Deallocate through the embedder's allocator.
   auto allocator = get_v8_api_array_buffer_allocator();
   TRACE_BS("BS:free   bs=%p mem=%p (length=%zu, capacity=%zu)\n", this,
@@ -694,7 +704,7 @@
 std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
     void* allocation_base, size_t allocation_length,
     v8::BackingStore::DeleterCallback deleter, void* deleter_data,
-    SharedFlag shared) {
+    SharedFlag shared, bool is_nodejs) {
   bool is_empty_deleter = (deleter == v8::BackingStore::EmptyDeleter);
   auto result = new BackingStore(nullptr,
                                  allocation_base,               // start
@@ -708,6 +718,7 @@
                                  false,              // has_guard_regions
                                  true,               // custom_deleter
                                  is_empty_deleter);  // empty_deleter
+  result->is_nodejs_ = is_nodejs;
   result->type_specific_data_.deleter = {deleter, deleter_data};
   TRACE_BS("BS:wrap   bs=%p mem=%p (length=%zu)\n", result,
            result->buffer_start(), result->byte_length());
diff -r -u --color up/v8/src/objects/backing-store.h nw/v8/src/objects/backing-store.h
--- up/v8/src/objects/backing-store.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/objects/backing-store.h	2025-05-14 18:41:13.534904859 +0000
@@ -75,7 +75,7 @@
   static std::unique_ptr<BackingStore> WrapAllocation(
       void* allocation_base, size_t allocation_length,
       v8::BackingStore::DeleterCallback deleter, void* deleter_data,
-      SharedFlag shared);
+      SharedFlag shared, bool is_nodejs = false);
 
   // Create an empty backing store.
   static std::unique_ptr<BackingStore> EmptyBackingStore(SharedFlag shared);
@@ -98,6 +98,7 @@
   bool is_resizable_by_js() const { return has_flag(kIsResizableByJs); }
   bool is_wasm_memory() const { return has_flag(kIsWasmMemory); }
   bool is_wasm_memory64() const { return has_flag(kIsWasmMemory64); }
+  bool is_node_js() const { return is_nodejs_; }
   bool has_guard_regions() const { return has_flag(kHasGuardRegions); }
 
   bool IsEmpty() const {
@@ -110,6 +111,8 @@
   ResizeOrGrowResult ResizeInPlace(Isolate* isolate, size_t new_byte_length);
   ResizeOrGrowResult GrowInPlace(Isolate* isolate, size_t new_byte_length);
 
+  void set_nodejs(bool nodejs) { is_nodejs_ = nodejs; }
+
 #if V8_ENABLE_WEBASSEMBLY
   // The IsResizableByJs flag is set for backing stores for a resizable
   // ArrayBuffer or a WebAssembly.Memory that exposes its buffer as resizable
@@ -278,6 +281,7 @@
   } type_specific_data_;
 
   std::atomic<base::EnumSet<Flag, uint16_t>> flags_;
+  bool is_nodejs_ : 1;
 };
 
 // A global, per-process mapping from buffer addresses to backing stores
diff -r -u --color up/v8/src/objects/js-array-buffer-inl.h nw/v8/src/objects/js-array-buffer-inl.h
--- up/v8/src/objects/js-array-buffer-inl.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/objects/js-array-buffer-inl.h	2025-05-14 18:41:13.542904881 +0000
@@ -190,6 +190,8 @@
                     JSArrayBuffer::IsSharedBit)
 BIT_FIELD_ACCESSORS(JSArrayBuffer, bit_field, is_resizable_by_js,
                     JSArrayBuffer::IsResizableByJsBit)
+BIT_FIELD_ACCESSORS(JSArrayBuffer, bit_field, is_node_js,
+                    JSArrayBuffer::IsNodejsBit)
 
 bool JSArrayBuffer::IsEmpty() const {
   auto backing_store = GetBackingStore();
diff -r -u --color up/v8/src/objects/js-array-buffer.h nw/v8/src/objects/js-array-buffer.h
--- up/v8/src/objects/js-array-buffer.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/objects/js-array-buffer.h	2025-05-14 18:41:13.543904884 +0000
@@ -74,6 +74,7 @@
 
   // [was_detached]: true => the buffer was previously detached.
   DECL_BOOLEAN_ACCESSORS(was_detached)
+  DECL_BOOLEAN_ACCESSORS(is_node_js)
 
   // [is_shared]: true if this is a SharedArrayBuffer or a
   // GrowableSharedArrayBuffer.
diff -r -u --color up/v8/src/objects/js-array-buffer.tq nw/v8/src/objects/js-array-buffer.tq
--- up/v8/src/objects/js-array-buffer.tq	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/objects/js-array-buffer.tq	2025-05-14 18:41:13.543904884 +0000
@@ -9,6 +9,7 @@
   is_asm_js_memory: bool: 1 bit;
   is_shared: bool: 1 bit;
   is_resizable_by_js: bool: 1 bit;
+  is_nodejs: bool: 1 bit;
 }
 
 extern class JSArrayBuffer extends JSAPIObjectWithEmbedderSlots {
diff -r -u --color up/v8/src/objects/js-function.cc nw/v8/src/objects/js-function.cc
--- up/v8/src/objects/js-function.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/objects/js-function.cc	2025-05-14 18:41:13.546904892 +0000
@@ -1444,6 +1444,13 @@
     return NativeCodeFunctionSourceString(isolate, shared_info);
   }
 
+  //NWJS#6061: moved here or it will crash when trying to print
+  //function as a class
+  // Check if we have source code for the {function}.
+  if (!shared_info->HasSourceCode()) {
+    return NativeCodeFunctionSourceString(isolate, shared_info);
+  }
+
   if (IsClassConstructor(shared_info->kind())) {
     // Check if we should print {function} as a class.
     DirectHandle<Object> maybe_class_positions = JSReceiver::GetDataProperty(
@@ -1460,11 +1467,6 @@
     }
   }
 
-  // Check if we have source code for the {function}.
-  if (!shared_info->HasSourceCode()) {
-    return NativeCodeFunctionSourceString(isolate, shared_info);
-  }
-
   // If this function was compiled from asm.js, use the recorded offset
   // information.
 #if V8_ENABLE_WEBASSEMBLY
diff -r -u --color up/v8/src/objects/script.h nw/v8/src/objects/script.h
--- up/v8/src/objects/script.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/objects/script.h	2025-05-14 18:41:13.562904935 +0000
@@ -284,8 +284,10 @@
   friend FactoryBase<Factory>;
   friend FactoryBase<LocalFactory>;
 
+public:
   // Hide torque-generated accessor, use Script::SetSource instead.
   using TorqueGeneratedScript::set_source;
+private:
 
   // Bit positions in the flags field.
   DEFINE_TORQUE_GENERATED_SCRIPT_FLAGS()
diff -r -u --color up/v8/src/profiler/tracing-cpu-profiler.cc nw/v8/src/profiler/tracing-cpu-profiler.cc
--- up/v8/src/profiler/tracing-cpu-profiler.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/profiler/tracing-cpu-profiler.cc	2025-05-14 18:41:13.575904970 +0000
@@ -28,6 +28,7 @@
 #if defined(V8_USE_PERFETTO)
   TrackEvent::RemoveSessionObserver(this);
 #else
+  if (V8::GetCurrentPlatform())
   V8::GetCurrentPlatform()->GetTracingController()->RemoveTraceStateObserver(
       this);
 #endif
diff -r -u --color up/v8/src/snapshot/code-serializer.cc nw/v8/src/snapshot/code-serializer.cc
--- up/v8/src/snapshot/code-serializer.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/snapshot/code-serializer.cc	2025-05-14 18:41:13.591905014 +0000
@@ -527,6 +527,7 @@
   if (!maybe_result.ToHandle(&result)) {
     // Deserializing may fail if the reservations cannot be fulfilled.
     if (v8_flags.profile_deserialization) PrintF("[Deserializing failed]\n");
+    cached_data->Reject();
     return MaybeDirectHandle<SharedFunctionInfo>();
   }
 
@@ -857,9 +858,12 @@
     SerializedCodeSanityCheckResult* rejection_result) {
   DisallowGarbageCollection no_gc;
   SerializedCodeData scd(cached_data);
+  *rejection_result = SerializedCodeSanityCheckResult::kSuccess;
+#if 0
   *rejection_result = scd.SanityCheck(
       Snapshot::ExtractReadOnlySnapshotChecksum(isolate->snapshot_blob()),
       expected_source_hash);
+#endif
   if (*rejection_result != SerializedCodeSanityCheckResult::kSuccess) {
     cached_data->Reject();
     return SerializedCodeData(nullptr, 0);
diff -r -u --color up/v8/src/snapshot/deserializer.cc nw/v8/src/snapshot/deserializer.cc
--- up/v8/src/snapshot/deserializer.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/snapshot/deserializer.cc	2025-05-14 18:41:13.591905014 +0000
@@ -346,7 +346,9 @@
 #ifdef DEBUG
   num_api_references_ = GetNumApiReferences(isolate);
 #endif  // DEBUG
-  CHECK_EQ(magic_number_, SerializedData::kMagicNumber);
+  bool ret =
+    (magic_number_ == SerializedData::kMagicNumber);
+  valid_ = ret;
 }
 
 template <typename IsolateT>
diff -r -u --color up/v8/src/snapshot/deserializer.h nw/v8/src/snapshot/deserializer.h
--- up/v8/src/snapshot/deserializer.h	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/snapshot/deserializer.h	2025-05-14 18:41:13.591905014 +0000
@@ -118,6 +118,8 @@
 
   DirectHandle<HeapObject> ReadObject();
 
+  bool valid_ = true;
+
  private:
   // A circular queue of hot objects. This is added to in the same order as in
   // Serializer::HotObjectsList, but this stores the objects as a vector of
diff -r -u --color up/v8/src/snapshot/object-deserializer.cc nw/v8/src/snapshot/object-deserializer.cc
--- up/v8/src/snapshot/object-deserializer.cc	2025-05-06 13:05:37.000000000 +0000
+++ nw/v8/src/snapshot/object-deserializer.cc	2025-05-14 18:41:13.592905016 +0000
@@ -36,6 +36,8 @@
 
 MaybeDirectHandle<HeapObject> ObjectDeserializer::Deserialize() {
   DCHECK(deserializing_user_code());
+  if (!valid_)
+    return MaybeHandle<HeapObject>();
   HandleScope scope(isolate());
   DirectHandle<HeapObject> result;
   {
Only in nw/v8/src: v8.gyp
