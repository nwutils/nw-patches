Only in nw/chromium: .git
diff -r -u --color up/chromium/.gitignore nw/chromium/.gitignore
--- up/chromium/.gitignore	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/.gitignore	2024-08-26 19:32:14.302595408 +0000
@@ -1,4 +1,5 @@
 /client-py/
+/content/nw
 *.bak
 *.code-workspace
 *.gstmp
diff -r -u --color up/chromium/.gn nw/chromium/.gn
--- up/chromium/.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/.gn	2024-08-26 19:32:14.302595408 +0000
@@ -73,7 +73,7 @@
 
   devtools_visibility = [ "*" ]
 
-  clang_unsafe_buffers_paths = "//build/config/unsafe_buffers_paths.txt"
+  clang_unsafe_buffers_paths = "" #"//build/config/unsafe_buffers_paths.txt"
 }
 
 # These are the targets to skip header checking by default. The files in targets
diff -r -u --color up/chromium/BUILD.gn nw/chromium/BUILD.gn
--- up/chromium/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/BUILD.gn	2024-08-26 19:32:14.302595408 +0000
@@ -147,6 +147,7 @@
         ]
       }
       deps += [
+        "//content/nw:nwjs",
         "//components/subresource_filter/tools:subresource_filter_tools",
         "//components/zucchini:zucchini",
         "//net:hpack_example_generator",
@@ -856,7 +857,7 @@
       deps += [ ":all_rust" ]
     }
 
-    if (!is_android && !is_ios) {
+    if (false && !is_android && !is_ios) {
       deps += [ "//components/cronet:cronet_tests" ]
     }
   }
@@ -1669,16 +1670,6 @@
   }
 }
 
-# TODO(cassew): Add more OS's that don't support x86.
-is_valid_x86_target =
-    target_os != "ios" && target_os != "mac" &&
-    (target_os != "linux" || use_libfuzzer || !build_with_chromium)
-
-# Note: v8_target_cpu == arm allows using the V8 arm simulator on x86 for fuzzing.
-assert(
-    is_valid_x86_target || target_cpu != "x86" || v8_target_cpu == "arm",
-    "'target_cpu=x86' is not supported for 'target_os=$target_os'. Consider omitting 'target_cpu' (default) or using 'target_cpu=x64' instead.")
-
 group("chromium_builder_perf") {
   testonly = true
 
diff -r -u --color up/chromium/DEPS nw/chromium/DEPS
--- up/chromium/DEPS	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/DEPS	2024-08-26 19:32:14.302595408 +0000
@@ -298,6 +298,7 @@
   'chrome_git': 'https://chrome-internal.googlesource.com',
   'chromium_git': 'https://chromium.googlesource.com',
   'dawn_git': 'https://dawn.googlesource.com',
+  'nwjs_git': 'https://github.com/nwjs',
   'pdfium_git': 'https://pdfium.googlesource.com',
   'quiche_git': 'https://quiche.googlesource.com',
   'skia_git': 'https://skia.googlesource.com',
@@ -560,6 +561,9 @@
 ]
 
 deps = {
+  'src/tools/gyp':
+    Var('chromium_git') + '/external/gyp.git' + '@' + 'd61a9397e668fa9843c4aa7da9e79460fe590bfb',
+
   # NPM dependencies for JavaScript code coverage.
   'src/third_party/js_code_coverage/node_modules': {
     'dep_type': 'gcs',
@@ -2648,8 +2652,8 @@
       'condition': 'checkout_mac',
   },
 
-  'src/v8':
-    Var('chromium_git') + '/v8/v8.git' + '@' +  Var('v8_revision'),
+  #'src/v8':
+  #  Var('chromium_git') + '/v8/v8.git' + '@' +  Var('v8_revision'),
 
   'src/internal': {
     'url': Var('chrome_git') + '/chrome/src-internal.git' + '@' + Var('src_internal_revision'),
@@ -5416,6 +5420,14 @@
                 'src/third_party/apache-win32',
     ],
   },
+  {
+    'name': 'nw_patch',
+    'pattern': '.',
+    'action': [
+      'python',
+      'src/content/nw/tools/patcher.py'
+      ],
+  },
 
   # Download Telemetry's binary dependencies via conditionals
   {
diff -r -u --color up/chromium/apps/app_lifetime_monitor.cc nw/chromium/apps/app_lifetime_monitor.cc
--- up/chromium/apps/app_lifetime_monitor.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/apps/app_lifetime_monitor.cc	2024-08-26 19:32:14.410595049 +0000
@@ -65,8 +65,10 @@
 }
 
 void AppLifetimeMonitor::OnAppWindowHidden(AppWindow* app_window) {
+#if 0
   if (!HasOtherVisibleAppWindows(app_window))
     NotifyAppDeactivated(app_window->extension_id());
+#endif
 }
 
 void AppLifetimeMonitor::OnAppWindowShown(AppWindow* app_window,
diff -r -u --color up/chromium/apps/launcher.cc nw/chromium/apps/launcher.cc
--- up/chromium/apps/launcher.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/apps/launcher.cc	2024-08-26 19:32:14.410595049 +0000
@@ -113,7 +113,10 @@
         extension_id(app->id()),
         entry_paths_(entry_paths),
         mime_type_collector_(context),
-        is_directory_collector_(context) {}
+        is_directory_collector_(context) {
+    if (app->is_nwjs_app()) //NWJS#5097
+      entry_paths_.clear();
+  }
 
   PlatformAppPathLauncher(content::BrowserContext* context,
                           const Extension* app,
@@ -122,7 +125,7 @@
         extension_id(app->id()),
         mime_type_collector_(context),
         is_directory_collector_(context) {
-    if (!file_path.empty())
+    if (!file_path.empty() && !app->is_nwjs_app()) //NWJS#5097
       entry_paths_.push_back(file_path);
   }
   PlatformAppPathLauncher(const PlatformAppPathLauncher&) = delete;
@@ -500,7 +503,7 @@
 
   extensions::ExtensionPrefs* extension_prefs =
       extensions::ExtensionPrefs::Get(context);
-  bool had_windows = extension_prefs->IsActive(app->id());
+  bool had_windows = extension_prefs->IsActive(app->id()) || true;
   extension_prefs->SetIsActive(app->id(), false);
   bool listening_to_launch = event_router->ExtensionHasEventListener(
       app->id(), app_runtime::OnLaunched::kEventName);
diff -r -u --color up/chromium/apps/ui/views/app_window_frame_view.cc nw/chromium/apps/ui/views/app_window_frame_view.cc
--- up/chromium/apps/ui/views/app_window_frame_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/apps/ui/views/app_window_frame_view.cc	2024-08-26 19:32:14.414595035 +0000
@@ -56,7 +56,7 @@
 void AppWindowFrameView::Init() {
   if (draw_frame_) {
     auto close_button = std::make_unique<views::ImageButton>(
-        base::BindRepeating(&views::Widget::Close, base::Unretained(widget_)));
+       base::BindRepeating(&views::Widget::Close, base::Unretained(widget_), false));
     close_button->SetImageModel(
         views::Button::STATE_NORMAL,
         ui::ImageModel::FromResourceId(IDR_APP_WINDOW_CLOSE));
diff -r -u --color up/chromium/base/BUILD.gn nw/chromium/base/BUILD.gn
--- up/chromium/base/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/BUILD.gn	2024-08-26 19:32:15.246592273 +0000
@@ -196,6 +196,7 @@
 # This does not include test code (test support and anything in the test
 # directory) which should use source_set as is recommended for GN targets).
 component("base") {
+  include_dirs = [ "//v8/include" ]
   sources = [
     "allocator/allocator_check.cc",
     "allocator/allocator_check.h",
@@ -447,6 +448,8 @@
     "message_loop/message_pump_for_io.h",
     "message_loop/message_pump_for_ui.h",
     "message_loop/message_pump_type.h",
+    "message_loop/message_pump_uv.cc",
+    "message_loop/message_pump_uv.h",
     "message_loop/work_id_provider.cc",
     "message_loop/work_id_provider.h",
     "metrics/bucket_ranges.cc",
@@ -1045,7 +1048,10 @@
 
   configs += [
     "//build/config:precompiled_headers",
-    "//build/config/compiler:prevent_unsafe_narrowing",
+
+    # TODO(crbug.com/1292951): Enable.
+    # "//build/config/compiler:prevent_unsafe_narrowing",
+
     "//build/config/compiler:wexit_time_destructors",
     "//build/config/compiler:wglobal_constructors",
   ]
@@ -2023,6 +2029,8 @@
       "memory/platform_shared_memory_region_apple.cc",
       "message_loop/message_pump_apple.h",
       "message_loop/message_pump_apple.mm",
+      "message_loop/message_pumpuv_mac.h",
+      "message_loop/message_pumpuv_mac.mm",
       "process/process_metrics_apple.cc",
       "profiler/module_cache_apple.cc",
       "strings/sys_string_conversions_apple.mm",
diff -r -u --color up/chromium/base/allocator/partition_allocator/partition_alloc.gni nw/chromium/base/allocator/partition_allocator/partition_alloc.gni
--- up/chromium/base/allocator/partition_allocator/partition_alloc.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/allocator/partition_allocator/partition_alloc.gni	2024-08-26 19:32:15.250592259 +0000
@@ -77,6 +77,8 @@
                                   use_partition_alloc_as_malloc_default
 }
 
+use_allocator = "none"
+
 assert(!use_allocator_shim || (is_android || is_apple || is_chromeos ||
                                    is_fuchsia || is_linux || is_win),
        "The allocator shim does not (yet) support the platform.")
diff -r -u --color up/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_bucket.cc nw/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_bucket.cc
--- up/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_bucket.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_bucket.cc	2024-08-26 19:32:15.266592206 +0000
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#pragma clang diagnostic ignored "-Wthread-safety-analysis"
 #include "partition_alloc/partition_bucket.h"
 
 #include <algorithm>
diff -r -u --color up/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_root.cc nw/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_root.cc
--- up/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_root.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_root.cc	2024-08-26 19:32:15.266592206 +0000
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#pragma clang diagnostic ignored "-Wmisleading-indentation"
 #include "partition_alloc/partition_root.h"
 
 #include <cstdint>
diff -r -u --color up/chromium/base/base_switches.cc nw/chromium/base/base_switches.cc
--- up/chromium/base/base_switches.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/base_switches.cc	2024-08-26 19:32:15.302592087 +0000
@@ -185,4 +185,5 @@
 const char kSchedulerBoostUrgent[] = "scheduler-boost-urgent";
 #endif
 
+const char kNWJS[] = "nwjs";
 }  // namespace switches
diff -r -u --color up/chromium/base/base_switches.h nw/chromium/base/base_switches.h
--- up/chromium/base/base_switches.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/base_switches.h	2024-08-26 19:32:15.302592087 +0000
@@ -64,6 +64,7 @@
 extern const char kSchedulerBoostUrgent[];
 #endif
 
+extern const char kNWJS[];
 }  // namespace switches
 
 #endif  // BASE_BASE_SWITCHES_H_
diff -r -u --color up/chromium/base/command_line.cc nw/chromium/base/command_line.cc
--- up/chromium/base/command_line.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/command_line.cc	2024-08-26 19:32:15.306592073 +0000
@@ -162,7 +162,51 @@
 
   return out;
 }
-#endif  // BUILDFLAG(IS_WIN)
+#else
+// see the similar code in base/command_line.cc
+std::string QuoteForCommandLineToArgv(const std::string& arg) {
+  std::string quotable_chars(" \\\"");
+  if (arg.find_first_of(quotable_chars) == std::string::npos) {
+    // No quoting necessary.
+    return arg;
+  }
+
+  std::string out;
+  out.push_back('"');
+  for (size_t i = 0; i < arg.size(); ++i) {
+    if (arg[i] == '\\') {
+      // Find the extent of this run of backslashes.
+      size_t start = i, end = start + 1;
+      for (; end < arg.size() && arg[end] == '\\'; ++end) {}
+      size_t backslash_count = end - start;
+
+      // Backslashes are escapes only if the run is followed by a
+      // double quote.
+      // Since we also will end the string with a double quote, we
+      // escape for
+      // either a double quote or the end of the string.
+      if (end == arg.size() || arg[end] == '"') {
+        // To quote, we need to output 2x as many backslashes.
+        backslash_count *= 2;
+      }
+      for (size_t j = 0; j < backslash_count; ++j)
+        out.push_back('\\');
+
+      // Advance i to one before the end to balance i++ in loop.
+      i = end - 1;
+    } else if (arg[i] == '"') {
+      out.push_back('\\');
+      out.push_back('"');
+    } else {
+      out.push_back(arg[i]);
+    }
+  }
+  out.push_back('"');
+
+  return out;
+}
+
+#endif
 
 }  // namespace
 
@@ -173,26 +217,54 @@
   g_duplicate_switch_handler = new_duplicate_switch_handler.release();
 }
 
-CommandLine::CommandLine(NoProgram no_program) : argv_(1), begin_args_(1) {}
+CommandLine::CommandLine(NoProgram no_program)
+    : argv_(1),
+      begin_args_(1),
+      argc0_(0) {
+}
 
 CommandLine::CommandLine(const FilePath& program)
     : argv_(1),
-      begin_args_(1) {
+      begin_args_(1),
+      argc0_(0) {
   SetProgram(program);
 }
 
 CommandLine::CommandLine(int argc, const CommandLine::CharType* const* argv)
-    : argv_(1), begin_args_(1) {
+    : argv_(1),
+      begin_args_(1),
+      argc0_(0) {
   InitFromArgv(argc, argv);
 }
 
 CommandLine::CommandLine(const StringVector& argv)
     : argv_(1),
-      begin_args_(1) {
+      begin_args_(1),
+      argc0_(0) {
   InitFromArgv(argv);
 }
 
-CommandLine::CommandLine(const CommandLine& other) = default;
+CommandLine::CommandLine(const CommandLine& other)
+    : argv_(other.argv_),
+      original_argv_(other.original_argv_),
+      switches_(other.switches_),
+      begin_args_(other.begin_args_),
+      argc0_(other.argc0_), argv0_(nullptr) {
+
+#if defined(OS_WIN)
+  if (other.argv0_) {
+    argv0_ = new char*[argc0_ + 1];
+    for (int i = 0; i < argc0_; ++i) {
+      argv0_[i] = new char[strlen(other.argv0_[i]) + 1];
+      strcpy(argv0_[i], other.argv0_[i]);
+    }
+    argv0_[argc0_] = NULL;
+  }
+#else
+  argv0_ = other.argv0_;
+#endif
+}
+
 CommandLine::CommandLine(CommandLine&& other) noexcept
     :
 #if BUILDFLAG(IS_WIN)
@@ -203,12 +275,48 @@
 #endif  // BUILDFLAG(IS_WIN)
       argv_(std::exchange(other.argv_, StringVector(1))),
       switches_(std::move(other.switches_)),
-      begin_args_(std::exchange(other.begin_args_, 1)) {
+      begin_args_(std::exchange(other.begin_args_, 1)),
+      argc0_(0), argv0_(nullptr) {
+
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
   other.sequence_checker_.Detach();
 #endif
+
+#if defined(OS_WIN)
+  if (other.argv0_) {
+    argv0_ = new char*[argc0_ + 1];
+    for (int i = 0; i < argc0_; ++i) {
+      argv0_[i] = new char[strlen(other.argv0_[i]) + 1];
+      strcpy(argv0_[i], other.argv0_[i]);
+    }
+    argv0_[argc0_] = NULL;
+  }
+#else
+  argv0_ = other.argv0_;
+#endif
 }
-CommandLine& CommandLine::operator=(const CommandLine& other) = default;
+
+CommandLine& CommandLine::operator=(const CommandLine& other) {
+  argv_ = other.argv_;
+  original_argv_ = other.original_argv_;
+  switches_ = other.switches_;
+  begin_args_ = other.begin_args_;
+#if defined(OS_WIN)
+  if (other.argv0_) {
+    argc0_ = other.argc0_;
+    argv0_ = new char*[argc0_ + 1];
+    for (int i = 0; i < argc0_; ++i) {
+      argv0_[i] = new char[strlen(other.argv0_[i]) + 1];
+      strcpy(argv0_[i], other.argv0_[i]);
+    }
+    argv0_[argc0_] = NULL;
+  }
+#else
+  argv0_ = other.argv0_;
+#endif
+  return *this;
+}
+
 CommandLine& CommandLine::operator=(CommandLine&& other) noexcept {
 #if BUILDFLAG(IS_WIN)
   raw_command_line_string_ =
@@ -222,9 +330,33 @@
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
   other.sequence_checker_.Detach();
 #endif
+  original_argv_ = other.original_argv_;
+#if defined(OS_WIN)
+  if (other.argv0_) {
+    argc0_ = other.argc0_;
+    argv0_ = new char*[argc0_ + 1];
+    for (int i = 0; i < argc0_; ++i) {
+      argv0_[i] = new char[strlen(other.argv0_[i]) + 1];
+      strcpy(argv0_[i], other.argv0_[i]);
+    }
+    argv0_[argc0_] = NULL;
+  }
+#else
+  argv0_ = other.argv0_;
+#endif
   return *this;
 }
-CommandLine::~CommandLine() = default;
+
+CommandLine::~CommandLine() {
+#if defined(OS_WIN)
+  if (!argv0_)
+    return;
+  for (int i = 0; i < argc0_; i++) {
+    delete[] argv0_[i];
+  }
+  delete[] argv0_;
+#endif
+}
 
 #if BUILDFLAG(IS_WIN)
 // static
@@ -305,12 +437,47 @@
 void CommandLine::InitFromArgv(int argc,
                                const CommandLine::CharType* const* argv) {
   StringVector new_argv;
+  argc0_ = argc;
+#if !defined(OS_WIN)
+  argv0_ = (char**)argv;
+#else
+  argv0_ = new char*[argc + 1];
+  for (int i = 0; i < argc; ++i) {
+    std::string str(base::WideToUTF8(argv[i]));
+    argv0_[i] = new char[str.length() + 1];
+    strcpy(argv0_[i], str.c_str());
+  }
+  argv0_[argc] = NULL;
+#endif
   for (int i = 0; i < argc; ++i)
     new_argv.push_back(argv[i]);
   InitFromArgv(new_argv);
 }
 
 void CommandLine::InitFromArgv(const StringVector& argv) {
+#if !defined(OS_MAC)
+  original_argv_ = argv;
+#else
+  for (size_t index = 0; index < argv.size(); ++index) {
+    if (argv[index].compare(0, strlen("--psn_"), "--psn_") != 0 &&
+        argv[index].compare(0, strlen("-psn_"), "-psn_") != 0) {
+      original_argv_.push_back(argv[index]);
+    }
+  }
+#endif
+
+#if defined(OS_WIN)
+  int argc = argv.size();
+  argv0_ = new char*[argc + 1];
+  for (int i = 0; i < argc; ++i) {
+    std::string str(base::WideToUTF8(argv[i]));
+    argv0_[i] = new char[str.length() + 1];
+    strcpy(argv0_[i], str.c_str());
+  }
+  argv0_[argc] = NULL;
+  argc0_ = argc;
+#endif
+
   argv_ = StringVector(1);
   switches_.clear();
   begin_args_ = 1;
@@ -504,6 +671,12 @@
   argv_.push_back(StringType(value));
 }
 
+#if defined(OS_MAC)
+void CommandLine::FixOrigArgv4Finder(const CommandLine::StringType& value) {
+  original_argv_.push_back(value);
+}
+#endif
+
 void CommandLine::AppendArguments(const CommandLine& other,
                                   bool include_program) {
   if (include_program)
@@ -630,6 +803,8 @@
 #if BUILDFLAG(IS_WIN)
         switch_value = QuoteForCommandLineToArgvWInternal(
             switch_value, allow_unsafe_insert_sequences);
+#else
+        switch_value = QuoteForCommandLineToArgv(switch_value);
 #endif
         params.append(kSwitchValueSeparator + switch_value);
       }
@@ -646,6 +821,8 @@
         arg = QuoteForCommandLineToArgvWInternal(arg,
                                                  allow_unsafe_insert_sequences);
       }
+#else
+      arg = QuoteForCommandLineToArgv(arg);
 #endif
       params.append(arg);
     }
@@ -659,6 +836,8 @@
   string = QuoteForCommandLineToArgvWInternal(
       string,
       /*allow_unsafe_insert_sequences=*/false);
+#else
+  string = QuoteForCommandLineToArgv(string);
 #endif
   StringType params(GetArgumentsString());
   if (!params.empty()) {
diff -r -u --color up/chromium/base/command_line.h nw/chromium/base/command_line.h
--- up/chromium/base/command_line.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/command_line.h	2024-08-26 19:32:15.306592073 +0000
@@ -28,6 +28,7 @@
 #include "base/base_export.h"
 #include "base/containers/span.h"
 #include "base/debug/debugging_buildflags.h"
+#include "base/memory/raw_ptr.h"
 #include "build/build_config.h"
 
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
@@ -179,6 +180,11 @@
 
   // Returns the original command line string as a vector of strings.
   const StringVector& argv() const { return argv_; }
+  int argc0() { return argc0_; }
+  char** argv0() { return argv0_; }
+
+  // Returns the original command line string as a vector of strings (keeps precedence).
+  const StringVector& original_argv() const { return original_argv_; }
 
   // Get and Set the program part of the command line string (the first item).
   FilePath GetProgram() const;
@@ -232,6 +238,10 @@
   void AppendArgPath(const FilePath& value);
   void AppendArgNative(StringPieceType value);
 
+#if defined(OS_MAC)
+  void FixOrigArgv4Finder(const StringType& value);
+#endif
+
   // Append the switches and arguments from another command line to this one.
   // If `include_program` is true, program will be overwritten by other's.
   void AppendArguments(const CommandLine& other, bool include_program);
@@ -329,6 +339,9 @@
   // The argv array: { program, [(--|-|/)switch[=value]]*, [--], [argument]* }
   StringVector argv_;
 
+  // The argv array (precedence not messed).
+  StringVector original_argv_;
+
   // Parsed-out switch keys and values.
   SwitchMap switches_;
 
@@ -338,6 +351,8 @@
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
   InstanceBoundSequenceChecker sequence_checker_;
 #endif
+  int argc0_;
+  raw_ptr<char*, AllowPtrArithmetic> argv0_ = nullptr;
 };
 
 class BASE_EXPORT DuplicateSwitchHandler {
diff -r -u --color up/chromium/base/files/file_util_posix.cc nw/chromium/base/files/file_util_posix.cc
--- up/chromium/base/files/file_util_posix.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/files/file_util_posix.cc	2024-08-26 19:32:15.322592020 +0000
@@ -825,7 +825,7 @@
 #elif BUILDFLAG(GOOGLE_CHROME_BRANDING)
   std::string_view prefix = "com.google.Chrome";
 #else
-  std::string_view prefix = "org.chromium.Chromium";
+  std::string_view prefix = "io.nwjs";
 #endif
   return FilePath(StrCat({".", prefix, ".", identifier}));
 }
diff -r -u --color up/chromium/base/i18n/icu_util.cc nw/chromium/base/i18n/icu_util.cc
--- up/chromium/base/i18n/icu_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/i18n/icu_util.cc	2024-08-26 19:32:15.330591993 +0000
@@ -389,6 +389,28 @@
   return g_icudtl_pf;
 }
 
+const uint8_t* GetRawIcuMemory() {
+  CHECK(g_icudtl_mapped_file);
+  return g_icudtl_mapped_file->data();
+}
+
+bool InitializeICUFromRawMemory(const uint8_t* raw_memory) {
+#if !defined(COMPONENT_BUILD)
+#if DCHECK_IS_ON()
+  DCHECK(!g_check_called_once || !g_called_once);
+  g_called_once = true;
+#endif
+
+  UErrorCode err = U_ZERO_ERROR;
+  udata_setCommonData(const_cast<uint8_t*>(raw_memory), &err);
+  // Never try to load ICU data from files.
+  udata_setFileAccess(UDATA_ONLY_PACKAGES, &err);
+  return err == U_ZERO_ERROR;
+#else
+  return true;
+#endif
+}
+
 void ResetGlobalsForTesting() {
   // Reset ICU library internal state before tearing-down the mapped data
   // file, or handle.
diff -r -u --color up/chromium/base/i18n/icu_util.h nw/chromium/base/i18n/icu_util.h
--- up/chromium/base/i18n/icu_util.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/i18n/icu_util.h	2024-08-26 19:32:15.330591993 +0000
@@ -49,6 +49,25 @@
     PlatformFile data_fd,
     const MemoryMappedFile::Region& data_region);
 
+// Returns a void pointer to the memory mapped ICU data file.
+//
+// There are cases on Android where we would be unsafely reusing a file
+// descriptor within the same process when initializing two copies of ICU from
+// different binaries in the same address space. This returns an unowned
+// pointer to the memory mapped icu data file; consumers copies of base must
+// not outlive the copy of base that owns the memory mapped file.
+BASE_I18N_EXPORT const uint8_t* GetRawIcuMemory();
+
+// Initializes ICU memory
+//
+// This does nothing in component builds; this initialization should only be
+// done in cases where there could be two copies of base in a single process in
+// non-component builds. (The big example is standalone service libraries: the
+// Service Manager will have a copy of base linked in, and the majority of
+// service libraries will have base linked in but in non-component builds,
+// these will be separate copies of base.)
+BASE_I18N_EXPORT bool InitializeICUFromRawMemory(const uint8_t* raw_memory);
+
 // Calls `u_cleanup()` to reset the ICU library, and clears global state,
 // notably releasing the mapped ICU data file, and handle.
 BASE_I18N_EXPORT void ResetGlobalsForTesting();
diff -r -u --color up/chromium/base/message_loop/message_pump.cc nw/chromium/base/message_loop/message_pump.cc
--- up/chromium/base/message_loop/message_pump.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/message_loop/message_pump.cc	2024-08-26 19:32:15.346591941 +0000
@@ -12,6 +12,7 @@
 #include "base/task/task_features.h"
 #include "base/threading/platform_thread.h"
 #include "build/build_config.h"
+#include "base/message_loop/message_pump_uv.h"
 
 #if BUILDFLAG(IS_APPLE)
 #include "base/message_loop/message_pump_apple.h"
@@ -87,6 +88,9 @@
       return std::make_unique<MessagePumpForUI>();
 #endif
 
+    case MessagePumpType::NODE:
+      return std::unique_ptr<MessagePump>(new MessagePumpUV());
+
     case MessagePumpType::IO:
       return std::make_unique<MessagePumpForIO>();
 
diff -r -u --color up/chromium/base/message_loop/message_pump_apple.h nw/chromium/base/message_loop/message_pump_apple.h
--- up/chromium/base/message_loop/message_pump_apple.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/message_loop/message_pump_apple.h	2024-08-26 19:32:15.346591941 +0000
@@ -141,10 +141,9 @@
   // Get the current mode mask from |enabled_modes_|.
   int GetModeMask() const;
 
- protected:
   raw_ptr<Delegate> delegate() { return delegate_; }
 
- private:
+ protected:
   class ScopedModeEnabler;
 
   // The maximum number of run loop modes that can be monitored.
@@ -160,13 +159,15 @@
   // the instance method; the instance method returns true if it resignalled
   // |work_source_| to be called again from the loop.
   static void RunWorkSource(void* info);
-  bool RunWork();
+ protected:
+  virtual bool RunWork();
 
   // Perform idle-priority work.  This is normally called by PreWaitObserver,
   // but can also be invoked from RunNestingDeferredWork when returning from a
   // nested loop.  When this function actually does perform idle work, it will
   // re-signal the |work_source_|.
   void RunIdleWork();
+  virtual void PreWaitObserverHook();
 
   // Perform work that may have been deferred because it was not runnable
   // within a nested run loop.  This is associated with
diff -r -u --color up/chromium/base/message_loop/message_pump_apple.mm nw/chromium/base/message_loop/message_pump_apple.mm
--- up/chromium/base/message_loop/message_pump_apple.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/message_loop/message_pump_apple.mm	2024-08-26 19:32:15.346591941 +0000
@@ -549,12 +549,16 @@
     // nesting-deferred work may have accumulated.  Schedule it for processing
     // if appropriate.
     self->MaybeScheduleNestingDeferredWork();
+    self->PreWaitObserverHook();
 
     // Notify the delegate that the loop is about to sleep.
     self->BeforeWait();
   });
 }
 
+void MessagePumpCFRunLoopBase::PreWaitObserverHook() {
+}
+
 // Called from the run loop.
 // static
 void MessagePumpCFRunLoopBase::AfterWaitObserver(CFRunLoopObserverRef observer,
diff -r -u --color up/chromium/base/message_loop/message_pump_type.h nw/chromium/base/message_loop/message_pump_type.h
--- up/chromium/base/message_loop/message_pump_type.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/message_loop/message_pump_type.h	2024-08-26 19:32:15.346591941 +0000
@@ -39,6 +39,7 @@
   // OSX and IOS.
   NS_RUNLOOP,
 #endif  // BUILDFLAG(IS_APPLE)
+  NODE,
 };
 
 }  // namespace base
Only in nw/chromium/base/message_loop: message_pump_uv.cc
Only in nw/chromium/base/message_loop: message_pump_uv.h
Only in nw/chromium/base/message_loop: message_pumpuv_mac.h
Only in nw/chromium/base/message_loop: message_pumpuv_mac.mm
diff -r -u --color up/chromium/base/native_library_posix.cc nw/chromium/base/native_library_posix.cc
--- up/chromium/base/native_library_posix.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/native_library_posix.cc	2024-08-26 19:32:15.358591900 +0000
@@ -33,7 +33,7 @@
   // please refer to the bug tracker.  Some useful bug reports to read include:
   // http://crbug.com/17943, http://crbug.com/17557, http://crbug.com/36892,
   // and http://crbug.com/40794.
-  int flags = RTLD_LAZY;
+  int flags = RTLD_LAZY | RTLD_GLOBAL;
 #if BUILDFLAG(IS_ANDROID) || !defined(RTLD_DEEPBIND)
   // Certain platforms don't define RTLD_DEEPBIND. Android dlopen() requires
   // further investigation, as it might vary across versions. Crash here to
diff -r -u --color up/chromium/base/power_monitor/speed_limit_observer_win.cc nw/chromium/base/power_monitor/speed_limit_observer_win.cc
--- up/chromium/base/power_monitor/speed_limit_observer_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/power_monitor/speed_limit_observer_win.cc	2024-08-26 19:32:15.362591888 +0000
@@ -103,7 +103,7 @@
   // Get the latest estimated throttling level (value between 0.0 and 1.0).
   float throttling_level = EstimateThrottlingLevel();
 
-#if BUILDFLAG(ENABLE_BASE_TRACING)
+#if 0//BUILDFLAG(ENABLE_BASE_TRACING)
   // Emit trace events to investigate issues with power throttling. Run this
   // block only if tracing is running to avoid executing expensive calls to
   // EstimateCpuFrequency(...).
@@ -166,7 +166,7 @@
     callback_.Run(speed_limit_);
   }
 
-#if BUILDFLAG(ENABLE_BASE_TRACING)
+#if 0//BUILDFLAG(ENABLE_BASE_TRACING)
   TRACE_COUNTER(kPowerTraceCategory, "speed_limit",
                 static_cast<unsigned int>(speed_limit));
 #endif  // BUILDFLAG(ENABLE_BASE_TRACING)
@@ -229,7 +229,7 @@
       << " num_non_idle_cpus:" << num_non_idle_cpus;
   throttling_level = (load_fraction_total / num_cpus());
 
-#if BUILDFLAG(ENABLE_BASE_TRACING)
+#if 0//BUILDFLAG(ENABLE_BASE_TRACING)
   TRACE_COUNTER(kPowerTraceCategory, "num_active_cpus", num_active_cpus);
 #endif  // BUILDFLAG(ENABLE_BASE_TRACING)
 
diff -r -u --color up/chromium/base/process/launch_posix.cc nw/chromium/base/process/launch_posix.cc
--- up/chromium/base/process/launch_posix.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/process/launch_posix.cc	2024-08-26 19:32:15.366591874 +0000
@@ -469,6 +469,7 @@
 #ifndef PR_SET_NO_NEW_PRIVS
 #define PR_SET_NO_NEW_PRIVS 38
 #endif
+#if 0
     if (!options.allow_new_privs) {
       if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) && errno != EINVAL) {
         // Only log if the error is not EINVAL (i.e. not supported).
@@ -483,6 +484,7 @@
       }
     }
 #endif
+#endif
 
     if (current_directory != nullptr) {
       RAW_CHECK(chdir(current_directory) == 0);
diff -r -u --color up/chromium/base/test/test_message_loop.cc nw/chromium/base/test/test_message_loop.cc
--- up/chromium/base/test/test_message_loop.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/test/test_message_loop.cc	2024-08-26 19:32:15.434591649 +0000
@@ -19,6 +19,7 @@
     MessagePumpType type) {
   switch (type) {
     case MessagePumpType::DEFAULT:
+    case MessagePumpType::NODE:
       return test::SingleThreadTaskEnvironment::MainThreadType::DEFAULT;
     case MessagePumpType::IO:
       return test::SingleThreadTaskEnvironment::MainThreadType::IO;
diff -r -u --color up/chromium/base/threading/thread_restrictions.h nw/chromium/base/threading/thread_restrictions.h
--- up/chromium/base/threading/thread_restrictions.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/base/threading/thread_restrictions.h	2024-08-26 19:32:15.446591608 +0000
@@ -191,6 +191,7 @@
 namespace audio {
 class OutputDevice;
 }
+
 namespace blink {
 class AudioDestination;
 class DiskDataAllocator;
@@ -205,6 +206,16 @@
 class NonMainThreadImpl;
 }
 }  // namespace blink
+
+namespace extensions {
+class NwAppSetProxyConfigFunction;
+class ContentVerifier;
+}
+
+namespace nw {
+class Package;
+}
+
 namespace cc {
 class CategorizedWorkerPoolImpl;
 class CategorizedWorkerPoolJob;
@@ -702,6 +713,7 @@
   friend bool disk_cache::CleanupDirectorySync(const base::FilePath&);
   friend bool gl::init::InitializeStaticGLBindings(gl::GLImplementationParts);
 
+ public:
   ScopedAllowBlocking(const Location& from_here = Location::Current());
   ~ScopedAllowBlocking();
 
@@ -932,6 +944,7 @@
   // Not used in production yet, https://crbug.com/844078.
   friend class service_manager::ServiceProcessLauncher;
   friend class ui::WindowResizeHelperMac;  // http://crbug.com/902829
+  friend class extensions::NwAppSetProxyConfigFunction;
 
   ScopedAllowBaseSyncPrimitivesOutsideBlockingScope(
       const Location& from_here = Location::Current());
@@ -1054,6 +1067,9 @@
 #endif  // BUILDFLAG(IS_IOS)
   friend class web::WebMainLoop;
 
+  friend class extensions::ContentVerifier;
+  friend class nw::Package;
+
   static void AllowBlocking() EMPTY_BODY_IF_DCHECK_IS_OFF;
   static void AllowBaseSyncPrimitives() EMPTY_BODY_IF_DCHECK_IS_OFF;
 };
Only in nw/chromium/build: common.gypi
diff -r -u --color up/chromium/build/config/BUILD.gn nw/chromium/build/config/BUILD.gn
--- up/chromium/build/config/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/config/BUILD.gn	2024-08-26 19:32:15.510591396 +0000
@@ -96,6 +96,10 @@
     defines += [ "OFFICIAL_BUILD" ]
   }
 
+  if (nwjs_sdk) {
+    defines += [ "NWJS_SDK" ]
+  }
+
   # ==============================================
   #   PLEASE DO NOT ADD MORE THINGS TO THIS LIST
   # ==============================================
diff -r -u --color up/chromium/build/config/BUILDCONFIG.gn nw/chromium/build/config/BUILDCONFIG.gn
--- up/chromium/build/config/BUILDCONFIG.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/config/BUILDCONFIG.gn	2024-08-26 19:32:15.510591396 +0000
@@ -135,6 +135,8 @@
   # set "is_official_build" to true for any build intended to ship to end-users.
   is_official_build = false
 
+  nwjs_sdk = true
+
   # Set to true when compiling with the Clang compiler.
   is_clang = current_os != "linux" ||
              (current_cpu != "s390x" && current_cpu != "s390" &&
diff -r -u --color up/chromium/build/config/compiler/BUILD.gn nw/chromium/build/config/compiler/BUILD.gn
--- up/chromium/build/config/compiler/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/config/compiler/BUILD.gn	2024-08-26 19:32:15.518591370 +0000
@@ -505,7 +505,10 @@
 
   # Linux-specific compiler flags setup.
   # ------------------------------------
-  if (use_icf && (!is_apple || use_lld)) {
+
+  if (is_linux && current_cpu == "x86") {
+    ldflags += [ "-Wl,--icf=none" ]
+  } else if (use_icf && (!is_apple || use_lld)) {
     ldflags += [ "-Wl,--icf=all" ]
   }
 
@@ -1884,6 +1887,9 @@
       # Disables.
       "-Wno-missing-field-initializers",  # "struct foo f = {0};"
       "-Wno-unused-parameter",  # Unused function parameters.
+      "-Wno-unused-private-field",
+      "-Wno-unused-const-variable",
+      "-Wno-unreachable-code",
     ]
 
     if (!is_nacl || is_nacl_saigo) {
@@ -1904,6 +1910,7 @@
       # which we no longer use. Check if it makes sense to remove
       # this as well. http://crbug.com/316352
       "-Wno-unneeded-internal-declaration",
+      "-Wno-unused-function",
     ]
 
     if (!is_nacl || is_nacl_saigo) {
@@ -2126,6 +2133,7 @@
     cflags += [
       "/wd4800",  # Disable warning when forcing value to bool.
       "/wd4267",  # TODO(jschuh): size_t to int.
+      "/wd4275",
     ]
   } else {
     if (is_clang && !is_nacl) {
@@ -2236,7 +2244,7 @@
 config("thin_archive") {
   # The macOS and iOS default linker ld64 does not support reading thin
   # archives.
-  if ((is_posix && !is_nacl && (!is_apple || use_lld)) || is_fuchsia) {
+  if ((is_posix && !is_nacl && !is_apple) || is_fuchsia) {
     arflags = [ "-T" ]
   } else if (is_win && use_lld) {
     arflags = [ "/llvmlibthin" ]
diff -r -u --color up/chromium/build/config/compiler/compiler.gni nw/chromium/build/config/compiler/compiler.gni
--- up/chromium/build/config/compiler/compiler.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/config/compiler/compiler.gni	2024-08-26 19:32:15.518591370 +0000
@@ -114,7 +114,7 @@
   # the crash dumps generated by Android's debuggerd are largely useless, and
   # having this additional mechanism to understand issues is particularly helpful
   # to WebView.
-  exclude_unwind_tables = is_official_build && !is_android
+  exclude_unwind_tables = true
 
   # Where to redirect clang crash diagnoses
   clang_diagnostic_dir =
diff -r -u --color up/chromium/build/config/dcheck_always_on.gni nw/chromium/build/config/dcheck_always_on.gni
--- up/chromium/build/config/dcheck_always_on.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/config/dcheck_always_on.gni	2024-08-26 19:32:15.518591370 +0000
@@ -21,8 +21,8 @@
   # Other clients typically set this to false. If another client wants to use
   # the same default value as Chromium, we'd need to add a separate gclient
   # variable to replace build_with_chromium here.
-  dcheck_always_on =
-      (build_with_chromium && !is_official_build) || dcheck_is_configurable
+  dcheck_always_on = false
+      #(build_with_chromium && !is_official_build) || dcheck_is_configurable
 }
 
 declare_args() {
diff -r -u --color up/chromium/build/config/features.gni nw/chromium/build/config/features.gni
--- up/chromium/build/config/features.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/config/features.gni	2024-08-26 19:32:15.518591370 +0000
@@ -28,8 +28,7 @@
   #
   # TODO(crbug.com/1314528): Remove chromecast-related conditions and force
   # builds to explicitly specify this.
-  proprietary_codecs = is_chrome_branded || is_castos || is_cast_android ||
-                       is_chrome_for_testing_branded
+  proprietary_codecs = true
 
   # libudev usage. This currently only affects the content layer.
   use_udev = (is_linux && !is_castos) || is_chromeos
diff -r -u --color up/chromium/build/config/gcc/BUILD.gn nw/chromium/build/config/gcc/BUILD.gn
--- up/chromium/build/config/gcc/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/config/gcc/BUILD.gn	2024-08-26 19:32:15.518591370 +0000
@@ -67,10 +67,10 @@
     # Note: Android, Aix don't support rpath. Chromecast has its own logic for
     # setting the rpath in //build/config/chromecast.
     if (current_toolchain != default_toolchain || gcc_target_rpath == "") {
-      ldflags = [
+      #ldflags = [
         # Want to pass "\$". GN will re-escape as required for ninja.
-        "-Wl,-rpath=\$ORIGIN",
-      ]
+        #"-Wl,-rpath=\$ORIGIN/${rpath_link}",
+      #]
     } else {
       ldflags = [ "-Wl,-rpath=${gcc_target_rpath}" ]
     }
@@ -92,7 +92,12 @@
 # Settings for executables.
 config("executable_config") {
   configs = executable_and_shared_library_configs_
-  ldflags = [ "-pie" ]
+  if (shlib_subdir != ".") {
+      rpath_link = "${shlib_subdir}/"
+  } else {
+      rpath_link = "."
+  }
+  ldflags = [ "-pie", "-Wl,-rpath=\$ORIGIN/${rpath_link}" ]
   if (is_android) {
     ldflags += [
       "-Bdynamic",
@@ -113,5 +118,5 @@
 
 # Settings for shared libraries.
 config("shared_library_config") {
-  configs = executable_and_shared_library_configs_
+  #configs = executable_and_shared_library_configs_
 }
diff -r -u --color up/chromium/build/config/mac/BUILD.gn nw/chromium/build/config/mac/BUILD.gn
--- up/chromium/build/config/mac/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/config/mac/BUILD.gn	2024-08-26 19:32:15.522591356 +0000
@@ -73,6 +73,7 @@
 
       # Path for loading shared libraries for bundled binaries. Get back from
       # Binary.app/Contents/MacOS.
+      "-lc++abi",
       "-Wl,-rpath,@loader_path/../../..",
     ]
 
diff -r -u --color up/chromium/build/config/nacl/rules.gni nw/chromium/build/config/nacl/rules.gni
--- up/chromium/build/config/nacl/rules.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/config/nacl/rules.gni	2024-08-26 19:32:15.522591356 +0000
@@ -69,8 +69,13 @@
       # Starts empty so the code below can use += everywhere.
       data = []
 
-      nmfflags +=
+      if (target_os == "linux") {
+        nmfflags +=
+          [ "--library-path=" + rebase_path("${root_out_dir}/lib", root_build_dir) ]
+      } else {
+        nmfflags +=
           [ "--library-path=" + rebase_path(root_out_dir, root_build_dir) ]
+      }
 
       # NOTE: There is no explicit dependency for the lib directory
       # (lib32 and lib64 for x86/x64) created in the product directory.
diff -r -u --color up/chromium/build/config/win/BUILD.gn nw/chromium/build/config/win/BUILD.gn
--- up/chromium/build/config/win/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/config/win/BUILD.gn	2024-08-26 19:32:15.526591343 +0000
@@ -68,7 +68,7 @@
 
   if (is_clang) {
     cflags += [
-      "/Zc:twoPhase",
+      #"/Zc:twoPhase",
 
       # Consistently use backslash as the path separator when expanding the
       # __FILE__ macro when targeting Windows regardless of the build
diff -r -u --color up/chromium/build/dotfile_settings.gni nw/chromium/build/dotfile_settings.gni
--- up/chromium/build/dotfile_settings.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/dotfile_settings.gni	2024-08-26 19:32:15.526591343 +0000
@@ -7,6 +7,7 @@
 
 build_dotfile_settings = {
   exec_script_whitelist = [
+    "//content/nw/BUILD.gn",
     "//build/config/android/rules.gni",
     "//build/config/chromeos/rules.gni",
     "//build/config/compiler/BUILD.gn",
Only in nw/chromium/build: gyp_chromium
Only in nw/chromium/build: gyp_chromium.py
Only in nw/chromium/build: gyp_environment.py
diff -r -u --color up/chromium/build/toolchain/apple/toolchain.gni nw/chromium/build/toolchain/apple/toolchain.gni
--- up/chromium/build/toolchain/apple/toolchain.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/toolchain/apple/toolchain.gni	2024-08-26 19:32:15.550591263 +0000
@@ -616,7 +616,9 @@
       # hardlink but ensure the file have distinct metadata (thus avoid the
       # error with ditto, see https://crbug.com/1042182).
       if (host_os == "mac") {
-        command = "rm -rf {{output}} && /bin/cp -Rc {{source}} {{output}}"
+        command =
+          "rm -rf {{output}} && cp -fRc {{source}} {{output}} 2>/dev/null " +
+          "|| (rm -rf {{output}} && cp -fR {{source}} {{output}})"
       } else {
         command = "rm -rf {{output}} && /bin/cp -Rld {{source}} {{output}}"
       }
diff -r -u --color up/chromium/build/toolchain/gcc_toolchain.gni nw/chromium/build/toolchain/gcc_toolchain.gni
--- up/chromium/build/toolchain/gcc_toolchain.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/toolchain/gcc_toolchain.gni	2024-08-26 19:32:15.550591263 +0000
@@ -491,6 +491,9 @@
       default_output_extension = default_shlib_extension
 
       default_output_dir = "{{root_out_dir}}${default_shlib_subdir}"
+      if (shlib_subdir != ".") {
+        default_output_dir += "/$shlib_subdir"
+      }
 
       output_prefix = "lib"
 
@@ -573,6 +576,9 @@
       }
 
       default_output_dir = "{{root_out_dir}}${default_shlib_subdir}"
+      if (shlib_subdir != ".") {
+        default_output_dir += "/$shlib_subdir"
+      }
 
       output_prefix = "lib"
 
diff -r -u --color up/chromium/build/toolchain/toolchain.gni nw/chromium/build/toolchain/toolchain.gni
--- up/chromium/build/toolchain/toolchain.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/toolchain/toolchain.gni	2024-08-26 19:32:15.550591263 +0000
@@ -55,6 +55,22 @@
   }
 }
 
+# Subdirectory within root_out_dir for shared library files.
+# TODO(agrieve): GYP sets this to "lib" for Linux & Android, but this won't work
+#     in GN until support for loadable_module() is added.
+#     See: https://codereview.chromium.org/1236503002/
+if (is_linux) {
+  shlib_subdir = "lib"
+} else {
+  shlib_subdir = "."
+}
+
+# Root out dir for shared library files.
+root_shlib_dir = root_out_dir
+if (shlib_subdir != ".") {
+  root_shlib_dir += "/$shlib_subdir"
+}
+
 # Extension for shared library files (including leading dot).
 if (is_apple) {
   shlib_extension = ".dylib"
@@ -85,12 +101,6 @@
   shlib_prefix = ""
 }
 
-# Directory for shared library files.
-if (is_fuchsia) {
-  shlib_subdir = "/lib"
-} else {
-  shlib_subdir = ""
-}
 
 # While other "tool"s in a toolchain are specific to the target of that
 # toolchain, the "stamp" and "copy" tools are really generic to the host;
Only in nw/chromium/build/util: version.gypi
diff -r -u --color up/chromium/build/win/reorder-imports.py nw/chromium/build/win/reorder-imports.py
--- up/chromium/build/win/reorder-imports.py	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build/win/reorder-imports.py	2024-08-26 19:32:15.554591249 +0000
@@ -24,8 +24,8 @@
   # correct executable in the first place, so that this script
   # only needs to verify that and not write a whole new exe.
 
-  input_image = os.path.join(input_dir, 'chrome.exe')
-  output_image = os.path.join(output_dir, 'chrome.exe')
+  input_image = os.path.join(input_dir, 'nw.exe')
+  output_image = os.path.join(output_dir, 'nw.exe')
 
   # pefile mmap()s the whole executable, and then parses parts of
   # it into python data structures for ease of processing.
@@ -47,8 +47,8 @@
 
   found_elf = False
   for i, peimport in enumerate(pe.DIRECTORY_ENTRY_IMPORT):
-    if peimport.dll.lower() == b'chrome_elf.dll':
-      assert not found_elf, 'only one chrome_elf.dll import expected'
+    if peimport.dll.lower() == b'nw_elf.dll':
+      assert not found_elf, 'only one nw_elf.dll import expected'
       found_elf = True
       if i > 0:
         swap = pe.DIRECTORY_ENTRY_IMPORT[0]
@@ -69,11 +69,11 @@
             swap.struct.Name, peimport.struct.Name
         peimport.struct.FirstThunk, swap.struct.FirstThunk = \
             swap.struct.FirstThunk, peimport.struct.FirstThunk
-  assert found_elf, 'chrome_elf.dll import not found'
+  assert found_elf, 'nw_elf.dll import not found'
 
   pe.write(filename=output_image)
 
-  for fname in glob.iglob(os.path.join(input_dir, 'chrome.exe.*')):
+  for fname in glob.iglob(os.path.join(input_dir, 'nw.exe.*')):
     shutil.copy(fname, os.path.join(output_dir, os.path.basename(fname)))
   return 0
 
@@ -81,9 +81,9 @@
 def main(argv):
   usage = 'reorder_imports.py -i <input_dir> -o <output_dir> -a <target_arch>'
   parser = optparse.OptionParser(usage=usage)
-  parser.add_option('-i', '--input', help='reorder chrome.exe in DIR',
+  parser.add_option('-i', '--input', help='reorder nw.exe in DIR',
       metavar='DIR')
-  parser.add_option('-o', '--output', help='write new chrome.exe to DIR',
+  parser.add_option('-o', '--output', help='write new nw.exe to DIR',
       metavar='DIR')
   parser.add_option('-a', '--arch', help='architecture of build (optional)',
       default='ia32')
diff -r -u --color up/chromium/build_overrides/partition_alloc.gni nw/chromium/build_overrides/partition_alloc.gni
--- up/chromium/build_overrides/partition_alloc.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/build_overrides/partition_alloc.gni	2024-08-26 19:32:15.558591237 +0000
@@ -86,7 +86,7 @@
 if (is_ios) {
   _is_partition_alloc_everywhere_platform = ios_partition_alloc_enabled
 } else {
-  _is_partition_alloc_everywhere_platform = !is_nacl
+  _is_partition_alloc_everywhere_platform = is_win
 }
 
 # Under Windows debug build, the allocator shim is not compatible with CRT.
diff -r -u --color up/chromium/buildtools/third_party/libc++/BUILD.gn nw/chromium/buildtools/third_party/libc++/BUILD.gn
--- up/chromium/buildtools/third_party/libc++/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/buildtools/third_party/libc++/BUILD.gn	2024-08-26 19:32:15.562591223 +0000
@@ -42,10 +42,14 @@
   ]
 }
 
-if (libcxx_is_shared) {
+if (!is_debug && libcxx_is_shared) {
   _libcxx_target_type = "shared_library"
 } else {
-  _libcxx_target_type = "source_set"
+  if (is_linux) {
+    _libcxx_target_type = "static_library"
+  } else {
+    _libcxx_target_type = "source_set"
+  }
 }
 target(_libcxx_target_type, "libc++") {
   # Most things that need to depend on libc++ should do so via the implicit
@@ -54,6 +58,7 @@
   visibility = [
     "//build/config:common_deps",
     "//third_party/catapult/devil:devil",
+    ":*",
   ]
   if (is_linux) {
     # This target packages libc++.so, so must have an explicit dependency on
@@ -61,7 +66,7 @@
     visibility +=
         [ "//remoting/host/linux:remoting_me2me_host_copy_user_session" ]
   }
-  if (libcxx_is_shared) {
+  if (!is_debug && libcxx_is_shared) {
     no_default_deps = true
   }
 
@@ -229,3 +234,9 @@
     }
   }
 }
+
+static_library("libcpp") {
+   complete_static_lib = true
+   configs -= [ "//build/config/compiler:thin_archive" ]
+   deps = [":libc++"]
+}
diff -r -u --color up/chromium/buildtools/third_party/libc++/__config_site nw/chromium/buildtools/third_party/libc++/__config_site
--- up/chromium/buildtools/third_party/libc++/__config_site	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/buildtools/third_party/libc++/__config_site	2024-08-26 19:32:15.562591223 +0000
@@ -16,9 +16,9 @@
 //    on Windows, the increase is great enough that we go above the 4GB size
 //    limit for PDBs (https://crbug.com/1327710#c5). To fix this, we set
 //    _LIBCPP_ABI_NAMESPACE to a shorter value.
-#define _LIBCPP_ABI_NAMESPACE __Cr
+#define _LIBCPP_ABI_NAMESPACE __1
 
-#define _LIBCPP_ABI_VERSION 2
+//#define _LIBCPP_ABI_VERSION 2
 
 /* #undef _LIBCPP_ABI_FORCE_ITANIUM */
 /* #undef _LIBCPP_ABI_FORCE_MICROSOFT */
diff -r -u --color up/chromium/buildtools/third_party/libc++abi/BUILD.gn nw/chromium/buildtools/third_party/libc++abi/BUILD.gn
--- up/chromium/buildtools/third_party/libc++abi/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/buildtools/third_party/libc++abi/BUILD.gn	2024-08-26 19:32:15.562591223 +0000
@@ -6,7 +6,7 @@
 import("//build/config/c++/c++.gni")
 import("//build/config/unwind.gni")
 
-source_set("libc++abi") {
+static_library("libc++abi") {
   if (export_libcxxabi_from_executables) {
     visibility = [ "//build/config:executable_deps" ]
   } else {
@@ -91,7 +91,7 @@
   configs +=
       [ "//build/config/sanitizers:default_sanitizer_flags_but_ubsan_vptr" ]
 
-  if (export_libcxxabi_from_executables || libcxx_is_shared) {
+  if (true || export_libcxxabi_from_executables || libcxx_is_shared) {
     configs -= [ "//build/config/gcc:symbol_visibility_hidden" ]
     configs += [ "//build/config/gcc:symbol_visibility_default" ]
   }
diff -r -u --color up/chromium/cc/metrics/compositor_frame_reporting_controller.cc nw/chromium/cc/metrics/compositor_frame_reporting_controller.cc
--- up/chromium/cc/metrics/compositor_frame_reporting_controller.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/cc/metrics/compositor_frame_reporting_controller.cc	2024-08-26 19:32:15.586591144 +0000
@@ -171,10 +171,12 @@
   if (reporters_[PipelineStage::kBeginImplFrame]) {
     // We need to use .get() below because operator<< in std::unique_ptr is a
     // C++20 feature.
+#if 0
     DCHECK_NE(reporters_[PipelineStage::kBeginMainFrame].get(),
               reporters_[PipelineStage::kBeginImplFrame].get());
     DCHECK_EQ(reporters_[PipelineStage::kBeginImplFrame]->frame_id(),
               args.frame_id);
+#endif
     reporters_[PipelineStage::kBeginImplFrame]->StartStage(
         StageType::kSendBeginMainFrameToCommit, Now());
     AdvanceReporterStage(PipelineStage::kBeginImplFrame,
diff -r -u --color up/chromium/cc/paint/color_filter.h nw/chromium/cc/paint/color_filter.h
--- up/chromium/cc/paint/color_filter.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/cc/paint/color_filter.h	2024-08-26 19:32:15.594591117 +0000
@@ -18,6 +18,7 @@
 
 class PaintOpWriter;
 class PaintOpReader;
+class PaintFlags;
 
 class CC_PAINT_EXPORT ColorFilter : public SkRefCnt {
  public:
diff -r -u --color up/chromium/chrome/BUILD.gn nw/chromium/chrome/BUILD.gn
--- up/chromium/chrome/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/BUILD.gn	2024-08-26 19:32:15.646590944 +0000
@@ -77,10 +77,10 @@
 
     # See comment in chrome_dll.gypi in the hardlink_to_output
     # target for why this cannot be 'initial' like the DLL.
-    inputs = [ "$root_out_dir/initialexe/chrome.exe" ]
+    inputs = [ "$root_out_dir/initialexe/nw.exe" ]
     outputs = [
-      "$root_out_dir/chrome.exe",
-      "$root_out_dir/chrome.exe.pdb",
+      "$root_out_dir/nw.exe",
+      "$root_out_dir/nw.exe.pdb",
     ]
     args = [
       "-i",
@@ -147,9 +147,9 @@
       configs -= [ "//build/config/compiler:thinlto_optimize_default" ]
       configs += [ "//build/config/compiler:thinlto_optimize_max" ]
       if (is_win) {
-        output_name = "initialexe/chrome"
+        output_name = "initialexe/nw"
       } else {
-        output_name = "chrome"
+        output_name = "nw"
       }
 
       # Because the sources list varies so significantly per-platform, generally
@@ -278,14 +278,25 @@
       }
 
       if (is_linux || is_chromeos) {
+        if (!is_component_build) {
+          configs += [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
+        }
+        if (is_component_build) {
         sources += [
           "app/chrome_dll_resource.h",
           "app/chrome_main.cc",
           "app/chrome_main_delegate.cc",
           "app/chrome_main_delegate.h",
-          "app/startup_timestamps.h",
         ]
+        if (is_linux) {
+          sources += [
+            "app/chrome_main_linux.cc",
+            "app/chrome_main_linux.h",
+          ]
+        }
+        }
 
+        if (is_component_build) {
         deps += [
           # On Linux, link the dependencies (libraries) that make up actual
           # Chromium functionality directly into the executable.
@@ -302,13 +313,19 @@
           # For headless mode.
           "//headless:headless_shell_lib",
         ]
+        } else {
+        deps += [
+          ":chrome_dll",
+        ]
+        }
 
+        if (is_component_build) {
         public_deps = [
           ":xdg_mime",  # Needs to be public for installer to consume files.
           "//chrome/common:buildflags",
         ]
 
-        data_deps += [ "//components/crash/core/app:chrome_crashpad_handler" ]
+        }
 
         ldflags = []
 
@@ -371,6 +388,10 @@
       # The step's output are needed at runtime, so we also need a data_dep.
       data_deps += [ ":packed_resources" ]
 
+      deps += [
+        "//content/nw:nw_base",
+      ]
+
       # ChromeOS by design is safe to have rpath=$ORIGIN. This simplifies shared
       # library usage.
       if (is_chromeos_ash && !is_component_build) {
@@ -392,12 +413,6 @@
         ldflags += [ "--collect-inputs-only" ]
       }
 
-      if (is_linux) {
-        sources += [
-          "app/chrome_main_linux.cc",
-          "app/chrome_main_linux.h",
-        ]
-      }
     }
   }
   _chrome_exe("chrome_initial") {
@@ -413,63 +428,90 @@
   }
 }  # !is_android && !is_mac
 
-if (is_win) {
+if (is_win || (is_linux && !is_component_build)) {
   shared_library("chrome_dll") {
     configs += [ "//build/config/compiler:wexit_time_destructors" ]
     configs -= [ "//build/config/compiler:thinlto_optimize_default" ]
     configs += [ "//build/config/compiler:thinlto_optimize_max" ]
 
     defines = []
+    ldflags = []
 
     sources = [
-      "//base/win/dllmain.cc",
       "app/chrome_main.cc",
       "app/chrome_main_delegate.cc",
       "app/chrome_main_delegate.h",
       "app/startup_timestamps.h",
     ]
 
-    output_name = "chrome"
+    if (is_win) {
+      sources += [ "//base/win/dllmain.cc" ]
+    }
+
+      if (is_linux) {
+        sources += [
+          "app/chrome_main_linux.cc",
+          "app/chrome_main_linux.h",
+        ]
+      }
+    output_name = "nw"
 
     deps = [
-      ":chrome_dll_manifest",
-      ":chrome_dll_version",
       ":dependencies",
       "//chrome/app:chrome_dll_resources",
       "//chrome/app:command_ids",
-      "//chrome/app/theme:chrome_unscaled_resources",
-      "//chrome/chrome_elf",
       "//chrome/common:buildflags",
       "//chrome/common:version_header",
       "//chrome/common/profiler",
-      "//chrome/install_static:install_static_util",
-      "//chrome/install_static:secondary_module",
-      "//components/crash/core/app",
-      "//components/memory_system",
-      "//components/policy:generated",
-      "//content/public/app",
-      "//crypto",
-      "//headless:headless_non_renderer",
-      "//headless:headless_shell_browser_lib",
-      "//net:net_resources",
-      "//ppapi/buildflags",
-      "//sandbox/win:sandbox",
-      "//third_party/cld_3/src/src:cld_3",
-      "//third_party/wtl",
-      "//ui/views",
     ]
 
+    # reverts commit a2052ac9b6ec749735f3d8e269bf5a5600935914
+    if (is_win) {
     configs += [ "//build/config/win:delayloads" ]
 
+    deps += [
+        ":chrome_dll_manifest",
+        ":chrome_dll_version",
+        "//chrome/app/theme:chrome_unscaled_resources",
+        "//chrome/install_static:install_static_util",
+        "//chrome/install_static:secondary_module",
+        "//chrome/chrome_elf",
+        "//components/crash/core/app",
+        "//components/memory_system",
+        "//components/policy:generated",
+        "//crypto",
+        "//headless:headless_non_renderer",
+        "//headless:headless_shell_lib",
+        "//net:net_resources",
+        "//ppapi/buildflags",
+        "//sandbox/win:sandbox",
+        "//third_party/wtl",
+        "//ui/views",
+    ]
+
+    if (!is_component_build) {
+      deps += [
+        "//v8:v8_initializers",
+      ]
+    }
+
+    } #is_win
+
     if (use_aura) {
       deps += [ "//ui/compositor" ]
     }
+
+    if (is_linux) {
+        deps += [ "//headless:headless_shell_lib", ]
+    }
   }
 
+  if (is_win) {
   copy("copy_first_run") {
     sources = [ "app/FirstRun" ]
     outputs = [ "$root_out_dir/First Run" ]
   }
+  }
 } else if (is_mac) {
   chrome_helper_name = chrome_product_full_name + " Helper"
   chrome_framework_name = chrome_product_full_name + " Framework"
@@ -550,7 +592,7 @@
       deps += [ ":chromium_updater_privileged_helper" ]
     }
 
-    if (enable_stripping) {
+    if (false) {
       # At link time, preserve the global symbols specified in the .exports
       # file. All other global symbols will be marked as private. The default
       # //build/config/apple:strip_all config will then remove the remaining
@@ -801,7 +843,7 @@
         ]
       }
 
-      if (enable_stripping) {
+      if (false) {
         # At link time, preserve the global symbols specified in the .exports
         # file. All other global symbols will be marked as private. The default
         # //build/config/apple:strip_all config will then remove the remaining
@@ -1000,7 +1042,8 @@
         } else if (current_cpu == "x64") {
           sources += [ "$root_out_dir/nacl_irt_x86_64.nexe" ]
         }
-        public_deps += [ "//ppapi/native_client:irt" ]
+        sources += [ "$root_out_dir/pnacl" ]
+        public_deps += [ "//ppapi/native_client:irt", "//ppapi/native_client/src/untrusted/pnacl_support_extension:pnacl_support_extension" ]
       }
     }
   } else {
@@ -1136,6 +1179,8 @@
       ":chrome_framework_shared_library",
     ]
 
+    output_name = "nw"
+
     sources = [
       "app/chrome_crash_reporter_client.cc",
       "app/chrome_crash_reporter_client.h",
@@ -1161,7 +1206,9 @@
       "//components/policy:generated",
       "//content/public/app",
       "//headless:headless_shell_lib",
-      "//third_party/cld_3/src/src:cld_3",
+      #"//third_party/cld_3/src/src:cld_3",
+      "//ui/events:dom_keycode_converter",
+      "//tools/v8_context_snapshot:buildflags",
     ]
 
     if (is_component_build) {
@@ -1174,9 +1221,10 @@
       ":chrome_dll_symbol_order",
       "//build/config/compiler:wexit_time_destructors",
     ]
-    if (!is_component_build && !using_sanitizer) {
+    if (false && !is_component_build && !using_sanitizer) {
       configs += [ ":chrome_dll_symbol_exports" ]
     }
+    configs += [ "//v8:external_startup_data" ]
   }
 
   mac_framework_bundle("chrome_framework") {
@@ -1224,7 +1272,7 @@
     }
 
     configs += [ ":chrome_dll_symbol_order" ]
-    if (!is_component_build && !using_sanitizer) {
+    if (false && !is_component_build && !using_sanitizer) {
       configs += [ ":chrome_dll_symbol_exports" ]
     }
 
@@ -1247,7 +1295,7 @@
       ldflags += [
         "-Wl,-install_name,@rpath/$chrome_framework_name.framework/$chrome_framework_name",
         "-Wl,-rpath,@loader_path/../../../../../..",
-        "-Wl,-reexport_library,libchrome_dll.dylib",
+        "-Wl,-reexport_library,libnw.dylib",
       ]
 
       data_deps = [ ":chrome_dll" ]
@@ -1260,7 +1308,7 @@
 
   # TOOD(crbug/1163903#c8) - thakis@ look into why profile and coverage
   # instrumentation adds these symbols in different orders
-  if (!is_component_build && chrome_pgo_phase != 1 && !using_sanitizer) {
+  if (false && !is_component_build && chrome_pgo_phase != 1 && !using_sanitizer) {
     action("verify_chrome_framework_order") {
       script = "//chrome/tools/build/mac/verify_order.py"
       stamp_file = "$target_out_dir/run_$target_name.stamp"
@@ -1359,6 +1407,41 @@
       }
     }
 
+    action("nw_sym_archive") {
+      script = "//content/nw/tools/archive_symbols.py"
+
+      _syms = [
+        "$root_out_dir/$chrome_framework_name-$chrome_version_full.breakpad",
+        "$root_out_dir/$chrome_helper_name-$chrome_version_full.breakpad",
+        "$root_out_dir/$chrome_product_full_name-$chrome_version_full.breakpad",
+      ]
+
+      sources = _chrome_symbols_sources
+
+      _output = "$root_out_dir/nwjs.breakpad.tar"
+
+      outputs = [
+        _output,
+      ]
+
+      args = [ rebase_path(_output, root_out_dir) ] +
+             rebase_path(_syms, root_out_dir)
+
+      deps = [
+        ":chrome_app",
+        ":chrome_framework",
+        ":chrome_dump_syms",
+        "//components/crash/core/app:chrome_crashpad_handler",
+        "//third_party/angle:libEGL",
+        "//third_party/angle:libGLESv2",
+        "//third_party/crashpad/crashpad/handler:crashpad_handler",
+        "//third_party/swiftshader/src/Vulkan:swiftshader_libvulkan",
+      ]
+      foreach(helper_params, chrome_mac_helpers) {
+        deps += [ ":chrome_helper_app_${helper_params[0]}" ]
+      }
+    }
+
     action("chrome_dsym_archive") {
       script = "//chrome/tools/build/mac/archive_symbols.py"
 
@@ -1589,10 +1672,10 @@
     # This needs to be in-sync with //chrome/app/packed_resources_integrity.h.
     files_to_hash = [
       "resources.pak",
-      "chrome_100_percent.pak",
+      "nw_100_percent.pak",
     ]
     if (enable_hidpi) {
-      files_to_hash += [ "chrome_200_percent.pak" ]
+      files_to_hash += [ "nw_200_percent.pak" ]
     }
   }
 
@@ -1731,13 +1814,13 @@
       }
     }
     extract_symbols("chrome_symbols") {
-      binary = "$root_out_dir/chrome"
+      binary = "$root_out_dir/nw"
 
       if (current_cpu == "x86") {
         # GYP used "ia32" so keep that naming for back-compat.
-        symbol_file = "$root_out_dir/chrome.breakpad.ia32"
+        symbol_file = "$root_out_dir/nw.breakpad.ia32"
       } else {
-        symbol_file = "$root_out_dir/chrome.breakpad.$current_cpu"
+        symbol_file = "$root_out_dir/nw.breakpad.$current_cpu"
       }
 
       deps = [ ":chrome" ]
diff -r -u --color up/chromium/chrome/app/app-Info.plist nw/chromium/chrome/app/app-Info.plist
--- up/chromium/chrome/app/app-Info.plist	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/app-Info.plist	2024-08-26 19:32:16.014589723 +0000
@@ -253,8 +253,6 @@
 	<string>1</string>
 	<key>LSMinimumSystemVersion</key>
 	<string>${CHROMIUM_MIN_SYSTEM_VERSION}</string>
-	<key>LSRequiresNativeExecution</key>
-	<true/>
 	<key>NSCameraReactionEffectGesturesEnabledDefault</key>
 	<false/>
 	<key>NSPrincipalClass</key>
@@ -274,7 +272,7 @@
 				<string>public.content</string>
 			</array>
 			<key>UTTypeDescription</key>
-			<string>Chromium Extension</string>
+			<string>NWJS Extension</string>
 			<key>UTTypeIdentifier</key>
 			<string>org.chromium.extension</string>
 			<key>UTTypeTagSpecification</key>
diff -r -u --color up/chromium/chrome/app/chrome_crash_reporter_client.cc nw/chromium/chrome/app/chrome_crash_reporter_client.cc
--- up/chromium/chrome/app/chrome_crash_reporter_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_crash_reporter_client.cc	2024-08-26 19:32:16.018589709 +0000
@@ -24,7 +24,7 @@
 #include "components/crash/core/common/crash_keys.h"
 #include "content/public/common/content_switches.h"
 
-#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_POSIX)
 #include "components/upload_list/crash_upload_list.h"
 #include "components/version_info/version_info.h"
 #include "components/version_info/version_info_values.h"
@@ -112,7 +112,7 @@
 }
 #endif
 
-#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_POSIX)// && !BUILDFLAG(IS_MAC)
 void ChromeCrashReporterClient::GetProductNameAndVersion(
     const char** product_name,
     const char** version) {
@@ -126,13 +126,13 @@
   *product_name = "Chrome_Lacros";
 #else  // BUILDFLAG(IS_ANDROID)
 #if !defined(ADDRESS_SANITIZER)
-  *product_name = "Chrome_Linux";
+  *product_name = product_name_.c_str();
 #else
   *product_name = "Chrome_Linux_ASan";
 #endif
 #endif
 
-  *version = PRODUCT_VERSION;
+  *version = product_version_.c_str();
 }
 
 void ChromeCrashReporterClient::GetProductNameAndVersion(
@@ -147,6 +147,7 @@
   *channel = chrome::GetChannelName(chrome::WithExtendedStable(true));
 }
 
+#if !BUILDFLAG(IS_MAC)
 base::FilePath ChromeCrashReporterClient::GetReporterLogFilename() {
   return base::FilePath(CrashUploadList::kReporterLogFilename);
 }
@@ -154,6 +155,7 @@
 bool ChromeCrashReporterClient::GetShouldDumpLargerDumps() {
   return chrome::GetChannel() != version_info::Channel::STABLE;
 }
+#endif
 #endif  // BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
 
 bool ChromeCrashReporterClient::GetCrashDumpLocation(
@@ -171,11 +173,14 @@
 #endif  // BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
 
 bool ChromeCrashReporterClient::IsRunningUnattended() {
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  return env->HasVar(env_vars::kHeadless);
+  // std::unique_ptr<base::Environment> env(base::Environment::Create());
+  // return env->HasVar(env_vars::kHeadless);
+  return !enable_upload_;
 }
 
 bool ChromeCrashReporterClient::GetCollectStatsConsent() {
+  return true;
+#if 0
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
   bool is_official_chrome_build = true;
 #else
@@ -224,6 +229,7 @@
           << " so returning that";
   return settings_consent;
 #endif  // BUILDFLAG(IS_ANDROID)
+#endif // 0
 }
 
 #if BUILDFLAG(IS_ANDROID)
diff -r -u --color up/chromium/chrome/app/chrome_crash_reporter_client.h nw/chromium/chrome/app/chrome_crash_reporter_client.h
--- up/chromium/chrome/app/chrome_crash_reporter_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_crash_reporter_client.h	2024-08-26 19:32:16.018589709 +0000
@@ -43,16 +43,18 @@
       const std::string& client_guid) override;
 #endif
 
-#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_POSIX) //&& !BUILDFLAG(IS_MAC)
   void GetProductNameAndVersion(const char** product_name,
                                 const char** version) override;
   void GetProductNameAndVersion(std::string* product_name,
                                 std::string* version,
                                 std::string* channel) override;
+#if !BUILDFLAG(IS_MAC)
   base::FilePath GetReporterLogFilename() override;
 
   bool GetShouldDumpLargerDumps() override;
 #endif
+#endif
 
   bool GetCrashDumpLocation(base::FilePath* crash_dir) override;
 
diff -r -u --color up/chromium/chrome/app/chrome_crash_reporter_client_win.cc nw/chromium/chrome/app/chrome_crash_reporter_client_win.cc
--- up/chromium/chrome/app/chrome_crash_reporter_client_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_crash_reporter_client_win.cc	2024-08-26 19:32:16.018589709 +0000
@@ -46,10 +46,12 @@
 
   std::wstring process_type = install_static::GetSwitchValueFromCommandLine(
       ::GetCommandLine(), install_static::kProcessType);
+  std::wstring disable_crash_handler = install_static::GetSwitchValueFromCommandLine(
+    ::GetCommandLine(), L"disable-crash-handler");
   // Don't set up Crashpad crash reporting in the Crashpad handler itself, nor
   // in the fallback crash handler for the Crashpad handler process.
   if (process_type != install_static::kCrashpadHandler &&
-      process_type != install_static::kFallbackHandler) {
+      process_type != install_static::kFallbackHandler && disable_crash_handler != L"true") {
     crash_reporter::SetCrashReporterClient(instance);
 
     std::wstring user_data_dir;
@@ -169,11 +171,11 @@
 }
 
 bool ChromeCrashReporterClient::IsRunningUnattended() {
-  return install_static::HasEnvironmentVariable(install_static::kHeadless);
+  return !enable_upload_;
 }
 
 bool ChromeCrashReporterClient::GetCollectStatsConsent() {
-  return install_static::GetCollectStatsConsent();
+  return true; // install_static::GetCollectStatsConsent();
 }
 
 bool ChromeCrashReporterClient::GetCollectStatsInSample() {
diff -r -u --color up/chromium/chrome/app/chrome_dll.rc nw/chromium/chrome/app/chrome_dll.rc
--- up/chromium/chrome/app/chrome_dll.rc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_dll.rc	2024-08-26 19:32:16.022589696 +0000
@@ -69,7 +69,6 @@
     "T",            IDC_FOCUS_TOOLBAR,          VIRTKEY, SHIFT, ALT
     VK_BACK,        IDC_FORWARD,                VIRTKEY, SHIFT
     VK_RIGHT,       IDC_FORWARD,                VIRTKEY, ALT
-    VK_F11,         IDC_FULLSCREEN,             VIRTKEY
     VK_F1,          IDC_HELP_PAGE_VIA_KEYBOARD, VIRTKEY
     VK_HOME,        IDC_HOME,                   VIRTKEY, ALT
     "N",            IDC_NEW_INCOGNITO_WINDOW,   VIRTKEY, CONTROL, SHIFT
diff -r -u --color up/chromium/chrome/app/chrome_dll.ver nw/chromium/chrome/app/chrome_dll.ver
--- up/chromium/chrome/app/chrome_dll.ver	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_dll.ver	2024-08-26 19:32:16.022589696 +0000
@@ -1,2 +1,2 @@
-INTERNAL_NAME=chrome_dll
-ORIGINAL_FILENAME=chrome.dll
+INTERNAL_NAME=nw_dll
+ORIGINAL_FILENAME=nw.dll
diff -r -u --color up/chromium/chrome/app/chrome_exe.ver nw/chromium/chrome/app/chrome_exe.ver
--- up/chromium/chrome/app/chrome_exe.ver	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_exe.ver	2024-08-26 19:32:16.022589696 +0000
@@ -1,2 +1,2 @@
-INTERNAL_NAME=chrome_exe
-ORIGINAL_FILENAME=chrome.exe
+INTERNAL_NAME=nw_exe
+ORIGINAL_FILENAME=nw.exe
diff -r -u --color up/chromium/chrome/app/chrome_exe_main_mac.cc nw/chromium/chrome/app/chrome_exe_main_mac.cc
--- up/chromium/chrome/app/chrome_exe_main_mac.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_exe_main_mac.cc	2024-08-26 19:32:16.022589696 +0000
@@ -204,7 +204,7 @@
            rel_path);
 
   void* library =
-      dlopen(framework_path.get(), RTLD_LAZY | RTLD_LOCAL | RTLD_FIRST);
+      dlopen(framework_path.get(), RTLD_LAZY | RTLD_FIRST);
   if (!library) {
     FatalError("dlopen %s: %s.", framework_path.get(), dlerror());
   }
diff -r -u --color up/chromium/chrome/app/chrome_exe_main_win.cc nw/chromium/chrome/app/chrome_exe_main_win.cc
--- up/chromium/chrome/app/chrome_exe_main_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_exe_main_win.cc	2024-08-26 19:32:16.022589696 +0000
@@ -67,6 +67,7 @@
 // process) created before MainDllLoader changes the current working directory
 // to the browser's version directory.
 void SetCwdForBrowserProcess() {
+#if 0
   if (!::IsBrowserProcess())
     return;
 
@@ -79,7 +80,9 @@
   base::SetCurrentDirectory(
       base::FilePath(base::FilePath::StringPieceType(&buffer[0], length))
           .DirName());
+#endif
 }
+#if 0
 
 bool IsFastStartSwitch(const std::string& command_line_switch) {
   return command_line_switch == switches::kProfileDirectory;
@@ -111,6 +114,7 @@
     return false;
   return chrome::AttemptToNotifyRunningChrome(chrome) == chrome::NOTIFY_SUCCESS;
 }
+#endif
 
 // Returns true if the child process |command_line| contains a /prefetch:#
 // argument where # is in [1, 8] prior to Win11 and [1,16] for it and later.
@@ -191,8 +195,8 @@
     const uint8_t** chrome_100_pak,
     const uint8_t** chrome_200_pak) {
   *resources_pak = kSha256_resources_pak.data();
-  *chrome_100_pak = kSha256_chrome_100_percent_pak.data();
-  *chrome_200_pak = kSha256_chrome_200_percent_pak.data();
+  *chrome_100_pak = kSha256_nw_100_percent_pak.data();
+  *chrome_200_pak = kSha256_nw_200_percent_pak.data();
 }
 
 #if !defined(WIN_CONSOLE_APP)
@@ -244,7 +248,6 @@
 
   SetCwdForBrowserProcess();
   install_static::InitializeFromPrimaryModule();
-  SignalInitializeCrashReporting();
   if (IsBrowserProcess())
     chrome::DisableDelayLoadFailureHooksForMainExecutable();
 #if defined(ARCH_CPU_32_BITS)
@@ -288,6 +291,13 @@
          HasValidWindowsPrefetchArgument(*command_line));
 
   if (process_type == crash_reporter::switches::kCrashpadHandler) {
+    // HACK: Let Windows know that we have started.  This is needed to suppress
+    // the IDC_APPSTARTING cursor from being displayed for a prolonged period
+    // while a subprocess is starting. NWJS#4685
+    PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0);
+    MSG msg;
+    PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
+
     // Check if we should monitor the exit code of this process
     std::unique_ptr<ExitCodeWatcher> exit_code_watcher;
 
@@ -342,8 +352,10 @@
   // The exit manager is in charge of calling the dtors of singletons.
   base::AtExitManager exit_manager;
 
+#if 0 //FIXME(nwjs)
   if (AttemptFastNotify(*command_line))
     return 0;
+#endif
 
   // Load and launch the chrome dll. *Everything* happens inside.
   VLOG(1) << "About to load main DLL.";
diff -r -u --color up/chromium/chrome/app/chrome_main.cc nw/chromium/chrome/app/chrome_main.cc
--- up/chromium/chrome/app/chrome_main.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_main.cc	2024-08-26 19:32:16.022589696 +0000
@@ -151,7 +151,7 @@
   auto crash_on_detach_resetter = base::ScopedClosureRunner(
       base::BindOnce(&base::win::SetShouldCrashOnProcessDetach,
                      base::win::ShouldCrashOnProcessDetach()));
-  base::win::SetShouldCrashOnProcessDetach(true);
+  base::win::SetShouldCrashOnProcessDetach(false);
   base::win::SetAbortBehaviorForCrashReporting();
   params.instance = instance;
   params.sandbox_info = sandbox_info;
diff -r -u --color up/chromium/chrome/app/chrome_main_delegate.cc nw/chromium/chrome/app/chrome_main_delegate.cc
--- up/chromium/chrome/app/chrome_main_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_main_delegate.cc	2024-08-26 19:32:16.022589696 +0000
@@ -2,8 +2,13 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "chrome/common/chrome_constants.h"
 #include "chrome/app/chrome_main_delegate.h"
 
+#include "chrome/chrome_elf/chrome_elf_main.h"
+#include "base/files/file_util.h"
+#include "tools/v8_context_snapshot/buildflags.h"
+
 #include <stddef.h>
 
 #include <string>
@@ -99,6 +104,7 @@
 #include "ui/base/resource/scoped_startup_resource_bundle.h"
 #include "ui/base/ui_base_switches.h"
 
+#include "content/nw/src/nw_base.h"
 #if BUILDFLAG(IS_WIN)
 #include <malloc.h>
 
@@ -246,6 +252,15 @@
 #include "ui/ozone/public/ozone_platform.h"
 #endif  // BUILDFLAG(IS_OZONE)
 
+#include "third_party/node-nw/src/node_webkit.h"
+#include "third_party/zlib/google/zip_reader.h"
+#include "base/native_library.h"
+#include "base/strings/utf_string_conversions.h"
+#if defined(OS_MAC)
+#include "base/apple/bundle_locations.h"
+#include "base/strings/sys_string_conversions.h"
+#endif
+
 base::LazyInstance<ChromeContentGpuClient>::DestructorAtExit
     g_chrome_content_gpu_client = LAZY_INSTANCE_INITIALIZER;
 base::LazyInstance<ChromeContentRendererClient>::DestructorAtExit
@@ -264,6 +279,13 @@
 const size_t ChromeMainDelegate::kNonWildcardDomainNonPortSchemesSize =
     std::size(kNonWildcardDomainNonPortSchemes);
 
+#if defined(COMPONENT_BUILD)
+CONTENT_EXPORT NodeStartFn g_node_start_fn;
+#else
+extern NodeStartFn g_node_start_fn;
+#endif
+SetBlobPathFn g_set_blob_path_fn = nullptr;
+
 namespace {
 
 #if BUILDFLAG(IS_CHROMEOS_LACROS)
@@ -614,7 +636,7 @@
   // when prelaunching at login screen.
   chromeos::lacros_paths::SetInitializedUserDataDir();
 #endif
-#if BUILDFLAG(IS_WIN)
+#if 0
   // Reach out to chrome_elf for the truth on the user data directory.
   // Note that in tests, this links to chrome_elf_test_stubs.
   wchar_t user_data_dir_buf[MAX_PATH], invalid_user_data_dir_buf[MAX_PATH];
@@ -651,10 +673,15 @@
     }
   }
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-#if BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN)
   policy::path_parser::CheckUserDataDirPolicy(&user_data_dir);
 #endif  // BUILDFLAG(IS_MAC)
 
+  // On Windows, trailing separators leave Chrome in a bad state.
+  // See crbug.com/464616.
+  if (user_data_dir.EndsWithSeparator())
+    user_data_dir = user_data_dir.StripTrailingSeparators();
+
   const bool specified_directory_was_invalid =
       !user_data_dir.empty() &&
       !base::PathService::OverrideAndCreateIfNeeded(chrome::DIR_USER_DATA,
@@ -685,7 +712,7 @@
 
   // Append the fallback user data directory to the commandline. Otherwise,
   // child or service processes will attempt to use the invalid directory.
-  if (specified_directory_was_invalid)
+  //if (specified_directory_was_invalid)
     command_line->AppendSwitchPath(switches::kUserDataDir, user_data_dir);
 #endif  // BUILDFLAG(IS_WIN)
 }
@@ -1241,7 +1268,7 @@
   ash::BootTimesRecorder::Get()->SaveChromeMainStats();
 #endif
 
-  const base::CommandLine& command_line =
+  base::CommandLine& command_line =
       *base::CommandLine::ForCurrentProcess();
 
   // Only allow disabling web security via the command-line flag if the user has
@@ -1298,6 +1325,35 @@
 
   content::Profiling::ProcessStarted();
 
+  const base::CommandLine::StringVector& args = command_line.GetArgs();
+  if (args.size() > 0) {
+    zip::ZipReader reader;
+    base::FilePath fp(args[0]);
+    //LOG(WARNING) << "final extension: " << fp.FinalExtension();
+    if (!command_line.HasSwitch(switches::kProcessType) && fp.FinalExtension() == FILE_PATH_LITERAL(".js") &&
+        base::PathExists(fp) && !base::DirectoryExists(fp) && !reader.Open(fp)) {
+      base::NativeLibraryLoadError error;
+#if defined(OS_MAC)
+      base::FilePath node_dll_path = base::apple::FrameworkBundlePath().Append(base::FilePath::FromUTF8Unsafe(base::GetNativeLibraryName("node")));
+      std::string blob_path = base::apple::PathForFrameworkBundleResource(BUILDFLAG(V8_CONTEXT_SNAPSHOT_FILENAME)).AsUTF8Unsafe();
+#else
+      base::FilePath node_dll_path = base::FilePath::FromUTF8Unsafe(base::GetNativeLibraryName("node"));
+#endif
+      base::NativeLibrary node_dll = base::LoadNativeLibrary(node_dll_path, &error);
+      if(!node_dll)
+        LOG(FATAL) << "Failed to load node library (error: " << error.ToString() << ")";
+      else {
+#if defined(OS_MAC)
+        g_set_blob_path_fn = (SetBlobPathFn)base::GetFunctionPointerFromNativeLibrary(node_dll, "g_set_blob_path");
+        g_set_blob_path_fn(blob_path.c_str());
+#endif
+        g_node_start_fn = (NodeStartFn)base::GetFunctionPointerFromNativeLibrary(node_dll, "g_node_start");
+        return g_node_start_fn(command_line.argc0(), command_line.argv0());
+      }
+    }
+  }
+
+
   // Setup tracing sampler profiler as early as possible at startup if needed.
   SetupTracing();
 
@@ -1444,6 +1500,26 @@
   }
 #endif
 
+  std::wstring product_name, product_version;
+  std::string report_url;
+
+  nw::InitNWPackage();
+  std::string name = nw::package()->GetName();
+  std::string version;
+  product_name = std::wstring(name.begin(), name.end());
+  std::string* str = nw::package()->root()->FindString("version");
+  if (str)
+    version = *str;
+  product_version = std::wstring(version.begin(), version.end());
+#if defined(OS_WIN)
+  SignalInitializeCrashReporting(&product_name, &product_version);
+  str = nw::package()->root()->FindString("crash_report_url");
+  if (str) {
+    report_url = *str;
+    crash_reporter::CrashReporterClient* client = (crash_reporter::CrashReporterClient*)ElfGetReporterClient();
+    client->SetUploadDump(true);
+  }
+#endif
   return std::nullopt;
 }
 
@@ -1518,7 +1594,39 @@
   ChromeCrashReporterClient::Create();
 #endif
 
+  std::string report_url;
+  std::string* str = nw::package()->root()->FindString("crash_report_url");
+  if (str) {
+    report_url = *str;
+#if !defined(OS_WIN)
+    crash_reporter::CrashReporterClient* client = crash_reporter::GetCrashReporterClient();
+    client->SetUploadDump(true);
+    client->product_name_ = nw::package()->GetName();
+    str = nw::package()->root()->FindString("version");
+    if (str)
+      client->product_version_ = *str;
+#endif
+  }
+
 #if BUILDFLAG(IS_MAC)
+  // On the Mac, the child executable lives at a predefined location within
+  // the app bundle's versioned directory.
+  std::string product_string;
+  str = nw::package()->root()->FindString("product_string");
+  if (str) {
+    product_string = *str;
+    std::string helperProcessExecutablePath = (product_string + " Helper.app/Contents/MacOS/" + product_string + " Helper");
+    base::PathService::OverrideAndCreateIfNeeded(content::CHILD_PROCESS_EXE,
+                                chrome::GetFrameworkBundlePath()
+                                .Append("Helpers")
+                                .Append(helperProcessExecutablePath), true, false);
+  }else{
+    base::PathService::OverrideAndCreateIfNeeded(content::CHILD_PROCESS_EXE,
+                                chrome::GetFrameworkBundlePath()
+                                .Append("Helpers")
+                                .Append(chrome::kHelperProcessExecutablePath), true, false);
+  }
+
   InitMacCrashReporter(command_line, process_type);
   SetUpInstallerPreferences(command_line);
 #endif
@@ -1593,7 +1701,7 @@
   }
 #endif  // BUILDFLAG(IS_CHROMEOS_LACROS)
 
-  // Register component_updater PathProvider after DIR_USER_DATA overridden by
+#if 1
   // command line flags. Maybe move the chrome PathProvider down here also?
   int alt_preinstalled_components_dir =
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -1612,6 +1720,7 @@
   component_updater::RegisterPathProvider(chrome::DIR_COMPONENTS,
                                           alt_preinstalled_components_dir,
                                           updated_components_dir);
+#endif
 
 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_WIN)
   // Android does InitLogging when library is loaded. Skip here.
@@ -1769,6 +1878,13 @@
   // line for crash reporting.
   crash_keys::SetCrashKeysFromCommandLine(command_line);
 
+#if 1 //!defined(OS_WIN)
+  if (!report_url.empty()) {
+    GURL url(report_url);
+    chrome_content_client_.SetNWReportURL(url);
+  }
+#endif
+
 #if BUILDFLAG(ENABLE_PDF)
   MaybePatchGdiGetFontData();
 #endif
diff -r -u --color up/chromium/chrome/app/chrome_main_mac.mm nw/chromium/chrome/app/chrome_main_mac.mm
--- up/chromium/chrome/app/chrome_main_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_main_mac.mm	2024-08-26 19:32:16.022589696 +0000
@@ -20,6 +20,8 @@
 #include "content/public/common/content_paths.h"
 #include "content/public/common/content_switches.h"
 
+#include "content/nw/src/nw_base.h"
+
 void SetUpBundleOverrides() {
   @autoreleasepool {
     base::apple::SetOverrideFrameworkBundlePath(
@@ -27,16 +29,6 @@
 
     NSBundle* base_bundle = chrome::OuterAppBundle();
     base::apple::SetBaseBundleID(base_bundle.bundleIdentifier.UTF8String);
-
-    base::FilePath child_exe_path =
-        chrome::GetFrameworkBundlePath().Append("Helpers").Append(
-            chrome::kHelperProcessExecutablePath);
-
-    // On the Mac, the child executable lives at a predefined location within
-    // the app bundle's versioned directory.
-    base::PathService::OverrideAndCreateIfNeeded(
-        content::CHILD_PROCESS_EXE, child_exe_path, /*is_absolute=*/true,
-        /*create=*/false);
   }
 }
 
diff -r -u --color up/chromium/chrome/app/chrome_version.rc.version nw/chromium/chrome/app/chrome_version.rc.version
--- up/chromium/chrome/app/chrome_version.rc.version	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chrome_version.rc.version	2024-08-26 19:32:16.022589696 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include <verrsrc.h>
+#include "../../content/nw/src/nw_version.h"
 
 /////////////////////////////////////////////////////////////////////////////
 //
@@ -10,9 +11,9 @@
 //
 
 VS_VERSION_INFO VERSIONINFO
- FILEVERSION @MAJOR@,@MINOR@,@BUILD@,@PATCH@
- PRODUCTVERSION @MAJOR@,@MINOR@,@BUILD@,@PATCH@
  FILEFLAGSMASK 0x17L
+ FILEVERSION NW_MAJOR_VERSION,NW_MINOR_VERSION,NW_PATCH_VERSION
+ PRODUCTVERSION NW_MAJOR_VERSION,NW_MINOR_VERSION,NW_PATCH_VERSION
 #ifdef _DEBUG
  FILEFLAGS 0x1L
 #else
@@ -28,16 +29,15 @@
         BEGIN
             VALUE "CompanyName", "@COMPANY_FULLNAME@"
             VALUE "FileDescription", "@PRODUCT_FULLNAME@"
-            VALUE "FileVersion", "@MAJOR@.@MINOR@.@BUILD@.@PATCH@"
+            VALUE "FileVersion", NW_VERSION_STRING
             VALUE "InternalName", "@INTERNAL_NAME@"
             VALUE "LegalCopyright", "@COPYRIGHT@"
             VALUE "OriginalFilename", "@ORIGINAL_FILENAME@"
             VALUE "ProductName", "@PRODUCT_FULLNAME@"
-            VALUE "ProductVersion", "@MAJOR@.@MINOR@.@BUILD@.@PATCH@"
+            VALUE "ProductVersion", NW_VERSION_STRING
             VALUE "CompanyShortName", "@COMPANY_SHORTNAME@"
             VALUE "ProductShortName", "@PRODUCT_SHORTNAME@"
             VALUE "LastChange", "@LASTCHANGE@"
-            VALUE "Official Build", "@OFFICIAL_BUILD@"
         END
     END
     BLOCK "VarFileInfo"
diff -r -u --color up/chromium/chrome/app/chromium_strings.grd nw/chromium/chrome/app/chromium_strings.grd
--- up/chromium/chrome/app/chromium_strings.grd	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/chromium_strings.grd	2024-08-26 19:32:16.070589536 +0000
@@ -294,10 +294,10 @@
         </then>
         <else>
           <message name="IDS_PRODUCT_NAME" desc="The Chrome application name" translateable="false">
-            Chromium
+            nwjs
           </message>
           <message name="IDS_SHORT_PRODUCT_NAME" desc="The Chrome application short name." translateable="false">
-            Chromium
+            nwjs
           </message>
         </else>
       </if>
@@ -309,7 +309,7 @@
         <message name="IDS_SHORTCUT_NAME_DEV" desc="Unused in Chromium builds" translateable="false">
         </message>
         <message name="IDS_PRODUCT_DESCRIPTION" desc="Browser description">
-          Chromium is a web browser that runs webpages and applications with lightning speed. It's fast, stable, and easy to use. Browse the web more safely with malware and phishing protection built into Chromium.
+          nwjs runtime enables writing native application with Web technologies.
         </message>
         <message name="IDS_WELCOME_TO_CHROME" desc="Welcoming text announced via screen readers the first time Chrome is launched at the conclusion of installation.">
           Welcome to Chromium; new browser window opened
@@ -362,7 +362,7 @@
           </then>
           <else>
             <message name="IDS_BROWSER_WINDOW_TITLE_FORMAT" desc="The format for titles displayed in tabs and popup windows">
-              <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Chromium
+              <ph name="PAGE_TITLE">$1<ex>Google</ex></ph>
             </message>
           </else>
         </if>
@@ -425,10 +425,10 @@
         </then>
         <else>
           <message name="IDS_ABOUT_VERSION_COMPANY_NAME" desc="Company name on the about pages">
-            The Chromium Authors
+            The Chromium Authors, NW.js, Node.js
           </message>
           <message name="IDS_ABOUT_VERSION_COPYRIGHT" desc="Copyright information on the about pages">
-            Copyright <ph name="YEAR">{0,date,y}<ex>2016</ex></ph> The Chromium Authors. All rights reserved.
+            Copyright <ph name="YEAR">{0,date,y}<ex>2016</ex></ph> The Chromium Authors, NW.js, Node.js. All rights reserved.
           </message>
         </else>
       </if>
@@ -944,13 +944,13 @@
 
       <if expr="is_macosx">
         <message name="IDS_APP_MENU_PRODUCT_NAME" desc="The application's short name, used for the Mac's application menu, activity monitor, etc. This should be less than 16 characters. Example: Chrome, not Google Chrome." translateable="false">
-          Chromium
+          nwjs
         </message>
         <message name="IDS_HELPER_NAME" desc="The helper application's name.  Should contain the Chrome application name (IDS_PRODUCT_NAME). Example: Google Chrome Helper.">
-          Chromium Helper
+          nwjs Helper
         </message>
         <message name="IDS_SHORT_HELPER_NAME" desc="The helper application's short name, used for the Mac's application menu, activity monitor, etc. Example: Chrome Helper, not Google Chrome Helper.">
-          Chromium Helper
+          nwjs Helper
         </message>
       </if>
 
diff -r -u --color up/chromium/chrome/app/framework.order nw/chromium/chrome/app/framework.order
--- up/chromium/chrome/app/framework.order	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/framework.order	2024-08-26 19:32:16.086589483 +0000
@@ -18,6 +18,267 @@
 # Provided by build/sanitizers/sanitizer_options.cc in ASan builds.
 ___asan_default_options
 
+__ZN4node14ErrnoExceptionEPN2v87IsolateEiPKcS4_S4_
+__ZN4node11UVExceptionEPN2v87IsolateEiPKcS4_S4_
+__ZN4node11UVExceptionEPN2v87IsolateEiPKcS4_S4_S4_
+__ZN4node16CallTickCallbackEPNS_11EnvironmentEN2v86HandleINS2_5ValueEEE
+__ZN4node12MakeCallbackEPN2v87IsolateENS0_6HandleINS0_6ObjectEEEPKciPNS3_INS0_5ValueEEE
+__ZN4node12MakeCallbackEPN2v87IsolateENS0_6HandleINS0_6ObjectEEENS3_INS0_6StringEEEiPNS3_INS0_5ValueEEE
+__ZN4node12MakeCallbackEPN2v87IsolateENS0_6HandleINS0_6ObjectEEENS3_INS0_8FunctionEEEiPNS3_INS0_5ValueEEE
+__ZN4node6EncodeEPN2v87IsolateEPKcmNS_8encodingE
+__ZN4node6EncodeEPN2v87IsolateEPKtm
+__ZN4node11DecodeBytesEPN2v87IsolateENS0_6HandleINS0_5ValueEEENS_8encodingE
+__ZN4node11DecodeWriteEPN2v87IsolateEPcmNS0_6HandleINS0_5ValueEEENS_8encodingE
+_node_module_register
+__ZN4node14FatalExceptionEPN2v87IsolateERKNS0_8TryCatchE
+__ZN4node9OnMessageEN2v86HandleINS0_7MessageEEENS1_INS0_5ValueEEE
+__ZN4node15LoadEnvironmentEPNS_11EnvironmentE
+__ZN4node4InitEPiPPKcS0_PS3_
+__ZN4node9RunAtExitEPNS_11EnvironmentE
+__ZN4node6AtExitEPFvPvES0_
+__ZN4node14EmitBeforeExitEPNS_11EnvironmentE
+__ZN4node8EmitExitEPNS_11EnvironmentE
+__ZN4node17CreateEnvironmentEPN2v87IsolateENS0_6HandleINS0_7ContextEEEiPKPKciS9_
+__ZN4node17CreateEnvironmentEPN2v87IsolateEP9uv_loop_sNS0_6HandleINS0_7ContextEEEiPKPKciSB_
+__ZN4node5StartEiPPc
+__ZN4node11SetupNWNodeEiPPc
+__ZN4node15StartNWInstanceEiPPcN2v86HandleINS2_7ContextEEE
+__ZN4node17SetNWTickCallbackEPFN2v86HandleINS0_5ValueEEEPNS_11EnvironmentES3_E
+__ZN4node18CallNWTickCallbackEPNS_11EnvironmentEN2v86HandleINS2_5ValueEEE
+__ZN4node6Buffer11HasInstanceEN2v86HandleINS1_5ValueEEE
+__ZN4node6Buffer11HasInstanceEN2v86HandleINS1_6ObjectEEE
+__ZN4node6Buffer4DataEN2v86HandleINS1_5ValueEEE
+__ZN4node6Buffer4DataEN2v86HandleINS1_6ObjectEEE
+__ZN4node6Buffer6LengthEN2v86HandleINS1_5ValueEEE
+__ZN4node6Buffer6LengthEN2v86HandleINS1_6ObjectEEE
+__ZN4node6Buffer3NewEPN2v87IsolateENS1_6HandleINS1_6StringEEENS_8encodingE
+__ZN4node6Buffer3NewEPN2v87IsolateEm
+__ZN4node6Buffer3NewEPN2v87IsolateEPKcm
+__ZN4node6Buffer3NewEPN2v87IsolateEPcmPFvS4_PvES5_
+__ZN4node6Buffer3UseEPN2v87IsolateEPcj
+__ZN4node4i18n22InitializeICUDirectoryEPKc
+__ZN4node7smalloc17ExternalArraySizeEN2v817ExternalArrayTypeE
+__ZN4node7smalloc5AllocEPN2v87IsolateENS1_6HandleINS1_6ObjectEEEmNS1_17ExternalArrayTypeE
+__ZN4node7smalloc5AllocEPN2v87IsolateENS1_6HandleINS1_6ObjectEEEPcmNS1_17ExternalArrayTypeE
+__ZN4node7smalloc5AllocEPN2v87IsolateENS1_6HandleINS1_6ObjectEEEmPFvPcPvES8_NS1_17ExternalArrayTypeE
+__ZN4node7smalloc5AllocEPN2v87IsolateENS1_6HandleINS1_6ObjectEEEPcmPFvS7_PvES8_NS1_17ExternalArrayTypeE
+__ZN4node7smalloc12AllocDisposeEPN2v87IsolateENS1_6HandleINS1_6ObjectEEE
+__ZN4node7smalloc15HasExternalDataEPN2v87IsolateENS1_5LocalINS1_6ObjectEEE
+_uv_fs_poll_init
+_uv_fs_poll_start
+_uv_fs_poll_stop
+_uv_fs_poll_getpath
+_uv_inet_ntop
+_uv_inet_pton
+_uv_queue_work
+_uv_cancel
+_uv_handle_size
+_uv_req_size
+_uv_loop_size
+_uv_buf_init
+_uv_err_name
+_uv_strerror
+_uv_ip4_addr
+_uv_ip6_addr
+_uv_ip4_name
+_uv_ip6_name
+_uv_tcp_bind
+_uv_udp_bind
+_uv_tcp_connect
+_uv_udp_send
+_uv_udp_try_send
+_uv_udp_recv_start
+_uv_udp_recv_stop
+_uv_walk
+_uv_ref
+_uv_unref
+_uv_has_ref
+_uv_stop
+_uv_now
+_uv_recv_buffer_size
+_uv_send_buffer_size
+_uv_fs_event_getpath
+_uv_fs_scandir_next
+_uv_loop_configure
+_uv_default_loop
+_uv_loop_new
+_uv_loop_close
+_uv_loop_delete
+_uv_version
+_uv_version_string
+_uv_async_init
+_uv_async_send
+_uv_hrtime
+_uv_close
+_uv_is_closing
+_uv_backend_fd
+_uv_backend_timeout
+_uv_loop_alive
+_uv_run
+_uv_update_time
+_uv_is_active
+_uv_cwd
+_uv_chdir
+_uv_disable_stdio_inheritance
+_uv_fileno
+_uv_getrusage
+_uv_dlopen
+_uv_dlclose
+_uv_dlsym
+_uv_dlerror
+_uv_fs_access
+_uv_fs_chmod
+_uv_fs_chown
+_uv_fs_close
+_uv_fs_fchmod
+_uv_fs_fchown
+_uv_fs_fdatasync
+_uv_fs_fstat
+_uv_fs_fsync
+_uv_fs_ftruncate
+_uv_fs_futime
+_uv_fs_lstat
+_uv_fs_link
+_uv_fs_mkdir
+_uv_fs_mkdtemp
+_uv_fs_open
+_uv_fs_read
+_uv_fs_scandir
+_uv_fs_readlink
+_uv_fs_rename
+_uv_fs_rmdir
+_uv_fs_sendfile
+_uv_fs_stat
+_uv_fs_symlink
+_uv_fs_unlink
+_uv_fs_utime
+_uv_fs_write
+_uv_fs_req_cleanup
+_uv_getaddrinfo
+_uv_freeaddrinfo
+_uv_getnameinfo
+_uv_loop_init
+_uv_prepare_init
+_uv_prepare_start
+_uv_prepare_stop
+_uv_check_init
+_uv_check_start
+_uv_check_stop
+_uv_idle_init
+_uv_idle_start
+_uv_idle_stop
+_uv_pipe_init
+_uv_pipe_bind
+_uv_pipe_open
+_uv_pipe_connect
+_uv_pipe_getsockname
+_uv_pipe_getpeername
+_uv_pipe_pending_instances
+_uv_pipe_pending_count
+_uv_pipe_pending_type
+_uv_poll_init
+_uv_poll_init_socket
+_uv_poll_stop
+_uv_poll_start
+_uv_spawn
+_uv_process_kill
+_uv_kill
+_uv_signal_init
+_uv_signal_start
+_uv_signal_stop
+_uv_accept
+_uv_listen
+_uv_shutdown
+_uv_write2
+_uv_write
+_uv_try_write
+_uv_read_start
+_uv_read_stop
+_uv_is_readable
+_uv_is_writable
+_uv_stream_set_blocking
+_uv_tcp_init
+_uv_tcp_open
+_uv_tcp_getsockname
+_uv_tcp_getpeername
+_uv_tcp_nodelay
+_uv_tcp_keepalive
+_uv_tcp_simultaneous_accepts
+_uv_thread_create
+_uv_thread_self
+_uv_thread_join
+_uv_thread_equal
+_uv_mutex_init
+_uv_mutex_destroy
+_uv_mutex_lock
+_uv_mutex_trylock
+_uv_mutex_unlock
+_uv_rwlock_init
+_uv_rwlock_destroy
+_uv_rwlock_rdlock
+_uv_rwlock_tryrdlock
+_uv_rwlock_rdunlock
+_uv_rwlock_wrlock
+_uv_rwlock_trywrlock
+_uv_rwlock_wrunlock
+_uv_once
+_uv_sem_init
+_uv_sem_destroy
+_uv_sem_post
+_uv_sem_wait
+_uv_sem_trywait
+_uv_cond_init
+_uv_cond_destroy
+_uv_cond_signal
+_uv_cond_broadcast
+_uv_cond_wait
+_uv_cond_timedwait
+_uv_barrier_init
+_uv_barrier_destroy
+_uv_barrier_wait
+_uv_key_create
+_uv_key_delete
+_uv_key_get
+_uv_key_set
+_uv_timer_init
+_uv_timer_start
+_uv_timer_stop
+_uv_timer_again
+_uv_timer_set_repeat
+_uv_timer_get_repeat
+_uv_tty_init
+_uv_tty_set_mode
+_uv_tty_get_winsize
+_uv_guess_handle
+_uv_tty_reset_mode
+_uv_udp_init
+_uv_udp_open
+_uv_udp_set_membership
+_uv_udp_set_broadcast
+_uv_udp_set_ttl
+_uv_udp_set_multicast_ttl
+_uv_udp_set_multicast_loop
+_uv_udp_set_multicast_interface
+_uv_udp_getsockname
+_uv_setup_args
+_uv_set_process_title
+_uv_get_process_title
+_uv_exepath
+_uv_get_free_memory
+_uv_get_total_memory
+_uv_loadavg
+_uv_resident_set_memory
+_uv_uptime
+_uv_cpu_info
+_uv_free_cpu_info
+_uv_interface_addresses
+_uv_free_interface_addresses
+_uv_fs_event_init
+_uv_fs_event_start
+_uv_fs_event_stop
+
+
+
 # Entry point from the app mode loader.
 _ChromeAppModeStart_v7
 
diff -r -u --color up/chromium/chrome/app/main_dll_loader_win.cc nw/chromium/chrome/app/main_dll_loader_win.cc
--- up/chromium/chrome/app/main_dll_loader_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/main_dll_loader_win.cc	2024-08-26 19:32:16.186589151 +0000
@@ -57,6 +57,8 @@
 
 typedef void (*RelaunchChromeBrowserWithNewCommandLineIfNeededFunc)();
 
+#define BUFSIZE MAX_PATH
+
 void RecordDidRun(const base::FilePath& dll_path) {
   installer::UpdateDidRunState();
 }
@@ -98,6 +100,11 @@
                                 bool is_browser,
                                 base::TimeTicks& preread_begin_ticks,
                                 base::TimeTicks& preread_end_ticks) {
+  bool restore_directory = false;
+  TCHAR Buffer[BUFSIZE];
+  if (::GetCurrentDirectoryW(BUFSIZE, Buffer)) {
+    restore_directory = true;
+  }
   ::SetCurrentDirectoryW(module.DirName().value().c_str());
   if (is_browser) {
     preread_begin_ticks = base::TimeTicks::Now();
@@ -116,6 +123,8 @@
   }
   HMODULE handle = ::LoadLibraryExW(module.value().c_str(), nullptr,
                                     LOAD_WITH_ALTERED_SEARCH_PATH);
+  if (restore_directory)
+    ::SetCurrentDirectory(Buffer);
   return handle;
 }
 
@@ -135,7 +144,7 @@
   HMODULE dll = LoadModuleWithDirectory(*module, cmd_line, is_browser,
                                         preread_begin_ticks, preread_end_ticks);
   if (!dll) {
-    PLOG(ERROR) << "Failed to load Chrome DLL from " << module->value();
+    PLOG(ERROR) << "Failed to load NW DLL from " << module->value();
   }
   return dll;
 }
Only in nw/chromium/chrome/app: nibs
Only in nw/chromium/chrome/app: nw.dll.manifest
Only in nw/chromium/chrome/app: nw.exe.manifest
diff -r -u --color up/chromium/chrome/app/packed_resources_integrity.h nw/chromium/chrome/app/packed_resources_integrity.h
--- up/chromium/chrome/app/packed_resources_integrity.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/packed_resources_integrity.h	2024-08-26 19:32:16.262588899 +0000
@@ -18,8 +18,8 @@
 // //chrome:packed_resources target.
 extern const std::array<uint8_t, 32> kSha256_resources_pak;
 
-extern const std::array<uint8_t, 32> kSha256_chrome_100_percent_pak;
+extern const std::array<uint8_t, 32> kSha256_nw_100_percent_pak;
 
-extern const std::array<uint8_t, 32> kSha256_chrome_200_percent_pak;
+extern const std::array<uint8_t, 32> kSha256_nw_200_percent_pak;
 
 #endif  // CHROME_APP_PACKED_RESOURCES_INTEGRITY_H_
diff -r -u --color up/chromium/chrome/app/theme/chromium/BRANDING nw/chromium/chrome/app/theme/chromium/BRANDING
--- up/chromium/chrome/app/theme/chromium/BRANDING	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/theme/chromium/BRANDING	2024-08-26 19:32:16.858586919 +0000
@@ -1,10 +1,10 @@
-COMPANY_FULLNAME=The Chromium Authors
-COMPANY_SHORTNAME=The Chromium Authors
-PRODUCT_FULLNAME=Chromium
-PRODUCT_SHORTNAME=Chromium
-PRODUCT_INSTALLER_FULLNAME=Chromium Installer
-PRODUCT_INSTALLER_SHORTNAME=Chromium Installer
-COPYRIGHT=Copyright @LASTCHANGE_YEAR@ The Chromium Authors. All rights reserved.
-MAC_BUNDLE_ID=org.chromium.Chromium
-MAC_CREATOR_CODE=Cr24
+COMPANY_FULLNAME=The NW.js Community
+COMPANY_SHORTNAME=nwjs.io
+PRODUCT_FULLNAME=nwjs
+PRODUCT_SHORTNAME=nwjs
+PRODUCT_INSTALLER_FULLNAME=NWJS Installer
+PRODUCT_INSTALLER_SHORTNAME=NWJS Installer
+COPYRIGHT=Copyright @LASTCHANGE_YEAR@, The NW.js community and The Chromium Authors. All rights reserved.
+MAC_BUNDLE_ID=io.nwjs.nwjs
+MAC_CREATOR_CODE=NWJS
 MAC_TEAM_ID=
Binary files up/chromium/chrome/app/theme/chromium/mac/app.icns and nw/chromium/chrome/app/theme/chromium/mac/app.icns differ
Binary files up/chromium/chrome/app/theme/chromium/mac/document.icns and nw/chromium/chrome/app/theme/chromium/mac/document.icns differ
Binary files up/chromium/chrome/app/theme/chromium/product_logo_128.png and nw/chromium/chrome/app/theme/chromium/product_logo_128.png differ
Binary files up/chromium/chrome/app/theme/chromium/product_logo_22_mono.png and nw/chromium/chrome/app/theme/chromium/product_logo_22_mono.png differ
Binary files up/chromium/chrome/app/theme/chromium/product_logo_24.png and nw/chromium/chrome/app/theme/chromium/product_logo_24.png differ
Binary files up/chromium/chrome/app/theme/chromium/product_logo_256.png and nw/chromium/chrome/app/theme/chromium/product_logo_256.png differ
Only in nw/chromium/chrome/app/theme/chromium: product_logo_32.xpm
Binary files up/chromium/chrome/app/theme/chromium/product_logo_64.png and nw/chromium/chrome/app/theme/chromium/product_logo_64.png differ
Binary files up/chromium/chrome/app/theme/chromium/win/chromium.ico and nw/chromium/chrome/app/theme/chromium/win/chromium.ico differ
diff -r -u --color up/chromium/chrome/app/version_assembly/BUILD.gn nw/chromium/chrome/app/version_assembly/BUILD.gn
--- up/chromium/chrome/app/version_assembly/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/version_assembly/BUILD.gn	2024-08-26 19:32:16.894586800 +0000
@@ -25,7 +25,6 @@
     as_invoker_manifest,
     common_controls_manifest,
     default_compatibility_manifest,
-    version_assembly_output_file,
   ]
 
   if (enable_segment_heap) {
diff -r -u --color up/chromium/chrome/app/version_assembly/version_assembly_manifest.template nw/chromium/chrome/app/version_assembly/version_assembly_manifest.template
--- up/chromium/chrome/app/version_assembly/version_assembly_manifest.template	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/app/version_assembly/version_assembly_manifest.template	2024-08-26 19:32:16.894586800 +0000
@@ -4,5 +4,5 @@
       name='@MAJOR@.@MINOR@.@BUILD@.@PATCH@'
       version='@MAJOR@.@MINOR@.@BUILD@.@PATCH@'
       type='win32'/>
-  <file name='chrome_elf.dll'/>
+  <file name='nw_elf.dll'/>
 </assembly>
diff -r -u --color up/chromium/chrome/browser/BUILD.gn nw/chromium/chrome/browser/BUILD.gn
--- up/chromium/chrome/browser/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/BUILD.gn	2024-08-26 19:32:16.898586786 +0000
@@ -1056,8 +1056,8 @@
     "page_load_metrics/observers/tab_strip_page_load_metrics_observer.h",
     "page_load_metrics/observers/third_party_cookie_deprecation_page_load_metrics_observer.cc",
     "page_load_metrics/observers/third_party_cookie_deprecation_page_load_metrics_observer.h",
-    "page_load_metrics/observers/translate_page_load_metrics_observer.cc",
-    "page_load_metrics/observers/translate_page_load_metrics_observer.h",
+    #"page_load_metrics/observers/translate_page_load_metrics_observer.cc",
+    #"page_load_metrics/observers/translate_page_load_metrics_observer.h",
     "page_load_metrics/page_load_metrics_initialize.cc",
     "page_load_metrics/page_load_metrics_initialize.h",
     "page_load_metrics/page_load_metrics_memory_tracker_factory.cc",
@@ -1805,18 +1805,18 @@
     "tracing/trace_event_system_stats_monitor.h",
     "transition_manager/full_browser_transition_manager.cc",
     "transition_manager/full_browser_transition_manager.h",
-    "translate/chrome_translate_client.cc",
-    "translate/chrome_translate_client.h",
-    "translate/translate_frame_binder.cc",
-    "translate/translate_frame_binder.h",
-    "translate/translate_model_service_factory.cc",
-    "translate/translate_model_service_factory.h",
-    "translate/translate_ranker_factory.cc",
-    "translate/translate_ranker_factory.h",
-    "translate/translate_ranker_metrics_provider.cc",
-    "translate/translate_ranker_metrics_provider.h",
-    "translate/translate_service.cc",
-    "translate/translate_service.h",
+    #"translate/chrome_translate_client.cc",
+    #"translate/chrome_translate_client.h",
+    #"translate/translate_frame_binder.cc",
+    #"translate/translate_frame_binder.h",
+    #"translate/translate_model_service_factory.cc",
+    #"translate/translate_model_service_factory.h",
+    #"translate/translate_ranker_factory.cc",
+    #"translate/translate_ranker_factory.h",
+    #"translate/translate_ranker_metrics_provider.cc",
+    #"translate/translate_ranker_metrics_provider.h",
+    #"translate/translate_service.cc",
+    #"translate/translate_service.h",
     "trusted_vault/trusted_vault_encryption_keys_tab_helper.cc",
     "trusted_vault/trusted_vault_encryption_keys_tab_helper.h",
     "trusted_vault/trusted_vault_service_factory.cc",
@@ -2058,6 +2058,7 @@
     "//build/config/chromebox_for_meetings:buildflags",
     "//build/config/compiler:compiler_buildflags",
     "//cc",
+    "//content/nw:nw_browser",
     "//chrome:extra_resources",
     "//chrome:resources",
     "//chrome:strings",
@@ -8903,7 +8904,11 @@
 }
 
 grit("resources") {
-  source = "browser_resources.grd"
+  if (nwjs_sdk) {
+    source = "browser_resources.grd"
+  } else {
+    source = "nwjs_resources.grd"
+  }
 
   use_brotli = true
 
@@ -8911,6 +8916,9 @@
   if (enable_hangout_services_extension) {
     defines += [ "enable_hangout_services_extension" ]
   }
+  if (nwjs_sdk) {
+    defines += [ "nwjs_sdk" ]
+  }
 
   output_dir = "$root_gen_dir/chrome"
   outputs = [
diff -r -u --color up/chromium/chrome/browser/app_controller_mac.mm nw/chromium/chrome/browser/app_controller_mac.mm
--- up/chromium/chrome/browser/app_controller_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/app_controller_mac.mm	2024-08-26 19:32:16.986586495 +0000
@@ -12,6 +12,8 @@
 
 #include "base/apple/bridging.h"
 #include "base/apple/foundation_util.h"
+#include "content/public/common/content_features.h"
+
 #include "base/auto_reset.h"
 #include "base/check_op.h"
 #include "base/command_line.h"
@@ -124,6 +126,8 @@
 #include "ui/native_theme/native_theme_observer.h"
 #include "url/gurl.h"
 
+#include "content/nw/src/nw_content.h"
+
 namespace {
 
 // True while AppController is calling chrome::NewEmptyWindow(). We need a
@@ -218,7 +222,7 @@
   }
 
   Browser* browser = chrome::FindLastActive();
-  CHECK(browser);
+  //CHECK(browser);
   return browser;
 }
 
@@ -831,15 +835,19 @@
          selector:@selector(willPowerOff:)
              name:NSWorkspaceWillPowerOffNotification
            object:nil];
+#if 0
 
   DCHECK([self cmdWMenuItem]);
   DCHECK([self shiftCmdWMenuItem]);
+#endif
 
   // Set up the command updater for when there are no windows open
   [self initMenuState];
 
   // Initialize the Profile menu.
+#if 0
   [self initProfileMenu];
+#endif
 }
 
 - (void)unregisterEventHandlers {
@@ -905,7 +913,7 @@
   // already shutting down.
   if (!browser_shutdown::IsTryingToQuit()) {
     chrome::OnClosingAllBrowsers(true);
-    chrome::CloseAllBrowsersAndQuit();
+    chrome::CloseAllBrowsersAndQuit(false, true);
   }
 
   return num_browsers == 0 ? YES : NO;
@@ -935,6 +943,9 @@
     return YES;
   }
 
+  if (!AppWindowRegistryUtil::CloseAllAppWindows(true))
+    return NSTerminateCancel;
+
   // Check if the preference is turned on.
   const PrefService* prefs = g_browser_process->local_state();
   if (!prefs->GetBoolean(prefs::kConfirmToQuitEnabled)) {
@@ -1072,7 +1083,11 @@
 
 - (void)openStartupUrls {
   DCHECK(_startupComplete);
-  [self openUrlsReplacingNTP:_startupUrls];
+  if (_startupUrls.size()) {
+    base::CommandLine::ForCurrentProcess()->AppendArg(_startupUrls[0].spec());
+    base::CommandLine::ForCurrentProcess()->FixOrigArgv4Finder(_startupUrls[0].spec());
+  }
+  //[self openUrlsReplacingNTP:_startupUrls];
   _startupUrls.clear();
 }
 
@@ -1094,7 +1109,10 @@
     return;
   }
 
+  nw::OSXOpenURLsHook(urls);
+#if 0
   OpenUrlsInBrowser(urls);
+#endif
 }
 
 - (void)resetKeepAliveWhileHidden {
@@ -1130,6 +1148,7 @@
 
   // Notify BrowserList to keep the application running so it doesn't go away
   // when all the browser windows get closed.
+  if (!base::FeatureList::IsEnabled(::features::kNWNewWin))
   _keepAlive = std::make_unique<ScopedKeepAlive>(
       KeepAliveOrigin::APP_CONTROLLER, KeepAliveRestartOption::DISABLED);
 
@@ -1137,7 +1156,7 @@
 
   // If enabled, keep Chrome alive when apps are open instead of quitting all
   // apps.
-  _quitWithAppsController = new QuitWithAppsController();
+  //_quitWithAppsController = new QuitWithAppsController();
 
   // Dynamically update shortcuts for "Close Window" and "Close Tab" menu items.
   [self fileMenu].delegate = self;
@@ -1627,6 +1646,8 @@
 // browser windows.
 - (BOOL)applicationShouldHandleReopen:(NSApplication*)theApplication
                     hasVisibleWindows:(BOOL)hasVisibleWindows {
+  return nw::ApplicationShouldHandleReopenHook(hasVisibleWindows) ? YES : NO;
+#if 0
   // If the browser is currently trying to quit, don't do anything and return NO
   // to prevent AppKit from doing anything.
   if (browser_shutdown::IsTryingToQuit())
@@ -1691,6 +1712,7 @@
   // We've handled the reopen event, so return NO to tell AppKit not
   // to do anything.
   return NO;
+#endif
 }
 
 - (void)initMenuState {
@@ -1891,6 +1913,9 @@
     [dockMenu addItem:[NSMenuItem separatorItem]];
   }
 
+#if 0
+  Profile* profile = [self lastProfileIfLoaded];
+
   NSString* titleStr = l10n_util::GetNSStringWithFixup(IDS_NEW_WINDOW_MAC);
   NSMenuItem* item =
       [[NSMenuItem alloc] initWithTitle:titleStr
@@ -1901,8 +1926,6 @@
   item.enabled = [self validateUserInterfaceItem:item];
   [dockMenu addItem:item];
 
-  Profile* profile = [self lastProfileIfLoaded];
-
   // Buttons below require the profile to be loaded. In particular, if the
   // profile picker is shown at startup, these buttons won't be added until the
   // user picks a profile.
@@ -1921,6 +1944,7 @@
     item.enabled = [self validateUserInterfaceItem:item];
     [dockMenu addItem:item];
   }
+#endif
 
   return dockMenu;
 }
@@ -1962,6 +1986,7 @@
 
   _profilePrefRegistrar.reset();
 
+#if 0
   NSMenuItem* bookmarkItem = [NSApp.mainMenu itemWithTag:IDC_BOOKMARKS_MENU];
   BOOL hidden = bookmarkItem.hidden;
   if (profile != nullptr) {
@@ -1983,12 +2008,15 @@
       _bookmarkMenuBridge->OnProfileWillBeDestroyed();
     }
   }
+#endif
 
   _lastProfile = profile;
 
   if (_lastProfile == nullptr)
     return;
 
+
+#if 0
   auto& entry = _profileBookmarkMenuBridgeMap[profile->GetPath()];
   if (!entry || !entry->GetProfile()) {
     // This creates a deep copy, but only the first 3 items in the root menu
@@ -2017,6 +2045,7 @@
   chrome::BrowserCommandController::
       UpdateSharedCommandsForIncognitoAvailability(
           _menuState.get(), _lastProfile);
+#endif
   _profilePrefRegistrar = std::make_unique<PrefChangeRegistrar>();
   _profilePrefRegistrar->Init(_lastProfile->GetPrefs());
   _profilePrefRegistrar->Add(
@@ -2111,6 +2140,7 @@
 
 // Updates menu items in the File menu to match the main window.
 - (void)updateMenuItemKeyEquivalents {
+#if 0
   // If the browser window has tabs, assign W to "Close Window"
   // and W to "Close Tab", otherwise hide the "Close Tab" item and
   // assign W to "Close Window".
@@ -2149,6 +2179,7 @@
   // Force no longer hidden items to appear, or newly hidden items to
   // disappear.
   [[self fileMenu] update];
+#endif
 }
 
 // This only has an effect on macOS 12+, and requests any state restoration
diff -r -u --color up/chromium/chrome/browser/apps/app_shim/app_shim_termination_manager.cc nw/chromium/chrome/browser/apps/app_shim/app_shim_termination_manager.cc
--- up/chromium/chrome/browser/apps/app_shim/app_shim_termination_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/apps/app_shim/app_shim_termination_manager.cc	2024-08-26 19:32:17.010586415 +0000
@@ -59,12 +59,15 @@
 
   // BrowserListObserver:
   void OnBrowserAdded(Browser* browser) override {
-    browser_session_running_ = true;
+    // fix https://github.com/nwjs/nw.js/issues/7226 for nw1
+    // browser_session_running_ will set to true once devtool is opened
+    // hence the TerminateIfNoAppWindows function will never be called
+    //browser_session_running_ = true;
   }
 
  private:
   void OnClosingAllBrowsersChanged(bool closing) {
-    browser_session_running_ = !closing;
+    //browser_session_running_ = !closing;
   }
 
   base::CallbackListSubscription closing_all_browsers_subscription_;
diff -r -u --color up/chromium/chrome/browser/apps/platform_apps/app_load_service.cc nw/chromium/chrome/browser/apps/platform_apps/app_load_service.cc
--- up/chromium/chrome/browser/apps/platform_apps/app_load_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/apps/platform_apps/app_load_service.cc	2024-08-26 19:32:17.018586388 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/apps/platform_apps/app_load_service.h"
 
+#include "content/nw/src/nw_content.h"
+
 #include "apps/app_restore_service.h"
 #include "apps/launcher.h"
 #include "base/notreached.h"
@@ -68,6 +70,8 @@
     return false;
   }
 
+  nw::SetMainExtensionId(extension_id);
+
   // Schedule the app to be launched once loaded.
   PostReloadAction& action = post_reload_actions_[extension_id];
   action.action_type = LAUNCH_FOR_LOAD_AND_LAUNCH;
@@ -131,7 +135,7 @@
   extensions::ExtensionPrefs* extension_prefs =
       extensions::ExtensionPrefs::Get(browser_context);
   if (WasUnloadedForReload(extension->id(), reason) &&
-      extension_prefs->IsActive(extension->id()) &&
+      (extension->is_nwjs_app() || extension_prefs->IsActive(extension->id())) &&
       !HasPostReloadAction(extension->id())) {
     post_reload_actions_[extension->id()].action_type = LAUNCH_FOR_RELOAD;
   }
diff -r -u --color up/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.cc nw/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.cc
--- up/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.cc	2024-08-26 19:32:17.022586374 +0000
@@ -42,7 +42,7 @@
 
 // static
 bool AppWindowRegistryUtil::IsAppWindowVisibleInAnyProfile(
-    int window_type_mask) {
+                                                           int window_type_mask, bool check_visible) {
   std::vector<Profile*> profiles =
       g_browser_process->profile_manager()->GetLoadedProfiles();
   for (std::vector<Profile*>::const_iterator i = profiles.begin();
@@ -57,7 +57,7 @@
       continue;
 
     for (const AppWindow* window : app_windows) {
-      if (!window->is_hidden() &&
+      if ((!window->is_hidden() || !check_visible )&&
           (window_type_mask == 0 || (window->window_type() & window_type_mask)))
         return true;
     }
@@ -67,7 +67,7 @@
 }
 
 // static
-void AppWindowRegistryUtil::CloseAllAppWindows() {
+bool AppWindowRegistryUtil::CloseAllAppWindows(bool user_force) {
   std::vector<Profile*> profiles =
       g_browser_process->profile_manager()->GetLoadedProfiles();
   for (std::vector<Profile*>::const_iterator i = profiles.begin();
@@ -82,8 +82,13 @@
     AppWindowList window_list_copy(registry->app_windows());
     for (AppWindow* window : window_list_copy) {
       // Ensure window is still valid.
-      if (base::Contains(registry->app_windows(), window))
-        window->GetBaseWindow()->Close();
+      if (base::Contains(registry->app_windows(), window)) {
+        if (window->NWCanClose(user_force))
+          window->GetBaseWindow()->Close();
+        else
+          return false;
+      }
     }
   }
+  return true;
 }
diff -r -u --color up/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.h nw/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.h
--- up/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.h	2024-08-26 19:32:17.022586374 +0000
@@ -21,10 +21,10 @@
   // Returns true if the number of visible app windows registered across all
   // browser contexts is non-zero. |window_type_mask| is a bitwise OR filter of
   // AppWindow::WindowType, or 0 for any window type.
-  static bool IsAppWindowVisibleInAnyProfile(int window_type_mask);
+  static bool IsAppWindowVisibleInAnyProfile(int window_type_mask, bool check_visible = true);
 
   // Close all app windows in all profiles.
-  static void CloseAllAppWindows();
+  static bool CloseAllAppWindows(bool user_force = false);
 };
 
 #endif  // CHROME_BROWSER_APPS_PLATFORM_APPS_APP_WINDOW_REGISTRY_UTIL_H_
diff -r -u --color up/chromium/chrome/browser/apps/platform_apps/browser_context_keyed_service_factories.cc nw/chromium/chrome/browser/apps/platform_apps/browser_context_keyed_service_factories.cc
--- up/chromium/chrome/browser/apps/platform_apps/browser_context_keyed_service_factories.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/apps/platform_apps/browser_context_keyed_service_factories.cc	2024-08-26 19:32:17.022586374 +0000
@@ -12,7 +12,7 @@
 
 void EnsureBrowserContextKeyedServiceFactoriesBuilt() {
   apps::AppLoadServiceFactory::GetInstance();
-  AppShortcutManagerFactory::GetInstance();
+  //AppShortcutManagerFactory::GetInstance();
   AppTerminationObserver::GetFactoryInstance();
 }
 
diff -r -u --color up/chromium/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc nw/chromium/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc
--- up/chromium/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc	2024-08-26 19:32:17.490586222 +0000
@@ -574,7 +574,7 @@
 }
 
 void ChromeAutocompleteProviderClient::PromptPageTranslation() {
-#if !BUILDFLAG(IS_ANDROID)
+#if 0 //!BUILDFLAG(IS_ANDROID)
   Browser* browser = BrowserList::GetInstance()->GetLastActive();
   content::WebContents* contents = nullptr;
   if (browser)
diff -r -u --color up/chromium/chrome/browser/background/background_application_list_model.cc nw/chromium/chrome/browser/background/background_application_list_model.cc
--- up/chromium/chrome/browser/background/background_application_list_model.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/background/background_application_list_model.cc	2024-08-26 19:32:17.506586231 +0000
@@ -247,8 +247,10 @@
   //    manifest.
 
   // Not a background app if we don't have the background permission.
+  // NWJS: nwjs_default_app is listed as background app and prevents
+  // quit so we need to disable it here
   if (!extension.permissions_data()->HasAPIPermission(
-          APIPermissionID::kBackground)) {
+                     APIPermissionID::kBackground, true)) {
     return false;
   }
 
@@ -385,7 +387,8 @@
         // Policy changes are only used for host permissions, so the
         // "background"
         // permission would never be present in  permissions .
-        NOTREACHED_IN_MIGRATION();
+        break;
+        //NOTREACHED_IN_MIGRATION();
     }
   }
 }
diff -r -u --color up/chromium/chrome/browser/background/background_contents_service.cc nw/chromium/chrome/browser/background/background_contents_service.cc
--- up/chromium/chrome/browser/background/background_contents_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/background/background_contents_service.cc	2024-08-26 19:32:17.506586231 +0000
@@ -722,6 +722,7 @@
 
 void BackgroundContentsService::HandleExtensionCrashed(
     const extensions::Extension* extension) {
+#if 0
   // When the extensions crash, notify the user about it and restart the crashed
   // contents.
   if (!extension)
@@ -736,6 +737,7 @@
     // Restart the extension.
     RestartForceInstalledExtensionOnCrash(extension);
   }
+#endif
 }
 
 void BackgroundContentsService::NotificationImageReady(
diff -r -u --color up/chromium/chrome/browser/browser_features.cc nw/chromium/chrome/browser/browser_features.cc
--- up/chromium/chrome/browser/browser_features.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/browser_features.cc	2024-08-26 19:32:17.514586235 +0000
@@ -70,7 +70,7 @@
              "DestroyProfileOnBrowserClose",
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN) || \
     BUILDFLAG(IS_CHROMEOS_LACROS)
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT);
 #else
              base::FEATURE_DISABLED_BY_DEFAULT);
 #endif
@@ -111,7 +111,7 @@
 // "frame" when inspecting a WebContents.
 BASE_FEATURE(kDevToolsTabTarget,
              "DevToolsTabTarget",
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT);
 
 // Let DevTools front-end log extensive VisualElements-style UMA metrics for
 // impressions and interactions.
diff -r -u --color up/chromium/chrome/browser/browser_process.h nw/chromium/chrome/browser/browser_process.h
--- up/chromium/chrome/browser/browser_process.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/browser_process.h	2024-08-26 19:32:17.518586238 +0000
@@ -254,6 +254,7 @@
   virtual void StartAutoupdateTimer() = 0;
 #endif
 
+
   virtual component_updater::ComponentUpdateService* component_updater() = 0;
 
   virtual MediaFileSystemRegistry* media_file_system_registry() = 0;
diff -r -u --color up/chromium/chrome/browser/browser_process_impl.cc nw/chromium/chrome/browser/browser_process_impl.cc
--- up/chromium/chrome/browser/browser_process_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/browser_process_impl.cc	2024-08-26 19:32:17.518586238 +0000
@@ -1,7 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunreachable-code"
 #include "chrome/browser/browser_process_impl.h"
 
 #include <stddef.h>
@@ -1176,6 +1176,7 @@
 }
 #endif
 
+#if 1
 component_updater::ComponentUpdateService*
 BrowserProcessImpl::component_updater() {
   if (component_updater_)
@@ -1197,6 +1198,7 @@
 
   return component_updater_.get();
 }
+#endif
 
 void BrowserProcessImpl::OnKeepAliveStateChanged(bool is_keeping_alive) {
   if (is_keeping_alive)
@@ -1227,8 +1229,11 @@
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   // chrome-extension:// URLs are safe to request anywhere, but may only
   // commit (including in iframes) in extension processes.
-  ChildProcessSecurityPolicy::GetInstance()->RegisterWebSafeIsolatedScheme(
-      extensions::kExtensionScheme, true);
+  // NWJS: Upstream: Remove command line/field trial support for
+  // disabling Isolate
+  // Extensions. https://codereview.chromium.org/2850793005
+  ChildProcessSecurityPolicy::GetInstance()->RegisterWebSafeScheme(
+      extensions::kExtensionScheme);
 #endif
 
   battery_metrics_ = std::make_unique<BatteryMetrics>();
@@ -1557,7 +1562,7 @@
 
 void BrowserProcessImpl::Pin() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  CHECK(!IsShuttingDown());
+  //CHECK(!IsShuttingDown());
 }
 
 void BrowserProcessImpl::Unpin() {
diff -r -u --color up/chromium/chrome/browser/browser_process_platform_part_mac.mm nw/chromium/chrome/browser/browser_process_platform_part_mac.mm
--- up/chromium/chrome/browser/browser_process_platform_part_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/browser_process_platform_part_mac.mm	2024-08-26 19:32:17.518586238 +0000
@@ -4,6 +4,9 @@
 
 #include "chrome/browser/browser_process_platform_part_mac.h"
 
+#include "base/feature_list.h"
+#include "chrome/browser/lifetime/application_lifetime_desktop.h"
+
 #include "base/apple/foundation_util.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/time/time.h"
@@ -34,14 +37,16 @@
   // come down this code path at all.) URL requests to exit have
   // |try_to_quit_application| set to true; keyboard menu invocations have it
   // set to false.
-
   if (!try_to_quit_application) {
+    chrome::CloseAllBrowsers(false, true);
+    return;
+#if 0
     // A keyboard menu invocation.
     if (![AppController.sharedController runConfirmQuitPanel]) {
       return;
     }
+#endif
   }
-
   chrome_browser_application_mac::Terminate();
 }
 
diff -r -u --color up/chromium/chrome/browser/browser_resources.grd nw/chromium/chrome/browser/browser_resources.grd
--- up/chromium/chrome/browser/browser_resources.grd	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/browser_resources.grd	2024-08-26 19:32:17.518586238 +0000
@@ -32,6 +32,8 @@
       </if>
     </structures>
     <includes>
+      <include name="IDR_NWJS_DEFAPP_MANIFEST" file="resources\nwjs_default_app\manifest.json" type="BINDATA" />
+      <include name="IDR_NWJS_DEFAPP_MANIFEST_NEWWIN" file="resources\nwjs_newwin_app\manifest.json" type="BINDATA" />
       <if expr="is_win">
         <include name="IDR_ABOUT_CONFLICTS_HTML" file="resources\conflicts\about_conflicts.html" type="BINDATA" />
         <include name="IDR_ABOUT_CONFLICTS_JS" file="${root_gen_dir}\chrome\browser\resources\conflicts\tsc\about_conflicts.js" use_base_dir="false" type="BINDATA" />
diff -r -u --color up/chromium/chrome/browser/browser_switcher/browser_switcher_navigation_throttle.cc nw/chromium/chrome/browser/browser_switcher/browser_switcher_navigation_throttle.cc
--- up/chromium/chrome/browser/browser_switcher/browser_switcher_navigation_throttle.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/browser_switcher/browser_switcher_navigation_throttle.cc	2024-08-26 19:32:17.518586238 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/browser_switcher/browser_switcher_navigation_throttle.h"
 
+#pragma clang diagnostic ignored "-Wunused-function"
+
 #include <memory>
 
 #include "base/functional/bind.h"
@@ -88,7 +90,7 @@
 BrowserSwitcherNavigationThrottle::MaybeCreateThrottleFor(
     content::NavigationHandle* navigation) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
+#if 0
   content::BrowserContext* browser_context =
       navigation->GetWebContents()->GetBrowserContext();
   Profile* profile = Profile::FromBrowserContext(browser_context);
@@ -102,6 +104,8 @@
   return std::make_unique<navigation_interception::InterceptNavigationThrottle>(
       navigation, base::BindRepeating(&MaybeLaunchAlternativeBrowser),
       navigation_interception::SynchronyMode::kSync);
+#endif
+  return nullptr;
 }
 
 }  // namespace browser_switcher
diff -r -u --color up/chromium/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc nw/chromium/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc
--- up/chromium/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc	2024-08-26 19:32:17.522586240 +0000
@@ -760,9 +760,10 @@
         ProtocolHandlerRegistryFactory::GetForBrowserContext(profile_);
     if (handler_registry)
       handler_registry->ClearUserDefinedHandlers(delete_begin_, delete_end_);
-
+#if 0
     ChromeTranslateClient::CreateTranslatePrefs(prefs)
         ->DeleteNeverPromptSitesBetween(delete_begin_, delete_end_);
+#endif
 
     host_content_settings_map_->ClearSettingsForOneTypeWithPredicate(
         ContentSettingsType::PERMISSION_AUTOREVOCATION_DATA, delete_begin,
diff -r -u --color up/chromium/chrome/browser/chrome_browser_application_mac.h nw/chromium/chrome/browser/chrome_browser_application_mac.h
--- up/chromium/chrome/browser/chrome_browser_application_mac.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_application_mac.h	2024-08-26 19:32:17.534586246 +0000
@@ -23,6 +23,8 @@
 
 - (BOOL)voiceOverStateForTesting;
 
+- (void)closeAllWindowsQuit:(id)sender;
+
 @end
 
 #endif  // __OBJC__
diff -r -u --color up/chromium/chrome/browser/chrome_browser_application_mac.mm nw/chromium/chrome/browser/chrome_browser_application_mac.mm
--- up/chromium/chrome/browser/chrome_browser_application_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_application_mac.mm	2024-08-26 19:32:17.534586246 +0000
@@ -8,6 +8,11 @@
 
 #include "base/apple/call_with_eh_frame.h"
 #include "base/check.h"
+#include "chrome/browser/apps/platform_apps/app_window_registry_util.h"
+#include "chrome/browser/lifetime/browser_close_manager.h"
+#include "chrome/browser/lifetime/application_lifetime_desktop.h"
+#include "content/public/common/content_features.h"
+
 #include "base/command_line.h"
 #import "base/mac/mac_util.h"
 #include "base/observer_list.h"
@@ -317,6 +322,15 @@
 // the NSApplicationWillTerminateNotification to be posted, which ends the
 // NSApplication event loop, so final post- MessageLoop::Run() work is done
 // before exiting.
+
+- (void)closeAllWindowsQuit:(id)sender {
+  if (base::FeatureList::IsEnabled(::features::kNWNewWin)) {
+    chrome::CloseAllBrowsers(false, true);
+    return;
+  }
+  AppWindowRegistryUtil::CloseAllAppWindows(true);
+}
+
 - (void)terminate:(id)sender {
   [AppController.sharedController tryToTerminateApplication:self];
   // Return, don't exit. The application is responsible for exiting on its own.
diff -r -u --color up/chromium/chrome/browser/chrome_browser_interface_binders.cc nw/chromium/chrome/browser/chrome_browser_interface_binders.cc
--- up/chromium/chrome/browser/chrome_browser_interface_binders.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_interface_binders.cc	2024-08-26 19:32:17.534586246 +0000
@@ -963,10 +963,10 @@
         base::BindRepeating(
             &performance_manager::BindDocumentCoordinationUnit));
   }
-
+#if 0
   map->Add<translate::mojom::ContentTranslateDriver>(
       base::BindRepeating(&translate::BindContentTranslateDriver));
-
+#endif
   map->Add<blink::mojom::CredentialManager>(
       base::BindRepeating(&ChromePasswordManagerClient::BindCredentialManager));
 
diff -r -u --color up/chromium/chrome/browser/chrome_browser_main.cc nw/chromium/chrome/browser/chrome_browser_main.cc
--- up/chromium/chrome/browser/chrome_browser_main.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_main.cc	2024-08-26 19:32:17.534586246 +0000
@@ -14,6 +14,9 @@
 #include <utility>
 #include <vector>
 
+#include "content/nw/src/browser/nw_chrome_browser_hooks.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
 #include "base/at_exit.h"
 #include "base/base_switches.h"
 #include "base/command_line.h"
@@ -543,6 +546,9 @@
   }
 #endif
 
+  if (!nw::ProcessSingletonNotificationCallbackHook(command_line, current_directory))
+    return;
+
 #if BUILDFLAG(IS_LINUX)
   // Set the global activation token sent as a command line switch by another
   // browser process. This also removes the switch after use to prevent any side
@@ -755,7 +761,7 @@
   g_browser_process->metrics_service()->StartUpdatingLastLiveTimestamp();
 #endif
 
-  g_browser_process->GetMetricsServicesManager()->UpdateUploadPermissions(true);
+  g_browser_process->GetMetricsServicesManager()->UpdateUploadPermissions(false);
 }
 
 void ChromeBrowserMainParts::RecordBrowserStartupTime() {
@@ -927,9 +933,13 @@
   // should be deferred to PreMainMessageLoopRunImpl.
 
   TRACE_EVENT0("startup", "ChromeBrowserMainParts::PreCreateThreads");
+
   result_code_ = PreCreateThreadsImpl();
 
   if (result_code_ == content::RESULT_CODE_NORMAL_EXIT) {
+    result_code_ = nw::MainPartsPreCreateThreadsHook();
+    if (result_code_ != content::RESULT_CODE_NORMAL_EXIT)
+      return result_code_;
     // These members must be initialized before exiting this function normally.
 #if !BUILDFLAG(IS_ANDROID)
     DCHECK(browser_creator_.get());
@@ -1244,6 +1254,8 @@
 
   result_code_ = PreMainMessageLoopRunImpl();
 
+  nw::MainPartsPreMainMessageLoopRunHook();
+
   for (auto& chrome_extra_part : chrome_extra_parts_)
     chrome_extra_part->PreMainMessageLoopRun();
 
@@ -1385,8 +1397,8 @@
 
   language::LanguageUsageMetrics::RecordAcceptLanguages(
       profile->GetPrefs()->GetString(language::prefs::kAcceptLanguages));
-  translate::TranslateMetricsLoggerImpl::LogApplicationStartMetrics(
-      ChromeTranslateClient::CreateTranslatePrefs(profile->GetPrefs()));
+  //translate::TranslateMetricsLoggerImpl::LogApplicationStartMetrics(
+  //    ChromeTranslateClient::CreateTranslatePrefs(profile->GetPrefs()));
 // On ChromeOS results in a crash. https://crbug.com/1151558
 #if !BUILDFLAG(IS_CHROMEOS_ASH)
   language::LanguageUsageMetrics::RecordPageLanguages(
@@ -1626,6 +1638,7 @@
 #endif  // BUILDFLAG(ENABLE_BACKGROUND_MODE)
   // Post-profile init ---------------------------------------------------------
 
+#if 0
   TranslateService::Initialize();
   if (base::FeatureList::IsEnabled(features::kGeoLanguage) ||
       language::GetOverrideLanguageModel() ==
@@ -1633,7 +1646,7 @@
     language::GeoLanguageProvider::GetInstance()->StartUp(
         browser_process_->local_state());
   }
-
+#endif
   // Needs to be done before PostProfileInit, since login manager on CrOS is
   // called inside PostProfileInit.
   content::WebUIControllerFactory::RegisterFactory(
@@ -1666,7 +1679,7 @@
   // Call `PostProfileInit()`and set it up for profiles created later.
   profile_init_manager_ = std::make_unique<ProfileInitManager>(this, profile);
 
-#if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_CHROMEOS_ASH)
+#if 0 //!BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_CHROMEOS_ASH)
   // Execute first run specific code after the PrefService has been initialized
   // and preferences have been registered since some of the import code depends
   // on preferences.
@@ -1722,7 +1735,7 @@
   //
   // This can't be created in the BrowserProcessImpl constructor because it
   // needs to read prefs that get set after that runs.
-  browser_process_->intranet_redirect_detector();
+  //browser_process_->intranet_redirect_detector();
 #endif
 
 #if BUILDFLAG(ENABLE_PDF)
@@ -1934,7 +1947,7 @@
   for (auto& chrome_extra_part : chrome_extra_parts_)
     chrome_extra_part->PostMainMessageLoopRun();
 
-  TranslateService::Shutdown();
+  //TranslateService::Shutdown();
 
 #if BUILDFLAG(ENABLE_PROCESS_SINGLETON)
   ChromeProcessSingleton::GetInstance()->Cleanup();
@@ -2021,6 +2034,9 @@
 #endif  // !BUILDFLAG(IS_CHROMEOS_ASH)
 
   device_event_log::Shutdown();
+
+  nw::MainPartsPostDestroyThreadsHook();
+
 #endif  // BUILDFLAG(IS_ANDROID)
 }
 
diff -r -u --color up/chromium/chrome/browser/chrome_browser_main_mac.mm nw/chromium/chrome/browser/chrome_browser_main_mac.mm
--- up/chromium/chrome/browser/chrome_browser_main_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_main_mac.mm	2024-08-26 19:32:17.534586246 +0000
@@ -4,6 +4,9 @@
 
 #include "chrome/browser/chrome_browser_main_mac.h"
 
+#include "content/nw/src/nw_base.h"
+#include "base/strings/utf_string_conversions.h"
+
 #import <Cocoa/Cocoa.h>
 
 #include <memory>
@@ -101,7 +104,7 @@
   // point (needed to load the nib).
   CHECK(ui::ResourceBundle::HasSharedInstance());
 
-#if !BUILDFLAG(CHROME_FOR_TESTING)
+#if 0
   // Disk image installation is sort of a first-run task, so it shares the
   // no first run switches.
   //
@@ -130,7 +133,7 @@
   CHECK_NE(nil, NSApp.delegate);
 
   chrome::BuildMainMenu(NSApp, app_controller,
-                        l10n_util::GetStringUTF16(IDS_PRODUCT_NAME), false);
+                        base::UTF8ToUTF16(nw::package()->GetName()), true);
   [app_controller mainMenuCreated];
 
   ui::WarmScreenCapture();
diff -r -u --color up/chromium/chrome/browser/chrome_content_browser_client.cc nw/chromium/chrome/browser/chrome_content_browser_client.cc
--- up/chromium/chrome/browser/chrome_content_browser_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_content_browser_client.cc	2024-08-26 19:32:17.538586248 +0000
@@ -3,6 +3,8 @@
 // found in the LICENSE file.
 
 #include "chrome/browser/chrome_content_browser_client.h"
+#include "content/browser/renderer_host/render_process_host_impl.h"
+#include "components/crash/core/app/crash_reporter_client.h"
 
 #include <iterator>
 #include <map>
@@ -14,6 +16,12 @@
 #include <utility>
 #include <vector>
 
+#include "content/nw/src/common/nw_content_common_hooks.h"
+#include "content/nw/src/common/shell_switches.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_base.h"
+#include "chrome/browser/profiles/profile_manager.h"
+
 #include "base/base_switches.h"
 #include "base/check_deref.h"
 #include "base/command_line.h"
@@ -666,6 +674,7 @@
 #include "extensions/browser/extension_navigation_throttle.h"
 #include "extensions/browser/extension_protocols.h"
 #include "extensions/browser/extension_registry.h"
+#include "chrome/browser/extensions/extension_service.h"
 #include "extensions/browser/extension_util.h"
 #include "extensions/browser/guest_view/web_view/web_view_guest.h"
 #include "extensions/browser/guest_view/web_view/web_view_permission_helper.h"
@@ -752,7 +761,7 @@
 #endif
 
 // This should be after all other #includes.
-#if defined(_WINDOWS_)  // Detect whether windows.h was included.
+#if 0 //defined(_WINDOWS_)  // Detect whether windows.h was included.
 #include "base/win/windows_h_disallowed.h"
 #endif  // defined(_WINDOWS_)
 
@@ -2185,6 +2194,24 @@
   return true;
 }
 
+bool ChromeContentBrowserClient::IsNWOrigin(const url::Origin& origin, content::BrowserContext* context) {
+  return IsNWURL(origin.GetURL(), context);
+}
+
+bool ChromeContentBrowserClient::IsNWURL(const GURL& url, content::BrowserContext* context) {
+  const extensions::ExtensionRegistry* registry =
+    extensions::ExtensionRegistry::Get(context);
+  const extensions::Extension* extension =
+    registry->enabled_extensions().GetByID(nw::GetMainExtensionId());
+  if (!extension)
+    return false;
+  if (url.SchemeIs(extensions::kExtensionScheme) && url.host() == nw::GetMainExtensionId())
+    return true;
+  if (extension->web_extent().MatchesURL(url))
+    return true;
+  return false;
+}
+
 bool ChromeContentBrowserClient::ShouldTreatURLSchemeAsFirstPartyWhenTopLevel(
     std::string_view scheme,
     bool is_embedded_origin_secure) {
@@ -2458,6 +2485,23 @@
 bool ChromeContentBrowserClient::ShouldTryToUseExistingProcessHost(
     content::BrowserContext* browser_context,
     const GURL& url) {
+  // PDF extension should use new process, or there is a loop of IPC
+  // message BrowserPluginHostMsg_SetFocus and InputMsg_SetFocus
+  // #4335
+
+  if (url.SchemeIs(extensions::kExtensionScheme)) {
+    if (url.host() == nw::GetMainExtensionId() && !content::RenderProcessHostImpl::main_host())
+      return false; //other extensions could load before the main
+                    //extension NWJS#5483
+    if (url.host() == extension_misc::kPdfExtensionId)
+      return false;
+  }
+
+  if (nw::PinningRenderer())
+    return true;
+  else
+    return false;
+#if 0
   // Top Chrome WebUI should try to share a RenderProcessHost with other
   // existing Top Chrome WebUI.
   if (IsTopChromeWebUIURL(url)) {
@@ -2465,6 +2509,7 @@
   }
 
   return false;
+#endif
 }
 
 bool ChromeContentBrowserClient::ShouldEmbeddedFramesTryToReuseExistingProcess(
@@ -2526,9 +2571,11 @@
 ChromeContentBrowserClient::GetOriginsRequiringDedicatedProcess() {
   std::vector<url::Origin> isolated_origin_list;
 
+#if 0
   if (DoesGaiaOriginRequireDedicatedProcess()) {
     isolated_origin_list.push_back(GaiaUrls::GetInstance()->gaia_origin());
   }
+#endif
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   auto origins_from_extensions = ChromeContentBrowserClientExtensionsPart::
@@ -2772,7 +2819,10 @@
   command_line->AppendSwitchASCII(ash::switches::kHomedir, homedir.value());
 #endif
 
+  command_line->AppendSwitchPath(switches::kNWAppPath, nw::package()->path());
   if (process_type == switches::kRendererProcess) {
+    command_line->AppendSwitch(switches::kNWJS);
+
     content::RenderProcessHost* process =
         content::RenderProcessHost::FromID(child_process_id);
     if (process) {
@@ -2939,6 +2989,7 @@
 
     // Please keep this in alphabetical order.
     static const char* const kSwitchNames[] = {
+      switches::kEnableSpellChecking,
       autofill::switches::kIgnoreAutocompleteOffForAutofill,
       autofill::switches::kShowAutofillSignatures,
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -3101,6 +3152,9 @@
 }
 
 gfx::ImageSkia ChromeContentBrowserClient::GetDefaultFavicon() {
+  gfx::ImageSkia* icon = nw::GetAppIcon();
+  if (icon)
+    return *icon;
   return favicon::GetDefaultFavicon().AsImageSkia();
 }
 
@@ -3254,6 +3308,20 @@
 #endif
 }
 
+base::FilePath ChromeContentBrowserClient::GetRootPath() {
+  std::string id = nw::GetMainExtensionId();
+  base::FilePath path;
+  extensions::ExtensionRegistry* extension_registry =
+    extensions::ExtensionRegistry::Get(ProfileManager::GetLastUsedProfileIfLoaded());
+  if (extension_registry) {
+    const extensions::Extension* extension =
+      extension_registry->GetExtensionById(id, extensions::ExtensionRegistry::EVERYTHING);
+    if (extension)
+      path = extension->path();
+  }
+  return path;
+}
+
 void ChromeContentBrowserClient::AllowWorkerFileSystem(
     const GURL& url,
     content::BrowserContext* browser_context,
@@ -4176,12 +4244,18 @@
   }
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 
+  auto* registry = extensions::ExtensionRegistry::Get(profile);
+  if (registry) {
+    const Extension* extension =
+        registry->enabled_extensions().GetExtensionOrAppByURL(opener_url);
+    if (extension && extension->is_nwjs_app())
+      return true;
+  }
   // If the opener is trying to create a background window but doesn't have
   // the appropriate permission, fail the attempt.
   if (container_type == content::mojom::WindowContainerType::BACKGROUND) {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
     auto* process_map = extensions::ProcessMap::Get(profile);
-    auto* registry = extensions::ExtensionRegistry::Get(profile);
     if (!URLHasExtensionPermission(process_map, registry, opener_url,
                                    opener->GetProcess()->GetID(),
                                    APIPermissionID::kBackground)) {
@@ -4212,12 +4286,15 @@
   if (target_url.SchemeIs(extensions::kExtensionScheme)) {
     // Intentionally duplicating |registry| code from above because we want to
     // reduce calls to retrieve them as this function is a SYNC IPC handler.
-    auto* registry = extensions::ExtensionRegistry::Get(profile);
     const Extension* extension =
         registry->enabled_extensions().GetExtensionOrAppByURL(target_url);
     if (extension && extension->is_platform_app()) {
+#if 1
+      return true;
+#else
       // window.open() may not be used to load v2 apps in a regular tab.
       return false;
+#endif
     }
   }
 #endif
@@ -4553,7 +4630,7 @@
       web_contents->GetPrimaryMainFrame()->GetSiteInstance()->GetSiteURL(),
       web_contents, GetWebTheme());
 
-  web_prefs->translate_service_available = TranslateService::IsAvailable(prefs);
+  web_prefs->translate_service_available = false; //TranslateService::IsAvailable(prefs);
 
   std::optional<ui::CaptionStyle> style =
       captions::GetCaptionStyleFromUserSettings(prefs,
@@ -4592,6 +4669,8 @@
 
   web_prefs->prefers_default_scrollbar_styles =
       prefs->GetBoolean(prefs::kPrefersDefaultScrollbarStyles);
+
+  nw::OverrideWebkitPrefsHook(web_contents, web_prefs);
 }
 
 bool ChromeContentBrowserClientParts::OverrideWebPreferencesAfterNavigation(
@@ -6400,9 +6479,9 @@
   // gets approval from ChildProcessSecurityPolicy. Keep this logic in sync with
   // ExtensionWebContentsObserver::RenderFrameCreated.
   Manifest::Type type = extension->GetType();
-  if ((type == Manifest::TYPE_EXTENSION ||
+  if (type == Manifest::TYPE_NWJS_APP || ((type == Manifest::TYPE_EXTENSION ||
        type == Manifest::TYPE_LEGACY_PACKAGED_APP) &&
-      extensions::util::AllowFileAccess(extension->id(), browser_context)) {
+      extensions::util::AllowFileAccess(extension->id(), browser_context))) {
     factories->emplace(
         url::kFileScheme,
         SpecialAccessFileURLLoaderFactory::Create(render_process_id));
@@ -7389,6 +7468,7 @@
     uint64_t line,
     uint64_t column,
     std::optional<content::LegacyTechCookieIssueDetails> cookie_issue_details) {
+#if 0
   WebContents* web_contents =
       WebContents::FromRenderFrameHost(render_frame_host);
   DCHECK(web_contents);
@@ -7404,6 +7484,7 @@
   }
   service->ReportEvent(type, url, frame_url, filename, line, column,
                        cookie_issue_details);
+#endif
 }
 
 bool ChromeContentBrowserClient::CanAcceptUntrustedExchangesIfNeeded() {
diff -r -u --color up/chromium/chrome/browser/chrome_content_browser_client.h nw/chromium/chrome/browser/chrome_content_browser_client.h
--- up/chromium/chrome/browser/chrome_content_browser_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_content_browser_client.h	2024-08-26 19:32:17.538586248 +0000
@@ -204,12 +204,14 @@
   bool ShouldTreatURLSchemeAsFirstPartyWhenTopLevel(
       std::string_view scheme,
       bool is_embedded_origin_secure) override;
+  bool IsNWOrigin(const url::Origin& origin, content::BrowserContext* context) override;
   bool ShouldIgnoreSameSiteCookieRestrictionsWhenTopLevel(
       std::string_view scheme,
       bool is_embedded_origin_secure) override;
   std::string GetSiteDisplayNameForCdmProcess(
       content::BrowserContext* browser_context,
       const GURL& site_url) override;
+  static bool IsNWURL(const GURL& origin, content::BrowserContext* context);
   void OverrideURLLoaderFactoryParams(
       content::BrowserContext* browser_context,
       const url::Origin& origin,
@@ -320,6 +322,7 @@
       const GURL& destination_url,
       base::OnceCallback<void(file_access::ScopedFileAccess)>
           continuation_callback) override;
+  base::FilePath GetRootPath() override;
   void AllowWorkerFileSystem(
       const GURL& url,
       content::BrowserContext* browser_context,
diff -r -u --color up/chromium/chrome/browser/component_updater/registration.cc nw/chromium/chrome/browser/component_updater/registration.cc
--- up/chromium/chrome/browser/component_updater/registration.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/component_updater/registration.cc	2024-08-26 19:32:17.598586281 +0000
@@ -100,13 +100,15 @@
 namespace component_updater {
 
 void RegisterComponentsForUpdate() {
-  auto* const cus = g_browser_process->component_updater();
 
+#if 0
 #if BUILDFLAG(IS_WIN)
   RegisterRecoveryImprovedComponent(cus, g_browser_process->local_state());
 #endif  // BUILDFLAG(IS_WIN)
+#endif  // 0
 
 #if BUILDFLAG(IS_MAC)
+  auto* const cus = g_browser_process->component_updater();
   RegisterRecoveryImprovedComponent(cus, g_browser_process->local_state());
   RegisterRecoveryComponent(cus, g_browser_process->local_state());
 #endif  // BUILDFLAG(IS_MAC)
@@ -116,9 +118,10 @@
 #endif
 
 #if BUILDFLAG(ENABLE_WIDEVINE_CDM_COMPONENT)
-  RegisterWidevineCdmComponent(cus);
+  //RegisterWidevineCdmComponent(cus);
 #endif  // BUILDFLAG(ENABLE_WIDEVINE_CDM_COMPONENT)
 
+#if 0
 #if BUILDFLAG(ENABLE_NACL) && !BUILDFLAG(IS_ANDROID)
 #if BUILDFLAG(IS_CHROMEOS)
   // PNaCl on Chrome OS is on rootfs and there is no need to download it. But
@@ -216,6 +219,7 @@
   RegisterCommerceHeuristicsComponent(cus);
 
   RegisterTpcdMetadataComponent(cus);
+#endif // disable component updater
 }
 
 }  // namespace component_updater
diff -r -u --color up/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.cc nw/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.cc
--- up/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.cc	2024-08-26 19:32:17.602586283 +0000
@@ -74,7 +74,7 @@
 const char ImageLoaderComponentName[] = "WidevineCdm";
 #endif
 
-#if !BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)
+#if 1 //!BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)
 // On Linux and ChromeOS the Widevine CDM is loaded at startup before the
 // zygote is locked down. As a result there is no need to register the CDM
 // with Chrome as it can't be used until Chrome is restarted.
@@ -398,7 +398,7 @@
     return;
   }
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if 0 //BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
   VLOG(1) << "Updating hint file with Widevine CDM " << cdm_version;
 
   // This is running on a thread that allows IO, so simply update the hint file.
@@ -448,4 +448,12 @@
   installer->Register(cus, base::OnceClosure());
 }
 
+void RegisterWidevineCdmComponent(ComponentUpdateService* cus,
+                                  base::OnceClosure callback) {
+  auto installer = base::MakeRefCounted<ComponentInstaller>(
+          std::make_unique<WidevineCdmComponentInstallerPolicy>());
+  installer->Register(cus, std::move(callback));
+}
+
+
 }  // namespace component_updater
diff -r -u --color up/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.h nw/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.h
--- up/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.h	2024-08-26 19:32:17.602586283 +0000
@@ -5,6 +5,8 @@
 #ifndef CHROME_BROWSER_COMPONENT_UPDATER_WIDEVINE_CDM_COMPONENT_INSTALLER_H_
 #define CHROME_BROWSER_COMPONENT_UPDATER_WIDEVINE_CDM_COMPONENT_INSTALLER_H_
 
+#include "base/functional/callback_forward.h"
+
 namespace component_updater {
 
 class ComponentUpdateService;
@@ -17,6 +19,7 @@
 // 4) Register the Widevine CDM (via the adapter) with Chrome.
 // The first part is IO intensive so we do it asynchronously in the file thread.
 void RegisterWidevineCdmComponent(ComponentUpdateService* cus);
+void RegisterWidevineCdmComponent(ComponentUpdateService* cus, base::OnceClosure callback);
 
 }  // namespace component_updater
 
diff -r -u --color up/chromium/chrome/browser/compose/chrome_compose_client.cc nw/chromium/chrome/browser/compose/chrome_compose_client.cc
--- up/chromium/chrome/browser/compose/chrome_compose_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/compose/chrome_compose_client.cc	2024-08-26 19:32:17.602586283 +0000
@@ -599,9 +599,12 @@
 }
 
 bool ChromeComposeClient::IsPageLanguageSupported() {
+  return false;
+#if 0
   translate::TranslateManager* translate_manager =
       ChromeTranslateClient::GetManagerFromWebContents(&GetWebContents());
   return compose_enabling_->IsPageLanguageSupported(translate_manager);
+#endif
 }
 
 bool ChromeComposeClient::GetMSBBStateFromPrefs() {
@@ -627,6 +630,8 @@
     const autofill::FormData& form_data,
     const autofill::FormFieldData& form_field_data,
     autofill::AutofillSuggestionTriggerSource trigger_source) {
+  return false;
+#if 0
   // Saved state notification needs the active field set earlier here at nudge
   // triggering, rather than later when the compose dialog is shown so that we
   // can know if the user focused on a different field.
@@ -687,6 +692,7 @@
     return true;
   }
   return false;
+#endif
 }
 
 bool ChromeComposeClient::IsPopupTimerRunning() {
@@ -719,6 +725,7 @@
 bool ChromeComposeClient::ShouldTriggerContextMenu(
     content::RenderFrameHost* rfh,
     content::ContextMenuParams& params) {
+#if 0
   translate::TranslateManager* translate_manager =
       ChromeTranslateClient::GetManagerFromWebContents(&GetWebContents());
   bool allow_context_menu = compose_enabling_->ShouldTriggerContextMenu(
@@ -727,6 +734,8 @@
     page_ukm_tracker_->MenuItemShown();
   }
   return allow_context_menu;
+#endif
+  return false;
 }
 
 void ChromeComposeClient::OnSessionComplete(
diff -r -u --color up/chromium/chrome/browser/devtools/chrome_devtools_manager_delegate.cc nw/chromium/chrome/browser/devtools/chrome_devtools_manager_delegate.cc
--- up/chromium/chrome/browser/devtools/chrome_devtools_manager_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/devtools/chrome_devtools_manager_delegate.cc	2024-08-26 19:32:17.626586296 +0000
@@ -364,7 +364,7 @@
     case Availability::kAllowed:
       return true;
     case Availability::kDisallowedForForceInstalledExtensions:
-      if (!extension) {
+      if (true || !extension) {
         return true;
       }
       if (extensions::Manifest::IsPolicyLocation(extension->location())) {
diff -r -u --color up/chromium/chrome/browser/devtools/devtools_ui_bindings.cc nw/chromium/chrome/browser/devtools/devtools_ui_bindings.cc
--- up/chromium/chrome/browser/devtools/devtools_ui_bindings.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/devtools/devtools_ui_bindings.cc	2024-08-26 19:32:17.630586299 +0000
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "extensions/browser/extension_protocols.h"
 #include "chrome/browser/devtools/devtools_ui_bindings.h"
 
 #include <stddef.h>
@@ -625,7 +626,8 @@
     return true;
   }
 
-  return SanitizeFrontendURL(url).spec() == url.spec();
+  //NW: webview.showDevTools in container; webview-localfile case; changed in c2db881506f
+  return SanitizeFrontendURL(url).spec() == url.spec() || url == GURL(url::kAboutBlankURL);
 }
 
 bool DevToolsUIBindings::IsValidRemoteFrontendURL(const GURL& url) {
@@ -1108,6 +1110,15 @@
   resource_request.headers.AddHeadersFromString(headers);
 
   NetworkResourceLoader::URLLoaderFactoryHolder url_loader_factory;
+  if (gurl.SchemeIs("chrome-extension")) {
+    content::RenderFrameHost* frame_host = web_contents()->GetPrimaryMainFrame();
+    mojo::PendingRemote<network::mojom::URLLoaderFactory> pending_remote
+      = extensions::CreateExtensionURLLoaderFactory(frame_host->GetProcess()->GetID(),
+                                                    frame_host->GetRoutingID());
+    url_loader_factory = network::SharedURLLoaderFactory::Create(
+        std::make_unique<network::WrapperPendingSharedURLLoaderFactory>(
+            std::move(pending_remote)));
+  } else
   if (gurl.SchemeIsFile()) {
     mojo::PendingRemote<network::mojom::URLLoaderFactory> pending_remote =
         content::CreateFileURLLoaderFactory(
@@ -1212,8 +1223,8 @@
 }
 
 void DevToolsUIBindings::RequestFileSystems() {
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   base::Value::List file_systems_value;
   for (auto const& file_system : file_helper_->GetFileSystems()) {
     file_systems_value.Append(CreateFileSystemValue(file_system));
@@ -1223,23 +1234,23 @@
 }
 
 void DevToolsUIBindings::AddFileSystem(const std::string& type) {
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   file_helper_->AddFileSystem(
       type, base::BindRepeating(&DevToolsUIBindings::ShowDevToolsInfoBar,
                                 weak_factory_.GetWeakPtr()));
 }
 
 void DevToolsUIBindings::RemoveFileSystem(const std::string& file_system_path) {
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   file_helper_->RemoveFileSystem(file_system_path);
 }
 
 void DevToolsUIBindings::UpgradeDraggedFileSystemPermissions(
     const std::string& file_system_url) {
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   file_helper_->UpgradeDraggedFileSystemPermissions(
       file_system_url,
       base::BindRepeating(&DevToolsUIBindings::ShowDevToolsInfoBar,
@@ -1251,8 +1262,8 @@
     const std::string& file_system_path,
     const std::string& excluded_folders_message) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   if (!file_helper_->IsFileSystemAdded(file_system_path)) {
     IndexingDone(index_request_id, file_system_path);
     return;
@@ -1300,8 +1311,8 @@
                                       const std::string& file_system_path,
                                       const std::string& query) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   if (!file_helper_->IsFileSystemAdded(file_system_path)) {
     SearchCompleted(search_request_id, file_system_path,
                     std::vector<std::string>());
@@ -1940,11 +1951,15 @@
 void DevToolsUIBindings::ShowDevToolsInfoBar(
     const std::u16string& message,
     DevToolsInfoBarDelegate::Callback callback) {
+#if 1
+  std::move(callback).Run(true); // #4602
+#else
   if (!delegate_->GetInfoBarManager()) {
     std::move(callback).Run(false);
     return;
   }
   DevToolsInfoBarDelegate::Create(message, std::move(callback));
+#endif
 }
 
 void DevToolsUIBindings::AddDevToolsExtensionsToClient() {
diff -r -u --color up/chromium/chrome/browser/devtools/devtools_window.cc nw/chromium/chrome/browser/devtools/devtools_window.cc
--- up/chromium/chrome/browser/devtools/devtools_window.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/devtools/devtools_window.cc	2024-08-26 19:32:17.630586299 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "chrome/browser/devtools/devtools_window.h"
+#include "net/cert/x509_certificate.h"
 
 #include <memory>
 #include <set>
@@ -416,9 +417,9 @@
 class DevToolsWindow::OwnedMainWebContents {
  public:
   explicit OwnedMainWebContents(
-      std::unique_ptr<content::WebContents> web_contents)
-      : keep_alive_(KeepAliveOrigin::DEVTOOLS_WINDOW,
-                    KeepAliveRestartOption::DISABLED),
+                  std::unique_ptr<content::WebContents> web_contents, bool headless = false)
+      : /* keep_alive_(KeepAliveOrigin::DEVTOOLS_WINDOW,
+           KeepAliveRestartOption::DISABLED), */
         web_contents_(std::move(web_contents)) {
     Profile* profile = GetProfileForDevToolsWindow(web_contents_.get());
     DCHECK(profile);
@@ -426,6 +427,11 @@
       // ScopedProfileKeepAlive does not support OTR profiles.
       profile_keep_alive_ = std::make_unique<ScopedProfileKeepAlive>(
           profile, ProfileKeepAliveOrigin::kDevToolsWindow);
+    if (!headless) //NWJS#7588: deadlock; in this NW feature, browser
+                   //quit/zero keepalive count
+                   //triggers destruction of DevToolsWindow
+      keep_alive_ = std::make_unique<ScopedKeepAlive>(KeepAliveOrigin::DEVTOOLS_WINDOW,
+                                                      KeepAliveRestartOption::DISABLED);
     }
   }
 
@@ -435,7 +441,7 @@
   }
 
  private:
-  ScopedKeepAlive keep_alive_;
+  std::unique_ptr<ScopedKeepAlive> keep_alive_;
   std::unique_ptr<ScopedProfileKeepAlive> profile_keep_alive_;
   std::unique_ptr<content::WebContents> web_contents_;
 };
@@ -862,6 +868,8 @@
 
   // If window is docked and visible, we hide it on toggle. If window is
   // undocked, we show (activate) it.
+  if (window->headless_)
+    return;
   if (!window->is_docked_ || do_open) {
     window->ScheduleShow(action);
   } else {
@@ -1013,6 +1021,8 @@
   bool should_show_window =
       !browser_ || (action.type() != DevToolsToggleAction::kInspect);
 
+  should_show_window = should_show_window && !headless_;
+
   if (!browser_)
     CreateDevToolsBrowser();
 
@@ -1110,7 +1120,8 @@
                                DevToolsUIBindings* bindings,
                                WebContents* inspected_web_contents,
                                bool can_dock,
-                               DevToolsOpenedByAction opened_by)
+                               DevToolsOpenedByAction opened_by,
+                               bool headless)
     : frontend_type_(frontend_type),
       profile_(profile),
       main_web_contents_(main_web_contents.get()),
@@ -1119,9 +1130,10 @@
       browser_(nullptr),
       is_docked_(true),
       owned_main_web_contents_(
-          std::make_unique<OwnedMainWebContents>(std::move(main_web_contents))),
+        std::make_unique<OwnedMainWebContents>(std::move(main_web_contents), headless)),
       can_dock_(can_dock),
       close_on_detach_(true),
+      headless_(headless),
       // This initialization allows external front-end to work without changes.
       // We don't wait for docking call, but instead immediately show undocked.
       life_stage_(can_dock ? kNotLoaded : kIsDockedSet),
@@ -1130,9 +1142,15 @@
       ready_for_test_(false),
       opened_by_(opened_by),
       closed_by_(DevToolsClosedByAction::kUnknown) {
+  // shouldn't own the web content in embedded cdt use case #6004
+  // or it will be double freed on quit
+  if (headless)
+    owned_main_web_contents_.release();
   // Set up delegate, so we get fully-functional window immediately.
   // It will not appear in UI though until |life_stage_ == kLoadCompleted|.
-  main_web_contents_->SetDelegate(this);
+  if (!headless) //NWJS#4709: keep delegate to web_view_guest so the
+                 //shortcut is handled there
+    main_web_contents_->SetDelegate(this);
   // Bindings take ownership over devtools as its delegate.
   bindings_->SetDelegate(this);
   // DevTools uses PageZoom::Zoom(), so main_web_contents_ requires a
@@ -1198,7 +1216,8 @@
     const std::string& panel,
     bool has_other_clients,
     bool browser_connection,
-    DevToolsOpenedByAction opened_by) {
+    DevToolsOpenedByAction opened_by,
+    content::WebContents* cdt_web_contents) {
   if (!AllowDevToolsFor(profile, inspected_web_contents))
     return nullptr;
 
@@ -1215,7 +1234,21 @@
 
   // Create WebContents with devtools.
   GURL url(GetDevToolsURL(profile, frontend_type, frontend_url, can_dock, panel,
-                          has_other_clients, browser_connection));
+                          has_other_clients, browser_connection, cdt_web_contents != nullptr));
+
+  if (cdt_web_contents) {
+    cdt_web_contents->GetController().LoadURL(
+      DecorateFrontendURL(url), content::Referrer(),
+      ui::PAGE_TRANSITION_AUTO_TOPLEVEL, std::string());
+    DevToolsUIBindings* bindings =
+      DevToolsUIBindings::ForWebContents(cdt_web_contents);
+    if (!bindings)
+      return nullptr;
+    std::unique_ptr<WebContents> cdt_contents(cdt_web_contents);
+    return new DevToolsWindow(frontend_type, profile, std::move(cdt_contents), bindings,
+                              inspected_web_contents, can_dock, opened_by, true);
+  }
+
   std::unique_ptr<WebContents> main_web_contents =
       WebContents::Create(WebContents::CreateParams(profile));
   main_web_contents->GetController().LoadURL(
@@ -1240,7 +1273,8 @@
                                     bool can_dock,
                                     const std::string& panel,
                                     bool has_other_clients,
-                                    bool browser_connection) {
+                                    bool browser_connection,
+				    bool headless) {
   std::string url;
 
   std::string remote_base =
@@ -1261,7 +1295,7 @@
         url += "&can_dock=true";
       if (!panel.empty())
         url += "&panel=" + panel;
-      if (base::FeatureList::IsEnabled(::features::kDevToolsTabTarget)) {
+      if (base::FeatureList::IsEnabled(::features::kDevToolsTabTarget) && !headless) {
         url += "&targetType=tab";
       }
       break;
@@ -1409,7 +1443,8 @@
                                         int opener_render_frame_id,
                                         const std::string& frame_name,
                                         const GURL& target_url,
-                                        WebContents* new_contents) {
+                                        WebContents* new_contents,
+                                        const std::u16string& nw_window_manifest) {
   if (target_url.SchemeIs(content::kChromeDevToolsScheme) &&
       target_url.path().rfind("device_mode_emulation_frame.html") !=
           std::string::npos) {
@@ -1530,7 +1565,7 @@
 }
 
 void DevToolsWindow::ActivateWindow() {
-  if (life_stage_ != kLoadCompleted)
+  if (life_stage_ != kLoadCompleted || headless_)
     return;
   if (is_docked_ && GetInspectedBrowserWindow())
     main_web_contents_->Focus();
@@ -1742,7 +1777,7 @@
   // Docked DevToolsWindow owns its main_web_contents_ and must delete it.
   // Undocked main_web_contents_ are owned and handled by browser.
   // see crbug.com/369932
-  if (is_docked_) {
+  if (is_docked_ && !headless_) {
     CloseContents(main_web_contents_);
   } else if (browser_ && crashed) {
     browser_->window()->Close();
@@ -1777,6 +1812,10 @@
   ::ShowCertificateViewer(inspected_contents, parent, cert.get());
 }
 
+void DevToolsWindow::Close() {
+  browser_->window()->Close();
+}
+
 void DevToolsWindow::OnLoadCompleted() {
   // First seed inspected tab id for extension APIs.
   WebContents* inspected_web_contents = GetInspectedWebContents();
diff -r -u --color up/chromium/chrome/browser/devtools/devtools_window.h nw/chromium/chrome/browser/devtools/devtools_window.h
--- up/chromium/chrome/browser/devtools/devtools_window.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/devtools/devtools_window.h	2024-08-26 19:32:17.630586299 +0000
@@ -283,7 +283,10 @@
   // content::DevToolsUIBindings::Delegate overrides
   void ActivateWindow() override;
 
- private:
+  void Close();
+
+ public:
+
   friend class DevToolsWindowTesting;
   friend class DevToolsWindowCreationObserver;
   friend class HatsNextWebDialogBrowserTest;
@@ -337,7 +340,8 @@
                  DevToolsUIBindings* bindings,
                  content::WebContents* inspected_web_contents,
                  bool can_dock,
-                 DevToolsOpenedByAction opened_by);
+                 DevToolsOpenedByAction opened_by,
+                 bool headless = false);
 
   // External frontend is always undocked.
   static void OpenExternalFrontend(
@@ -361,14 +365,17 @@
                                 const std::string& panel,
                                 bool has_other_clients,
                                 bool browser_connection,
-                                DevToolsOpenedByAction opened_by);
+                                DevToolsOpenedByAction opened_by,
+                                content::WebContents* cdt_web_contents = nullptr);
+
   static GURL GetDevToolsURL(Profile* profile,
                              FrontendType frontend_type,
                              const std::string& frontend_url,
                              bool can_dock,
                              const std::string& panel,
                              bool has_other_clients,
-                             bool browser_connection);
+                             bool browser_connection,
+			     bool headless = false);
 
   static void ToggleDevToolsWindow(
       content::WebContents* web_contents,
@@ -394,7 +401,7 @@
                           int opener_render_frame_id,
                           const std::string& frame_name,
                           const GURL& target_url,
-                          content::WebContents* new_contents) override;
+                          content::WebContents* new_contents, const std::u16string& nw_window_manifest) override;
   void CloseContents(content::WebContents* source) override;
   void ContentsZoomChange(bool zoom_in) override;
   void BeforeUnloadFired(content::WebContents* tab,
@@ -428,6 +435,7 @@
   void SetWhitelistedShortcuts(const std::string& message) override;
   void SetEyeDropperActive(bool active) override;
   void OpenNodeFrontend() override;
+ public:
   void InspectedContentsClosing() override;
   void OnLoadCompleted() override;
   void ReadyForTest() override;
@@ -501,6 +509,7 @@
 
   const bool can_dock_;
   bool close_on_detach_;
+  const bool headless_;
   LifeStage life_stage_;
   DevToolsToggleAction action_on_load_;
   DevToolsContentsResizingStrategy contents_resizing_strategy_;
diff -r -u --color up/chromium/chrome/browser/download/download_browsertest.cc nw/chromium/chrome/browser/download/download_browsertest.cc
--- up/chromium/chrome/browser/download/download_browsertest.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_browsertest.cc	2024-08-26 19:32:17.654586311 +0000
@@ -679,6 +679,7 @@
   std::optional<safe_browsing::ClientDownloadResponse::Verdict> fake_verdict_;
 };
 
+#if 0
 class FakeSafeBrowsingService : public safe_browsing::TestSafeBrowsingService {
  public:
   FakeSafeBrowsingService() : TestSafeBrowsingService() {}
@@ -771,6 +772,7 @@
   mojo::Remote<device::mojom::WakeLockProvider> wake_lock_provider_;
 };
 
+#endif
 }  // namespace
 
 using DownloadTest = DownloadTestBase;
diff -r -u --color up/chromium/chrome/browser/download/download_prefs.cc nw/chromium/chrome/browser/download/download_prefs.cc
--- up/chromium/chrome/browser/download/download_prefs.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_prefs.cc	2024-08-26 19:32:17.658586313 +0000
@@ -279,7 +279,7 @@
     user_prefs::PrefRegistrySyncable* registry) {
   registry->RegisterBooleanPref(
       prefs::kPromptForDownload,
-      false,
+      true,
       user_prefs::PrefRegistrySyncable::SYNCABLE_PREF);
   registry->RegisterStringPref(prefs::kDownloadExtensionsToOpen, std::string());
   registry->RegisterListPref(prefs::kDownloadExtensionsToOpenByPolicy, {});
diff -r -u --color up/chromium/chrome/browser/download/download_request_limiter.cc nw/chromium/chrome/browser/download/download_request_limiter.cc
--- up/chromium/chrome/browser/download/download_request_limiter.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_request_limiter.cc	2024-08-26 19:32:17.658586313 +0000
@@ -224,7 +224,7 @@
         new DownloadPermissionRequest(factory_.GetWeakPtr(), request_origin));
   } else {
     // Call CancelOnce() so we don't set the content settings.
-    CancelOnce(request_origin);
+    Accept(request_origin);
   }
 }
 
diff -r -u --color up/chromium/chrome/browser/download/download_status_updater_linux.cc nw/chromium/chrome/browser/download/download_status_updater_linux.cc
--- up/chromium/chrome/browser/download/download_status_updater_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_status_updater_linux.cc	2024-08-26 19:32:17.658586313 +0000
@@ -120,6 +120,7 @@
 bool IsRunning() {
   return inspector && get_unity_running && get_unity_running(inspector);
 }
+}  // namespace
 
 NO_SANITIZE("cfi-icall")
 void SetDownloadCount(int count) {
@@ -138,7 +139,6 @@
   }
 }
 
-}  // namespace
 
 void DownloadStatusUpdater::UpdateAppIconDownloadProgress(
     download::DownloadItem* download) {
diff -r -u --color up/chromium/chrome/browser/download/download_status_updater_mac.mm nw/chromium/chrome/browser/download/download_status_updater_mac.mm
--- up/chromium/chrome/browser/download/download_status_updater_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_status_updater_mac.mm	2024-08-26 19:32:17.658586313 +0000
@@ -114,8 +114,12 @@
 
 void DownloadStatusUpdater::UpdateAppIconDownloadProgress(
     download::DownloadItem* download) {
-  // Always update overall progress in the Dock icon.
 
+  NSDockTile *dockTile = [NSApp dockTile];
+  if (dockTile.contentView && [dockTile.contentView.subviews count] > 0)
+    return;
+
+  // Always update overall progress.
   float progress = 0;
   int download_count = 0;
   bool progress_known = GetProgress(&progress, &download_count);
diff -r -u --color up/chromium/chrome/browser/download/download_ui_controller.cc nw/chromium/chrome/browser/download/download_ui_controller.cc
--- up/chromium/chrome/browser/download/download_ui_controller.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_ui_controller.cc	2024-08-26 19:32:17.662586315 +0000
@@ -25,6 +25,9 @@
 #include "content/public/browser/download_item_utils.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/browser/web_contents_delegate.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "extensions/browser/app_window/native_app_window.h"
 
 #if BUILDFLAG(IS_ANDROID)
 #include "base/strings/string_util.h"
@@ -359,6 +362,20 @@
       DownloadController::CloseTabIfEmpty(web_contents, item);
     }
 #else   // BUILDFLAG(IS_ANDROID)
+    Profile* profile = Profile::FromBrowserContext(web_contents->GetBrowserContext());
+    extensions::AppWindowRegistry* registry = extensions::AppWindowRegistry::Get(profile);
+    if (!registry)
+      return;
+    extensions::AppWindow* app_window = registry->GetAppWindowForWebContents(web_contents);
+    if (!app_window)
+      return;
+    if (web_contents->GetController().IsInitialNavigation() &&
+        app_window->NWCanClose() &&
+        !item->IsSavePackageDownload()) {
+      app_window->GetBaseWindow()->Close();
+    }
+
+#if 0
     Browser* browser = chrome::FindBrowserWithTab(web_contents);
     // If the download occurs in a new tab, and it's not a save page
     // download (started before initial navigation completed) close it.
@@ -372,6 +389,7 @@
         !item->IsSavePackageDownload()) {
       web_contents->Close();
     }
+#endif
 #endif  // BUILDFLAG(IS_ANDROID)
   }
 
diff -r -u --color up/chromium/chrome/browser/enterprise/reporting/extension_info.cc nw/chromium/chrome/browser/enterprise/reporting/extension_info.cc
--- up/chromium/chrome/browser/enterprise/reporting/extension_info.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/enterprise/reporting/extension_info.cc	2024-08-26 19:32:17.706586339 +0000
@@ -149,6 +149,8 @@
       return em::Extension_ExtensionType_TYPE_LEGACY_PACKAGED_APP;
     case extensions::Manifest::TYPE_PLATFORM_APP:
       return em::Extension_ExtensionType_TYPE_PLATFORM_APP;
+    case extensions::Manifest::TYPE_NWJS_APP:
+      return em::Extension_ExtensionType_TYPE_PLATFORM_APP;
     case extensions::Manifest::TYPE_LOGIN_SCREEN_EXTENSION:
       return em::Extension_ExtensionType_TYPE_LOGIN_SCREEN_EXTENSION;
     case extensions::Manifest::TYPE_CHROMEOS_SYSTEM_EXTENSION:
diff -r -u --color up/chromium/chrome/browser/extensions/activity_log/activity_log.cc nw/chromium/chrome/browser/extensions/activity_log/activity_log.cc
--- up/chromium/chrome/browser/extensions/activity_log/activity_log.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/activity_log/activity_log.cc	2024-08-26 19:32:17.718586346 +0000
@@ -221,7 +221,7 @@
 
   if (found) {
     *url = contents->GetURL();
-    *is_incognito = browser->profile()->IsOffTheRecord();
+    *is_incognito = false; //browser->profile()->IsOffTheRecord();
     return true;
   } else {
     return false;
diff -r -u --color up/chromium/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc nw/chromium/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc
--- up/chromium/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc	2024-08-26 19:32:17.718586346 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/extensions/browser_context_keyed_service_factories.h"
 
+#include "content/nw/src/api/object_manager_factory.h"
+
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/extensions/api/activity_log_private/activity_log_private_api.h"
@@ -106,6 +108,7 @@
   extensions::NetworkingPrivateDelegateFactory::GetInstance()
       ->SetUIDelegateFactory(std::move(networking_private_ui_delegate_factory));
 #endif
+  nw::ObjectManagerFactory::GetInstance();
   extensions::OmniboxAPI::GetFactoryInstance();
   extensions::PasswordsPrivateDelegateFactory::GetInstance();
   extensions::PasswordsPrivateEventRouterFactory::GetInstance();
diff -r -u --color up/chromium/chrome/browser/extensions/api/cookies/cookies_api.cc nw/chromium/chrome/browser/extensions/api/cookies/cookies_api.cc
--- up/chromium/chrome/browser/extensions/api/cookies/cookies_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/cookies/cookies_api.cc	2024-08-26 19:32:17.726586350 +0000
@@ -5,6 +5,7 @@
 // Implements the Chrome Extensions Cookies API.
 
 #include "chrome/browser/extensions/api/cookies/cookies_api.h"
+#include "base/strings/string_number_conversions.h"
 
 #include <memory>
 #include <utility>
@@ -29,6 +30,7 @@
 #include "components/safe_browsing/core/common/features.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_thread.h"
+#include "extensions/browser/guest_view/web_view/web_view_guest.h"
 #include "content/public/browser/storage_partition.h"
 #include "extensions/browser/event_router.h"
 #include "extensions/browser/extensions_browser_client.h"
@@ -67,6 +69,45 @@
   return true;
 }
 
+std::vector<std::string> Split(std::string str, const std::string delim) {
+  std::vector<std::string> result;
+  size_t position = 0;
+  while ((position = str.find(delim)) != std::string::npos)
+  {
+    result.push_back(str.substr(0, position));
+    str.erase(0, position + delim.length());
+  }
+
+  result.push_back(str);
+  return result;
+}
+
+content::StoragePartition* GetStoragePartitionFromWebview(const std::string& store_id) {
+  if (store_id.find(",") == std::string::npos)
+    return nullptr;
+
+  std::vector<std::string> processGuestIds = Split(store_id, ",");
+  if (processGuestIds.size() != 2)
+    return nullptr;
+
+  int processId, guessId;
+  if (!base::StringToInt(processGuestIds[0], &processId)
+    || !base::StringToInt(processGuestIds[1], &guessId))
+    return nullptr;
+
+  extensions::WebViewGuest* guest = extensions::WebViewGuest::FromInstanceID(
+    processId, guessId);
+
+  if (!guest)
+    return nullptr;
+
+  content::StoragePartition* partition =
+    guest->web_contents()->GetBrowserContext()->GetStoragePartition(
+      guest->web_contents()->GetSiteInstance());
+
+  return partition;
+}
+
 network::mojom::CookieManager* ParseStoreCookieManager(
     content::BrowserContext* function_context,
     bool include_incognito,
@@ -75,6 +116,11 @@
   Profile* function_profile = Profile::FromBrowserContext(function_context);
   Profile* store_profile = nullptr;
   if (!store_id->empty()) {
+    content::StoragePartition* partition = GetStoragePartitionFromWebview(*store_id);
+    if (partition) {
+      return partition->GetCookieManagerForBrowserProcess();
+    }
+
     store_profile = cookies_helpers::ChooseProfileFromStoreId(
         *store_id, function_profile, include_incognito);
     if (!store_profile) {
diff -r -u --color up/chromium/chrome/browser/extensions/api/debugger/debugger_api.cc nw/chromium/chrome/browser/extensions/api/debugger/debugger_api.cc
--- up/chromium/chrome/browser/extensions/api/debugger/debugger_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/debugger/debugger_api.cc	2024-08-26 19:32:17.726586350 +0000
@@ -436,10 +436,12 @@
   if (Manifest::IsPolicyLocation(extension_->location()))
     return true;
 
+#if 0
   subscription_ = ExtensionDevToolsInfoBarDelegate::Create(
       extension_id(), extension_->name(),
       base::BindOnce(&ExtensionDevToolsClientHost::InfoBarDestroyed,
                      base::Unretained(this)));
+#endif
   if (extension_service_worker_id_) {
     ProcessManager* process_manager = ProcessManager::Get(profile_);
     CHECK(process_manager);
diff -r -u --color up/chromium/chrome/browser/extensions/api/desktop_capture/desktop_capture_api.cc nw/chromium/chrome/browser/extensions/api/desktop_capture/desktop_capture_api.cc
--- up/chromium/chrome/browser/extensions/api/desktop_capture/desktop_capture_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/desktop_capture/desktop_capture_api.cc	2024-08-26 19:32:17.734586355 +0000
@@ -94,9 +94,14 @@
     // was requested for capture.
     target_render_frame_host = web_contents->GetPrimaryMainFrame();
   } else {
-    origin = extension()->url();
     target_name = base::UTF8ToUTF16(GetExtensionTargetName());
     target_render_frame_host = render_frame_host();
+    // NWJS fix for nwjs/nw.js#4579
+    // NWJS app allows running on origins other than `chrome-extension://*/*`.
+    // The origin should then be from the senders URL, in order not to fail
+    // the origin checking in `DesktopStreamsRegistry::RequestMediaForStreamId`.
+    origin = extension()->is_nwjs_app() ? target_render_frame_host->GetLastCommittedURL().
+      DeprecatedGetOriginAsURL() : extension()->url();
   }
 
   if (!target_render_frame_host)
diff -r -u --color up/chromium/chrome/browser/extensions/api/gcm/gcm_api.cc nw/chromium/chrome/browser/extensions/api/gcm/gcm_api.cc
--- up/chromium/chrome/browser/extensions/api/gcm/gcm_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/gcm/gcm_api.cc	2024-08-26 19:32:17.746586361 +0000
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "components/prefs/pref_service.h"
 #include "chrome/browser/extensions/api/gcm/gcm_api.h"
 
 #include <stddef.h>
@@ -96,6 +97,10 @@
     return false;
   }
 
+  if (!profile->GetPrefs()->GetBoolean("gcm.channel_status")) {
+    *error = "GCM is turned off.";
+    return false;
+  }
   return true;
 }
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/instance_id/instance_id_api.cc nw/chromium/chrome/browser/extensions/api/instance_id/instance_id_api.cc
--- up/chromium/chrome/browser/extensions/api/instance_id/instance_id_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/instance_id/instance_id_api.cc	2024-08-26 19:32:17.750586363 +0000
@@ -59,9 +59,19 @@
     return RespondNow(Error(
         "chrome.instanceID not supported in incognito mode"));
   }
+
+  if (!IsEnabled()) {
+    return RespondNow(Error(
+        InstanceIDResultToError(instance_id::InstanceID::DISABLED)));
+  }
+
   return DoWork();
 }
 
+bool InstanceIDApiFunction::IsEnabled() const {
+  return instance_id::InstanceIDProfileService::IsInstanceIDEnabled();
+}
+
 instance_id::InstanceID* InstanceIDApiFunction::GetInstanceID() const {
   return instance_id::InstanceIDProfileServiceFactory::GetForProfile(
       Profile::FromBrowserContext(browser_context()))->driver()->
diff -r -u --color up/chromium/chrome/browser/extensions/api/language_settings_private/language_settings_private_api.cc nw/chromium/chrome/browser/extensions/api/language_settings_private/language_settings_private_api.cc
--- up/chromium/chrome/browser/extensions/api/language_settings_private/language_settings_private_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/language_settings_private/language_settings_private_api.cc	2024-08-26 19:32:17.754586365 +0000
@@ -209,6 +209,10 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateGetLanguageListFunction::Run() {
+#if 1
+  base::Value::List language_list;
+  return RespondNow(WithArguments(std::move(language_list)));
+#else
   // Collect the language codes from the supported accept-languages.
   const std::string app_locale = g_browser_process->GetApplicationLocale();
   const std::unique_ptr<translate::TranslatePrefs> translate_prefs =
@@ -292,6 +296,7 @@
 #endif  // BUILDFLAG(IS_WIN)
 
   return RespondNow(WithArguments(std::move(language_list_)));
+#endif
 }
 
 #if BUILDFLAG(IS_WIN)
@@ -328,6 +333,7 @@
   const auto parameters =
       language_settings_private::EnableLanguage::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(parameters);
+#if 0
   const std::string& language_code = parameters->language_code;
 
   std::unique_ptr<translate::TranslatePrefs> translate_prefs =
@@ -340,6 +346,7 @@
 
   translate_prefs->AddToLanguageList(language_code, /*force_blocked=*/false);
 
+#endif
   return RespondNow(NoArguments());
 }
 
@@ -354,6 +361,7 @@
   const auto parameters =
       language_settings_private::DisableLanguage::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(parameters);
+#if 0
   const std::string& language_code = parameters->language_code;
 
   std::unique_ptr<translate::TranslatePrefs> translate_prefs =
@@ -366,6 +374,7 @@
 
   translate_prefs->RemoveFromLanguageList(language_code);
 
+#endif
   return RespondNow(NoArguments());
 }
 
@@ -380,6 +389,7 @@
   const auto parameters = language_settings_private::
       SetEnableTranslationForLanguage::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(parameters);
+#if 0
   const std::string& language_code = parameters->language_code;
   // True if translation enabled, false if disabled.
   const bool enable = parameters->enable;
@@ -393,6 +403,7 @@
     translate_prefs->BlockLanguage(language_code);
   }
 
+#endif
   return RespondNow(NoArguments());
 }
 
@@ -404,6 +415,7 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateGetAlwaysTranslateLanguagesFunction::Run() {
+#if 0
   const std::unique_ptr<translate::TranslatePrefs> translate_prefs =
       CreateTranslatePrefsForBrowserContext(browser_context());
 
@@ -416,6 +428,8 @@
   }
 
   return RespondNow(WithArguments(std::move(always_translate_languages)));
+#endif
+  return RespondNow(NoArguments());
 }
 
 LanguageSettingsPrivateSetLanguageAlwaysTranslateStateFunction::
@@ -426,6 +440,7 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateSetLanguageAlwaysTranslateStateFunction::Run() {
+#if 0
   const auto params = language_settings_private::
       SetLanguageAlwaysTranslateState::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(params);
@@ -435,7 +450,7 @@
 
   translate_prefs->SetLanguageAlwaysTranslateState(params->language_code,
                                                    params->always_translate);
-
+#endif
   return RespondNow(NoArguments());
 }
 
@@ -447,6 +462,7 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateGetNeverTranslateLanguagesFunction::Run() {
+#if 0
   const std::unique_ptr<translate::TranslatePrefs> translate_prefs =
       CreateTranslatePrefsForBrowserContext(browser_context());
 
@@ -458,6 +474,8 @@
     never_translate_languages.Append(std::move(entry));
   }
   return RespondNow(WithArguments(std::move(never_translate_languages)));
+#endif
+  return RespondNow(NoArguments());
 }
 
 LanguageSettingsPrivateMoveLanguageFunction::
@@ -468,6 +486,7 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateMoveLanguageFunction::Run() {
+#if 0
   const auto parameters =
       language_settings_private::MoveLanguage::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(parameters);
@@ -507,6 +526,7 @@
   translate_prefs->RearrangeLanguage(language_code, where, offset,
                                      supported_language_codes);
 
+#endif
   return RespondNow(NoArguments());
 }
 
@@ -640,12 +660,16 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateGetTranslateTargetLanguageFunction::Run() {
+#if 0
   language::LanguageModel* language_model =
       LanguageModelManagerFactory::GetForBrowserContext(browser_context())
           ->GetPrimaryModel();
   return RespondNow(WithArguments(TranslateService::GetTargetLanguage(
       Profile::FromBrowserContext(browser_context())->GetPrefs(),
       language_model)));
+#else
+  return RespondNow(NoArguments());
+#endif
 }
 
 LanguageSettingsPrivateSetTranslateTargetLanguageFunction::
@@ -656,6 +680,7 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateSetTranslateTargetLanguageFunction::Run() {
+#if 0
   const auto parameters =
       language_settings_private::SetTranslateTargetLanguage::Params::Create(
           args());
@@ -671,7 +696,7 @@
     return RespondNow(NoArguments());
   }
   translate_prefs->SetRecentTargetLanguage(language_code);
-
+#endif
   return RespondNow(NoArguments());
 }
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/preference/preference_api.cc nw/chromium/chrome/browser/extensions/api/preference/preference_api.cc
--- up/chromium/chrome/browser/extensions/api/preference/preference_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/preference/preference_api.cc	2024-08-26 19:32:17.766586372 +0000
@@ -505,7 +505,11 @@
   CHECK(pref);
 
   // Retrieve level of control.
-  std::string level_of_control =
+  std::string level_of_control;
+  if (extension()->is_nwjs_app())
+    level_of_control = "controllable_by_this_extension";
+  else
+    level_of_control =
       extensions::preference_helpers::GetLevelOfControl(
           profile, extension_id(), browser_pref, incognito);
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/preference/preference_helpers.cc nw/chromium/chrome/browser/extensions/api/preference/preference_helpers.cc
--- up/chromium/chrome/browser/extensions/api/preference/preference_helpers.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/preference/preference_helpers.cc	2024-08-26 19:32:17.766586372 +0000
@@ -101,7 +101,11 @@
       DCHECK(!args.empty());
       DCHECK(args[0].is_dict());
 
-      std::string level_of_control =
+      std::string level_of_control;
+      if (extension->is_nwjs_app())
+        level_of_control = kControlledByThisExtension;
+      else
+        level_of_control =
           level_getter.Run(profile, extension->id(), browser_pref, incognito);
 
       args[0].GetDict().Set(kLevelOfControlKey, level_of_control);
diff -r -u --color up/chromium/chrome/browser/extensions/api/scripting/scripting_api.cc nw/chromium/chrome/browser/extensions/api/scripting/scripting_api.cc
--- up/chromium/chrome/browser/extensions/api/scripting/scripting_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/scripting/scripting_api.cc	2024-08-26 19:32:17.770586374 +0000
@@ -695,6 +695,7 @@
                          : blink::mojom::UserActivationOption::kDoNotActivate,
           blink::mojom::PromiseResultOption::kAwait)),
       frame_scope, frame_ids, ScriptExecutor::MATCH_ABOUT_BLANK, run_location,
+      ScriptExecutor::ISOLATED_WORLD,
       ScriptExecutor::DEFAULT_PROCESS,
       /* webview_src */ GURL(),
       base::BindOnce(&ScriptingExecuteScriptFunction::OnScriptExecuted, this));
@@ -819,7 +820,9 @@
           std::move(sources), ConvertStyleOriginToCSSOrigin(injection_.origin),
           mojom::CSSInjection::Operation::kAdd)),
       frame_scope, frame_ids, ScriptExecutor::MATCH_ABOUT_BLANK,
-      kCSSRunLocation, ScriptExecutor::DEFAULT_PROCESS,
+      kCSSRunLocation,
+      ScriptExecutor::ISOLATED_WORLD,
+      ScriptExecutor::DEFAULT_PROCESS,
       /* webview_src */ GURL(),
       base::BindOnce(&ScriptingInsertCSSFunction::OnCSSInserted, this));
 
@@ -896,7 +899,9 @@
           std::move(sources), ConvertStyleOriginToCSSOrigin(injection.origin),
           mojom::CSSInjection::Operation::kRemove)),
       frame_scope, frame_ids, ScriptExecutor::MATCH_ABOUT_BLANK,
-      kCSSRunLocation, ScriptExecutor::DEFAULT_PROCESS,
+      kCSSRunLocation,
+      ScriptExecutor::ISOLATED_WORLD,
+      ScriptExecutor::DEFAULT_PROCESS,
       /* webview_src */ GURL(),
       base::BindOnce(&ScriptingRemoveCSSFunction::OnCSSRemoved, this));
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/sessions/sessions_api.cc nw/chromium/chrome/browser/extensions/api/sessions/sessions_api.cc
--- up/chromium/chrome/browser/extensions/api/sessions/sessions_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/sessions/sessions_api.cc	2024-08-26 19:32:17.770586374 +0000
@@ -330,6 +330,9 @@
 
   api::windows::WindowState state = api::windows::WindowState::kNone;
   switch (window.show_state) {
+    case ui::SHOW_STATE_HIDDEN:
+      state = api::windows::WindowState::kHidden;
+      break;
     case ui::SHOW_STATE_NORMAL:
       state = api::windows::WindowState::kNormal;
       break;
diff -r -u --color up/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc nw/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc
--- up/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc	2024-08-26 19:32:17.778586379 +0000
@@ -147,11 +147,16 @@
   const bool match_incognito_profile = include_incognito_information();
   Browser* target_browser =
       GetLastActiveBrowser(profile, match_incognito_profile);
+#if 0
   if (!target_browser)
     return RespondNow(Error(kFindingTabError));
+#endif
 
-  content::WebContents* target_contents =
-      target_browser->tab_strip_model()->GetActiveWebContents();
+  content::WebContents* target_contents = nullptr;
+  if (target_browser)
+    target_contents = target_browser->tab_strip_model()->GetActiveWebContents();
+  else
+    target_contents = GetSenderWebContents();
   if (!target_contents)
     return RespondNow(Error(kFindingTabError));
 
@@ -177,7 +182,7 @@
 
   // Make sure either we have been granted permission to capture through an
   // extension icon click or our extension is allowlisted.
-  if (!extension()->permissions_data()->HasAPIPermissionForTab(
+  if (!extension()->is_nwjs_app() && !extension()->permissions_data()->HasAPIPermissionForTab(
           sessions::SessionTabHelper::IdForTab(target_contents).id(),
           mojom::APIPermissionID::kTabCaptureForTab) &&
       (GetAllowlistedExtensionID() != extension_id)) {
diff -r -u --color up/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_registry.cc nw/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_registry.cc
--- up/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_registry.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_registry.cc	2024-08-26 19:32:17.778586379 +0000
@@ -23,6 +23,10 @@
 #include "extensions/common/extension_id.h"
 #include "url/origin.h"
 
+#include "chrome/browser/profiles/profile_manager.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "extensions/browser/app_window/app_window.h"
+
 using content::BrowserThread;
 using extensions::tab_capture::TabCaptureState;
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/tabs_api.cc nw/chromium/chrome/browser/extensions/api/tabs/tabs_api.cc
--- up/chromium/chrome/browser/extensions/api/tabs/tabs_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/tabs_api.cc	2024-08-26 19:32:17.778586379 +0000
@@ -2,7 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#pragma clang diagnostic ignored "-Wunused-but-set-variable"
+
 #include "chrome/browser/extensions/api/tabs/tabs_api.h"
+#include "ui/display/screen.h"
+
+#include "ui/gfx/image/image_skia_operations.h"
 
 #include <stddef.h>
 
@@ -14,6 +19,14 @@
 #include <utility>
 #include <vector>
 
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+#if defined(OS_MAC)
+#include "content/nw/src/nw_content_mac.h"
+#endif
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "extensions/browser/extension_registry.h"
+
 #include "base/check_op.h"
 #include "base/command_line.h"
 #include "base/containers/contains.h"
@@ -141,6 +154,8 @@
 #include "ui/base/clipboard/clipboard_buffer.h"
 #endif  // BUILDFLAG(IS_CHROMEOS_LACROS)
 
+#include "extensions/browser/guest_view/web_view/web_view_guest.h"
+
 using content::BrowserThread;
 using content::NavigationController;
 using content::NavigationEntry;
@@ -260,6 +275,8 @@
 
 ui::WindowShowState ConvertToWindowShowState(windows::WindowState state) {
   switch (state) {
+    case windows::WindowState::kHidden:
+      return ui::SHOW_STATE_HIDDEN;
     case windows::WindowState::kNormal:
       return ui::SHOW_STATE_NORMAL;
     case windows::WindowState::kMinimized:
@@ -292,9 +309,10 @@
     case windows::WindowState::kFullscreen:
     case windows::WindowState::kLockedFullscreen:
       // If maximised/fullscreen, default focused state should be focused.
-      return !(create_data->focused && !*create_data->focused) && !has_bound;
+      return true; //!(create_data->focused && !*create_data->focused) && !has_bound;
     case windows::WindowState::kNormal:
     case windows::WindowState::kNone:
+    case windows::WindowState::kHidden:
       return true;
   }
   NOTREACHED_IN_MIGRATION();
@@ -691,12 +709,28 @@
   if (!IsValidStateForWindowsCreateFunction(base::OptionalToPtr(create_data)))
     return RespondNow(Error(tabs_constants::kInvalidWindowStateError));
 
-  Browser::Type window_type = Browser::TYPE_NORMAL;
+  Browser::Type window_type = Browser::TYPE_POPUP;
 
   gfx::Rect window_bounds;
   bool focused = true;
+  bool hidden = false;
+  bool new_instance = false;
+  bool mixed_context = false;
+  bool frameless = false;
+  bool kiosk = false;
+  bool transparent = false;
+  bool always_on_top = false;
+  bool all_visible = false;
+  bool show_in_taskbar = true;
+  bool resizable = true;
+  bool block_parser = false;
+  std::string title;
+  int min_width = 0; int min_height = 0; int max_width = 0; int max_height = 0;
   std::string extension_id;
+  std::string position;
+  std::string windows_key;
 
+  std::string inject_js_start, inject_js_end;
   if (create_data) {
     // Figure out window type before figuring out bounds so that default
     // bounds can be set according to the window type.
@@ -721,8 +755,9 @@
 
     // Initialize default window bounds according to window type.
     ui::WindowShowState ignored_show_state = ui::SHOW_STATE_DEFAULT;
+    gfx::Rect ignored_window_bounds;
     WindowSizer::GetBrowserWindowBoundsAndShowState(
-        gfx::Rect(), nullptr, &window_bounds, &ignored_show_state);
+        gfx::Rect(), nullptr, &ignored_window_bounds, &ignored_show_state);
 
     // Update the window bounds based on the create parameters.
     bool set_window_position = false;
@@ -758,6 +793,25 @@
       return RespondNow(Error(tabs_constants::kInvalidWindowBoundsError));
     }
 
+    if (create_data->min_width) {
+      min_width = *create_data->min_width;
+      if (window_bounds.width())
+        window_bounds.set_width(std::max(min_width, window_bounds.width()));
+    }
+    if (create_data->max_width) {
+      max_width = *create_data->max_width;
+      window_bounds.set_width(std::min(max_width, window_bounds.width()));
+    }
+    if (create_data->min_height) {
+      min_height = *create_data->min_height;
+      if (window_bounds.height())
+        window_bounds.set_height(std::max(min_height, window_bounds.height()));
+    }
+    if (create_data->max_height) {
+      max_height = *create_data->max_height;
+      window_bounds.set_height(std::min(max_height, window_bounds.height()));
+    }
+
     if (create_data->focused)
       focused = *create_data->focused;
 
@@ -767,6 +821,38 @@
                               window_bounds.width());
     UMA_HISTOGRAM_COUNTS_1000("Extensions.CreateWindowHeight",
                               window_bounds.height());
+    if (create_data->hidden)
+      hidden = *create_data->hidden;
+    if (create_data->inject_js_start)
+      inject_js_start = *create_data->inject_js_start;
+    if (create_data->inject_js_end)
+      inject_js_end = *create_data->inject_js_end;
+    if (create_data->new_instance)
+      new_instance = *create_data->new_instance;
+    if (create_data->mixed_context)
+      mixed_context = *create_data->mixed_context;
+    if (create_data->frameless)
+      frameless = *create_data->frameless;
+    if (create_data->kiosk)
+      kiosk = *create_data->kiosk;
+    if (create_data->alpha_enabled)
+      transparent = *create_data->alpha_enabled;
+    if (create_data->always_on_top)
+      always_on_top = *create_data->always_on_top;
+    if (create_data->all_visible)
+      all_visible = *create_data->all_visible;
+    if (create_data->resizable)
+      resizable = *create_data->resizable;
+    if (create_data->show_in_taskbar)
+      show_in_taskbar = *create_data->show_in_taskbar;
+    if (create_data->title)
+      title = *create_data->title;
+    if (create_data->position)
+      position = *create_data->position;
+    if (create_data->block_parser)
+      block_parser = *create_data->block_parser;
+    if (create_data->id)
+      windows_key = *create_data->id;
   }
 
   // Create a new BrowserWindow if possible.
@@ -776,6 +862,7 @@
   }
   Browser::CreateParams create_params(window_type, window_profile,
                                       user_gesture());
+
   if (isolated_web_app_url_info.has_value()) {
     create_params = Browser::CreateParams::CreateForApp(
         web_app::GenerateApplicationNameFromAppId(
@@ -788,10 +875,38 @@
     // extension_id is only set for CREATE_TYPE_POPUP.
     create_params = Browser::CreateParams::CreateForAppPopup(
         web_app::GenerateApplicationNameFromAppId(extension_id),
-        /*trusted_source=*/false, window_bounds, window_profile,
+        extension() && extension()->is_nwjs_app() /* trusted_source */, window_bounds, window_profile,
         user_gesture());
   }
-  create_params.initial_show_state = ui::SHOW_STATE_NORMAL;
+  create_params.extension_id = extension_id;
+  create_params.windows_key = windows_key;
+  create_params.frameless = frameless;
+  create_params.alpha_enabled = transparent;
+  create_params.always_on_top = always_on_top;
+  create_params.all_visible = all_visible;
+  create_params.resizable = resizable;
+  create_params.show_in_taskbar = show_in_taskbar;
+  create_params.title = title;
+
+  if (create_data && create_data->icon) {
+    base::ScopedAllowBlocking allow_io;
+    gfx::Image app_icon;
+    nw::Package* package = nw::package();
+    if (nw::GetPackageImage(package,
+                            base::FilePath::FromUTF8Unsafe(*create_data->icon),
+                            &app_icon)) {
+      if (app_icon.Width() > 128 || app_icon.Height() > 128) {
+        const gfx::ImageSkia* originImageSkia = app_icon.ToImageSkia();
+        gfx::ImageSkia resizedImageSkia =
+          gfx::ImageSkiaOperations::CreateResizedImage(*originImageSkia,
+                                                       skia::ImageOperations::RESIZE_GOOD,
+                                                       gfx::Size(128, 128));
+        app_icon = gfx::Image(resizedImageSkia);
+      }
+      create_params.icon = app_icon;
+    }
+  }
+  create_params.initial_show_state = ui::SHOW_STATE_DEFAULT;
   if (create_data && create_data->state != windows::WindowState::kNone) {
     if (create_data->state == windows::WindowState::kLockedFullscreen &&
         !ExtensionHasLockedFullscreenPermission(extension())) {
@@ -802,10 +917,19 @@
         ConvertToWindowShowState(create_data->state);
   }
 
+  create_params.position = position;
   Browser* new_window = Browser::Create(create_params);
   if (!new_window)
     return RespondNow(Error(tabs_constants::kBrowserWindowNotAllowed));
 
+  BrowserFrame* frame = BrowserView::GetBrowserViewForBrowser(new_window)->frame();
+
+  if (kiosk) {
+    frame->SetFullscreen(true);
+#if defined(OS_MAC)
+    NWSetNSAppKioskOptions();
+#endif
+  }
   for (const GURL& url : urls) {
     NavigateParams navigate_params(new_window, url, ui::PAGE_TRANSITION_LINK);
     navigate_params.disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;
@@ -832,7 +956,19 @@
           render_frame_host()->GetSiteInstance();
     }
 
+    navigate_params.inject_js_start = inject_js_start;
+    navigate_params.inject_js_end = inject_js_end;
+    navigate_params.block_parser = block_parser;
+
+    if (new_instance)
+      nw::SetPinningRenderer(false);
+    if (mixed_context)
+      nw::SetMixedContext(true);
     Navigate(&navigate_params);
+    if (mixed_context)
+      nw::SetMixedContext(false);
+    if (new_instance)
+      nw::SetPinningRenderer(true);
   }
 
   const TabModel* tab = nullptr;
@@ -862,6 +998,19 @@
       TabStripUserGestureDetails(
           TabStripUserGestureDetails::GestureType::kNone));
 
+  new_window->window()->SetMinimumSize(gfx::Size(min_width, min_height));
+  new_window->window()->SetMaximumSize(gfx::Size(max_width, max_height));
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable)
+    new_window->window()->SetResizable(false);
+#endif
+
+  if (create_params.initial_show_state == ui::SHOW_STATE_FULLSCREEN) {
+    BrowserFrame* frame2 = BrowserView::GetBrowserViewForBrowser(new_window)->frame();
+    frame2->SetFullscreen(true);
+  }
+
+  if (!hidden) {
   if (focused) {
     new_window->window()->Show();
   } else {
@@ -886,6 +1035,9 @@
     if (reset_active && base::Contains(*browser_list, active_browser))
       active_browser->window()->Activate();
   }
+  } else {
+    new_window->window()->Hide();
+  }
 
 // Despite creating the window with initial_show_state() ==
 // ui::SHOW_STATE_MINIMIZED above, on Linux the window is not created as
@@ -913,11 +1065,33 @@
     // profile and CanCrossIncognito isn't allowed.
     return RespondNow(WithArguments(base::Value()));
   }
-
-  return RespondNow(
-      WithArguments(ExtensionTabUtil::CreateWindowValueForExtension(
+  if (new_window->DidFinishFirstNavigation())
+    return RespondNow(WithArguments(ExtensionTabUtil::CreateWindowValueForExtension(
           *new_window, extension(), ExtensionTabUtil::kPopulateTabs,
           source_context_type())));
+
+  new_window->AddOnDidFinishFirstNavigationCallback(
+    base::BindOnce(&WindowsCreateFunction::
+                   OnFinishedFirstNavigationOrClosed,
+                   this, base::Unretained(new_window), base::Unretained(extension()),
+		   source_context_type()));
+
+  return RespondLater();
+}
+
+void WindowsCreateFunction::OnFinishedFirstNavigationOrClosed(
+							      Browser* browser,
+							      const Extension* extension,
+							      mojom::ContextType context,
+							      bool did_finish) {
+  DCHECK(!did_respond());
+
+  if (!did_finish) {
+    Respond(Error("Browser is closed before ready to commit first navigation."));
+    return;
+  }
+
+  Respond(WithArguments(ExtensionTabUtil::CreateWindowValueForExtension(*browser, extension, ExtensionTabUtil::kPopulateTabs, context)));
 }
 
 ExtensionFunction::ResponseAction WindowsUpdateFunction::Run() {
@@ -954,21 +1128,71 @@
                                 ? browser->window()->GetRestoredBounds()
                                 : browser->window()->GetBounds();
   bool set_window_bounds = false;
+  bool set_pos_only = false;
+
+  bool set_min_size = false;
+  bool set_max_size = false;
+  gfx::Size min_size = BrowserView::GetBrowserViewForBrowser(browser)->GetMinimumSize();
+  gfx::Size max_size = BrowserView::GetBrowserViewForBrowser(browser)->GetMaximumSize();
+  if (params->update_info.min_width) {
+    min_size.set_width(*params->update_info.min_width);
+    set_min_size = true;
+  }
+  if (params->update_info.min_height) {
+    min_size.set_height(*params->update_info.min_height);
+    set_min_size = true;
+  }
+  if (params->update_info.max_width) {
+    max_size.set_width(*params->update_info.max_width);
+    set_max_size = true;
+  }
+  if (params->update_info.max_height) {
+    max_size.set_height(*params->update_info.max_height);
+    set_max_size = true;
+  }
+  if (set_min_size)
+    browser->window()->SetMinimumSize(min_size);
+  if (set_max_size)
+    browser->window()->SetMaximumSize(max_size);
   if (params->update_info.left) {
     window_bounds.set_x(*params->update_info.left);
     set_window_bounds = true;
+    set_pos_only = true;
   }
   if (params->update_info.top) {
     window_bounds.set_y(*params->update_info.top);
     set_window_bounds = true;
+    set_pos_only = true;
   }
   if (params->update_info.width) {
     window_bounds.set_width(*params->update_info.width);
     set_window_bounds = true;
+    set_pos_only = false;
   }
   if (params->update_info.height) {
     window_bounds.set_height(*params->update_info.height);
     set_window_bounds = true;
+    set_pos_only = false;
+  }
+
+  bool set_client_bounds = false;
+  BrowserFrame* frame = BrowserView::GetBrowserViewForBrowser(browser)->frame();
+  gfx::Rect client_bounds = frame->non_client_view()->frame_view()->GetBoundsForClientView();
+  client_bounds.Offset(window_bounds.OffsetFromOrigin());
+
+  if (params->update_info.inner_width) {
+    client_bounds.set_width(*params->update_info.inner_width);
+    set_client_bounds = true;
+  }
+
+  if (params->update_info.inner_height) {
+    client_bounds.set_height(*params->update_info.inner_height);
+    set_client_bounds = true;
+  }
+
+  if (set_client_bounds) {
+    gfx::Rect win_bounds = frame->non_client_view()->GetWindowBoundsForClientBounds(client_bounds);
+    browser->window()->SetBounds(win_bounds);
   }
 
   if (set_window_bounds && !WindowBoundsIntersectDisplays(window_bounds))
@@ -1030,8 +1254,12 @@
           true, extension()->url());
       break;
     case ui::SHOW_STATE_NORMAL:
+      browser->window()->Show();
       browser->window()->Restore();
       break;
+    case ui::SHOW_STATE_HIDDEN:
+      browser->window()->Hide();
+      break;
     default:
       break;
   }
@@ -1039,7 +1267,25 @@
   if (set_window_bounds) {
     // TODO(varkha): Updating bounds during a drag can cause problems and a more
     // general solution is needed. See http://crbug.com/251813 .
-    browser->window()->SetBounds(window_bounds);
+#if defined(OS_WIN)
+    if (set_pos_only)
+      browser->window()->SetPosition(window_bounds.origin());
+    else
+#endif
+      browser->window()->SetBounds(window_bounds);
+  }
+
+  if (params->update_info.position &&
+      *params->update_info.position == "center")
+    BrowserView::GetBrowserViewForBrowser(browser)->frame()->CenterWindow(window_bounds.size());
+  if (params->update_info.position &&
+      *params->update_info.position == "mouse") {
+    BrowserFrame* browser_frame =
+      BrowserView::GetBrowserViewForBrowser(browser)->frame();
+      gfx::Point cursor_pos(display::Screen::GetScreen()->GetCursorScreenPoint());
+      gfx::Rect bounds = browser_frame->GetWindowBoundsInScreen();
+      bounds.set_origin(cursor_pos);
+      browser_frame->SetBounds(bounds);
   }
 
   if (params->update_info.focused) {
@@ -1050,6 +1296,16 @@
     }
   }
 
+  if (params->update_info.show && *params->update_info.show)
+    browser->window()->Show();
+  if (params->update_info.resizable)
+    browser->window()->SetResizable(*params->update_info.resizable);
+  if (params->update_info.all_visible)
+    browser->window()->SetAllVisible(*params->update_info.all_visible);
+  if (params->update_info.always_on_top)
+    browser->window()->SetZOrderLevel(*params->update_info.always_on_top ? ui::ZOrderLevel::kFloatingWindow : ui::ZOrderLevel::kNormal);
+  if (params->update_info.show_in_taskbar)
+    browser->window()->SetShowInTaskbar(*params->update_info.show_in_taskbar);
   if (params->update_info.draw_attention)
     browser->window()->FlashFrame(*params->update_info.draw_attention);
 
@@ -1348,6 +1604,7 @@
     options.index = params->create_properties.index;
     options.url = params->create_properties.url;
 
+    options.create_browser_if_needed = true;
     auto result = ExtensionTabUtil::OpenTab(this, options, user_gesture());
     if (!result.has_value()) {
       return Error(result.error());
@@ -2406,6 +2663,8 @@
       tabs::DetectLanguage::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(params);
 
+  return RespondNow(Error("disabled in NW.js"));
+#if 0
   int tab_id = 0;
   Browser* browser = nullptr;
   WebContents* contents = nullptr;
@@ -2468,6 +2727,7 @@
   is_observing_ = true;
 
   return RespondLater();
+#endif
 }
 
 void TabsDetectLanguageFunction::NavigationEntryCommitted(
@@ -2492,9 +2752,11 @@
     const std::string& language) {
   // Stop observing.
   if (is_observing_) {
+#if 0
     ChromeTranslateClient::FromWebContents(web_contents())
         ->GetTranslateDriver()
         ->RemoveLanguageDetectionObserver(this);
+#endif
     Observe(nullptr);
   }
 
@@ -2631,12 +2893,17 @@
   bool success = GetTabById(execute_tab_id_, browser_context(),
                             include_incognito_information(), &browser, nullptr,
                             &contents, nullptr, error) &&
-                 contents && browser;
+                 contents;
 
   if (!success)
     return nullptr;
 
-  return TabHelper::FromWebContents(contents)->script_executor();
+  if (TabHelper::FromWebContents(contents))
+    return TabHelper::FromWebContents(contents)->script_executor();
+  auto* web_view = extensions::WebViewGuest::FromWebContents(contents);
+  if (web_view)
+    return web_view->script_executor();
+  return nullptr;
 }
 
 bool ExecuteCodeInTabFunction::IsWebView() const {
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/tabs_api.h nw/chromium/chrome/browser/extensions/api/tabs/tabs_api.h
--- up/chromium/chrome/browser/extensions/api/tabs/tabs_api.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/tabs_api.h	2024-08-26 19:32:17.778586379 +0000
@@ -71,6 +71,9 @@
   DECLARE_EXTENSION_FUNCTION("windows.getAll", WINDOWS_GETALL)
 };
 class WindowsCreateFunction : public ExtensionFunction {
+  void OnFinishedFirstNavigationOrClosed(Browser*, const Extension* extension,
+					 mojom::ContextType context,
+                                         bool did_finish);
   ~WindowsCreateFunction() override {}
   ResponseAction Run() override;
   DECLARE_EXTENSION_FUNCTION("windows.create", WINDOWS_CREATE)
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.cc nw/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.cc
--- up/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.cc	2024-08-26 19:32:17.778586379 +0000
@@ -151,6 +151,15 @@
   router_->TabUpdated(this, std::move(changed_property_names));
 }
 
+void TabsEventRouter::NWStatusUpdated(content::WebContents* web_contents,
+                                      const std::string& nwstatus) {
+  std::set<std::string> changed_property_names;
+  changed_property_names.insert("nwstatus");
+  TabEntry* entry = GetTabEntry(web_contents);
+  if (entry)
+    TabUpdated(entry, std::move(changed_property_names));
+}
+
 void TabsEventRouter::TabEntry::TitleWasSet(content::NavigationEntry* entry) {
   std::set<std::string> changed_property_names;
   changed_property_names.insert(tabs_constants::kTitleKey);
@@ -193,6 +202,13 @@
   }
 }
 
+void TabsEventRouter::OnBrowserNoLongerActive(Browser* browser) {
+  TabsWindowsAPI* tabs_window_api = TabsWindowsAPI::Get(profile_);
+  if (tabs_window_api) {
+    tabs_window_api->windows_event_router()->OnActiveWindowChanged(NULL);
+  }
+}
+
 void TabsEventRouter::OnTabStripModelChanged(
     TabStripModel* tab_strip_model,
     const TabStripModelChange& change,
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.h nw/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.h
--- up/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.h	2024-08-26 19:32:17.778586379 +0000
@@ -48,12 +48,15 @@
   TabsEventRouter& operator=(const TabsEventRouter&) = delete;
 
   ~TabsEventRouter() override;
+  void NWStatusUpdated(content::WebContents* web_contents,
+                       const std::string& nwstatus);
 
   // BrowserTabStripTrackerDelegate:
   bool ShouldTrackBrowser(Browser* browser) override;
 
   // BrowserListObserver:
   void OnBrowserSetLastActive(Browser* browser) override;
+  void OnBrowserNoLongerActive(Browser* browser) override;
 
   // TabStripModelObserver:
   void OnTabStripModelChanged(
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/windows_event_router.cc nw/chromium/chrome/browser/extensions/api/tabs/windows_event_router.cc
--- up/chromium/chrome/browser/extensions/api/tabs/windows_event_router.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/windows_event_router.cc	2024-08-26 19:32:17.782586381 +0000
@@ -281,6 +281,44 @@
 }
 #endif
 
+void WindowsEventRouter::OnWindowMove(WindowController* window_controller) {
+  if (!HasEventListener(windows::OnMove::kEventName))
+    return;
+  if (!window_controller)
+    return;
+  if (!profile_->IsSameOrParent(window_controller->profile()))
+    return;
+  // Ignore any windows without an associated browser (e.g., AppWindows).
+  if (!window_controller->GetBrowser())
+    return;
+
+  base::Value::List args;
+  args.Append(ExtensionTabUtil::CreateWindowValueForExtension(
+      *window_controller->GetBrowser(), nullptr,
+      ExtensionTabUtil::kDontPopulateTabs, mojom::ContextType::kUnspecified));
+  DispatchEvent(events::UNKNOWN, windows::OnMove::kEventName,
+                window_controller, std::move(args));
+}
+
+void WindowsEventRouter::OnWindowChanged(WindowController* window_controller) {
+  if (!window_controller)
+    return;
+  if (!HasEventListener(windows::OnWindowChanged::kEventName))
+    return;
+  if (!profile_->IsSameOrParent(window_controller->profile()))
+    return;
+  // Ignore any windows without an associated browser (e.g., AppWindows).
+  if (!window_controller->GetBrowser())
+    return;
+
+  base::Value::List args;
+  args.Append(ExtensionTabUtil::CreateWindowValueForExtension(
+      *window_controller->GetBrowser(), nullptr,
+      ExtensionTabUtil::kDontPopulateTabs, mojom::ContextType::kUnspecified));
+  DispatchEvent(events::UNKNOWN, windows::OnWindowChanged::kEventName,
+                window_controller, std::move(args));
+}
+
 void WindowsEventRouter::OnActiveWindowChanged(
     WindowController* window_controller) {
   Profile* window_profile = nullptr;
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/windows_event_router.h nw/chromium/chrome/browser/extensions/api/tabs/windows_event_router.h
--- up/chromium/chrome/browser/extensions/api/tabs/windows_event_router.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/windows_event_router.h	2024-08-26 19:32:17.782586381 +0000
@@ -54,6 +54,8 @@
 
   // |window_controller| is NULL to indicate a focused window has lost focus.
   void OnActiveWindowChanged(WindowController* window_controller);
+  void OnWindowMove(WindowController* window_controller);
+  void OnWindowChanged(WindowController* window_controller);
 
  private:
   // extensions::AppWindowRegistry::Observer:
diff -r -u --color up/chromium/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc nw/chromium/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
--- up/chromium/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc	2024-08-26 19:32:17.782586381 +0000
@@ -15,7 +15,7 @@
 
 
 // static
-bool FrameNavigationState::allow_extension_scheme_ = false;
+bool FrameNavigationState::allow_extension_scheme_ = true;
 
 DOCUMENT_USER_DATA_KEY_IMPL(FrameNavigationState);
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/web_navigation/web_navigation_api_helpers.cc nw/chromium/chrome/browser/extensions/api/web_navigation/web_navigation_api_helpers.cc
--- up/chromium/chrome/browser/extensions/api/web_navigation/web_navigation_api_helpers.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/web_navigation/web_navigation_api_helpers.cc	2024-08-26 19:32:17.782586381 +0000
@@ -175,6 +175,7 @@
   details.tab_id = ExtensionTabUtil::GetTabId(web_contents);
   details.url = url.spec();
   details.process_id = frame_host->GetProcess()->GetID();
+  details.routing_id = frame_host->GetRoutingID();
   details.frame_id = ExtensionApiFrameIdMap::GetFrameId(frame_host);
   details.parent_frame_id =
       ExtensionApiFrameIdMap::GetParentFrameId(frame_host);
diff -r -u --color up/chromium/chrome/browser/extensions/browser_context_keyed_service_factories.cc nw/chromium/chrome/browser/extensions/browser_context_keyed_service_factories.cc
--- up/chromium/chrome/browser/extensions/browser_context_keyed_service_factories.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/browser_context_keyed_service_factories.cc	2024-08-26 19:32:17.790586385 +0000
@@ -7,6 +7,8 @@
 #include "chrome/browser/extensions/api/api_browser_context_keyed_service_factories.h"
 #include "chrome/browser/extensions/chrome_browser_context_keyed_service_factories.h"
 
+#include "content/nw/src/api/object_manager_factory.h"
+
 namespace chrome_extensions {
 
 void EnsureBrowserContextKeyedServiceFactoriesBuilt() {
diff -r -u --color up/chromium/chrome/browser/extensions/browser_extension_window_controller.cc nw/chromium/chrome/browser/extensions/browser_extension_window_controller.cc
--- up/chromium/chrome/browser/extensions/browser_extension_window_controller.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/browser_extension_window_controller.cc	2024-08-26 19:32:17.790586385 +0000
@@ -65,7 +65,7 @@
   // is null and allowing access to all windows. It would be better if we could
   // pass in mojom::ContextType or some way to detect caller type.
   // Platform apps can only see their own windows.
-  if (extension && extension->is_platform_app())
+  if (extension && extension->is_platform_app() && !extension->is_nwjs_app())
     return false;
 
   return !browser_->is_type_devtools() || allow_dev_tools_windows;
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_component_extension_resource_manager.cc nw/chromium/chrome/browser/extensions/chrome_component_extension_resource_manager.cc
--- up/chromium/chrome/browser/extensions/chrome_component_extension_resource_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_component_extension_resource_manager.cc	2024-08-26 19:32:17.790586385 +0000
@@ -192,7 +192,9 @@
   base::FilePath relative_path;
   if (!base::PathService::Get(chrome::DIR_RESOURCES, &resources_dir) ||
       !resources_dir.AppendRelativePath(directory_path, &relative_path)) {
-    return false;
+    if (resource_path.AsUTF8Unsafe() != kNWJSDefaultAppJS &&
+        resource_path.AsUTF8Unsafe() != "nwjs/newwin.js")
+      return false;
   }
   relative_path = relative_path.Append(resource_path);
   relative_path = relative_path.NormalizePathSeparators();
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_content_browser_client_extensions_part.cc nw/chromium/chrome/browser/extensions/chrome_content_browser_client_extensions_part.cc
--- up/chromium/chrome/browser/extensions/chrome_content_browser_client_extensions_part.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_content_browser_client_extensions_part.cc	2024-08-26 19:32:17.790586385 +0000
@@ -4,6 +4,9 @@
 
 #include "chrome/browser/extensions/chrome_content_browser_client_extensions_part.h"
 
+#include "content/browser/renderer_host/render_process_host_impl.h"
+#include "extensions/common/manifest_url_handlers.h"
+
 #include <stddef.h>
 
 #include <algorithm>
@@ -334,8 +337,12 @@
   const Extension* extension = ExtensionRegistry::Get(browser_context)
                                    ->enabled_extensions()
                                    .GetExtensionOrAppByURL(effective_site_url);
-  // Isolate all extensions.
-  return extension != nullptr;
+  if (!extension)
+    return false;
+
+  if (extension->manifest()->FindKey("devtools_page"))
+    return true;
+  return false;
 }
 
 // static
@@ -421,6 +428,15 @@
   if (extension->is_hosted_app())
     return extension->id() != kWebStoreAppId;
 
+  if (extension->is_nwjs_app()) //NWJS#6784
+    return true;
+
+  //moved here from is_guest block since eeae1106f478:
+  //[Extensions] Restructure extensions::ProcessMap
+  //breaking react-devtools-extension
+
+  if (!extensions::ManifestURL::Get(extension, "devtools_page").is_empty())
+    return true;
   // Platform app URLs may commit in their own guest processes, when they have
   // the webview permission.  (Some extensions are allowlisted for webviews as
   // well, but their pages load in their own extension process and are allowed
@@ -448,6 +464,8 @@
     Profile* profile,
     content::RenderProcessHost* process_host,
     const GURL& site_url) {
+  return true;
+#if 0
   DCHECK(profile);
 
   ExtensionRegistry* registry = ExtensionRegistry::Get(profile);
@@ -485,6 +503,7 @@
   // Otherwise, the extensions layer is ok with using `process_host` for
   // `site_url`.
   return true;
+#endif
 }
 
 size_t
@@ -767,6 +786,8 @@
     return;
   }
 
+  if (extension->is_nwjs_app() && !content::RenderProcessHostImpl::main_host())
+    ((content::RenderProcessHostImpl*)site_instance->GetProcess())->set_main_host();
   // Don't consider guests that load extension URLs as extension processes,
   // except for the PDF Viewer extension URL. This is possible when an embedder
   // app navigates <webview> to a webview-accessible app resource; the resulting
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.cc nw/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.cc
--- up/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.cc	2024-08-26 19:32:17.790586385 +0000
@@ -209,7 +209,9 @@
 
 void ChromeContentVerifierDelegate::VerifyFailed(
     const ExtensionId& extension_id,
-    ContentVerifyJob::FailureReason reason) {
+    const base::FilePath& relative_path,
+    ContentVerifyJob::FailureReason reason,
+    scoped_refptr<ContentVerifyJob> verify_job) {
   ExtensionRegistry* registry = ExtensionRegistry::Get(context_);
   const Extension* extension =
       registry->enabled_extensions().GetByID(extension_id);
@@ -341,6 +343,8 @@
   if (should_repair)
     return VerifyInfo(default_mode_, is_from_webstore, should_repair);
 
+  if (extension.is_nwjs_app() && !Manifest::IsComponentLocation(extension.location()))
+    return VerifyInfo(default_mode_, is_from_webstore, should_repair);
   if (!extension.is_extension() && !extension.is_legacy_packaged_app())
     return VerifyInfo(VerifyInfo::Mode::NONE, is_from_webstore, should_repair);
   if (!Manifest::IsAutoUpdateableLocation(extension.location()))
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.h nw/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.h
--- up/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.h	2024-08-26 19:32:17.790586385 +0000
@@ -82,7 +82,9 @@
   std::set<base::FilePath> GetBrowserImagePaths(
       const extensions::Extension* extension) override;
   void VerifyFailed(const ExtensionId& extension_id,
-                    ContentVerifyJob::FailureReason reason) override;
+                    const base::FilePath& relative_path,
+                    ContentVerifyJob::FailureReason reason,
+                    scoped_refptr<ContentVerifyJob> verify_job) override;
   void Shutdown() override;
 
   // A helper class to allow tests to provide their own `VerifyInfo` for
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extension_frame_host.cc nw/chromium/chrome/browser/extensions/chrome_extension_frame_host.cc
--- up/chromium/chrome/browser/extensions/chrome_extension_frame_host.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extension_frame_host.cc	2024-08-26 19:32:17.790586385 +0000
@@ -19,6 +19,8 @@
 #include "third_party/blink/public/common/logging/logging_utils.h"
 #include "url/gurl.h"
 
+#include "third_party/blink/public/mojom/page/draggable_region.mojom.h"
+
 namespace extensions {
 
 ChromeExtensionFrameHost::ChromeExtensionFrameHost(
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extension_frame_host.h nw/chromium/chrome/browser/extensions/chrome_extension_frame_host.h
--- up/chromium/chrome/browser/extensions/chrome_extension_frame_host.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extension_frame_host.h	2024-08-26 19:32:17.790586385 +0000
@@ -11,6 +11,8 @@
 #include "extensions/common/mojom/injection_type.mojom-shared.h"
 #include "extensions/common/mojom/run_location.mojom-shared.h"
 
+#include "third_party/blink/public/mojom/page/draggable_region.mojom.h"
+
 namespace content {
 class WebContents;
 }
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc nw/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc
--- up/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc	2024-08-26 19:32:17.790586385 +0000
@@ -28,13 +28,50 @@
 #include "extensions/common/switches.h"
 #include "third_party/blink/public/common/chrome_debug_urls.h"
 
+#include "components/zoom/zoom_controller.h"
+#include "content/public/browser/web_contents.h"
+
+using content::BrowserContext;
+
 namespace extensions {
 
 ChromeExtensionWebContentsObserver::ChromeExtensionWebContentsObserver(
     content::WebContents* web_contents)
     : ExtensionWebContentsObserver(web_contents),
       content::WebContentsUserData<ChromeExtensionWebContentsObserver>(
-          *web_contents) {}
+          *web_contents) {
+  // Since ZoomController is also a WebContentsObserver, we need to be careful
+  // about disconnecting from it since the relative order of destruction of
+  // WebContentsObservers is not guaranteed. ZoomController silently clears
+  // its ZoomObserver list during WebContentsDestroyed() so there's no need
+  // to explicitly remove ourselves on destruction.
+  zoom::ZoomController* zoom_controller =
+      zoom::ZoomController::FromWebContents(web_contents);
+  // There may not always be a ZoomController, e.g. in tests.
+  if (zoom_controller)
+    zoom_controller->AddObserver(this);
+}
+
+void ChromeExtensionWebContentsObserver::OnZoomChanged(
+    const zoom::ZoomController::ZoomChangedEventData& data) {
+  ProcessManager* const process_manager = ProcessManager::Get(browser_context());
+  const Extension* const extension =
+      process_manager->GetExtensionForWebContents(web_contents());
+  if (extension) {
+    base::Value::List args;
+    args.Append(data.old_zoom_level);
+    args.Append(data.new_zoom_level);
+
+    content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+    ExtensionWebContentsObserver::GetForWebContents(web_contents())
+      ->GetLocalFrame(rfh)
+      ->MessageInvoke(extension->id(), "nw.Window",
+                      "updateAppWindowZoom", std::move(args));
+  }
+}
+
+void ChromeExtensionWebContentsObserver::OnZoomControllerDestroyed(zoom::ZoomController* zoom_controller) {
+}
 
 ChromeExtensionWebContentsObserver::~ChromeExtensionWebContentsObserver() {}
 
@@ -72,7 +109,8 @@
   // Components of chrome that are implemented as extensions or platform apps
   // are allowed to use chrome://resources/ and chrome://theme/ URLs.
   if ((extension->is_extension() || extension->is_platform_app()) &&
-      Manifest::IsComponentLocation(extension->location())) {
+      (Manifest::IsComponentLocation(extension->location()) ||
+       extension->is_nwjs_app())) {
     policy->GrantRequestOrigin(
         process_id, url::Origin::Create(GURL(blink::kChromeUIResourcesURL)));
     policy->GrantRequestOrigin(
@@ -85,6 +123,7 @@
   // never given access to Chrome APIs).
   if (extension->is_extension() ||
       extension->is_legacy_packaged_app() ||
+      extension->is_nwjs_app() ||
       (extension->is_platform_app() &&
        Manifest::IsComponentLocation(extension->location()))) {
     policy->GrantRequestOrigin(
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.h nw/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.h
--- up/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.h	2024-08-26 19:32:17.790586385 +0000
@@ -13,6 +13,8 @@
 #include "extensions/browser/extension_web_contents_observer.h"
 #include "extensions/common/stack_frame.h"
 
+#include "components/zoom/zoom_observer.h"
+
 namespace content {
 class RenderFrameHost;
 }
@@ -24,6 +26,7 @@
 // renderers and updating autoplay policy.
 class ChromeExtensionWebContentsObserver
     : public ExtensionWebContentsObserver,
+      public zoom::ZoomObserver,
       public content::WebContentsUserData<ChromeExtensionWebContentsObserver> {
  public:
   ChromeExtensionWebContentsObserver(
@@ -32,7 +35,11 @@
       const ChromeExtensionWebContentsObserver&) = delete;
 
   ~ChromeExtensionWebContentsObserver() override;
-
+  // ZoomObserver implementation.
+  void OnZoomChanged(
+      const zoom::ZoomController::ZoomChangedEventData& data) override;
+  void OnZoomControllerDestroyed(
+      zoom::ZoomController* zoom_controller) override;
   // Creates and initializes an instance of this class for the given
   // |web_contents|, if it doesn't already exist.
   static void CreateForWebContents(content::WebContents* web_contents);
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc nw/chromium/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc
--- up/chromium/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc	2024-08-26 19:32:17.790586385 +0000
@@ -8,6 +8,8 @@
 #include "chrome/browser/extensions/api/preference/preference_api.h"
 #include "extensions/browser/extension_function_registry.h"
 
+#include "content/nw/src/api/generated_api_registration.h"
+
 namespace extensions {
 
 ChromeExtensionsBrowserAPIProvider::ChromeExtensionsBrowserAPIProvider() =
@@ -24,6 +26,7 @@
 
   // Generated APIs from Chrome.
   api::ChromeGeneratedFunctionRegistry::RegisterAll(registry);
+  nwapi::nwjsGeneratedFunctionRegistry::RegisterAll(registry);
 }
 
 }  // namespace extensions
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extensions_browser_client.cc nw/chromium/chrome/browser/extensions/chrome_extensions_browser_client.cc
--- up/chromium/chrome/browser/extensions/chrome_extensions_browser_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extensions_browser_client.cc	2024-08-26 19:32:17.794586387 +0000
@@ -131,6 +131,8 @@
 #include "chromeos/startup/browser_params_proxy.h"
 #endif
 
+#include "content/nw/src/api/generated_api_registration.h"
+
 namespace extensions {
 
 namespace {
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_url_request_util.cc nw/chromium/chrome/browser/extensions/chrome_url_request_util.cc
--- up/chromium/chrome/browser/extensions/chrome_url_request_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_url_request_util.cc	2024-08-26 19:32:17.794586387 +0000
@@ -23,6 +23,7 @@
 #include "extensions/browser/extensions_browser_client.h"
 #include "extensions/browser/url_request_util.h"
 #include "extensions/common/extension_id.h"
+#include "extensions/common/constants.h"
 #include "extensions/common/file_util.h"
 #include "mojo/public/c/system/types.h"
 #include "mojo/public/cpp/bindings/receiver.h"
@@ -269,6 +270,23 @@
   *resource_id = 0;
   // |chrome_resources_path| corresponds to src/chrome/browser/resources in
   // source tree.
+  std::string path = request.url.path();
+  if (path.size() > 1 &&
+      (path.substr(1) == extensions::kNWJSDefaultAppJS ||
+       path.substr(1) == "nwjs/newwin.js")) {
+    base::FilePath relative_path;
+    base::FilePath request_path =
+      extensions::file_util::ExtensionURLToRelativeFilePath(request.url);
+    if (ExtensionsBrowserClient::Get()
+        ->GetComponentExtensionResourceManager()
+        ->IsComponentExtensionResource(
+                     extension_resources_path, request_path, resource_id)) {
+      relative_path = relative_path.Append(request_path);
+      relative_path = relative_path.NormalizePathSeparators();
+      return relative_path;
+    } else
+      return base::FilePath();
+  }
   base::FilePath chrome_resources_path;
   if (!base::PathService::Get(chrome::DIR_RESOURCES, &chrome_resources_path))
     return base::FilePath();
diff -r -u --color up/chromium/chrome/browser/extensions/component_loader.cc nw/chromium/chrome/browser/extensions/component_loader.cc
--- up/chromium/chrome/browser/extensions/component_loader.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/component_loader.cc	2024-08-26 19:32:17.794586387 +0000
@@ -7,6 +7,8 @@
 #include <optional>
 #include <string>
 #include <string_view>
+#include "content/public/common/content_features.h"
+#include "base/strings/utf_string_conversions.h"
 
 #include "base/command_line.h"
 #include "base/feature_list.h"
@@ -343,6 +345,18 @@
   }
 }
 
+std::string ComponentLoader::GetExtensionID(
+					    int manifest_resource_id,
+					    const base::FilePath& root_directory) {
+  std::optional<base::Value::Dict> manifest =
+    ParseManifest(ui::ResourceBundle::GetSharedInstance().GetRawDataResource(
+									     manifest_resource_id));
+  if (!manifest)
+    return std::string();
+
+  return GenerateId(manifest.value(), root_directory);
+}
+
 bool ComponentLoader::Exists(const ExtensionId& id) const {
   for (const auto& component_extension : component_extensions_) {
     if (component_extension.extension_id == id) {
@@ -471,6 +485,7 @@
 
 void ComponentLoader::AddDefaultComponentExtensions(
     bool skip_session_components) {
+#if 0
   // Do not add component extensions that have background pages here -- add them
   // to AddDefaultComponentExtensionsWithBackgroundPages.
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -495,13 +510,49 @@
       AddChromeApp();
     }
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+  }
+
+#endif
+
+  AddDefaultComponentExtensionsWithBackgroundPages(skip_session_components);
 #if BUILDFLAG(ENABLE_PDF)
     Add(pdf_extension_util::GetManifest(),
         base::FilePath(FILE_PATH_LITERAL("pdf")));
 #endif  // BUILDFLAG(ENABLE_PDF)
-  }
 
-  AddDefaultComponentExtensionsWithBackgroundPages(skip_session_components);
+  base::CommandLine& command_line(*base::CommandLine::ForCurrentProcess());
+
+  //match the condition in startup_browser_creator.cc
+  if (command_line.HasSwitch("nwapp") || command_line.GetArgs().size() > 0)
+    return;
+
+  std::string url;
+  if (command_line.HasSwitch("url")) {
+      url = command_line.GetSwitchValueASCII("url");
+  }
+  std::string manifest_contents;
+  std::string default_path("nwjs_default_app");
+  if (base::FeatureList::IsEnabled(::features::kNWNewWin)) {
+    manifest_contents = 
+      std::string(ui::ResourceBundle::GetSharedInstance().GetRawDataResource(IDR_NWJS_DEFAPP_MANIFEST_NEWWIN));
+    default_path = "nwjs_newwin_app";
+  }
+  else
+    manifest_contents =
+      std::string(ui::ResourceBundle::GetSharedInstance().GetRawDataResource(IDR_NWJS_DEFAPP_MANIFEST));
+  std::optional<base::Value::Dict> manifest
+    = ParseManifest(manifest_contents);
+  if (manifest) {
+    if (!url.empty())
+      manifest->Set("cmdlineUrl", url);
+    manifest->Set(extensions::manifest_keys::kNWJSMixedContext,
+		  command_line.HasSwitch("mixed-context"));
+#if defined(OS_WIN)
+    Add(std::move(*manifest), base::FilePath::FromUTF8Unsafe(default_path), true);
+#else
+    Add(std::move(*manifest), base::FilePath(default_path), true);
+#endif
+  }
 }
 
 void ComponentLoader::AddDefaultComponentExtensionsForKioskMode(
@@ -529,6 +580,7 @@
 
 void ComponentLoader::AddDefaultComponentExtensionsWithBackgroundPages(
     bool skip_session_components) {
+#if 0 //nwjs
   const base::CommandLine* command_line =
       base::CommandLine::ForCurrentProcess();
 
@@ -599,6 +651,8 @@
 #endif
 
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
+
+#endif //nwjs
 }
 
 void ComponentLoader::
diff -r -u --color up/chromium/chrome/browser/extensions/component_loader.h nw/chromium/chrome/browser/extensions/component_loader.h
--- up/chromium/chrome/browser/extensions/component_loader.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/component_loader.h	2024-08-26 19:32:17.794586387 +0000
@@ -46,6 +46,9 @@
     return component_extensions_.size();
   }
 
+  std::string GetExtensionID(
+                             int manifest_resource_id,
+                             const base::FilePath& root_directory);
   // Creates and loads all registered component extensions.
   void LoadAll();
 
diff -r -u --color up/chromium/chrome/browser/extensions/content_verifier_browsertest.cc nw/chromium/chrome/browser/extensions/content_verifier_browsertest.cc
--- up/chromium/chrome/browser/extensions/content_verifier_browsertest.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/content_verifier_browsertest.cc	2024-08-26 19:32:17.794586387 +0000
@@ -698,7 +698,7 @@
   TestExtensionRegistryObserver registry_observer(
       ExtensionRegistry::Get(profile()), kExtensionId);
   ContentVerifier* verifier = system->content_verifier();
-  verifier->VerifyFailedForTest(kExtensionId, ContentVerifyJob::HASH_MISMATCH);
+  verifier->VerifyFailed(kExtensionId, base::FilePath(), ContentVerifyJob::HASH_MISMATCH, nullptr);
 
   // Set our mock update client to check that the corrupt bit is set on the
   // data structure it receives.
diff -r -u --color up/chromium/chrome/browser/extensions/extension_browser_window_helper.cc nw/chromium/chrome/browser/extensions/extension_browser_window_helper.cc
--- up/chromium/chrome/browser/extensions/extension_browser_window_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_browser_window_helper.cc	2024-08-26 19:32:17.802586392 +0000
@@ -96,6 +96,11 @@
   // terminated case (as when the extension crashed), we let the sad tabs stay.
   if (reason != extensions::UnloadedExtensionReason::TERMINATE)
     CleanUpTabsOnUnload(extension);
+
+  if (extension->is_nwjs_app()) {
+    browser_->window()->Close();
+    return;
+  }
 }
 
 void ExtensionBrowserWindowHelper::CleanUpTabsOnUnload(
diff -r -u --color up/chromium/chrome/browser/extensions/extension_service.cc nw/chromium/chrome/browser/extensions/extension_service.cc
--- up/chromium/chrome/browser/extensions/extension_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_service.cc	2024-08-26 19:32:17.810586396 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/extensions/extension_service.h"
 
+#include "content/nw/src/nw_content.h"
+
 #include <stddef.h>
 
 #include <iterator>
@@ -129,6 +131,8 @@
 #include "storage/browser/file_system/file_system_context.h"
 #endif
 
+#include "content/nw/src/nw_content.h"
+
 using content::BrowserContext;
 using content::BrowserThread;
 using extensions::mojom::ManifestLocation;
@@ -455,6 +459,7 @@
   ExtensionManagementFactory::GetForBrowserContext(profile_)->AddObserver(this);
 
   // Set up the ExtensionUpdater.
+#if 0
   if (autoupdate_enabled) {
     updater_ = std::make_unique<ExtensionUpdater>(
         this, extension_prefs, profile->GetPrefs(), profile,
@@ -464,12 +469,15 @@
                             profile));
   }
 
+#endif
   component_loader_ = std::make_unique<ComponentLoader>(system_, profile);
 
+#if 0
   if (extensions_enabled_) {
     ExternalProviderImpl::CreateExternalProviders(
         this, profile_, &external_extension_providers_);
   }
+#endif
 
   // Set this as the ExtensionService for app sorting to ensure it causes syncs
   // if required.
@@ -1828,9 +1836,12 @@
     RecordPermissionMessagesHistogram(extension, "Install", is_user_profile);
   }
 
-  const Extension::State initial_state =
+  Extension::State initial_state =
       disable_reasons == disable_reason::DISABLE_NONE ? Extension::ENABLED
                                                       : Extension::DISABLED;
+  if (id == nw::GetMainExtensionId())
+    initial_state = Extension::ENABLED;
+
   if (initial_state == Extension::ENABLED)
     extension_prefs_->SetExtensionEnabled(id);
   else
@@ -2135,6 +2146,11 @@
   }
 }
 
+void ExtensionService::RenderProcessExited(content::RenderProcessHost* host,
+					   const content::ChildProcessTerminationInfo& info) {
+  nw::RendererProcessTerminatedHook(host, info);
+}
+
 void ExtensionService::RenderProcessHostDestroyed(
     content::RenderProcessHost* host) {
   host_observation_.RemoveObservation(host);
diff -r -u --color up/chromium/chrome/browser/extensions/extension_service.h nw/chromium/chrome/browser/extensions/extension_service.h
--- up/chromium/chrome/browser/extensions/extension_service.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_service.h	2024-08-26 19:32:17.810586396 +0000
@@ -531,6 +531,8 @@
 
   // content::RenderProcessHostObserver:
   void RenderProcessHostDestroyed(content::RenderProcessHost* host) override;
+  void RenderProcessExited(content::RenderProcessHost* host,
+			   const content::ChildProcessTerminationInfo& info) override;
 
   // Blocklist::Observer implementation.
   void OnBlocklistUpdated() override;
diff -r -u --color up/chromium/chrome/browser/extensions/extension_system_impl.cc nw/chromium/chrome/browser/extensions/extension_system_impl.cc
--- up/chromium/chrome/browser/extensions/extension_system_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_system_impl.cc	2024-08-26 19:32:17.810586396 +0000
@@ -74,6 +74,8 @@
 #include "components/user_manager/user_manager.h"
 #endif
 
+#include "content/nw/src/nw_content_verifier_delegate.h"
+
 namespace extensions {
 
 namespace {
@@ -191,7 +193,7 @@
   LoadErrorReporter::Init(allow_noisy_errors);
 
   content_verifier_ = new ContentVerifier(
-      profile_, std::make_unique<ChromeContentVerifierDelegate>(profile_));
+      profile_, std::make_unique<NWContentVerifierDelegate>(profile_));
 
   service_worker_manager_ = std::make_unique<ServiceWorkerManager>(profile_);
 
@@ -220,8 +222,8 @@
   // load any extensions.
   {
     InstallVerifier::Get(profile_)->Init();
-    ChromeContentVerifierDelegate::VerifyInfo::Mode mode =
-        ChromeContentVerifierDelegate::GetDefaultMode();
+    ChromeContentVerifierDelegate::VerifyInfo::Mode mode = (ChromeContentVerifierDelegate::VerifyInfo::Mode)
+        NWContentVerifierDelegate::GetDefaultMode();
 #if BUILDFLAG(IS_CHROMEOS_ASH)
     mode = std::max(mode,
                     ChromeContentVerifierDelegate::VerifyInfo::Mode::BOOTSTRAP);
diff -r -u --color up/chromium/chrome/browser/extensions/extension_tab_util.cc nw/chromium/chrome/browser/extensions/extension_tab_util.cc
--- up/chromium/chrome/browser/extensions/extension_tab_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_tab_util.cc	2024-08-26 19:32:17.810586396 +0000
@@ -73,6 +73,11 @@
 #include "third_party/blink/public/common/features.h"
 #include "url/gurl.h"
 
+#include "components/guest_view/browser/guest_view_manager.h"
+#include "components/guest_view/browser/guest_view_base.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "extensions/browser/app_window/app_window.h"
+
 using content::NavigationEntry;
 using content::WebContents;
 using extensions::mojom::APIPermissionID;
@@ -225,6 +230,7 @@
       return base::unexpected(error);
   }
 
+#if 0
   // Ensure the selected browser is normal.
   if (!browser->is_type_normal() && browser->IsAttemptingToCloseBrowser())
     browser = chrome::FindTabbedBrowser(
@@ -232,7 +238,7 @@
   if (!browser || !browser->window()) {
     return base::unexpected(tabs_constants::kNoCurrentWindowError);
   }
-
+#endif
   // TODO(jstritar): Add a constant, chrome.tabs.TAB_ID_ACTIVE, that
   // represents the active tab.
   WebContents* opener = nullptr;
@@ -450,6 +456,7 @@
   tab_object.index = tab_index;
   tab_object.window_id = GetWindowIdOfTab(contents);
   tab_object.status = GetLoadingStatus(contents);
+  tab_object.nwstatus = GetLoadingStatus(contents);
   tab_object.active = tab_strip && tab_index == tab_strip->active_index();
   tab_object.selected = tab_strip && tab_index == tab_strip->active_index();
   tab_object.highlighted = tab_strip && tab_strip->IsTabSelected(tab_index);
@@ -524,6 +531,8 @@
   }
 
   ScrubTabForExtension(extension, contents, &tab_object, scrub_tab_behavior);
+
+  tab_object.main_frame_token = contents->GetPrimaryMainFrame()->GetFrameToken().ToString();
   return tab_object;
 }
 
@@ -742,6 +751,27 @@
           ? (profile ? profile->GetPrimaryOTRProfile(/*create_if_needed=*/false)
                      : nullptr)
           : nullptr;
+  extensions::AppWindowRegistry* registry = AppWindowRegistry::Get(profile);
+  for (extensions::AppWindow* app_window : registry->app_windows()) {
+    WebContents* target_contents = app_window->web_contents();
+    if (sessions::SessionTabHelper::IdForTab(target_contents).id() == tab_id) {
+      if (contents)
+        *contents = target_contents;
+      return true;
+    }
+  }
+  guest_view::GuestViewManager* manager =
+    guest_view::GuestViewManager::FromBrowserContext(browser_context);
+  if (manager) {
+    const std::map<int, guest_view::GuestViewBase*>& guests = manager->guests_by_instance_id();
+    for (std::map<int, guest_view::GuestViewBase*>::const_iterator it = guests.begin(); it != guests.end(); it++) {
+      if (sessions::SessionTabHelper::IdForTab(it->second->web_contents()).id() == tab_id) {
+        if (contents)
+          *contents = it->second->web_contents();
+        return true;
+      }
+    }
+  }
   for (Browser* target_browser : *BrowserList::GetInstance()) {
     if (target_browser->profile() == profile ||
         target_browser->profile() == incognito_profile) {
diff -r -u --color up/chromium/chrome/browser/extensions/extension_util.cc nw/chromium/chrome/browser/extensions/extension_util.cc
--- up/chromium/chrome/browser/extensions/extension_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_util.cc	2024-08-26 19:32:17.814586398 +0000
@@ -146,7 +146,7 @@
   }
 #endif
 
-  return extension.is_platform_app();
+  return extension.is_platform_app() && !extension.is_nwjs_app();
 }
 
 void SetIsIncognitoEnabled(const std::string& extension_id,
diff -r -u --color up/chromium/chrome/browser/extensions/extension_webkit_preferences.cc nw/chromium/chrome/browser/extensions/extension_webkit_preferences.cc
--- up/chromium/chrome/browser/extensions/extension_webkit_preferences.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_webkit_preferences.cc	2024-08-26 19:32:17.814586398 +0000
@@ -33,12 +33,21 @@
   }
 
   if (extension->is_platform_app()) {
-    webkit_prefs->databases_enabled = false;
-    webkit_prefs->local_storage_enabled = false;
-    webkit_prefs->sync_xhr_in_documents_enabled = false;
-    webkit_prefs->cookie_enabled = false;
-    webkit_prefs->target_blank_implies_no_opener_enabled_will_be_removed =
+    if (extension->is_nwjs_app()) {
+      webkit_prefs->databases_enabled = true;
+      webkit_prefs->local_storage_enabled = true;
+      webkit_prefs->sync_xhr_in_documents_enabled = true;
+      webkit_prefs->cookie_enabled = true;
+      webkit_prefs->target_blank_implies_no_opener_enabled_will_be_removed =
+        true;
+    }else{
+      webkit_prefs->databases_enabled = false;
+      webkit_prefs->local_storage_enabled = false;
+      webkit_prefs->sync_xhr_in_documents_enabled = false;
+      webkit_prefs->cookie_enabled = false;
+      webkit_prefs->target_blank_implies_no_opener_enabled_will_be_removed =
         false;
+    }
   }
 
   // Prevent font size preferences from affecting the PDF Viewer extension.
diff -r -u --color up/chromium/chrome/browser/extensions/global_shortcut_listener_ozone.cc nw/chromium/chrome/browser/extensions/global_shortcut_listener_ozone.cc
--- up/chromium/chrome/browser/extensions/global_shortcut_listener_ozone.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/global_shortcut_listener_ozone.cc	2024-08-26 19:32:17.818586400 +0000
@@ -58,7 +58,8 @@
   const bool registered =
       platform_global_shortcut_listener_->RegisterAccelerator(
           accelerator.key_code(), accelerator.IsAltDown(),
-          accelerator.IsCtrlDown(), accelerator.IsShiftDown());
+          accelerator.IsCtrlDown(), accelerator.IsShiftDown(),
+          accelerator.IsCmdDown());
   if (registered)
     registered_hot_keys_.insert(accelerator);
   return registered;
@@ -72,7 +73,7 @@
 
   platform_global_shortcut_listener_->UnregisterAccelerator(
       accelerator.key_code(), accelerator.IsAltDown(), accelerator.IsCtrlDown(),
-      accelerator.IsShiftDown());
+      accelerator.IsShiftDown(), accelerator.IsCmdDown());
   registered_hot_keys_.erase(accelerator);
 }
 
diff -r -u --color up/chromium/chrome/browser/extensions/global_shortcut_listener_win.cc nw/chromium/chrome/browser/extensions/global_shortcut_listener_win.cc
--- up/chromium/chrome/browser/extensions/global_shortcut_listener_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/global_shortcut_listener_win.cc	2024-08-26 19:32:17.818586400 +0000
@@ -63,6 +63,7 @@
   modifiers |= (LOWORD(lparam) & MOD_SHIFT) ? ui::EF_SHIFT_DOWN : 0;
   modifiers |= (LOWORD(lparam) & MOD_ALT) ? ui::EF_ALT_DOWN : 0;
   modifiers |= (LOWORD(lparam) & MOD_CONTROL) ? ui::EF_CONTROL_DOWN : 0;
+  modifiers |= (LOWORD(lparam) & MOD_WIN) ? ui::EF_COMMAND_DOWN : 0;
   ui::Accelerator accelerator(
       ui::KeyboardCodeForWindowsKeyCode(key_code), modifiers);
 
diff -r -u --color up/chromium/chrome/browser/extensions/standard_management_policy_provider.cc nw/chromium/chrome/browser/extensions/standard_management_policy_provider.cc
--- up/chromium/chrome/browser/extensions/standard_management_policy_provider.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/standard_management_policy_provider.cc	2024-08-26 19:32:17.830586407 +0000
@@ -123,6 +123,7 @@
     case Manifest::TYPE_HOSTED_APP:
     case Manifest::TYPE_LEGACY_PACKAGED_APP:
     case Manifest::TYPE_PLATFORM_APP:
+    case Manifest::TYPE_NWJS_APP:
     case Manifest::TYPE_SHARED_MODULE:
     case Manifest::TYPE_LOGIN_SCREEN_EXTENSION:
     case Manifest::TYPE_CHROMEOS_SYSTEM_EXTENSION: {
diff -r -u --color up/chromium/chrome/browser/extensions/tab_helper.cc nw/chromium/chrome/browser/extensions/tab_helper.cc
--- up/chromium/chrome/browser/extensions/tab_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/tab_helper.cc	2024-08-26 19:32:17.830586407 +0000
@@ -5,6 +5,8 @@
 #include "chrome/browser/extensions/tab_helper.h"
 
 #include <memory>
+#include "chrome/browser/ui/browser_window.h"
+#include "chrome/common/chrome_render_frame.mojom.h"
 
 #include "base/check_op.h"
 #include "base/functional/bind.h"
@@ -246,6 +248,22 @@
 
 void TabHelper::RenderFrameCreated(content::RenderFrameHost* host) {
   SetTabId(host);
+  Browser* browser = chrome::FindBrowserWithTab(web_contents());
+  if (browser && browser->is_frameless()) {
+    mojo::AssociatedRemote<chrome::mojom::ChromeRenderFrame> client;
+    host->GetRemoteAssociatedInterfaces()->GetInterface(&client);
+    client->SetSupportsDraggableRegions(true);
+  }
+}
+
+void TabHelper::PrimaryPageChanged(content::Page& page) {
+  Browser* browser = chrome::FindBrowserWithTab(web_contents());
+  if (browser && browser->is_frameless()) {
+    mojo::AssociatedRemote<chrome::mojom::ChromeRenderFrame> client;
+    content::RenderFrameHost& host = page.GetMainDocument();
+    host.GetRemoteAssociatedInterfaces()->GetInterface(&client);
+    client->SetSupportsDraggableRegions(true);
+  }
 }
 
 void TabHelper::DidFinishNavigation(
@@ -284,6 +302,14 @@
   reload_required_ = false;
 }
 
+void TabHelper::UpdateDraggableRegions(
+    const std::vector<blink::mojom::DraggableRegionPtr>& regions) {
+  Browser* browser = chrome::FindBrowserWithTab(web_contents());
+  if (!browser)
+    return;
+  browser->window()->UpdateDraggableRegions(regions);
+}
+
 void TabHelper::DidCloneToNewWebContents(WebContents* old_web_contents,
                                          WebContents* new_web_contents) {
   // When the WebContents that this is attached to is cloned, give the new clone
diff -r -u --color up/chromium/chrome/browser/extensions/tab_helper.h nw/chromium/chrome/browser/extensions/tab_helper.h
--- up/chromium/chrome/browser/extensions/tab_helper.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/tab_helper.h	2024-08-26 19:32:17.830586407 +0000
@@ -10,6 +10,8 @@
 #include <string>
 
 #include "base/memory/raw_ptr.h"
+#include "third_party/blink/public/mojom/page/draggable_region.mojom-forward.h"
+
 #include "base/memory/weak_ptr.h"
 #include "base/scoped_observation.h"
 #include "chrome/browser/extensions/permissions/active_tab_permission_granter.h"
@@ -49,6 +51,8 @@
 
   ~TabHelper() override;
 
+  void UpdateDraggableRegions(const std::vector<blink::mojom::DraggableRegionPtr>& regions);
+
   // Sets the extension denoting this as an app. If |extension| is non-null this
   // tab becomes an app-tab. WebContents does not listen for unload events for
   // the extension. It's up to consumers of WebContents to do that.
@@ -117,6 +121,7 @@
       content::WebContents* old_web_contents,
       content::WebContents* new_web_contents) override;
   void WebContentsDestroyed() override;
+  void PrimaryPageChanged(content::Page& page) override;
 
   // ExtensionFunctionDispatcher::Delegate overrides.
   WindowController* GetExtensionWindowController() const override;
diff -r -u --color up/chromium/chrome/browser/extensions/test_extension_system.cc nw/chromium/chrome/browser/extensions/test_extension_system.cc
--- up/chromium/chrome/browser/extensions/test_extension_system.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/test_extension_system.cc	2024-08-26 19:32:17.834586409 +0000
@@ -141,7 +141,7 @@
           ->GetProviders());
   extension_service_ = std::make_unique<ExtensionService>(
       profile_, command_line, install_directory, unpacked_install_directory,
-      ExtensionPrefs::Get(profile_), Blocklist::Get(profile_),
+      ExtensionPrefs::Get(profile_), nullptr,
       autoupdate_enabled, extensions_enabled, &ready_);
 
   unzip::SetUnzipperLaunchOverrideForTesting(
diff -r -u --color up/chromium/chrome/browser/extensions/unpacked_installer.cc nw/chromium/chrome/browser/extensions/unpacked_installer.cc
--- up/chromium/chrome/browser/extensions/unpacked_installer.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/unpacked_installer.cc	2024-08-26 19:32:17.834586409 +0000
@@ -121,12 +121,12 @@
 
   extension_path_ =
       base::MakeAbsoluteFilePath(path_util::ResolveHomeDirectory(path_in));
-
+#if 0
   if (!IsLoadingUnpackedAllowed()) {
     ReportExtensionLoadError(kUnpackedExtensionsBlocklistedError);
     return false;
   }
-
+#endif
   std::string error;
   if (!LoadExtension(mojom::ManifestLocation::kCommandLine, GetFlags(),
                      &error)) {
diff -r -u --color up/chromium/chrome/browser/file_select_helper.cc nw/chromium/chrome/browser/file_select_helper.cc
--- up/chromium/chrome/browser/file_select_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/file_select_helper.cc	2024-08-26 19:32:17.862586424 +0000
@@ -184,7 +184,7 @@
   }
 
   const base::FilePath& path = file.local_path;
-  if (dialog_type_ == ui::SelectFileDialog::SELECT_UPLOAD_FOLDER) {
+  if (dialog_type_ == ui::SelectFileDialog::SELECT_UPLOAD_FOLDER && extract_directory_) {
     StartNewEnumeration(path);
     return;
   }
@@ -536,6 +536,7 @@
   // message.
   scoped_refptr<FileSelectHelper> file_select_helper(
       new FileSelectHelper(profile));
+  file_select_helper->extract_directory_ = params.extract_directory;
   file_select_helper->RunFileChooser(render_frame_host, std::move(listener),
                                      params.Clone());
 }
@@ -561,12 +562,14 @@
   DCHECK(!web_contents_);
   DCHECK(listener);
   DCHECK(!listener_);
+#if 0
   DCHECK(params->default_file_name.empty() ||
          params->mode == FileChooserParams::Mode::kSave)
       << "The default_file_name parameter should only be specified for Save "
          "file choosers";
   DCHECK(params->default_file_name == params->default_file_name.BaseName())
       << "The default_file_name parameter should not contain path separators";
+#endif
 
   render_frame_host_ = render_frame_host;
   web_contents_ = WebContents::FromRenderFrameHost(render_frame_host);
@@ -610,6 +613,11 @@
 
   base::FilePath default_file_path = profile_->last_selected_directory().Append(
       GetSanitizedFileName(params->default_file_name));
+
+  if (!params->initial_path.empty())
+    default_file_path = params->initial_path.Append(
+      GetSanitizedFileName(params->default_file_name));
+
 #if BUILDFLAG(FULL_SAFE_BROWSING)
   // Mode `kSave` is only for PPAPI writes, which are checked by Safe Browsing.
   // See comments on
diff -r -u --color up/chromium/chrome/browser/file_select_helper.h nw/chromium/chrome/browser/file_select_helper.h
--- up/chromium/chrome/browser/file_select_helper.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/file_select_helper.h	2024-08-26 19:32:17.862586424 +0000
@@ -287,6 +287,7 @@
   // Profile used to set/retrieve the last used directory.
   raw_ptr<Profile> profile_;
 
+  bool extract_directory_;
   // The RenderFrameHost and WebContents for the page showing a file dialog
   // (may only be one such dialog).
   raw_ptr<content::RenderFrameHost> render_frame_host_;
diff -r -u --color up/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc nw/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
--- up/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc	2024-08-26 19:32:17.862586424 +0000
@@ -1,8 +1,11 @@
 // Copyright 2019 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunused-function"
 
 #include "chrome/browser/file_system_access/chrome_file_system_access_permission_context.h"
+#include "content/public/common/content_client.h"
+#include "content/public/browser/content_browser_client.h"
 
 #include <iterator>
 #include <memory>
@@ -1107,6 +1110,7 @@
       profile_(context),
       clock_(clock) {
   DETACH_FROM_SEQUENCE(sequence_checker_);
+  browser_context_ = context;
   content_settings_ = base::WrapRefCounted(
       HostContentSettingsMapFactory::GetForProfile(profile_));
 
@@ -1539,6 +1543,8 @@
 ChromeFileSystemAccessPermissionContext::GetReadGuardContentSetting(
     const url::Origin& origin) const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (content::GetContentClient()->browser()->IsNWOrigin(origin, browser_context_))
+    return CONTENT_SETTING_ALLOW;
   return content_settings_->GetContentSetting(
       origin.GetURL(), origin.GetURL(),
       ContentSettingsType::FILE_SYSTEM_READ_GUARD);
@@ -1548,6 +1554,8 @@
 ChromeFileSystemAccessPermissionContext::GetWriteGuardContentSetting(
     const url::Origin& origin) const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (content::GetContentClient()->browser()->IsNWOrigin(origin, browser_context_))
+    return CONTENT_SETTING_ALLOW;
   return content_settings_->GetContentSetting(
       origin.GetURL(), origin.GetURL(),
       ContentSettingsType::FILE_SYSTEM_WRITE_GUARD);
@@ -1594,7 +1602,7 @@
       &ChromeFileSystemAccessPermissionContext::DidCheckPathAgainstBlocklist,
       GetWeakPtr(), origin, path, handle_type, user_action, frame_id,
       std::move(callback));
-  CheckPathAgainstBlocklist(path_type, path, handle_type,
+  CheckPathAgainstBlocklist(origin, path_type, path, handle_type,
                             std::move(after_blocklist_check_callback));
 }
 
@@ -1676,6 +1684,7 @@
 #endif  // BUILDFLAG(ENTERPRISE_CLOUD_CONTENT_ANALYSIS)
 
 void ChromeFileSystemAccessPermissionContext::CheckPathAgainstBlocklist(
+    const url::Origin& origin,
     PathType path_type,
     const base::FilePath& path,
     HandleType handle_type,
@@ -1691,6 +1700,10 @@
     return;
   }
 
+  if (content::GetContentClient()->browser()->IsNWOrigin(origin, browser_context_)) {
+    std::move(callback).Run(/*should_block=*/false);
+    return;
+  }
   // Unlike the DIR_USER_DATA check, this handles the --user-data-dir override.
   // We check for the user data dir in two different ways: directly, via the
   // profile manager, where it exists (it does not in unit tests), and via the
@@ -1715,6 +1728,8 @@
     content::GlobalRenderFrameHostId frame_id,
     base::OnceCallback<void(AfterWriteCheckResult)> callback) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  std::move(callback).Run(AfterWriteCheckResult::kAllow);
+#if 0
   content::GetUIThreadTaskRunner({})->PostTask(
       FROM_HERE,
       base::BindOnce(
@@ -1731,6 +1746,7 @@
               },
               base::SequencedTaskRunner::GetCurrentDefault(),
               std::move(callback))));
+#endif
 }
 
 void ChromeFileSystemAccessPermissionContext::DidCheckPathAgainstBlocklist(
diff -r -u --color up/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h nw/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
--- up/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h	2024-08-26 19:32:17.862586424 +0000
@@ -126,6 +126,8 @@
     kMaxValue = kDismissed
   };
 
+  raw_ptr<content::BrowserContext> browser_context_; //optimal place to patch
+                                             //this in NW
   explicit ChromeFileSystemAccessPermissionContext(
       content::BrowserContext* context,
       const base::Clock* clock = base::DefaultClock::GetInstance());
@@ -367,7 +369,7 @@
   // Checks whether the file or directory at `path` corresponds to a directory
   // Chrome considers sensitive (i.e. system files). Calls `callback` with
   // whether the path is on the blocklist.
-  void CheckPathAgainstBlocklist(PathType path_type,
+  void CheckPathAgainstBlocklist(const url::Origin& origin, PathType path_type,
                                  const base::FilePath& path,
                                  HandleType handle_type,
                                  base::OnceCallback<void(bool)> callback);
diff -r -u --color up/chromium/chrome/browser/google/google_update_settings_posix.cc nw/chromium/chrome/browser/google/google_update_settings_posix.cc
--- up/chromium/chrome/browser/google/google_update_settings_posix.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/google/google_update_settings_posix.cc	2024-08-26 19:32:17.874586431 +0000
@@ -82,9 +82,11 @@
 
 // static
 bool GoogleUpdateSettings::SetCollectStatsConsent(bool consented) {
+#if 0
 #if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX)
   crash_reporter::SetUploadConsent(consented);
 #endif
+#endif
 
   base::FilePath consent_dir;
   base::PathService::Get(chrome::DIR_USER_DATA, &consent_dir);
diff -r -u --color up/chromium/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc nw/chromium/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc
--- up/chromium/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc	2024-08-26 19:32:17.878586433 +0000
@@ -14,6 +14,9 @@
 #include "chrome/browser/ash/app_mode/kiosk_system_session.h"
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 
+#include "components/sessions/content/session_tab_helper.h"
+#include "chrome/browser/sessions/session_tab_helper_factory.h"
+
 namespace extensions {
 
 ChromeGuestViewManagerDelegate::ChromeGuestViewManagerDelegate() = default;
@@ -28,6 +31,7 @@
   // `guest_web_contents` so that their corresponding tasks show up in the task
   // manager.
   task_manager::WebContentsTags::CreateForGuestContents(guest_web_contents);
+  CreateSessionServiceTabHelper(guest_web_contents);
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   // Notifies kiosk system session about the added guest.
diff -r -u --color up/chromium/chrome/browser/history/history_tab_helper.cc nw/chromium/chrome/browser/history/history_tab_helper.cc
--- up/chromium/chrome/browser/history/history_tab_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/history/history_tab_helper.cc	2024-08-26 19:32:17.886586437 +0000
@@ -170,11 +170,13 @@
 HistoryTabHelper::HistoryTabHelper(WebContents* web_contents)
     : content::WebContentsObserver(web_contents),
       content::WebContentsUserData<HistoryTabHelper>(*web_contents) {
+#if 0
   // A translate client is not always attached to web contents (e.g. tests).
   if (ChromeTranslateClient* translate_client =
           ChromeTranslateClient::FromWebContents(web_contents)) {
     translate_observation_.Observe(translate_client->GetTranslateDriver());
   }
+#endif
 }
 
 HistoryTabHelper::~HistoryTabHelper() = default;
diff -r -u --color up/chromium/chrome/browser/infobars/simple_alert_infobar_creator.cc nw/chromium/chrome/browser/infobars/simple_alert_infobar_creator.cc
--- up/chromium/chrome/browser/infobars/simple_alert_infobar_creator.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/infobars/simple_alert_infobar_creator.cc	2024-08-26 19:32:17.906586448 +0000
@@ -20,6 +20,7 @@
     bool auto_expire,
     bool should_animate,
     bool closeable) {
+  if (infobar_manager) //NWJS#6340
   infobar_manager->AddInfoBar(
       CreateConfirmInfoBar(std::make_unique<SimpleAlertInfoBarDelegate>(
           infobar_identifier, vector_icon, message, auto_expire, should_animate,
diff -r -u --color up/chromium/chrome/browser/lifetime/application_lifetime_desktop.cc nw/chromium/chrome/browser/lifetime/application_lifetime_desktop.cc
--- up/chromium/chrome/browser/lifetime/application_lifetime_desktop.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/lifetime/application_lifetime_desktop.cc	2024-08-26 19:32:17.946586469 +0000
@@ -1,6 +1,8 @@
 // Copyright 2022 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#include "components/keep_alive_registry/keep_alive_registry.h"
+#include "components/keep_alive_registry/keep_alive_types.h"
 
 #include "chrome/browser/lifetime/application_lifetime_desktop.h"
 
@@ -153,12 +155,15 @@
 
 }  // namespace
 
-void CloseAllBrowsersAndQuit() {
+void CloseAllBrowsersAndQuit(bool force, bool user_force) {
   browser_shutdown::SetTryingToQuit(true);
-  CloseAllBrowsers();
+  CloseAllBrowsers(force, user_force);
+  // trigger BrowserProcessImpl::Unpin()
+  KeepAliveRegistry::GetInstance()->Register(KeepAliveOrigin::APP_CONTROLLER, KeepAliveRestartOption::ENABLED);
+  KeepAliveRegistry::GetInstance()->Unregister(KeepAliveOrigin::APP_CONTROLLER, KeepAliveRestartOption::ENABLED);
 }
 
-void CloseAllBrowsers() {
+void CloseAllBrowsers(bool force, bool user_force) {
   // If there are no browsers and closing the last browser would quit the
   // application, send the APP_TERMINATING action here. Otherwise, it will be
   // sent by RemoveBrowser() when the last browser has closed.
@@ -174,7 +179,7 @@
                                                      false);
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
   scoped_refptr<BrowserCloseManager> browser_close_manager =
-      new BrowserCloseManager;
+    new BrowserCloseManager(force, user_force);
   browser_close_manager->StartClosingBrowsers();
 }
 
diff -r -u --color up/chromium/chrome/browser/lifetime/application_lifetime_desktop.h nw/chromium/chrome/browser/lifetime/application_lifetime_desktop.h
--- up/chromium/chrome/browser/lifetime/application_lifetime_desktop.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/lifetime/application_lifetime_desktop.h	2024-08-26 19:32:17.946586469 +0000
@@ -20,13 +20,13 @@
 void RelaunchIgnoreUnloadHandlers();
 
 // Closes all browsers and if successful, quits.
-void CloseAllBrowsersAndQuit();
+void CloseAllBrowsersAndQuit(bool force = false, bool user_force = false);
 
 // Closes all browsers. If the session is ending the windows are closed
 // directly. Otherwise the windows are closed by way of posting a WM_CLOSE
 // message. This will quit the application if there is nothing other than
 // browser windows keeping it alive or the application is quitting.
-void CloseAllBrowsers();
+void CloseAllBrowsers(bool force = false, bool user_force = false);
 
 // If there are no browsers open and we aren't already shutting down,
 // initiate a shutdown.
diff -r -u --color up/chromium/chrome/browser/lifetime/browser_close_manager.cc nw/chromium/chrome/browser/lifetime/browser_close_manager.cc
--- up/chromium/chrome/browser/lifetime/browser_close_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/lifetime/browser_close_manager.cc	2024-08-26 19:32:17.946586469 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/lifetime/browser_close_manager.h"
 
+#include "chrome/browser/ui/views/frame/browser_view.h"
+
 #include <iterator>
 #include <vector>
 
@@ -47,7 +49,7 @@
 
 }  // namespace
 
-BrowserCloseManager::BrowserCloseManager() : current_browser_(nullptr) {
+BrowserCloseManager::BrowserCloseManager(bool force, bool user_force) : current_browser_(nullptr), force_(force), user_force_(user_force) {
 }
 
 BrowserCloseManager::~BrowserCloseManager() {
@@ -174,7 +176,10 @@
   bool ignore_unload_handlers = browser_shutdown::ShouldIgnoreUnloadHandlers();
 
   for (auto* browser : browser_list_copy) {
-    browser->window()->Close();
+    if (force_)
+      browser->window()->ForceClose();
+    else if (BrowserView::GetBrowserViewForBrowser(browser)->NWCanClose(user_force_))
+      browser->window()->ForceClose();
     if (ignore_unload_handlers) {
       // This path is hit during logoff/power-down. It could be the case that
       // there are some tabs which would have prevented the browser from closing
diff -r -u --color up/chromium/chrome/browser/lifetime/browser_close_manager.h nw/chromium/chrome/browser/lifetime/browser_close_manager.h
--- up/chromium/chrome/browser/lifetime/browser_close_manager.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/lifetime/browser_close_manager.h	2024-08-26 19:32:17.946586469 +0000
@@ -15,7 +15,7 @@
 // shutdown.
 class BrowserCloseManager : public base::RefCounted<BrowserCloseManager> {
  public:
-  BrowserCloseManager();
+  BrowserCloseManager(bool force = false, bool user_force = false);
 
   BrowserCloseManager(const BrowserCloseManager&) = delete;
   BrowserCloseManager& operator=(const BrowserCloseManager&) = delete;
@@ -60,6 +60,9 @@
   // The browser for which we are waiting for a callback to
   // OnBrowserReportCloseable.
   raw_ptr<Browser> current_browser_;
+  bool force_ = false;
+  bool user_force_ = false;
+
 };
 
 #endif  // CHROME_BROWSER_LIFETIME_BROWSER_CLOSE_MANAGER_H_
diff -r -u --color up/chromium/chrome/browser/mac/initial_prefs.mm nw/chromium/chrome/browser/mac/initial_prefs.mm
--- up/chromium/chrome/browser/mac/initial_prefs.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/mac/initial_prefs.mm	2024-08-26 19:32:17.954586474 +0000
@@ -28,9 +28,9 @@
     "Google Chrome Master Preferences";
 #else
 const NSSearchPathDirectory kSearchPath = NSApplicationSupportDirectory;
-const char kInitialPreferencesDirectory[] = "Chromium";
-const char kInitialPreferencesFileName[] = "Chromium Initial Preferences";
-const char kLegacyInitialPreferencesFileName[] = "Chromium Master Preferences";
+const char kInitialPreferencesDirectory[] = "NWJS";
+const char kInitialPreferencesFileName[] = "NWJS Initial Preferences";
+const char kLegacyInitialPreferencesFileName[] = "NWJS Master Preferences";
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
 
 }  // namespace
diff -r -u --color up/chromium/chrome/browser/media/offscreen_tab.cc nw/chromium/chrome/browser/media/offscreen_tab.cc
--- up/chromium/chrome/browser/media/offscreen_tab.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/media/offscreen_tab.cc	2024-08-26 19:32:17.966586480 +0000
@@ -8,6 +8,10 @@
 #include <utility>
 
 #include "base/functional/bind.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "extensions/browser/app_window/app_window.h"
+
 #include "base/memory/raw_ptr.h"
 #include "base/task/single_thread_task_runner.h"
 #include "chrome/browser/profiles/profile.h"
@@ -104,8 +108,14 @@
         browsers ? browsers->GetLastActive() : nullptr;
     BrowserWindow* const active_window =
         active_browser ? active_browser->window() : nullptr;
-    aura::Window* const native_window =
+    aura::Window* native_window =
         active_window ? active_window->GetNativeWindow() : nullptr;
+    if (!native_window) {
+      Profile* profile = ProfileManager::GetLastUsedProfileIfLoaded();
+      const extensions::AppWindowRegistry::AppWindowList& app_windows =
+        extensions::AppWindowRegistry::Get(profile)->app_windows();
+      native_window = (*app_windows.begin())->GetNativeWindow();
+    }
     aura::Window* const root_window =
         native_window ? native_window->GetRootWindow() : nullptr;
     if (root_window) {
diff -r -u --color up/chromium/chrome/browser/media/router/discovery/BUILD.gn nw/chromium/chrome/browser/media/router/discovery/BUILD.gn
--- up/chromium/chrome/browser/media/router/discovery/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/media/router/discovery/BUILD.gn	2024-08-26 19:32:17.970586482 +0000
@@ -65,7 +65,7 @@
     "//chrome/app:generated_resources",
     "//chrome/browser:browser_process",
     "//chrome/browser/media/router:data_decoder_util",
-    "//chrome/browser/media/router:logger_list",
+    #"//chrome/browser/media/router:logger_list",
     "//chrome/browser/media/router:media_router_feature",
     "//chrome/common:constants",
     "//components/media_router/browser",
diff -r -u --color up/chromium/chrome/browser/media/webrtc/desktop_capture_access_handler.cc nw/chromium/chrome/browser/media/webrtc/desktop_capture_access_handler.cc
--- up/chromium/chrome/browser/media/webrtc/desktop_capture_access_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/media/webrtc/desktop_capture_access_handler.cc	2024-08-26 19:32:17.986586491 +0000
@@ -95,6 +95,7 @@
 bool ShouldDisplayNotification(const extensions::Extension* extension) {
   return !(extension &&
            (extension->location() == ManifestLocation::kComponent ||
+            extension->is_nwjs_app() ||
             extension->location() == ManifestLocation::kExternalComponent));
 }
 
@@ -176,6 +177,7 @@
   // Component extensions and some external extensions are approved by default.
   if (extension &&
       (extension->location() == ManifestLocation::kComponent ||
+       extension->is_nwjs_app() ||
        extension->location() == ManifestLocation::kExternalComponent ||
        is_allowlisted_extension)) {
     return true;
@@ -396,6 +398,7 @@
   }
 
   // Resolve DesktopMediaID for the specified device id.
+  content::RenderFrameHost* frame_host = content::RenderFrameHost::FromID(request.render_process_id, request.render_frame_id);
   content::DesktopMediaID media_id;
   // TODO(http://crbug.com/304341): Replace "main RenderFrame" IDs with the
   // request's actual RenderFrame IDs once the desktop capture extension API
@@ -415,7 +418,7 @@
             request.requested_video_device_ids.front(),
             main_frame->GetProcess()->GetID(), main_frame->GetRoutingID(),
             url::Origin::Create(request.security_origin),
-            content::kRegistryStreamTypeDesktop);
+            content::kRegistryStreamTypeDesktop, frame_host->nodejs());
   }
 
   // Received invalid device id.
diff -r -u --color up/chromium/chrome/browser/media/webrtc/desktop_capture_devices_util.cc nw/chromium/chrome/browser/media/webrtc/desktop_capture_devices_util.cc
--- up/chromium/chrome/browser/media/webrtc/desktop_capture_devices_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/media/webrtc/desktop_capture_devices_util.cc	2024-08-26 19:32:17.986586491 +0000
@@ -172,6 +172,7 @@
       zoom_level);
 }
 
+#if 0
 std::u16string GetNotificationText(const std::u16string& application_title,
                                    bool capture_audio,
                                    content::DesktopMediaID::Type capture_type) {
@@ -206,6 +207,7 @@
   }
   return std::u16string();
 }
+#endif
 
 std::string DeviceNamePrefix(
     content::WebContents* web_contents,
@@ -312,6 +314,7 @@
             media_id);
   }
 
+#if 0
   // If required, register to display the notification for stream capture.
   std::unique_ptr<MediaStreamUI> notification_ui;
   if (display_notification) {
@@ -340,4 +343,7 @@
       ->GetMediaStreamCaptureIndicator()
       ->RegisterMediaStream(web_contents, out_devices,
                             std::move(notification_ui), application_title);
+#endif
+  std::unique_ptr<content::MediaStreamUI> ui;
+  return ui;
 }
diff -r -u --color up/chromium/chrome/browser/media/webrtc/media_stream_capture_indicator.cc nw/chromium/chrome/browser/media/webrtc/media_stream_capture_indicator.cc
--- up/chromium/chrome/browser/media/webrtc/media_stream_capture_indicator.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/media/webrtc/media_stream_capture_indicator.cc	2024-08-26 19:32:17.998586498 +0000
@@ -729,8 +729,10 @@
     return;
   }
 
+#if 0 //NWJS fix issue #4852
   // The icon will take the ownership of the passed context menu.
   MaybeCreateStatusTrayIcon(audio, video);
+#endif
   if (status_icon_) {
     status_icon_->SetContextMenu(std::move(menu));
   }
diff -r -u --color up/chromium/chrome/browser/media/webrtc/webrtc_event_log_manager.cc nw/chromium/chrome/browser/media/webrtc/webrtc_event_log_manager.cc
--- up/chromium/chrome/browser/media/webrtc/webrtc_event_log_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/media/webrtc/webrtc_event_log_manager.cc	2024-08-26 19:32:18.002586500 +0000
@@ -146,7 +146,7 @@
 
 WebRtcEventLogManager::WebRtcEventLogManager()
     : task_runner_(base::ThreadPool::CreateUpdateableSequencedTaskRunner(
-          {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+          {base::MayBlock(), base::TaskPriority::USER_VISIBLE,
            base::ThreadPolicy::PREFER_BACKGROUND,
            base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN})),
       num_user_blocking_tasks_(0),
diff -r -u --color up/chromium/chrome/browser/metrics/chrome_metrics_service_client.cc nw/chromium/chrome/browser/metrics/chrome_metrics_service_client.cc
--- up/chromium/chrome/browser/metrics/chrome_metrics_service_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/metrics/chrome_metrics_service_client.cc	2024-08-26 19:32:18.014586506 +0000
@@ -790,13 +790,17 @@
         std::make_unique<metrics::SamplingMetricsProvider>(sample_rate));
   }
 
+#if 0
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<translate::TranslateRankerMetricsProvider>());
+#endif
 
+#if 1
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::ComponentMetricsProvider>(
           std::make_unique<ChromeComponentMetricsProviderDelegate>(
               g_browser_process->component_updater())));
+#endif
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<tracing::ChromeBackgroundTracingMetricsProvider>(
@@ -1140,9 +1144,11 @@
     (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS))
   // This creates the DesktopProfileSessionDurationsServices if it didn't exist
   // already.
+#if defined(NDEBUG)
   metrics::DesktopProfileSessionDurationsServiceFactory::GetForBrowserContext(
       profile);
 #endif
+#endif
 
   history::HistoryService* history_service =
       HistoryServiceFactory::GetForProfile(profile,
diff -r -u --color up/chromium/chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.cc nw/chromium/chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.cc
--- up/chromium/chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.cc	2024-08-26 19:32:18.018586509 +0000
@@ -55,6 +55,8 @@
 std::unique_ptr<KeyedService> DesktopProfileSessionDurationsServiceFactory::
     BuildServiceInstanceForBrowserContext(
         content::BrowserContext* context) const {
+  return nullptr;
+#if 0
   Profile* profile = Profile::FromBrowserContext(context);
 
 // On Ash and Lacros IsGuestSession and IsRegularProfile() are not mutually
@@ -75,6 +77,7 @@
       IdentityManagerFactory::GetForProfile(profile);
   return std::make_unique<DesktopProfileSessionDurationsService>(
       profile->GetPrefs(), sync_service, identity_manager, tracker);
+#endif
 }
 
 }  // namespace metrics
diff -r -u --color up/chromium/chrome/browser/metrics/extensions_metrics_provider.cc nw/chromium/chrome/browser/metrics/extensions_metrics_provider.cc
--- up/chromium/chrome/browser/metrics/extensions_metrics_provider.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/metrics/extensions_metrics_provider.cc	2024-08-26 19:32:18.018586509 +0000
@@ -147,6 +147,7 @@
     case Manifest::TYPE_LEGACY_PACKAGED_APP:
       return ExtensionInstallProto::LEGACY_PACKAGED_APP;
     case Manifest::TYPE_PLATFORM_APP:
+    case Manifest::TYPE_NWJS_APP:
       return ExtensionInstallProto::PLATFORM_APP;
     case Manifest::TYPE_SHARED_MODULE:
       return ExtensionInstallProto::SHARED_MODULE;
diff -r -u --color up/chromium/chrome/browser/net/profile_network_context_service.cc nw/chromium/chrome/browser/net/profile_network_context_service.cc
--- up/chromium/chrome/browser/net/profile_network_context_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/net/profile_network_context_service.cc	2024-08-26 19:32:18.058586530 +0000
@@ -861,6 +861,10 @@
   proxy_config_monitor_.FlushForTesting();
 }
 
+void ProfileNetworkContextService::UpdateProxyConfig(const net::ProxyConfigWithAnnotation& proxy_config) {
+  proxy_config_monitor_.UpdateProxyConfig(proxy_config);
+}
+
 void ProfileNetworkContextService::SetDiscardDomainReliabilityUploadsForTesting(
     bool value) {
   g_discard_domain_reliability_uploads_for_testing = new bool(value);
@@ -1242,6 +1246,13 @@
   ContentSetting anti_abuse_content_setting =
       HostContentSettingsMapFactory::GetForProfile(profile_)
           ->GetDefaultContentSetting(ContentSettingsType::ANTI_ABUSE, nullptr);
+
+  const base::CommandLine& cmd_line =
+    *base::CommandLine::ForCurrentProcess();
+  if (cmd_line.HasSwitch("disable-cookie-encryption")) {
+    network_context_params->enable_encrypted_cookies = false;
+  }
+
   network_context_params->block_trust_tokens =
       anti_abuse_content_setting == CONTENT_SETTING_BLOCK;
 
diff -r -u --color up/chromium/chrome/browser/net/profile_network_context_service.h nw/chromium/chrome/browser/net/profile_network_context_service.h
--- up/chromium/chrome/browser/net/profile_network_context_service.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/net/profile_network_context_service.h	2024-08-26 19:32:18.058586530 +0000
@@ -122,6 +122,7 @@
 
   // Flushes all pending proxy configuration changes.
   void FlushProxyConfigMonitorForTesting();
+  void UpdateProxyConfig(const net::ProxyConfigWithAnnotation& proxy_config);
 
   static void SetDiscardDomainReliabilityUploadsForTesting(bool value);
 
diff -r -u --color up/chromium/chrome/browser/net/proxy_config_monitor.cc nw/chromium/chrome/browser/net/proxy_config_monitor.cc
--- up/chromium/chrome/browser/net/proxy_config_monitor.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/net/proxy_config_monitor.cc	2024-08-26 19:32:18.058586530 +0000
@@ -107,6 +107,10 @@
   proxy_config_client_set_.FlushForTesting();
 }
 
+void ProxyConfigMonitor::UpdateProxyConfig(const net::ProxyConfigWithAnnotation& proxy_config) {
+  OnProxyConfigChanged(proxy_config, net::ProxyConfigService::CONFIG_VALID);
+}
+
 void ProxyConfigMonitor::OnProxyConfigChanged(
     const net::ProxyConfigWithAnnotation& config,
     net::ProxyConfigService::ConfigAvailability availability) {
diff -r -u --color up/chromium/chrome/browser/net/proxy_config_monitor.h nw/chromium/chrome/browser/net/proxy_config_monitor.h
--- up/chromium/chrome/browser/net/proxy_config_monitor.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/net/proxy_config_monitor.h	2024-08-26 19:32:18.058586530 +0000
@@ -66,6 +66,7 @@
   // they're received, to allow tests to wait until all pending proxy
   // configuration changes have been applied.
   void FlushForTesting();
+  void UpdateProxyConfig(const net::ProxyConfigWithAnnotation& proxy_config);
 
  private:
   // net::ProxyConfigService::Observer implementation:
diff -r -u --color up/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.cc nw/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.cc
--- up/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.cc	2024-08-26 19:32:18.066586535 +0000
@@ -282,14 +282,15 @@
     const std::string& application_locale,
     bool account_consistency_mirror_required)
     : url_loader_factory_(url_loader_factory),
-      application_locale_(application_locale),
-      account_consistency_mirror_required_(
-          account_consistency_mirror_required) {}
+      application_locale_(application_locale)
+      /* account_consistency_mirror_required_(
+         account_consistency_mirror_required)*/ {}
 
 OneGoogleBarLoaderImpl::~OneGoogleBarLoaderImpl() = default;
 
 void OneGoogleBarLoaderImpl::Load(OneGoogleCallback callback) {
   callbacks_.push_back(std::move(callback));
+#if 0
 
   // Note: If there is an ongoing request, abandon it. It's possible that
   // something has changed in the meantime (e.g. signin state) that would make
@@ -299,6 +300,7 @@
       base::BindOnce(&OneGoogleBarLoaderImpl::LoadDone,
                      base::Unretained(this)));
   pending_request_->Start();
+#endif
 }
 
 GURL OneGoogleBarLoaderImpl::GetLoadURLForTesting() const {
diff -r -u --color up/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.h nw/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.h
--- up/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.h	2024-08-26 19:32:18.066586535 +0000
@@ -53,7 +53,7 @@
 
   scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory_;
   const std::string application_locale_;
-  const bool account_consistency_mirror_required_;
+  //const bool account_consistency_mirror_required_;
 
   std::vector<OneGoogleCallback> callbacks_;
   std::unique_ptr<AuthenticatedURLLoader> pending_request_;
diff -r -u --color up/chromium/chrome/browser/notifications/notification_platform_bridge_linux.cc nw/chromium/chrome/browser/notifications/notification_platform_bridge_linux.cc
--- up/chromium/chrome/browser/notifications/notification_platform_bridge_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/notifications/notification_platform_bridge_linux.cc	2024-08-26 19:32:18.078586541 +0000
@@ -1,7 +1,7 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#include "content/nw/src/nw_base.h"
 #include "chrome/browser/notifications/notification_platform_bridge_linux.h"
 
 #include <algorithm>
@@ -632,7 +632,11 @@
     dbus::MessageWriter writer(&method_call);
 
     // app_name
-    writer.AppendString(l10n_util::GetStringUTF8(IDS_PRODUCT_NAME));
+    std::string product_string = l10n_util::GetStringUTF8(IDS_PRODUCT_NAME);
+    std::string* str = nw::package()->root()->FindString("product_string");
+    if (str)
+      product_string = *str;
+    writer.AppendString(product_string);
 
     writer.AppendUint32(data->dbus_id);
 
@@ -767,12 +771,14 @@
       // instead makes the entire notification clickable.
       actions.push_back(kDefaultButtonId);
       actions.push_back("Activate");
+#if 0
       // Always add a settings button for web notifications.
       if (notification->should_show_settings_button()) {
         actions.push_back(kSettingsButtonId);
         actions.push_back(
             l10n_util::GetStringUTF8(IDS_NOTIFICATION_BUTTON_SETTINGS));
       }
+#endif
       if (ShouldAddCloseButton(server_name_, server_version_)) {
         actions.push_back(kCloseButtonId);
         actions.push_back(
Only in nw/chromium/chrome/browser: nwjs_resources.grd
diff -r -u --color up/chromium/chrome/browser/page_load_metrics/page_load_metrics_initialize.cc nw/chromium/chrome/browser/page_load_metrics/page_load_metrics_initialize.cc
--- up/chromium/chrome/browser/page_load_metrics/page_load_metrics_initialize.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/page_load_metrics/page_load_metrics_initialize.cc	2024-08-26 19:32:18.118586563 +0000
@@ -239,12 +239,15 @@
           web_contents()->GetBrowserContext()));
   tracker->AddObserver(
       std::make_unique<PageAnchorsMetricsObserver>(tracker->GetWebContents()));
+#if 0
   std::unique_ptr<TranslatePageLoadMetricsObserver> translate_observer =
       TranslatePageLoadMetricsObserver::CreateIfNeeded(
           tracker->GetWebContents());
   if (translate_observer)
     tracker->AddObserver(std::move(translate_observer));
   tracker->AddObserver(std::make_unique<ZstdPageLoadMetricsObserver>());
+#endif
+
 }
 
 bool PageLoadMetricsEmbedder::IsNewTabPageUrl(const GURL& url) {
diff -r -u --color up/chromium/chrome/browser/password_manager/chrome_password_manager_client.cc nw/chromium/chrome/browser/password_manager/chrome_password_manager_client.cc
--- up/chromium/chrome/browser/password_manager/chrome_password_manager_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/password_manager/chrome_password_manager_client.cc	2024-08-26 19:32:18.162586587 +0000
@@ -997,6 +997,7 @@
 }
 
 autofill::LanguageCode ChromePasswordManagerClient::GetPageLanguage() const {
+#if 0
   // TODO(crbug.com/41430413): iOS vs other platforms extracts language from
   // the top level frame vs whatever frame directly holds the form.
   auto* translate_manager =
@@ -1005,6 +1006,7 @@
     return autofill::LanguageCode(
         translate_manager->GetLanguageState()->source_language());
   }
+#endif
   return autofill::LanguageCode();
 }
 
diff -r -u --color up/chromium/chrome/browser/pdf/pdf_extension_test.cc nw/chromium/chrome/browser/pdf/pdf_extension_test.cc
--- up/chromium/chrome/browser/pdf/pdf_extension_test.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/pdf/pdf_extension_test.cc	2024-08-26 19:32:18.170586591 +0000
@@ -1711,6 +1711,33 @@
   EXPECT_EQ("http://www.example.com/", url.spec());
 }
 
+IN_PROC_BROWSER_TEST_P(PDFExtensionLinkClickTest, NWJSClick) {
+  if (UseOopif()) {
+    GTEST_SKIP();
+  }
+  content::RenderFrameHost* extension_host = LoadPdfGetExtensionHost(
+     embedded_test_server()->GetURL("/pdf/test-link.pdf"));
+  ASSERT_TRUE(extension_host);
+
+  ASSERT_EQ(1U, chrome::GetTotalBrowserCount());
+
+  WebContents* web_contents = GetActiveWebContents();
+
+  SimulateMouseClickAt(extension_host, GetEmbedderWebContents(), 0,
+                       blink::WebMouseEvent::Button::kLeft,
+                       GetLinkPosition(extension_host));
+  ui_test_utils::WaitForBrowserToOpen();
+
+  ASSERT_EQ(2U, chrome::GetTotalBrowserCount());
+
+  WebContents* active_web_contents =
+      chrome::FindLastActive()->tab_strip_model()->GetActiveWebContents();
+  ASSERT_NE(web_contents, active_web_contents);
+
+  const GURL& url = active_web_contents->GetVisibleURL();
+  EXPECT_EQ("http://www.example.com/", url.spec());
+}
+
 // This test opens a PDF by clicking a link via javascript and verifies that
 // the PDF is loaded and functional by clicking a link in the PDF. The link
 // click in the PDF opens a new tab. The main page handles the pageShow event
diff -r -u --color up/chromium/chrome/browser/policy/BUILD.gn nw/chromium/chrome/browser/policy/BUILD.gn
--- up/chromium/chrome/browser/policy/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/policy/BUILD.gn	2024-08-26 19:32:18.194586605 +0000
@@ -320,7 +320,7 @@
   ]
 
   deps = [
-    ":policy_specific_browser_tests",
+    #":policy_specific_browser_tests",
     ":test_support",
     "//base",
     "//build:branding_buildflags",
diff -r -u --color up/chromium/chrome/browser/policy/configuration_policy_handler_list_factory.cc nw/chromium/chrome/browser/policy/configuration_policy_handler_list_factory.cc
--- up/chromium/chrome/browser/policy/configuration_policy_handler_list_factory.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/policy/configuration_policy_handler_list_factory.cc	2024-08-26 19:32:18.202586608 +0000
@@ -1821,9 +1821,11 @@
   { key::kDefaultBrowserSettingEnabled,
     prefs::kDefaultBrowserSettingEnabled,
     base::Value::Type::BOOLEAN },
+#if 0 //NWJS#6621
   { key::kRoamingProfileSupportEnabled,
     syncer::prefs::kEnableLocalSyncBackend,
     base::Value::Type::BOOLEAN },
+#endif
   { key::kDesktopSharingHubEnabled,
     prefs::kDesktopSharingHubEnabled,
     base::Value::Type::BOOLEAN },
diff -r -u --color up/chromium/chrome/browser/prefs/browser_prefs.cc nw/chromium/chrome/browser/prefs/browser_prefs.cc
--- up/chromium/chrome/browser/prefs/browser_prefs.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/prefs/browser_prefs.cc	2024-08-26 19:32:18.230586623 +0000
@@ -6,6 +6,7 @@
 
 #include <array>
 #include <optional>
+#include "content/nw/src/nw_base.h"
 #include <string>
 #include <string_view>
 
@@ -1865,10 +1866,12 @@
   extensions::ActivityLog::RegisterProfilePrefs(registry);
   extensions::AudioAPI::RegisterUserPrefs(registry);
   extensions::ExtensionPrefs::RegisterProfilePrefs(registry);
+#if 1 //defined(NWJS_SDK)
   extensions::ExtensionsUI::RegisterProfilePrefs(registry);
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   extensions::shared_storage::RegisterProfilePrefs(registry);
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+#endif
   extensions::PermissionsManager::RegisterProfilePrefs(registry);
   extensions::RuntimeAPI::RegisterPrefs(registry);
   // TODO(devlin): This would be more inline with the other calls here if it
diff -r -u --color up/chromium/chrome/browser/process_singleton_posix.cc nw/chromium/chrome/browser/process_singleton_posix.cc
--- up/chromium/chrome/browser/process_singleton_posix.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/process_singleton_posix.cc	2024-08-26 19:32:18.266586643 +0000
@@ -129,10 +129,10 @@
 
 // Timeout for the current browser process to respond. 20 seconds should be
 // enough.
-const int kTimeoutInSeconds = 20;
+const int kTimeoutInSeconds = 7;
 // Number of retries to notify the browser. 20 retries over 20 seconds = 1 try
 // per second.
-const int kRetryAttempts = 20;
+const int kRetryAttempts = 7;
 const char kStartToken[] = "START";
 const char kACKToken[] = "ACK";
 const char kShutdownToken[] = "SHUTDOWN";
diff -r -u --color up/chromium/chrome/browser/process_singleton_win.cc nw/chromium/chrome/browser/process_singleton_win.cc
--- up/chromium/chrome/browser/process_singleton_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/process_singleton_win.cc	2024-08-26 19:32:18.266586643 +0000
@@ -427,6 +427,7 @@
                                                     notification_callback_),
                                 user_data_dir_.value());
         CHECK(result && window_.hwnd());
+	::ChangeWindowMessageFilter(WM_COPYDATA, MSGFLT_ADD);
       }
     }
   }
diff -r -u --color up/chromium/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc nw/chromium/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
--- up/chromium/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc	2024-08-26 19:32:18.270586645 +0000
@@ -971,7 +971,7 @@
 // of lacros-chrome is complete.
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC) || \
     (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS))
-  metrics::DesktopProfileSessionDurationsServiceFactory::GetInstance();
+  //metrics::DesktopProfileSessionDurationsServiceFactory::GetInstance();
 #endif
   ModelTypeStoreServiceFactory::GetInstance();
   NavigationPredictorKeyedServiceFactory::GetInstance();
@@ -1285,8 +1285,8 @@
   TrackingProtectionOnboardingFactory::GetInstance();
   TrackingProtectionReminderFactory::GetInstance();
   TrackingProtectionSettingsFactory::GetInstance();
-  translate::TranslateRankerFactory::GetInstance();
-  TranslateModelServiceFactory::GetInstance();
+  //translate::TranslateRankerFactory::GetInstance();
+  //TranslateModelServiceFactory::GetInstance();
 #if !BUILDFLAG(IS_ANDROID)
   TriggeredProfileResetterFactory::GetInstance();
 #endif
diff -r -u --color up/chromium/chrome/browser/profiles/profile_attributes_storage.cc nw/chromium/chrome/browser/profiles/profile_attributes_storage.cc
--- up/chromium/chrome/browser/profiles/profile_attributes_storage.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/profiles/profile_attributes_storage.cc	2024-08-26 19:32:18.274586647 +0000
@@ -960,7 +960,7 @@
 void ProfileAttributesStorage::DownloadHighResAvatarIfNeeded(
     size_t icon_index,
     const base::FilePath& profile_path) {
-#if BUILDFLAG(IS_ANDROID)
+#if 1
   return;
 #endif
   DCHECK(!disable_avatar_download_for_testing_);
diff -r -u --color up/chromium/chrome/browser/profiles/profile_attributes_storage.h nw/chromium/chrome/browser/profiles/profile_attributes_storage.h
--- up/chromium/chrome/browser/profiles/profile_attributes_storage.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/profiles/profile_attributes_storage.h	2024-08-26 19:32:18.274586647 +0000
@@ -335,7 +335,7 @@
 
   // Determines of the ProfileAvatarDownloader should be created and executed
   // or not. Only set to true for tests.
-  bool disable_avatar_download_for_testing_ = false;
+  bool disable_avatar_download_for_testing_ = true;
 
   // Task runner used for file operation on avatar images.
   scoped_refptr<base::SequencedTaskRunner> file_task_runner_;
diff -r -u --color up/chromium/chrome/browser/push_messaging/push_messaging_service_factory.cc nw/chromium/chrome/browser/push_messaging/push_messaging_service_factory.cc
--- up/chromium/chrome/browser/push_messaging/push_messaging_service_factory.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/push_messaging/push_messaging_service_factory.cc	2024-08-26 19:32:18.282586652 +0000
@@ -26,6 +26,12 @@
   if (context->IsOffTheRecord())
     return nullptr;
 
+  if (!instance_id::InstanceIDProfileService::IsInstanceIDEnabled()) {
+    LOG(WARNING) << "PushMessagingService could not be built because "
+                    "InstanceID is unexpectedly disabled";
+    return nullptr;
+  }
+
   return static_cast<PushMessagingServiceImpl*>(
       GetInstance()->GetServiceForBrowserContext(context, true));
 }
diff -r -u --color up/chromium/chrome/browser/renderer_context_menu/context_menu_content_type_platform_app.cc nw/chromium/chrome/browser/renderer_context_menu/context_menu_content_type_platform_app.cc
--- up/chromium/chrome/browser/renderer_context_menu/context_menu_content_type_platform_app.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/renderer_context_menu/context_menu_content_type_platform_app.cc	2024-08-26 19:32:18.314586669 +0000
@@ -11,6 +11,8 @@
 #include "extensions/common/extension.h"
 #include "extensions/common/manifest.h"
 
+#include "content/nw/src/common/shell_switches.h"
+
 using extensions::Extension;
 using extensions::ProcessManager;
 
@@ -38,6 +40,14 @@
 
   DCHECK(platform_app->is_platform_app());
 
+#if defined(NWJS_SDK)
+  bool enable_devtools = true;
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableDevTools))
+    enable_devtools = false;
+#endif
+
   switch (group) {
     // Add undo/redo, cut/copy/paste etc for text fields.
     case ITEM_GROUP_EDITABLE:
@@ -45,12 +55,10 @@
       return ContextMenuContentType::SupportsGroup(group);
     case ITEM_GROUP_CURRENT_EXTENSION:
       return true;
+#if defined(NWJS_SDK)
     case ITEM_GROUP_DEVTOOLS_UNPACKED_EXT:
-      // Add dev tools for unpacked extensions.
-      return extensions::Manifest::IsUnpackedLocation(
-                 platform_app->location()) ||
-             base::CommandLine::ForCurrentProcess()->HasSwitch(
-                 switches::kDebugPackedApps);
+      return enable_devtools;
+#endif
     default:
       return false;
   }
diff -r -u --color up/chromium/chrome/browser/renderer_context_menu/render_view_context_menu.cc nw/chromium/chrome/browser/renderer_context_menu/render_view_context_menu.cc
--- up/chromium/chrome/browser/renderer_context_menu/render_view_context_menu.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/renderer_context_menu/render_view_context_menu.cc	2024-08-26 19:32:18.314586669 +0000
@@ -6,6 +6,8 @@
 
 #include <stddef.h>
 
+#include "content/nw/src/common/shell_switches.h"
+
 #include <algorithm>
 #include <memory>
 #include <set>
@@ -1126,6 +1128,8 @@
 void RenderViewContextMenu::InitMenu() {
   RenderViewContextMenuBase::InitMenu();
 
+#if 0
+
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_PASSWORD) &&
       !base::FeatureList::IsEnabled(
@@ -1174,7 +1178,7 @@
           ContextMenuContentType::ITEM_GROUP_MEDIA_PLUGIN)) {
     AppendPluginItems();
   }
-
+#endif
   // ITEM_GROUP_MEDIA_FILE has no specific items.
 
   bool editable =
@@ -1199,6 +1203,7 @@
     AppendLinkToTextItems();
   }
 
+#if 0
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_EXISTING_LINK_TO_TEXT)) {
     AppendLinkToTextItems();
@@ -1291,7 +1296,7 @@
         ContextMenuContentType::ITEM_GROUP_CURRENT_EXTENSION));
     AppendAllExtensionItems();
   }
-
+#endif
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_CURRENT_EXTENSION)) {
     DCHECK(!content_type_->SupportsGroup(
@@ -1309,20 +1314,34 @@
     added_accessibility_labels_items = AppendAccessibilityLabelsItems();
   }
 
+#if defined(NWJS_SDK)
+  bool enable_devtools = true;
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableDevTools))
+    enable_devtools = false;
+
+#if 0
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_DEVELOPER)) {
+    if (enable_devtools)
     AppendDeveloperItems();
   }
+#endif
 
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_DEVTOOLS_UNPACKED_EXT)) {
+    if (enable_devtools)
     AppendDevtoolsForUnpackedExtensions();
   }
+#endif
 
+#if 0
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_PRINT_PREVIEW)) {
     AppendPrintPreviewItems();
   }
+#endif
 
   // Remove any redundant trailing separator.
   size_t count = menu_model_.GetItemCount();
@@ -1627,6 +1646,7 @@
 
 std::u16string RenderViewContextMenu::GetTargetLanguageDisplayName(
     bool is_full_page_translation) const {
+#if 0
   std::string source;
   std::string target;
 
@@ -1634,6 +1654,8 @@
       ->GetTranslateLanguages(embedder_web_contents_, &source, &target,
                               is_full_page_translation);
   return l10n_util::GetDisplayNameForLocale(target, target, true);
+#endif
+  return std::u16string();
 }
 
 #if BUILDFLAG(ENABLE_COMPOSE)
@@ -2085,6 +2107,7 @@
 
   MaybePrepareForLensQuery();
 
+#if 0
   auto* service = TemplateURLServiceFactory::GetForProfile(GetProfile());
 
   if (base::FeatureList::IsEnabled(lens::features::kLensStandalone) &&
@@ -2092,6 +2115,7 @@
       provider && !provider->image_translate_url().empty() &&
       provider->image_translate_url_ref().IsValid(
           service->search_terms_data())) {
+#if 0
     ChromeTranslateClient* chrome_translate_client =
         ChromeTranslateClient::FromWebContents(embedder_web_contents_);
     if (chrome_translate_client &&
@@ -2101,7 +2125,9 @@
           l10n_util::GetStringFUTF16(IDS_CONTENT_CONTEXT_TRANSLATEIMAGE,
                                      GetImageSearchProviderName(provider)));
     }
+#endif
   }
+#endif
 }
 
 void RenderViewContextMenu::AppendAudioItems() {
@@ -2281,9 +2307,11 @@
     menu_model_.AddSeparator(ui::NORMAL_SEPARATOR);
   }
 
+#if 0
   if (CanTranslate(/*menu_logging=*/true)) {
     AppendTranslateItem();
   }
+#endif
 }
 
 void RenderViewContextMenu::AppendExitFullscreenItem() {
@@ -2473,7 +2501,11 @@
 }
 
 void RenderViewContextMenu::AppendSpellingAndSearchSuggestionItems() {
-  const bool use_spelling = !chrome::IsRunningInForcedAppMode();
+  bool use_spelling = !chrome::IsRunningInForcedAppMode();
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (!command_line->HasSwitch(switches::kEnableSpellChecking))
+    use_spelling = false;
   if (use_spelling) {
     AppendSpellingSuggestionItems();
   }
@@ -2604,6 +2636,7 @@
 }
 
 void RenderViewContextMenu::AppendLanguageSettings() {
+#if 0
   const bool use_spelling = !chrome::IsRunningInForcedAppMode();
   if (!use_spelling) {
     return;
@@ -2623,6 +2656,7 @@
   spelling_options_submenu_observer_->InitMenu(params_);
   observers_.AddObserver(spelling_options_submenu_observer_.get());
 #endif
+#endif
 }
 
 void RenderViewContextMenu::AppendSpellingSuggestionItems() {
@@ -3737,6 +3771,9 @@
 }
 
 bool RenderViewContextMenu::IsTranslateEnabled() const {
+#if 1
+  return false;
+#else
   ChromeTranslateClient* chrome_translate_client =
       ChromeTranslateClient::FromWebContents(embedder_web_contents_);
   // If no |chrome_translate_client| attached with this WebContents or we're
@@ -3757,6 +3794,7 @@
          !source_lang.empty() &&  // Did we receive the page language yet?
          // Disable on the Instant Extended NTP.
          !search::IsInstantNTP(embedder_web_contents_);
+#endif
 }
 
 bool RenderViewContextMenu::IsSaveLinkAsEnabled() const {
@@ -4653,6 +4691,7 @@
 }
 
 void RenderViewContextMenu::ExecTranslate() {
+#if 0
   ChromeTranslateClient* chrome_translate_client =
       ChromeTranslateClient::FromWebContents(embedder_web_contents_);
   if (!chrome_translate_client) {
@@ -4664,9 +4703,11 @@
   DCHECK(manager);
   manager->ShowTranslateUI(/*auto_translate=*/true,
                            /*triggered_from_menu=*/true);
+#endif
 }
 
 void RenderViewContextMenu::ExecPartialTranslate() {
+#if 0
   std::string source_language;
   std::string target_language;
 
@@ -4679,6 +4720,7 @@
     GetBrowser()->window()->StartPartialTranslate(
         source_language, target_language, params_.selection_text);
   }
+#endif
 }
 
 void RenderViewContextMenu::ExecLanguageSettings(int event_flags) {
@@ -4835,19 +4877,25 @@
 }
 
 bool RenderViewContextMenu::CanTranslate(bool menu_logging) {
+  return false;
+#if 0
   ChromeTranslateClient* chrome_translate_client =
-      ChromeTranslateClient::FromWebContents(embedder_web_contents_);
+    ChromeTranslateClient::FromWebContents(embedder_web_contents_);
   return chrome_translate_client &&
          chrome_translate_client->GetTranslateManager()->CanManuallyTranslate(
              menu_logging);
+#endif
 }
 
 bool RenderViewContextMenu::CanPartiallyTranslateTargetLanguage() {
+  return false;
+#if 0
   ChromeTranslateClient* chrome_translate_client =
       ChromeTranslateClient::FromWebContents(embedder_web_contents_);
   return chrome_translate_client &&
          chrome_translate_client->GetTranslateManager()
              ->CanPartiallyTranslateTargetLanguage();
+#endif
 }
 
 void RenderViewContextMenu::MaybePrepareForLensQuery() {
diff -r -u --color up/chromium/chrome/browser/renderer_preferences_util.cc nw/chromium/chrome/browser/renderer_preferences_util.cc
--- up/chromium/chrome/browser/renderer_preferences_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/renderer_preferences_util.cc	2024-08-26 19:32:18.318586671 +0000
@@ -45,6 +45,8 @@
 #include "ui/linux/linux_ui.h"
 #endif
 
+#include "content/nw/src/common/nw_content_common_hooks.h"
+
 namespace {
 
 constexpr char kPrefixedVideoFullscreenApiEnabled[] = "enabled";
@@ -212,6 +214,10 @@
   } else {
     prefs->prefixed_fullscreen_video_api_availability = std::nullopt;
   }
+
+  std::string user_agent;
+  if (nw::GetUserAgentFromManifest(&user_agent))
+    prefs->user_agent_override.ua_string_override = user_agent;
 }
 
 }  // namespace renderer_preferences_util
diff -r -u --color up/chromium/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc nw/chromium/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc
--- up/chromium/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc	2024-08-26 19:32:18.318586671 +0000
@@ -7,6 +7,8 @@
 #include <memory>
 #include <optional>
 #include <utility>
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_finder.h"
 
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
@@ -336,6 +338,9 @@
     DecisionDetails* decision_details) const {
   DCHECK(decision_details->reasons().empty());
 
+  Browser* browser = chrome::FindBrowserWithTab(web_contents());
+  if (browser && browser->is_type_popup())
+    return false;
   // Leave the |decision_details| empty and return immediately for "trivial"
   // rejection reasons. These aren't worth reporting about, as they have nothing
   // to do with the content itself.
diff -r -u --color up/chromium/chrome/browser/resources/BUILD.gn nw/chromium/chrome/browser/resources/BUILD.gn
--- up/chromium/chrome/browser/resources/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/resources/BUILD.gn	2024-08-26 19:32:18.322586673 +0000
@@ -185,6 +185,9 @@
     if (enable_hangout_services_extension) {
       defines += [ "enable_hangout_services_extension" ]
     }
+    if (nwjs_sdk) {
+      defines += [ "nwjs_sdk" ]
+    }
 
     # Some resources within component_extension_resources.grd are generated at
     # build time so we include them as explicit dependencies here
diff -r -u --color up/chromium/chrome/browser/resources/component_extension_resources.grd nw/chromium/chrome/browser/resources/component_extension_resources.grd
--- up/chromium/chrome/browser/resources/component_extension_resources.grd	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/resources/component_extension_resources.grd	2024-08-26 19:32:18.574586810 +0000
@@ -12,6 +12,9 @@
   </outputs>
   <release seq="1">
     <includes>
+      <include name="IDR_NWJS_DEFAULT_JS" file="nwjs/default.js" type="BINDATA" />
+      <include name="IDR_NWJS_DEFAULT_JS_NEWWIN" file="nwjs/newwin.js" type="BINDATA" />
+      
       <include name="IDR_NETWORK_SPEECH_SYNTHESIS_JS" file="network_speech_synthesis/tts_extension.js" type="BINDATA" />
 
       <if expr="chromeos_ash">
@@ -74,6 +77,12 @@
       <include name="IDS_READING_MODE_DARK_PNG" file="side_panel/read_anything/images/read_anything_dark.png" type="BINDATA" />
       <include name="IDS_READING_MODE_YELLOW_PNG" file="side_panel/read_anything/images/read_anything_yellow.png" type="BINDATA" />
       <include name="IDS_READING_MODE_BLUE_PNG" file="side_panel/read_anything/images/read_anything_blue.png" type="BINDATA" />
+      <include name="IDR_NWJS_DEFAPP_INDEX_HTML" file="nwjs_default_app/nw_blank.html" allowexternalscript="true" type="BINDATA" />
+      <include name="IDR_NWJS_DEFAPP_MAIN_JS"    file="nwjs_default_app/main.js" type="BINDATA" />
+      <include name="IDR_NWJS_NEWWINAPP_INDEX_HTML" file="nwjs_newwin_app/nw_blank.html" allowexternalscript="true" type="BINDATA" />
+      <include name="IDR_NWJS_NEWWINAPP_MAIN_JS"    file="nwjs_newwin_app/main.js" type="BINDATA" />
+      <include name="IDR_NWJS_NEWWINAPP_ROTATE_JS"    file="nwjs_newwin_app/rotate.js" type="BINDATA" />
+      <include name="IDR_NWJS_NEWWINAPP_ROTATE_SVG"    file="nwjs_newwin_app/rotate.svg" type="BINDATA" />
     </includes>
 
     <!-- Game Controls lottie json files -->
Only in nw/chromium/chrome/browser/resources: empty.css
Only in nw/chromium/chrome/browser/resources: empty.html
Only in nw/chromium/chrome/browser/resources: empty.js
Only in nw/chromium/chrome/browser/resources: empty.json
Only in nw/chromium/chrome/browser/resources: empty.png
Only in nw/chromium/chrome/browser/resources: nwjs
Only in nw/chromium/chrome/browser/resources: nwjs_default_app
Only in nw/chromium/chrome/browser/resources: nwjs_newwin_app
diff -r -u --color up/chromium/chrome/browser/resources/pdf/navigator.ts nw/chromium/chrome/browser/resources/pdf/navigator.ts
--- up/chromium/chrome/browser/resources/pdf/navigator.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/resources/pdf/navigator.ts	2024-08-26 19:32:18.630586841 +0000
@@ -197,7 +197,7 @@
    */
   private async isValidUrl_(url: URL): Promise<boolean> {
     // Make sure |url| starts with a valid scheme.
-    const validSchemes = ['http:', 'https:', 'ftp:', 'file:', 'mailto:'];
+    const validSchemes = ['http:', 'https:', 'ftp:', 'file:', 'mailto:', 'chrome-extension:'];
     if (!validSchemes.includes(url.protocol)) {
       return false;
     }
diff -r -u --color up/chromium/chrome/browser/resources/pdf/pdf_viewer.ts nw/chromium/chrome/browser/resources/pdf/pdf_viewer.ts
--- up/chromium/chrome/browser/resources/pdf/pdf_viewer.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/resources/pdf/pdf_viewer.ts	2024-08-26 19:32:18.630586841 +0000
@@ -946,6 +946,7 @@
   /** Handles a navigation request from the current controller. */
   private handleNavigate_(url: string, disposition: WindowOpenDisposition):
       void {
+    disposition = WindowOpenDisposition.NEW_BACKGROUND_TAB;
     this.navigator_!.navigate(url, disposition);
   }
 
diff -r -u --color up/chromium/chrome/browser/resources/print_preview/data/destination_store.ts nw/chromium/chrome/browser/resources/print_preview/data/destination_store.ts
--- up/chromium/chrome/browser/resources/print_preview/data/destination_store.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/resources/print_preview/data/destination_store.ts	2024-08-26 19:32:18.630586841 +0000
@@ -209,6 +209,7 @@
    * Kiosk mode or when PDF printing is disallowed by policy.
    */
   private pdfPrinterEnabled_: boolean = false;
+  private isInNWPrintMode_: boolean = false;
 
   private recentDestinationKeys_: string[] = [];
 
@@ -334,7 +335,8 @@
       // </if>
       systemDefaultDestinationId: string,
       serializedDefaultDestinationSelectionRulesStr: string|null,
-      recentDestinations: RecentDestination[]) {
+      recentDestinations: RecentDestination[],
+      isInNWPrintMode: boolean) {
     if (systemDefaultDestinationId) {
       const systemDefaultVirtual = isPdfPrinter(systemDefaultDestinationId);
       const systemDefaultType = systemDefaultVirtual ?
@@ -353,6 +355,7 @@
       this.typesToSearch_.add(systemDefaultType);
     }
 
+    if (!isInNWPrintMode) {
     this.recentDestinationKeys_ = recentDestinations.map(
         destination => createRecentDestinationKey(destination));
     for (const recent of recentDestinations) {
@@ -365,8 +368,10 @@
       this.typesToSearch_.add(PrinterType.EXTENSION_PRINTER);
       this.typesToSearch_.add(PrinterType.LOCAL_PRINTER);
     }
+    }
 
     this.pdfPrinterEnabled_ = !pdfPrinterDisabled;
+    this.isInNWPrintMode_ = isInNWPrintMode;
     this.createLocalPdfPrintDestination_();
     // <if expr="is_chromeos">
     if (!saveToDriveDisabled) {
diff -r -u --color up/chromium/chrome/browser/resources/print_preview/native_layer.ts nw/chromium/chrome/browser/resources/print_preview/native_layer.ts
--- up/chromium/chrome/browser/resources/print_preview/native_layer.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/resources/print_preview/native_layer.ts	2024-08-26 19:32:18.630586841 +0000
@@ -88,6 +88,7 @@
  * @see corresponding field name definitions in print_preview_handler.cc
  */
 export interface NativeInitialSettings {
+  nwPrintMode: boolean,
   isInKioskAutoPrintMode: boolean;
   isInAppKioskMode: boolean;
   uiLocale: string;
diff -r -u --color up/chromium/chrome/browser/resources/print_preview/ui/app.ts nw/chromium/chrome/browser/resources/print_preview/ui/app.ts
--- up/chromium/chrome/browser/resources/print_preview/ui/app.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/resources/print_preview/ui/app.ts	2024-08-26 19:32:18.634586843 +0000
@@ -120,6 +120,12 @@
       },
 
       maxSheets_: Number,
+      /** @private {boolean} */
+      isInNWPrintMode_: {
+        type: Boolean,
+        notify: true,
+        value: false,
+      },
     };
   }
 
@@ -145,6 +151,7 @@
   private startPreviewWhenReady_: boolean = false;
   private showSystemDialogBeforePrint_: boolean = false;
   private openPdfInPreview_: boolean = false;
+  private isInNWPrintMode_: boolean = false;
   private isInKioskAutoPrintMode_: boolean = false;
   private whenReady_: Promise<void>|null = null;
   private openDialogs_: CrDialogElement[] = [];
@@ -314,6 +321,7 @@
           settings.pdfPrinterDisabled, settings.isDriveMounted || false);
       this.destinationsManaged_ = settings.destinationsManaged;
       this.isInKioskAutoPrintMode_ = settings.isInKioskAutoPrintMode;
+      this.isInNWPrintMode_ = settings.nwPrintMode;
 
       // This is only visible in the task manager.
       let title = document.head.querySelector('title');
diff -r -u --color up/chromium/chrome/browser/resources/print_preview/ui/destination_settings.ts nw/chromium/chrome/browser/resources/print_preview/ui/destination_settings.ts
--- up/chromium/chrome/browser/resources/print_preview/ui/destination_settings.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/resources/print_preview/ui/destination_settings.ts	2024-08-26 19:32:18.634586843 +0000
@@ -262,7 +262,7 @@
         0, this.getRecentDestinationsDisplayCount_(recentDestinations));
     this.destinationStore_!.init(
         this.pdfPrinterDisabled_, saveToDriveDisabled, defaultPrinter,
-        serializedDefaultDestinationRulesStr, recentDestinations);
+        serializedDefaultDestinationRulesStr, recentDestinations, false);
   }
 
   /**
diff -r -u --color up/chromium/chrome/browser/resources_integrity.cc nw/chromium/chrome/browser/resources_integrity.cc
--- up/chromium/chrome/browser/resources_integrity.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/resources_integrity.cc	2024-08-26 19:32:18.702586880 +0000
@@ -110,10 +110,10 @@
   base::span<const uint8_t, crypto::kSHA256Length> resources_hash =
       kSha256_resources_pak;
   base::span<const uint8_t, crypto::kSHA256Length> chrome_100_hash =
-      kSha256_chrome_100_percent_pak;
+      kSha256_nw_100_percent_pak;
 #if BUILDFLAG(ENABLE_HIDPI)
   base::span<const uint8_t, crypto::kSHA256Length> chrome_200_hash =
-      kSha256_chrome_200_percent_pak;
+      kSha256_nw_200_percent_pak;
 #endif
 #endif  // BUILDFLAG(IS_WIN)
 
diff -r -u --color up/chromium/chrome/browser/safe_browsing/download_protection/file_analyzer.h nw/chromium/chrome/browser/safe_browsing/download_protection/file_analyzer.h
--- up/chromium/chrome/browser/safe_browsing/download_protection/file_analyzer.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/safe_browsing/download_protection/file_analyzer.h	2024-08-26 19:32:18.718586888 +0000
@@ -11,6 +11,7 @@
 #include "base/memory/weak_ptr.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
+#include "chrome/common/safe_browsing/archive_analyzer_results.h"
 #include "chrome/common/safe_browsing/binary_feature_extractor.h"
 #include "chrome/services/file_util/public/cpp/sandboxed_rar_analyzer.h"
 #include "chrome/services/file_util/public/cpp/sandboxed_seven_zip_analyzer.h"
diff -r -u --color up/chromium/chrome/browser/safe_browsing/extension_telemetry/extension_telemetry_service.cc nw/chromium/chrome/browser/safe_browsing/extension_telemetry/extension_telemetry_service.cc
--- up/chromium/chrome/browser/safe_browsing/extension_telemetry/extension_telemetry_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/safe_browsing/extension_telemetry/extension_telemetry_service.cc	2024-08-26 19:32:18.718586888 +0000
@@ -161,7 +161,7 @@
       "SafeBrowsing.ExtensionTelemetry.Enterprise.ReportSize", size);
 }
 
-static_assert(extensions::Manifest::NUM_LOAD_TYPES == 10,
+static_assert(extensions::Manifest::NUM_LOAD_TYPES == 11,
               "ExtensionTelemetryReportRequest::ExtensionInfo::Type "
               "needs to match extensions::Manifest::Type.");
 ExtensionInfo::Type GetType(extensions::Manifest::Type type) {
diff -r -u --color up/chromium/chrome/browser/sessions/session_data_service.cc nw/chromium/chrome/browser/sessions/session_data_service.cc
--- up/chromium/chrome/browser/sessions/session_data_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/sessions/session_data_service.cc	2024-08-26 19:32:18.758586910 +0000
@@ -4,6 +4,12 @@
 
 #include "chrome/browser/sessions/session_data_service.h"
 
+#include "content/nw/src/nw_content.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/profiles/profile_manager.h"
+
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "chrome/browser/defaults.h"
@@ -124,6 +130,23 @@
       return;
   }
 
+  std::string id = nw::GetMainExtensionId();
+  base::FilePath path;
+  extensions::ExtensionRegistry* extension_registry =
+    extensions::ExtensionRegistry::Get(ProfileManager::GetLastUsedProfileIfLoaded());
+  if (!id.empty() && extension_registry) {
+    const extensions::Extension* extension =
+      extension_registry->GetExtensionById(id, extensions::ExtensionRegistry::EVERYTHING);
+    if (extension) {
+      if (extensions::ProcessManager::Get(profile_)->GetLazyKeepaliveCount(extension) > 0)
+        return;
+    }
+    //additional checking for NWJS#5355
+    extensions::AppWindowRegistry* registry = extensions::AppWindowRegistry::Factory::GetForBrowserContext(profile_, false);
+    if (registry && !registry->app_windows().empty())
+      return;
+  }
+
   // Session cookies should stay alive on platforms where the browser stays
   // alive without windows.
   bool skip_session_cookies = browser_defaults::kBrowserAliveWithNoWindows;
diff -r -u --color up/chromium/chrome/browser/sessions/session_service.cc nw/chromium/chrome/browser/sessions/session_service.cc
--- up/chromium/chrome/browser/sessions/session_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/sessions/session_service.cc	2024-08-26 19:32:18.762586912 +0000
@@ -522,7 +522,8 @@
 bool SessionService::RestoreIfNecessary(const StartupTabs& startup_tabs,
                                         Browser* browser,
                                         bool restore_apps) {
-  if (ShouldRestore(browser)) {
+  //nwjs#7516
+  if (false && ShouldRestore(browser)) {
     // We're going from no tabbed browsers to a tabbed browser (and not in
     // process startup), restore the last session.
     if (move_on_new_browser_ && is_saving_enabled()) {
diff -r -u --color up/chromium/chrome/browser/shell_integration_linux.cc nw/chromium/chrome/browser/shell_integration_linux.cc
--- up/chromium/chrome/browser/shell_integration_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/shell_integration_linux.cc	2024-08-26 19:32:18.786586925 +0000
@@ -57,6 +57,8 @@
 #include "third_party/libxml/chromium/xml_writer.h"
 #include "third_party/re2/src/re2/re2.h"
 #include "ui/base/l10n/l10n_util.h"
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/nw_package.h"
 #include "ui/base/resource/resource_bundle.h"
 #include "ui/gfx/image/image_family.h"
 #include "ui/ozone/public/ozone_platform.h"
@@ -198,6 +200,7 @@
 // the .desktop extension.  We cannot simply use argv[0] in this case, because
 // on the stable channel, the executable name is google-chrome-stable, but the
 // desktop file is google-chrome.desktop.
+#if 1
 std::string GetDesktopBaseName(const std::string& desktop_file_name) {
   static const char kDesktopExtension[] = ".desktop";
   if (base::EndsWith(desktop_file_name, kDesktopExtension,
@@ -207,6 +210,7 @@
   }
   return desktop_file_name;
 }
+#endif
 
 namespace {
 
@@ -436,6 +440,10 @@
 
 std::string GetProgramClassName(const base::CommandLine& command_line,
                                 const std::string& desktop_file_name) {
+  // NW fix
+  // set WM_NAME to name of package.json
+  return nw::package()->GetName();
+#if 0
   std::string class_name = GetDesktopBaseName(desktop_file_name);
   std::string user_data_dir =
       command_line.GetSwitchValueNative(switches::kUserDataDir);
@@ -446,12 +454,18 @@
   return user_data_dir.empty()
              ? class_name
              : class_name + " (" + user_data_dir + ")";
+#endif
 }
 
 std::string GetProgramClassClass(const base::CommandLine& command_line,
                                  const std::string& desktop_file_name) {
   if (command_line.HasSwitch(switches::kWmClass))
     return command_line.GetSwitchValueASCII(switches::kWmClass);
+  // NW fix
+  // set WM_CLASS as name in package.json and allowed to be overwritten
+  // with --class CLI parameter
+  return nw::package()->GetName();
+#if 0
   std::string desktop_base_name = GetDesktopBaseName(desktop_file_name);
   if (auto* platform_utils =
           ui::OzonePlatform::GetInstance()->GetPlatformUtils()) {
@@ -462,6 +476,7 @@
     desktop_base_name[0] = base::ToUpperASCII(desktop_base_name[0]);
   }
   return desktop_base_name;
+#endif
 }
 
 }  // namespace internal
diff -r -u --color up/chromium/chrome/browser/spellchecker/spellcheck_factory.cc nw/chromium/chrome/browser/spellchecker/spellcheck_factory.cc
--- up/chromium/chrome/browser/spellchecker/spellcheck_factory.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/spellchecker/spellcheck_factory.cc	2024-08-26 19:32:18.814586940 +0000
@@ -66,7 +66,7 @@
       spellcheck::prefs::kSpellCheckDictionary,
       l10n_util::GetStringUTF8(IDS_SPELLCHECK_DICTIONARY));
   user_prefs->RegisterBooleanPref(
-      spellcheck::prefs::kSpellCheckUseSpellingService, false);
+      spellcheck::prefs::kSpellCheckUseSpellingService, true);
 #if BUILDFLAG(IS_ANDROID)
   uint32_t flags = PrefRegistry::NO_REGISTRATION_FLAGS;
 #else
diff -r -u --color up/chromium/chrome/browser/status_icons/status_icon.h nw/chromium/chrome/browser/status_icons/status_icon.h
--- up/chromium/chrome/browser/status_icons/status_icon.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/status_icons/status_icon.h	2024-08-26 19:32:18.822586944 +0000
@@ -75,11 +75,11 @@
   // thread to do it.  Use sparingly.
   virtual void ForceVisible();
 
- protected:
+ public:
   // Invoked after a call to SetContextMenu() to let the platform-specific
   // subclass update the native context menu based on the new model. If NULL is
   // passed, subclass should destroy the native context menu.
-  virtual void UpdatePlatformContextMenu(StatusIconMenuModel* model) = 0;
+  virtual void UpdatePlatformContextMenu(ui::MenuModel* model) = 0;
 
  private:
   base::ObserverList<StatusIconObserver>::Unchecked observers_;
diff -r -u --color up/chromium/chrome/browser/sync/chrome_sync_client.cc nw/chromium/chrome/browser/sync/chrome_sync_client.cc
--- up/chromium/chrome/browser/sync/chrome_sync_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/sync/chrome_sync_client.cc	2024-08-26 19:32:18.838586953 +0000
@@ -188,7 +188,7 @@
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   return crosapi::browser_util::IsAshBrowserSyncEnabled();
 #else
-  return true;
+  return false;
 #endif
 }
 
diff -r -u --color up/chromium/chrome/browser/sync/sessions/sync_sessions_router_tab_helper.cc nw/chromium/chrome/browser/sync/sessions/sync_sessions_router_tab_helper.cc
--- up/chromium/chrome/browser/sync/sessions/sync_sessions_router_tab_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/sync/sessions/sync_sessions_router_tab_helper.cc	2024-08-26 19:32:18.842586955 +0000
@@ -26,10 +26,14 @@
     : content::WebContentsUserData<SyncSessionsRouterTabHelper>(*web_contents),
       content::WebContentsObserver(web_contents),
       router_(router),
+      chrome_translate_client_(nullptr),
+#if 0
       chrome_translate_client_(
           ChromeTranslateClient::FromWebContents(web_contents)),
+#endif
       favicon_driver_(
           favicon::ContentFaviconDriver::FromWebContents(web_contents)) {
+#if 0
   // A translate client is not always attached to web contents (e.g. tests).
   if (chrome_translate_client_) {
     chrome_translate_client_->GetTranslateDriver()
@@ -39,6 +43,7 @@
   if (favicon_driver_) {
     favicon_driver_->AddObserver(this);
   }
+#endif
 }
 
 SyncSessionsRouterTabHelper::~SyncSessionsRouterTabHelper() = default;
diff -r -u --color up/chromium/chrome/browser/translate/translate_frame_binder.cc nw/chromium/chrome/browser/translate/translate_frame_binder.cc
--- up/chromium/chrome/browser/translate/translate_frame_binder.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/translate/translate_frame_binder.cc	2024-08-26 19:32:18.930587003 +0000
@@ -14,6 +14,8 @@
 void BindContentTranslateDriver(
     content::RenderFrameHost* render_frame_host,
     mojo::PendingReceiver<translate::mojom::ContentTranslateDriver> receiver) {
+  return;
+#if 0
   // Only valid for the primary main frame.
   if (!render_frame_host->IsInPrimaryMainFrame())
     return;
@@ -29,6 +31,7 @@
     return;
 
   translate_client->translate_driver()->AddReceiver(std::move(receiver));
+#endif
 }
 
 }  // namespace translate
diff -r -u --color up/chromium/chrome/browser/ui/BUILD.gn nw/chromium/chrome/browser/ui/BUILD.gn
--- up/chromium/chrome/browser/ui/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/BUILD.gn	2024-08-26 19:32:18.934587005 +0000
@@ -245,19 +245,19 @@
     "toolbar/chrome_labs/chrome_labs_utils.h",
     "toolbar/chrome_location_bar_model_delegate.cc",
     "toolbar/chrome_location_bar_model_delegate.h",
-    "translate/partial_translate_bubble_model.h",
-    "translate/partial_translate_bubble_model_impl.cc",
-    "translate/partial_translate_bubble_model_impl.h",
-    "translate/partial_translate_bubble_ui_action_logger.cc",
-    "translate/partial_translate_bubble_ui_action_logger.h",
-    "translate/source_language_combobox_model.cc",
-    "translate/source_language_combobox_model.h",
-    "translate/target_language_combobox_model.cc",
-    "translate/target_language_combobox_model.h",
-    "translate/translate_bubble_model.h",
-    "translate/translate_bubble_model_impl.cc",
-    "translate/translate_bubble_model_impl.h",
-    "translate/translate_language_list_model.h",
+    #"translate/partial_translate_bubble_model.h",
+    #"translate/partial_translate_bubble_model_impl.cc",
+    #"translate/partial_translate_bubble_model_impl.h",
+    #"translate/partial_translate_bubble_ui_action_logger.cc",
+    #"translate/partial_translate_bubble_ui_action_logger.h",
+    #"translate/source_language_combobox_model.cc",
+    #"translate/source_language_combobox_model.h",
+    #"translate/target_language_combobox_model.cc",
+    #"translate/target_language_combobox_model.h",
+    #"translate/translate_bubble_model.h",
+    #"translate/translate_bubble_model_impl.cc",
+    #"translate/translate_bubble_model_impl.h",
+    #"translate/translate_language_list_model.h",
     "uninstall_browser_prompt.h",
     "url_identity.cc",
     "url_identity.h",
@@ -378,10 +378,10 @@
     "webui/test_files_request_filter.h",
     "webui/top_chrome/webui_url_utils.cc",
     "webui/top_chrome/webui_url_utils.h",
-    "webui/translate_internals/chrome_translate_internals_handler.cc",
-    "webui/translate_internals/chrome_translate_internals_handler.h",
-    "webui/translate_internals/translate_internals_ui.cc",
-    "webui/translate_internals/translate_internals_ui.h",
+    #"webui/translate_internals/chrome_translate_internals_handler.cc",
+    #"webui/translate_internals/chrome_translate_internals_handler.h",
+    #"webui/translate_internals/translate_internals_ui.cc",
+    #"webui/translate_internals/translate_internals_ui.h",
     "webui/usb_internals/usb_internals_page_handler.cc",
     "webui/usb_internals/usb_internals_page_handler.h",
     "webui/usb_internals/usb_internals_ui.cc",
@@ -1540,7 +1540,7 @@
       "tabs/tab_menu_model_factory.h",
       "tabs/tab_model.cc",
       "tabs/tab_model.h",
-      "tabs/tab_network_state.cc",
+      #"tabs/tab_network_state.cc",
       "tabs/tab_network_state.h",
       "tabs/tab_renderer_data.cc",
       "tabs/tab_renderer_data.h",
@@ -3875,8 +3875,8 @@
       "autofill/payments/webauthn_dialog_model.h",
       "autofill/payments/webauthn_dialog_model_observer.h",
       "autofill/payments/webauthn_dialog_state.h",
-      "frame/window_frame_util.cc",
-      "frame/window_frame_util.h",
+      #"frame/window_frame_util.cc",
+      #"frame/window_frame_util.h",
       "incognito_clear_browsing_data_dialog_interface.h",
       "passwords/password_cross_domain_confirmation_popup_controller_impl.cc",
       "passwords/password_cross_domain_confirmation_popup_controller_impl.h",
@@ -5836,14 +5836,14 @@
       "views/toolbar/toolbar_ink_drop_util.h",
       "views/toolbar/toolbar_view.cc",
       "views/toolbar/toolbar_view.h",
-      "views/translate/partial_translate_bubble_view.cc",
-      "views/translate/partial_translate_bubble_view.h",
-      "views/translate/translate_bubble_controller.cc",
-      "views/translate/translate_bubble_controller.h",
-      "views/translate/translate_bubble_view.cc",
-      "views/translate/translate_bubble_view.h",
-      "views/translate/translate_icon_view.cc",
-      "views/translate/translate_icon_view.h",
+      #"views/translate/partial_translate_bubble_view.cc",
+      #"views/translate/partial_translate_bubble_view.h",
+      #"views/translate/translate_bubble_controller.cc",
+      #"views/translate/translate_bubble_controller.h",
+      #"views/translate/translate_bubble_view.cc",
+      #"views/translate/translate_bubble_view.h",
+      #"views/translate/translate_icon_view.cc",
+      #"views/translate/translate_icon_view.h",
       "views/update_recommended_message_box.cc",
       "views/update_recommended_message_box.h",
       "views/upgrade_notification_controller.cc",
diff -r -u --color up/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc nw/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc
--- up/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc	2024-08-26 19:32:19.186587142 +0000
@@ -10,6 +10,15 @@
 
 #include "base/functional/bind.h"
 #include "build/build_config.h"
+
+#include "components/sessions/content/session_tab_helper.h"
+#include "chrome/browser/extensions/tab_helper.h"
+#include "chrome/browser/password_manager/chrome_password_manager_client.h"
+#include "chrome/browser/ui/passwords/manage_passwords_ui_controller.h"
+#include "chrome/browser/external_protocol/external_protocol_observer.h"
+#include "components/content_settings/browser/page_specific_content_settings.h"
+#include "chrome/browser/content_settings/page_specific_content_settings_delegate.h"
+
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/app_mode/app_mode_utils.h"
 #include "chrome/browser/apps/platform_apps/audio_focus_web_contents_observer.h"
@@ -62,10 +71,16 @@
 #include "chrome/browser/printing/printing_init.h"
 #endif
 
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/ui/autofill/chrome_autofill_client.h"
+#include "components/autofill/content/browser/content_autofill_driver_factory.h"
+#include "components/autofill/core/browser/browser_autofill_manager.h"
+#include "chrome/browser/ui/prefs/prefs_tab_helper.h"
+
 namespace {
 
 // Time to wait for an app window to show before allowing Chrome to quit.
-int kAppWindowFirstShowTimeoutSeconds = 10;
+//int kAppWindowFirstShowTimeoutSeconds = 10;
 
 bool disable_external_open_for_testing_ = false;
 
@@ -90,7 +105,7 @@
     new_tab_params.disposition = WindowOpenDisposition::OFF_THE_RECORD;
     new_tab_params.window_action = NavigateParams::SHOW_WINDOW;
   } else {
-    new_tab_params.disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;
+    new_tab_params.disposition = WindowOpenDisposition::NEW_POPUP;
     new_tab_params.window_action = NavigateParams::SHOW_WINDOW;
   }
 
@@ -222,7 +237,8 @@
       is_hidden_(true),
       for_lock_screen_app_(false),
       profile_(profile),
-      new_window_contents_delegate_(new NewWindowContentsDelegate()) {
+      new_window_contents_delegate_(new NewWindowContentsDelegate()),
+      web_contents_(nullptr) {
   if (keep_alive) {
     keep_alive_ = std::make_unique<ScopedKeepAlive>(
         KeepAliveOrigin::CHROME_APP_DELEGATE, KeepAliveRestartOption::DISABLED);
@@ -245,21 +261,36 @@
 }
 
 void ChromeAppDelegate::InitWebContents(content::WebContents* web_contents) {
+  web_contents_ = web_contents;
+
   favicon::CreateContentFaviconDriverForWebContents(web_contents);
 
 #if BUILDFLAG(ENABLE_PRINTING)
   printing::InitializePrintingForWebContents(web_contents);
 #endif
+  // ZoomController comes before common tab helpers since ChromeExtensionWebContentsObserver
+  // may want to register as a ZoomObserver with it.
+  zoom::ZoomController::CreateForWebContents(web_contents);
 
+#if 1
+  extensions::TabHelper::CreateForWebContents(web_contents);
+#else
+  SessionTabHelper::CreateForWebContents(web_contents);
+#endif
   apps::AudioFocusWebContentsObserver::CreateForWebContents(web_contents);
 
 #if BUILDFLAG(IS_CHROMEOS)
   policy::DlpContentTabHelper::MaybeCreateForWebContents(web_contents);
 #endif
 
-  zoom::ZoomController::CreateForWebContents(web_contents);
-
   FileSystemAccessPermissionRequestManager::CreateForWebContents(web_contents);
+  autofill::ChromeAutofillClient::CreateForWebContents(web_contents);
+  ChromePasswordManagerClient::CreateForWebContents(web_contents);
+  ManagePasswordsUIController::CreateForWebContents(web_contents);
+  PrefsTabHelper::CreateForWebContents(web_contents);
+  ExternalProtocolObserver::CreateForWebContents(web_contents);
+  content_settings::PageSpecificContentSettings::CreateForWebContents(web_contents,
+                                                                     std::make_unique<chrome::PageSpecificContentSettingsDelegate>(web_contents));
 }
 
 void ChromeAppDelegate::RenderFrameCreated(
@@ -305,12 +336,14 @@
     const blink::mojom::WindowFeatures& window_features,
     bool user_gesture) {
   if (!disable_external_open_for_testing_) {
+#if 0
     // We don't really want to open a window for |new_contents|, but we need to
     // capture its intended navigation. Here we give ownership to the
     // NewWindowContentsDelegate, which will dispose of the contents once
     // a navigation is captured.
     new_window_contents_delegate_->BecomeOwningDeletageOf(
         std::move(new_contents));
+#endif
     return;
   }
 
@@ -387,6 +420,7 @@
 
 void ChromeAppDelegate::OnHide() {
   is_hidden_ = true;
+#if 0
   if (has_been_shown_) {
     profile_keep_alive_.reset();
     keep_alive_.reset();
@@ -400,17 +434,20 @@
       base::BindOnce(&ChromeAppDelegate::RelinquishKeepAliveAfterTimeout,
                      weak_factory_.GetWeakPtr()),
       base::Seconds(kAppWindowFirstShowTimeoutSeconds));
+#endif
 }
 
 void ChromeAppDelegate::OnShow() {
   has_been_shown_ = true;
   is_hidden_ = false;
+#if 0
   keep_alive_ = std::make_unique<ScopedKeepAlive>(
       KeepAliveOrigin::CHROME_APP_DELEGATE, KeepAliveRestartOption::DISABLED);
   if (!profile_->IsOffTheRecord()) {
     profile_keep_alive_ = std::make_unique<ScopedProfileKeepAlive>(
         profile_, ProfileKeepAliveOrigin::kAppWindow);
   }
+#endif
 }
 
 bool ChromeAppDelegate::TakeFocus(content::WebContents* web_contents,
diff -r -u --color up/chromium/chrome/browser/ui/apps/chrome_app_delegate.h nw/chromium/chrome/browser/ui/apps/chrome_app_delegate.h
--- up/chromium/chrome/browser/ui/apps/chrome_app_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/apps/chrome_app_delegate.h	2024-08-26 19:32:19.186587142 +0000
@@ -95,6 +95,7 @@
   std::unique_ptr<NewWindowContentsDelegate> new_window_contents_delegate_;
   base::OnceClosure terminating_callback_;
   base::CallbackListSubscription subscription_;
+  raw_ptr<content::WebContents> web_contents_;
   base::WeakPtrFactory<ChromeAppDelegate> weak_factory_{this};
 };
 
diff -r -u --color up/chromium/chrome/browser/ui/apps/chrome_app_window_client.cc nw/chromium/chrome/browser/ui/apps/chrome_app_window_client.cc
--- up/chromium/chrome/browser/ui/apps/chrome_app_window_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/apps/chrome_app_window_client.cc	2024-08-26 19:32:19.186587142 +0000
@@ -22,6 +22,7 @@
 #if BUILDFLAG(IS_CHROMEOS_ASH)
 #include "chrome/browser/ash/lock_screen_apps/state_controller.h"
 #endif
+#include "content/nw/src/nw_content.h"
 
 // TODO(jamescook): We probably shouldn't compile this class at all on Android.
 // See http://crbug.com/343612
@@ -48,8 +49,10 @@
   return NULL;
 #else
   Profile* profile = Profile::FromBrowserContext(context);
-  return new extensions::AppWindow(
+  extensions::AppWindow* ret = new extensions::AppWindow(
       context, std::make_unique<ChromeAppDelegate>(profile, true), extension);
+  nw::CreateAppWindowHook(ret);
+  return ret;
 #endif
 }
 
diff -r -u --color up/chromium/chrome/browser/ui/autofill/chrome_autofill_client.cc nw/chromium/chrome/browser/ui/autofill/chrome_autofill_client.cc
--- up/chromium/chrome/browser/ui/autofill/chrome_autofill_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/autofill/chrome_autofill_client.cc	2024-08-26 19:32:19.234587168 +0000
@@ -372,22 +372,26 @@
 }
 
 const translate::LanguageState* ChromeAutofillClient::GetLanguageState() {
+#if 0
   // TODO(crbug.com/41430413): iOS vs other platforms extracts the language from
   // the top level frame vs whatever frame directly holds the form.
   auto* translate_manager =
       ChromeTranslateClient::GetManagerFromWebContents(web_contents());
   if (translate_manager)
     return translate_manager->GetLanguageState();
+#endif
   return nullptr;
 }
 
 translate::TranslateDriver* ChromeAutofillClient::GetTranslateDriver() {
+#if 0
   // TODO(crbug.com/41430413): iOS vs other platforms extracts the language from
   // the top level frame vs whatever frame directly holds the form.
   auto* translate_client =
       ChromeTranslateClient::FromWebContents(web_contents());
   if (translate_client)
     return translate_client->translate_driver();
+#endif
   return nullptr;
 }
 
@@ -718,6 +722,13 @@
 }
 
 bool ChromeAutofillClient::IsContextSecure() const {
+
+  content::NavigationEntry* navigation_entry =
+      web_contents()->GetController().GetLastCommittedEntry();
+
+  if (navigation_entry && navigation_entry->GetURL().SchemeIs("chrome-extension"))
+    return true;
+
   SecurityStateTabHelper* helper =
       SecurityStateTabHelper::FromWebContents(web_contents());
   if (!helper)
diff -r -u --color up/chromium/chrome/browser/ui/browser.cc nw/chromium/chrome/browser/ui/browser.cc
--- up/chromium/chrome/browser/ui/browser.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser.cc	2024-08-26 19:32:19.246587175 +0000
@@ -4,6 +4,14 @@
 
 #include "chrome/browser/ui/browser.h"
 
+#include "extensions/browser/process_manager.h"
+#include "third_party/blink/public/common/renderer_preferences/renderer_preferences.h"
+#include "chrome/browser/web_applications/web_app_helpers.h"
+#include "extensions/common/mojom/event_dispatcher.mojom.h"
+#include "chrome/browser/extensions/api/tabs/tabs_windows_api.h"
+#include "chrome/browser/extensions/api/tabs/tabs_event_router.h"
+#include "components/javascript_dialogs/app_modal_dialog_manager.h"
+
 #include <stddef.h>
 
 #include <algorithm>
@@ -12,6 +20,13 @@
 #include <string>
 #include <utility>
 
+#include "extensions/browser/app_window/app_window.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_base.h"
+#include "content/public/common/content_switches.h"
+#include "ui/display/display.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+
 #include "base/base_paths.h"
 #include "base/command_line.h"
 #include "base/containers/contains.h"
@@ -423,12 +438,19 @@
 // Browser, CreateParams:
 
 Browser::CreateParams::CreateParams(Profile* profile, bool user_gesture)
-    : CreateParams(TYPE_NORMAL, profile, user_gesture) {}
+    : CreateParams(TYPE_POPUP, profile, user_gesture) {}
+
+Browser::CreateParams::CreateParams(Profile* profile, bool user_gesture, const gfx::Rect& bounds)
+  : CreateParams(TYPE_POPUP, profile, user_gesture) {
+  initial_bounds = bounds;
+}
 
 Browser::CreateParams::CreateParams(Type type,
                                     Profile* profile,
                                     bool user_gesture)
-    : type(type), profile(profile), user_gesture(user_gesture) {}
+    : type(type == TYPE_DEVTOOLS ? TYPE_DEVTOOLS : TYPE_POPUP),
+      profile(profile),
+      user_gesture(user_gesture) {}
 
 Browser::CreateParams::CreateParams(const CreateParams& other) = default;
 
@@ -501,6 +523,21 @@
   return params;
 }
 
+void Browser::AddOnDidFinishFirstNavigationCallback(
+    DidFinishFirstNavigationCallback callback) {
+  on_did_finish_first_navigation_callbacks_.push_back(std::move(callback));
+}
+
+void Browser::OnDidFinishFirstNavigation() {
+  if (did_finish_first_navigation_)
+    return;
+  did_finish_first_navigation_ = true;
+  std::vector<DidFinishFirstNavigationCallback> callbacks;
+  std::swap(callbacks, on_did_finish_first_navigation_callbacks_);
+  for (auto&& callback : callbacks)
+    std::move(callback).Run(true /* did_finish */);
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Browser, Constructors, Creation, Showing:
 
@@ -528,11 +565,17 @@
   // not possible, e.g. using the wrong profile or during shutdown. The caller
   // should handle this; see e.g. crbug.com/1141608 and crbug.com/1261628.
   CHECK_EQ(CreationStatus::kOk, GetCreationStatusForProfile(params.profile));
-  return new Browser(params);
+  Browser* ret = new Browser(params);
+  nw::CreateAppWindowHook(nullptr);
+  return ret;
 }
 
 Browser::Browser(const CreateParams& params)
-    : create_params_(params),
+   :  nw_menu_(nullptr),
+      extension_id_(params.extension_id),
+      create_params_(params),
+      frameless_(params.frameless),
+      alpha_enabled_(params.alpha_enabled),
       type_(params.type),
       profile_(params.profile),
       window_(nullptr),
@@ -546,6 +589,7 @@
       tab_menu_model_delegate_(
           std::make_unique<chrome::BrowserTabMenuModelDelegate>(this)),
       app_name_(params.app_name),
+      windows_key_(params.windows_key),
       is_trusted_source_(params.trusted_source),
       session_id_(SessionID::NewUnique()),
       omit_from_session_restore_(params.omit_from_session_restore),
@@ -557,6 +601,13 @@
       initial_visible_on_all_workspaces_state_(
           params.initial_visible_on_all_workspaces_state),
       creation_source_(params.creation_source),
+      initial_ontop_(params.always_on_top),
+      initial_allvisible_(params.all_visible),
+      initial_resizable_(params.resizable),
+      initial_showintaskbar_(params.show_in_taskbar),
+      initial_position_(params.position),
+      title_override_(params.title),
+      icon_override_(params.icon),
       unload_controller_(this),
       content_setting_bubble_model_delegate_(
           new BrowserContentSettingBubbleModelDelegate(this)),
@@ -589,6 +640,11 @@
       overscroll_pref_manager_(std::make_unique<OverscrollPrefManager>(this))
 #endif
 {
+  content::g_support_transparency = !base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kDisableTransparency);
+  if (content::g_support_transparency) {
+    content::g_force_cpu_draw = base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kForceCpuDraw);
+  }
+
   browser_actions_->InitializeBrowserActions();
 
   if (!profile_->IsOffTheRecord()) {
@@ -596,7 +652,6 @@
         params.profile->GetOriginalProfile(),
         ProfileKeepAliveOrigin::kBrowserWindow);
   }
-
   tab_strip_model_->AddObserver(this);
 
   if (tab_groups::IsTabGroupsSaveV2Enabled() &&
@@ -643,6 +698,9 @@
                                                 params.user_gesture,
                                                 params.in_tab_dragging);
 
+  if (!initial_showintaskbar_)
+    window_->SetShowInTaskbar(false);
+
   if (app_controller_)
     app_controller_->UpdateCustomTabBarVisibility(false);
 
@@ -771,6 +829,44 @@
     select_file_dialog_->ListenerDestroyed();
 }
 
+bool Browser::NWCanClose(bool user_force) {
+  const extensions::Extension* extension = GetExtension();
+  if (!extension)
+    return true;
+  //content::RenderFrameHost* rfh = web_contents->GetMainFrame();
+  extensions::EventRouter* event_router = extensions::EventRouter::Get(profile_);
+  std::string listener_extension_id;
+  int instance_id = extensions::ExtensionTabUtil::GetWindowId(this);
+  std::string frame_token;
+  if (tab_strip_model() && tab_strip_model()->GetActiveWebContents())
+    frame_token = tab_strip_model()->GetActiveWebContents()->GetPrimaryMainFrame()->GetFrameToken().ToString();
+  bool listening_to_close = event_router->
+    ExtensionHasEventListener(extension->id(), extensions::api::windows::OnRemoving::kEventName,
+			      frame_token, &listener_extension_id);
+  if (listening_to_close) {
+    std::unique_ptr<base::Value::List> args(new base::Value::List());
+    args->Append(session_id().id());
+    if (user_force)
+      args->Append("quit");
+    auto event =
+      std::make_unique<extensions::Event>(extensions::events::UNKNOWN,
+                                          extensions::api::windows::OnRemoving::kEventName,
+                                          std::move(*args), profile());
+    event->filter_info = extensions::mojom::EventFilteringInfo::New();
+    event->filter_info->window_exposed_by_default = true;
+    event->filter_info->instance_id = instance_id;
+    event_router->BroadcastEvent(std::move(event));
+    return false;
+  }
+  return true;
+}
+
+const extensions::Extension* Browser::GetExtension() const {
+  return extensions::ExtensionRegistry::Get(profile_)
+      ->enabled_extensions()
+      .GetByID(extension_id_);
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Getters & Setters
 
@@ -809,6 +905,8 @@
 }
 
 gfx::Image Browser::GetCurrentPageIcon() const {
+  if (!icon_override_.IsEmpty())
+    return icon_override_;
   WebContents* web_contents = tab_strip_model_->GetActiveWebContents();
   // |web_contents| can be NULL since GetCurrentPageIcon() is called by the
   // window during the window's creation (before tabs have been added).
@@ -908,7 +1006,25 @@
 
   // |contents| can be NULL because GetWindowTitleForCurrentTab is called by the
   // window during the window's creation (before tabs have been added).
-  if (title.empty() && contents) {
+  std::u16string override = base::UTF8ToUTF16(title_override_);
+
+  // |contents| can be NULL because GetWindowTitleForCurrentTab is called by the
+  // window during the window's creation (before tabs have been added).
+  content::NavigationEntry* entry = contents ?
+      contents->GetController().GetLastCommittedEntry() : nullptr;
+  if (!entry || entry->GetTitle().empty()) {
+    if (override.empty()) {
+      const std::string extension_id =
+        web_app::GetAppIdFromApplicationName(app_name());
+      const Extension* extension =
+        extensions::ExtensionRegistry::Get(profile())
+          ->GetExtensionById(extension_id,
+                             extensions::ExtensionRegistry::EVERYTHING);
+      if (extension)
+        title = base::UTF8ToUTF16(extension->name());
+    } else
+      title = override;
+  } else if (title.empty() && contents) {
     title = FormatTitleForDisplay(app_controller_ ? app_controller_->GetTitle()
                                                   : contents->GetTitle());
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
@@ -932,10 +1048,13 @@
   if (title.empty() && (is_type_normal() || is_type_popup()))
     title = CoreTabHelper::GetDefaultTitle();
 
+  if (title.empty() && is_type_app())
+    return override;
 #if BUILDFLAG(IS_MAC)
   // On Mac, we don't want to suffix the page title with the application name.
   return title;
 #else
+
   // If there is no title and this is an app, fall back on the app name. This
   // ensures that the native window gets a title which is important for a11y,
   // for example the window selector uses the Aura window title.
@@ -1238,6 +1357,7 @@
 // Browser, Tab adding/showing functions:
 
 void Browser::WindowFullscreenStateChanged() {
+  if (exclusive_access_manager_)
   exclusive_access_manager_->fullscreen_controller()
       ->WindowFullscreenStateChanged();
   command_controller_->FullscreenStateChanged();
@@ -1925,12 +2045,12 @@
     // cannot switch their independent spaces simultaneously (crbug.com/1315749)
     fullscreen_controller->RunOrDeferUntilTransitionIsComplete(base::BindOnce(
         &chrome::AddWebContents, this, source, std::move(new_contents),
-        target_url, disposition, window_features, window_action));
+        target_url, disposition, window_features, window_action, tmp_manifest()));
     return;
   }
 
   chrome::AddWebContents(this, source, std::move(new_contents), target_url,
-                         disposition, window_features, window_action);
+                         disposition, window_features, window_action, tmp_manifest());
 }
 
 void Browser::ActivateContents(WebContents* contents) {
@@ -1947,6 +2067,24 @@
                                   bool should_show_loading_ui) {
   ScheduleUIUpdate(source, content::INVALIDATE_TYPE_LOAD);
   UpdateWindowForLoadingStateChanged(source, should_show_loading_ui);
+  std::string nwstatus;
+  if (source->IsLoading()) {
+    nwstatus = "loading";
+    last_to_different_document_ = should_show_loading_ui ? 1 : 0;
+    if (!should_show_loading_ui) //NWJS#5001
+      return;
+  } else {
+    if (last_to_different_document_ == 0)
+      return;
+    nwstatus = "loaded";
+  }
+  extensions::TabsWindowsAPI* tabs_window_api = extensions::TabsWindowsAPI::Get(profile_);
+  if (!tabs_window_api)
+    return;
+  extensions::TabsEventRouter* tabs_event_router = tabs_window_api->tabs_event_router();
+  if (!tabs_event_router)
+    return;
+  tabs_event_router->NWStatusUpdated(source, nwstatus);
 }
 
 void Browser::CloseContents(WebContents* source) {
@@ -2003,7 +2141,7 @@
 }
 
 void Browser::ContentsZoomChange(bool zoom_in) {
-  chrome::ExecuteCommand(this, zoom_in ? IDC_ZOOM_PLUS : IDC_ZOOM_MINUS);
+  //chrome::ExecuteCommand(this, zoom_in ? IDC_ZOOM_PLUS : IDC_ZOOM_MINUS);
 }
 
 bool Browser::TakeFocus(content::WebContents* source, bool reverse) {
@@ -2100,13 +2238,21 @@
                                  int opener_render_frame_id,
                                  const std::string& frame_name,
                                  const GURL& target_url,
-                                 WebContents* new_contents) {
+                                 WebContents* new_contents, const std::u16string& nw_window_manifest) {
   // Adopt the WebContents now, so all observers are in place, as the network
   // requests for its initial navigation will start immediately. The WebContents
   // will later be inserted into this browser using Browser::Navigate via
   // AddNewContents.
   TabHelpers::AttachTabHelpers(new_contents);
-
+  extensions::AppWindow::CreateParams params;
+  std::string js_doc_start, js_doc_end;
+  nw::CalcNewWinParams(new_contents, &params, &js_doc_start, &js_doc_end, std::string());
+  nw::SetCurrentNewWinManifest(std::u16string());
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_start = js_doc_start;
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_end = js_doc_end;
+  new_contents->SyncRendererPrefs();
   // Make the tab show up in the task manager.
   task_manager::WebContentsTags::CreateForTabContents(new_contents);
 }
@@ -2115,6 +2261,7 @@
     WebContents* source,
     content::RenderWidgetHost* render_widget_host,
     base::RepeatingClosure hang_monitor_restarter) {
+#if 0
   // Don't show the page hung dialog when a HTML popup hangs because
   // the dialog will take the focus and immediately close the popup.
   RenderWidgetHostView* view = render_widget_host->GetView();
@@ -2122,6 +2269,7 @@
     TabDialogs::FromWebContents(source)->ShowHungRendererDialog(
         render_widget_host, std::move(hang_monitor_restarter));
   }
+#endif
 }
 
 void Browser::RendererResponsive(
@@ -2136,7 +2284,8 @@
 
 content::JavaScriptDialogManager* Browser::GetJavaScriptDialogManager(
     WebContents* source) {
-  return javascript_dialogs::TabModalDialogManager::FromWebContents(source);
+  //return javascript_dialogs::TabModalDialogManager::FromWebContents(source);
+  return javascript_dialogs::AppModalDialogManager::GetInstance();
 }
 
 bool Browser::GuestSaveFrame(content::WebContents* guest_web_contents) {
@@ -2171,6 +2320,7 @@
   if (app_controller_) {
     app_controller_->DraggableRegionsChanged(regions, contents);
   }
+  window()->UpdateDraggableRegions(regions);
 }
 
 void Browser::DidFinishNavigation(
@@ -2182,6 +2332,7 @@
   if (navigation_handle->IsInPrimaryMainFrame() &&
       navigation_handle->HasCommitted()) {
     UpdateBookmarkBarState(BOOKMARK_BAR_STATE_CHANGE_TAB_STATE);
+    OnDidFinishFirstNavigation();
   }
 }
 
@@ -2621,12 +2772,14 @@
 
 void Browser::OnIsPageTranslatedChanged(content::WebContents* source) {
   DCHECK(source);
+#if 0
   if (tab_strip_model_->GetActiveWebContents() == source) {
     window_->SetTranslateIconToggled(
         ChromeTranslateClient::FromWebContents(source)
             ->GetLanguageState()
             .IsPageTranslated());
   }
+#endif
 }
 
 void Browser::OnTranslateEnabledChanged(content::WebContents* source) {
@@ -3142,18 +3295,18 @@
   // ...and all the helpers.
   WebContentsModalDialogManager::FromWebContents(web_contents)
       ->SetDelegate(delegate);
-  translate::ContentTranslateDriver* content_translate_driver =
-      ChromeTranslateClient::FromWebContents(web_contents)->translate_driver();
+  //translate::ContentTranslateDriver* content_translate_driver =
+  //    ChromeTranslateClient::FromWebContents(web_contents)->translate_driver();
   zoom::ZoomController* zoom_controller =
       zoom::ZoomController::FromWebContents(web_contents);
   if (delegate) {
     zoom_controller->AddObserver(this);
-    content_translate_driver->AddTranslationObserver(this);
+    //content_translate_driver->AddTranslationObserver(this);
     BookmarkTabHelper::FromWebContents(web_contents)->AddObserver(this);
     web_contents_collection_.StartObserving(web_contents);
   } else {
     zoom_controller->RemoveObserver(this);
-    content_translate_driver->RemoveTranslationObserver(this);
+    //content_translate_driver->RemoveTranslationObserver(this);
     BookmarkTabHelper::FromWebContents(web_contents)->RemoveObserver(this);
     web_contents_collection_.StopObserving(web_contents);
   }
@@ -3203,33 +3356,38 @@
 
 bool Browser::NormalBrowserSupportsWindowFeature(WindowFeature feature,
                                                  bool check_can_support) const {
-  bool fullscreen = ShouldHideUIForFullscreen();
+  //bool fullscreen = ShouldHideUIForFullscreen();
   switch (feature) {
     case FEATURE_BOOKMARKBAR:
-      return true;
+      return false;
     case FEATURE_TABSTRIP:
     case FEATURE_TOOLBAR:
     case FEATURE_LOCATIONBAR:
-      return check_can_support || !fullscreen;
+      return false;
     case FEATURE_TITLEBAR:
     case FEATURE_NONE:
       return false;
+    case FEATURE_NW_FRAMELESS:
+      return true;
   }
 }
 
 bool Browser::PopupBrowserSupportsWindowFeature(WindowFeature feature,
                                                 bool check_can_support) const {
-  bool fullscreen = ShouldHideUIForFullscreen();
+  //bool fullscreen = ShouldHideUIForFullscreen();
 
   switch (feature) {
     case FEATURE_TITLEBAR:
+      return true;
     case FEATURE_LOCATIONBAR:
-      return check_can_support || (!fullscreen && !is_trusted_source());
+      return false; //check_can_support || (!fullscreen && !is_trusted_source());
     case FEATURE_TABSTRIP:
     case FEATURE_TOOLBAR:
     case FEATURE_BOOKMARKBAR:
     case FEATURE_NONE:
       return false;
+    case FEATURE_NW_FRAMELESS:
+      return true;
   }
 }
 
@@ -3274,6 +3432,8 @@
     case FEATURE_BOOKMARKBAR:
     case FEATURE_NONE:
       return false;
+    case FEATURE_NW_FRAMELESS:
+      return true;
   }
 }
 
@@ -3299,6 +3459,7 @@
     bool check_can_support) const {
   switch (feature) {
     case FEATURE_TITLEBAR:
+    case FEATURE_NW_FRAMELESS:
       return true;
     case FEATURE_LOCATIONBAR:
     case FEATURE_TABSTRIP:
diff -r -u --color up/chromium/chrome/browser/ui/browser.h nw/chromium/chrome/browser/ui/browser.h
--- up/chromium/chrome/browser/ui/browser.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser.h	2024-08-26 19:32:19.246587175 +0000
@@ -13,6 +13,8 @@
 #include <vector>
 
 #include "base/functional/callback.h"
+#include "ui/gfx/image/image.h"
+
 #include "base/gtest_prod_util.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/scoped_refptr.h"
@@ -84,6 +86,10 @@
 class SavedTabGroupModel;
 }
 
+namespace extensions {
+class Extension;
+}
+
 namespace blink {
 enum class ProtocolHandlerSecurityLevel;
 }
@@ -110,6 +116,10 @@
 struct SelectedFileInfo;
 }
 
+namespace nw {
+  class Menu;
+}
+
 namespace web_app {
 class AppBrowserController;
 }
@@ -148,6 +158,13 @@
                 public ui::SelectFileDialog::Listener,
                 public BrowserWindowInterface {
  public:
+  using DidFinishFirstNavigationCallback =
+                      base::OnceCallback<void(bool did_finish)>;
+  void AddOnDidFinishFirstNavigationCallback(
+                      DidFinishFirstNavigationCallback callback);
+  bool DidFinishFirstNavigation() { return did_finish_first_navigation_; }
+  // Called when first navigation was completed.
+  void OnDidFinishFirstNavigation();
   // SessionService::WindowType mirrors these values.  If you add to this
   // enum, look at SessionService::WindowType to see if it needs to be
   // updated.
@@ -197,6 +214,7 @@
     FEATURE_TOOLBAR = 1 << 2,
     FEATURE_LOCATIONBAR = 1 << 3,
     FEATURE_BOOKMARKBAR = 1 << 4,
+    FEATURE_NW_FRAMELESS = 1 << 5
     // TODO(crbug.com/40639933): Add FEATURE_PAGECONTROLS to describe the
     // presence of per-page controls such as Content Settings Icons, which
     // should be decoupled from FEATURE_LOCATIONBAR as they have independent
@@ -264,6 +282,7 @@
 
   struct CreateParams {
     explicit CreateParams(Profile* profile, bool user_gesture);
+    explicit CreateParams(Profile* profile, bool user_gesture, const gfx::Rect& bounds);
     CreateParams(Type type, Profile* profile, bool user_gesture);
     CreateParams(const CreateParams& other);
     CreateParams& operator=(const CreateParams& other);
@@ -288,6 +307,16 @@
 
     static CreateParams CreateForDevTools(Profile* profile);
 
+    std::string extension_id;
+    bool frameless = false;
+    bool alpha_enabled = false;
+    bool always_on_top = false;
+    bool all_visible = false;
+    bool resizable = true;
+    bool show_in_taskbar = true;
+    std::string title;
+    std::string position;
+    gfx::Image icon;
     // The browser type.
     Type type;
 
@@ -296,6 +325,7 @@
 
     // Specifies the browser `is_trusted_source_` value.
     bool trusted_source = false;
+    std::string windows_key;
 
     // Specifies the browser `omit_from_session_restore_` value, whether the new
     // Browser should be omitted from being saved/restored by session restore.
@@ -421,8 +451,15 @@
   Browser(const Browser&) = delete;
   Browser& operator=(const Browser&) = delete;
 
+  raw_ptr<nw::Menu> nw_menu_ = nullptr;
+
+  std::string extension_id_;
+
   ~Browser() override;
 
+  const extensions::Extension* GetExtension() const;
+  bool NWCanClose(bool user_force = false);
+
   // Set overrides for the initial window bounds and maximized state.
   void set_override_bounds(const gfx::Rect& bounds) {
     override_bounds_ = bounds;
@@ -431,6 +468,16 @@
   void set_initial_show_state(ui::WindowShowState initial_show_state) {
     initial_show_state_ = initial_show_state;
   }
+
+  void set_title_override(const std::string& title) { title_override_ = title; }
+
+  bool initial_ontop() const { return initial_ontop_; }
+  bool initial_allvisible() const { return initial_allvisible_; }
+  bool initial_resizable() const { return initial_resizable_; }
+  bool initial_showintaskbar() const { return initial_showintaskbar_; }
+  const std::string& initial_position() const { return initial_position_; }
+  gfx::Image icon_override() const { return icon_override_; }
+
   // Return true if the initial window bounds have been overridden.
   bool bounds_overridden() const { return !override_bounds_.IsEmpty(); }
   // Set indicator that this browser is being created via session restore.
@@ -463,7 +510,12 @@
   Type type() const { return type_; }
   const std::string& app_name() const { return app_name_; }
   const std::string& user_title() const { return user_title_; }
+  const std::string& windows_key() const { return windows_key_; }
   bool is_trusted_source() const { return is_trusted_source_; }
+  bool is_frameless() const { return frameless_; }
+  bool is_transparent() const {
+    return alpha_enabled_;
+  }
   Profile* profile() const { return profile_; }
   gfx::Rect override_bounds() const { return override_bounds_; }
   const std::string& initial_workspace() const { return initial_workspace_; }
@@ -884,6 +936,11 @@
   GetWebContentsModalDialogHostForWindow() override;
 
  private:
+  int last_to_different_document_ = -1;
+  std::vector<DidFinishFirstNavigationCallback> on_did_finish_first_navigation_callbacks_;
+  // Whether the first navigation was completed in both browser and renderer
+  // processes.
+  bool did_finish_first_navigation_ = false;
   friend class BrowserTest;
   friend class ExclusiveAccessTest;
   friend class FullscreenControllerInteractiveTest;
@@ -993,7 +1050,7 @@
                           int opener_render_frame_id,
                           const std::string& frame_name,
                           const GURL& target_url,
-                          content::WebContents* new_contents) override;
+                          content::WebContents* new_contents, const std::u16string& nw_window_manifest) override;
   void RendererUnresponsive(
       content::WebContents* source,
       content::RenderWidgetHost* render_widget_host,
@@ -1282,6 +1339,10 @@
   // This Browser's create params.
   const CreateParams create_params_;
 
+  bool frameless_;
+
+  bool alpha_enabled_;
+
   // This Browser's type.
   const Type type_;
 
@@ -1304,6 +1365,7 @@
   // 1) we launch an application via an application shortcut or extension API.
   // 2) we launch an undocked devtool window.
   const std::string app_name_;
+  const std::string windows_key_;
 
   // True if the source is trusted (i.e. we do not need to show the URL in a
   // a popup window). Also used to determine which app windows to save and
@@ -1361,6 +1423,13 @@
   bool initial_visible_on_all_workspaces_state_;
 
   CreationSource creation_source_ = CreationSource::kUnknown;
+  bool initial_ontop_;
+  bool initial_allvisible_;
+  bool initial_resizable_;
+  bool initial_showintaskbar_;
+  std::string initial_position_;
+  std::string title_override_;
+  gfx::Image icon_override_;
 
   UnloadController unload_controller_;
 
diff -r -u --color up/chromium/chrome/browser/ui/browser_command_controller.cc nw/chromium/chrome/browser/ui/browser_command_controller.cc
--- up/chromium/chrome/browser/ui/browser_command_controller.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_command_controller.cc	2024-08-26 19:32:19.246587175 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "chrome/browser/ui/browser_command_controller.h"
+#include "content/nw/src/common/shell_switches.h"
 
 #include <stddef.h>
 
@@ -1611,6 +1612,7 @@
   UpdateCommandAndActionEnabled(IDC_QRCODE_GENERATOR, kActionQrCodeGenerator,
                                 CanGenerateQrCode(browser_));
 
+#if 0
   ChromeTranslateClient* chrome_translate_client =
       ChromeTranslateClient::FromWebContents(current_web_contents);
   const bool can_translate =
@@ -1618,6 +1620,7 @@
       chrome_translate_client->GetTranslateManager()->CanManuallyTranslate();
   UpdateCommandAndActionEnabled(IDC_SHOW_TRANSLATE, kActionShowTranslate,
                                 can_translate);
+#endif
 
   bool is_isolated_app = current_web_contents->GetPrimaryMainFrame()
                              ->GetWebExposedIsolationLevel() ==
@@ -1675,6 +1678,10 @@
 
   bool dev_tools_enabled = DevToolsWindow::AllowDevToolsFor(
       profile(), browser_->tab_strip_model()->GetActiveWebContents());
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableDevTools))
+    dev_tools_enabled = false;
   command_updater_.UpdateCommandEnabled(IDC_DEV_TOOLS, dev_tools_enabled);
   command_updater_.UpdateCommandEnabled(IDC_DEV_TOOLS_CONSOLE,
                                         dev_tools_enabled);
diff -r -u --color up/chromium/chrome/browser/ui/browser_commands.cc nw/chromium/chrome/browser/ui/browser_commands.cc
--- up/chromium/chrome/browser/ui/browser_commands.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_commands.cc	2024-08-26 19:32:19.250587177 +0000
@@ -563,6 +563,7 @@
 }
 
 void NewEmptyWindow(Profile* profile, bool should_trigger_session_restore) {
+#if 0
   bool off_the_record = profile->IsOffTheRecord();
   PrefService* prefs = profile->GetPrefs();
   if (off_the_record) {
@@ -602,6 +603,7 @@
       OpenEmptyWindow(profile->GetOriginalProfile());
     }
   }
+#endif
 }
 
 Browser* OpenEmptyWindow(Profile* profile,
@@ -1578,6 +1580,7 @@
 }
 
 void ShowTranslateBubble(Browser* browser) {
+#if 0
   if (!browser->window()->IsActive()) {
     return;
   }
@@ -1620,6 +1623,7 @@
   browser->window()->ShowTranslateBubble(
       web_contents, step, source_language, target_language,
       translate::TranslateErrors::NONE, true);
+#endif
 }
 
 void ManagePasswordsForPage(Browser* browser) {
diff -r -u --color up/chromium/chrome/browser/ui/browser_list.cc nw/chromium/chrome/browser/ui/browser_list.cc
--- up/chromium/chrome/browser/ui/browser_list.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_list.cc	2024-08-26 19:32:19.250587177 +0000
@@ -267,7 +267,8 @@
 // static
 void BrowserList::MoveBrowsersInWorkspaceToFront(
     const std::string& new_workspace) {
-  DCHECK(!new_workspace.empty());
+  if(new_workspace.empty())
+    return;
 
   BrowserList* instance = GetInstance();
 
diff -r -u --color up/chromium/chrome/browser/ui/browser_navigator.cc nw/chromium/chrome/browser/ui/browser_navigator.cc
--- up/chromium/chrome/browser/ui/browser_navigator.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_navigator.cc	2024-08-26 19:32:19.250587177 +0000
@@ -10,6 +10,10 @@
 #include <string_view>
 #include <utility>
 
+#include "chrome/browser/ui/views/frame/browser_frame.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "content/browser/web_contents/web_contents_impl.h"
+
 #include "base/memory/raw_ptr.h"
 #include "base/notreached.h"
 #include "base/strings/utf_string_conversions.h"
@@ -80,6 +84,12 @@
 #include "components/captive_portal/content/captive_portal_tab_helper.h"
 #endif
 
+#include "third_party/blink/public/mojom/renderer_preferences.mojom.h"
+
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/common/shell_switches.h"
+
 using content::GlobalRequestID;
 using content::NavigationController;
 using content::WebContents;
@@ -121,6 +131,14 @@
 
 // Finds an existing Browser compatible with |profile|, making a new one if no
 // such Browser is located.
+Browser* GetOrCreateBrowser(Profile* profile, const NavigateParams& params) {
+  Browser* browser = chrome::FindTabbedBrowser(profile, false);
+  Browser::CreateParams browser_params(profile, params.user_gesture, params.window_features.bounds);
+  browser_params.frameless = params.frameless;
+  return browser ? browser
+    : Browser::Create(browser_params);
+}
+
 Browser* GetOrCreateBrowser(Profile* profile, bool user_gesture) {
   Browser* browser = chrome::FindTabbedBrowser(profile, false);
 
@@ -287,7 +305,7 @@
 
       // Find a compatible window and re-execute this command in it. Otherwise
       // re-run with NEW_WINDOW.
-      return {GetOrCreateBrowser(profile, params.user_gesture), -1};
+      return {GetOrCreateBrowser(profile, params), -1};
     case WindowOpenDisposition::NEW_PICTURE_IN_PICTURE:
 #if !BUILDFLAG(IS_ANDROID)
     {
@@ -368,9 +386,11 @@
       Browser* browser = nullptr;
       if (Browser::GetCreationStatusForProfile(profile) ==
           Browser::CreationStatus::kOk) {
-        browser = Browser::Create(
-            Browser::CreateParams(profile, params.user_gesture));
+      Browser::CreateParams browser_params(profile, params.user_gesture, params.window_features.bounds);
+      browser_params.frameless = params.frameless;
+      browser = Browser::Create(browser_params);
       }
+
       return {browser, -1};
     }
     case WindowOpenDisposition::OFF_THE_RECORD:
@@ -487,6 +507,11 @@
   load_url_params.impression = params->impression;
   load_url_params.suggested_system_entropy = params->suggested_system_entropy;
 
+  bool new_site = params->url.SchemeIs("chrome") || !nw::PinningRenderer();
+  if (params->block_parser && !new_site) {
+    load_url_params.block_parser = true;
+  }
+
   // |frame_tree_node_id| is kNoFrameTreeNodeId for main frame navigations.
   if (params->frame_tree_node_id ==
       content::RenderFrameHost::kNoFrameTreeNodeId) {
@@ -544,6 +569,11 @@
         (*contents_)->Focus();
         window->Activate();
       }
+    } else if (params_->window_action == NavigateParams::SHOW_WINDOW_FULLSCREEN) {
+      BrowserWindow* window2 = params_->browser->window();
+      BrowserFrame* frame = BrowserView::GetBrowserViewForBrowser(params_->browser)->frame();
+      frame->SetFullscreen(true);
+      window2->Show();
     }
   }
 
@@ -606,6 +636,28 @@
   apps::SetAppIdForWebContents(params.browser->profile(), target_contents.get(),
                                params.app_id);
 
+  nw::Package* package = nw::package();
+  std::string js_doc_start(params.inject_js_start), js_doc_end(params.inject_js_end);
+  if (js_doc_start.empty()) {
+    std::string* str = package->root()->FindString(::switches::kmInjectJSDocStart);
+    if (str)
+      js_doc_start = *str;
+  }
+  target_contents->GetMutableRendererPrefs()->nw_inject_js_doc_start = js_doc_start;
+  if (js_doc_end.empty()) {
+    std::string* str = package->root()->FindString(::switches::kmInjectJSDocEnd);
+    if (str)
+      js_doc_end = *str;
+  }
+  target_contents->GetMutableRendererPrefs()->nw_inject_js_doc_end = js_doc_end;
+  bool new_site = params.url.SchemeIs("chrome") || !nw::PinningRenderer();
+  if (params.block_parser && !new_site) {
+    static_cast<content::WebContentsImpl*>(target_contents.get())->SetSkipBlockingParser(false);
+    target_contents->GetPrimaryMainFrame()->set_skip_blocking_parser(false);
+  }
+  if (!js_doc_start.empty() || !js_doc_end.empty())
+    target_contents->SyncRendererPrefs();
+
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   captive_portal::CaptivePortalTabHelper::FromWebContents(target_contents.get())
       ->set_window_type(params.captive_portal_window_type);
diff -r -u --color up/chromium/chrome/browser/ui/browser_navigator_params.h nw/chromium/chrome/browser/ui/browser_navigator_params.h
--- up/chromium/chrome/browser/ui/browser_navigator_params.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_navigator_params.h	2024-08-26 19:32:19.250587177 +0000
@@ -120,6 +120,8 @@
   // url is about:blank or about:srcdoc.
   std::optional<GURL> initiator_base_url;
 
+  bool block_parser = false;
+  std::string inject_js_start, inject_js_end;
   // The frame name to be used for the main frame.
   std::string frame_name;
 
@@ -224,7 +226,8 @@
     // Note: This may cause a space / virtual desktop switch if the window is
     // being shown on a display which is currently showing a fullscreen app.
     // (crbug.com/1315749).
-    SHOW_WINDOW_INACTIVE
+    SHOW_WINDOW_INACTIVE,
+    SHOW_WINDOW_FULLSCREEN
   };
   // Default is NO_ACTION (don't show or activate the window).
   // If disposition is NEW_WINDOW or NEW_POPUP, and |window_action| is set to
@@ -241,7 +244,7 @@
 
   // If false then the navigation was not initiated by a user gesture.
   bool user_gesture = true;
-
+  bool frameless = false;
   // What to do with the path component of the URL for singleton navigations.
   enum PathBehavior {
     // Two URLs with differing paths are different.
diff -r -u --color up/chromium/chrome/browser/ui/browser_tab_strip_tracker.cc nw/chromium/chrome/browser/ui/browser_tab_strip_tracker.cc
--- up/chromium/chrome/browser/ui/browser_tab_strip_tracker.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_tab_strip_tracker.cc	2024-08-26 19:32:19.250587177 +0000
@@ -78,3 +78,4 @@
   // observer is not in the ObserverList (i.e. if |browser| is not tracked).
   browser->tab_strip_model()->RemoveObserver(tab_strip_model_observer_);
 }
+
diff -r -u --color up/chromium/chrome/browser/ui/browser_tabstrip.cc nw/chromium/chrome/browser/ui/browser_tabstrip.cc
--- up/chromium/chrome/browser/ui/browser_tabstrip.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_tabstrip.cc	2024-08-26 19:32:19.250587177 +0000
@@ -4,6 +4,12 @@
 
 #include "chrome/browser/ui/browser_tabstrip.h"
 
+#include "base/json/json_reader.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_base.h"
+#include "third_party/blink/public/common/renderer_preferences/renderer_preferences.h"
+
 #include "base/command_line.h"
 #include "base/feature_list.h"
 #include "chrome/browser/ui/browser.h"
@@ -75,18 +81,53 @@
                     const GURL& target_url,
                     WindowOpenDisposition disposition,
                     const blink::mojom::WindowFeatures& window_features,
-                    NavigateParams::WindowAction window_action) {
+                    NavigateParams::WindowAction window_action,
+		    std::string manifest) {
   // No code for this yet.
   DCHECK(disposition != WindowOpenDisposition::SAVE_TO_DISK);
   // Can't create a new contents for the current tab - invalid case.
   DCHECK(disposition != WindowOpenDisposition::CURRENT_TAB);
 
+  gfx::Rect rect = window_features.bounds;
+  bool has_frame = true;
+  bool fullscreen = false;
+  if (!manifest.empty()) {
+    std::optional<base::Value> root = base::JSONReader::Read(manifest);
+    if (root && root->is_dict()) {
+      base::Value::Dict* mnfst = root->GetIfDict();
+      std::optional<int> width = mnfst->FindInt("width");
+      if (width)
+        rect.set_width(*width);
+      std::optional<int> height = mnfst->FindInt("height");
+      if (height)
+        rect.set_height(*height);
+      std::optional<int> x = mnfst->FindInt("x");
+      if (x)
+        rect.set_x(*x);
+      std::optional<int> y = mnfst->FindInt("y");
+      if (y)
+        rect.set_y(*y);
+      has_frame = mnfst->FindBool("frame").value_or(true);
+      fullscreen = mnfst->FindBool("fullscreen").value_or(false);
+    }
+  }
+  extensions::AppWindow::CreateParams params0;
+  std::string js_doc_start, js_doc_end;
+  nw::CalcNewWinParams(new_contents.get(), &params0, &js_doc_start, &js_doc_end, manifest);
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_start = js_doc_start;
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_end = js_doc_end;
+  new_contents->SyncRendererPrefs();
+
   NavigateParams params(browser, std::move(new_contents));
   params.source_contents = source_contents;
   params.url = target_url;
   params.disposition = disposition;
   params.window_features = window_features;
-  params.window_action = window_action;
+  params.window_features.bounds = rect;
+  params.window_action = fullscreen ? NavigateParams::SHOW_WINDOW_FULLSCREEN : window_action;
+  params.frameless = !has_frame;
   // At this point, we're already beyond the popup blocker. Even if the popup
   // was created without a user gesture, we have to set |user_gesture| to true,
   // so it gets correctly focused.
diff -r -u --color up/chromium/chrome/browser/ui/browser_tabstrip.h nw/chromium/chrome/browser/ui/browser_tabstrip.h
--- up/chromium/chrome/browser/ui/browser_tabstrip.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_tabstrip.h	2024-08-26 19:32:19.250587177 +0000
@@ -65,7 +65,8 @@
     const GURL& target_url,
     WindowOpenDisposition disposition,
     const blink::mojom::WindowFeatures& window_features,
-    NavigateParams::WindowAction window_action = NavigateParams::SHOW_WINDOW);
+    NavigateParams::WindowAction window_action = NavigateParams::SHOW_WINDOW,
+    std::string manifest = std::string());
 
 // Closes the specified WebContents in the specified Browser. If
 // |add_to_history| is true, an entry in the historical tab database is created.
diff -r -u --color up/chromium/chrome/browser/ui/browser_window.h nw/chromium/chrome/browser/ui/browser_window.h
--- up/chromium/chrome/browser/ui/browser_window.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_window.h	2024-08-26 19:32:19.254587179 +0000
@@ -10,6 +10,8 @@
 #include <string>
 #include <vector>
 
+#include "third_party/blink/public/mojom/page/draggable_region.mojom-forward.h"
+
 #include "base/feature_list.h"
 #include "base/functional/callback_forward.h"
 #include "base/functional/callback_helpers.h"
@@ -45,6 +47,8 @@
 #error This file should only be included on desktop.
 #endif
 
+class SkRegion;
+
 class Browser;
 class DownloadBubbleUIController;
 class DownloadShelf;
@@ -154,6 +158,15 @@
 
   //////////////////////////////////////////////////////////////////////////////
   // Browser specific methods:
+  virtual void SetShowInTaskbar(bool) = 0;
+  virtual void SetResizable(bool) = 0;
+  virtual void SetAllVisible(bool) = 0;
+  virtual void SetMinimumSize(gfx::Size) = 0;
+  virtual void SetMaximumSize(gfx::Size) = 0;
+  virtual void UpdateDraggableRegions(
+                                      const std::vector<blink::mojom::DraggableRegionPtr>& regions) = 0;
+  virtual SkRegion* GetDraggableRegion() = 0;
+  virtual void NativeWindowChanged() = 0;
 
   // Returns the browser window currently hosting `web_contents`. If no browser
   // window exists this returns null.
@@ -298,6 +311,10 @@
   // be called after the TabStripModel has an active tab.
   virtual void SetContentsSize(const gfx::Size& size) = 0;
 
+#if defined(OS_WIN)
+  virtual void SetPosition(const gfx::Point& pos) = 0;
+#endif
+
   // Updates the visual state of the specified page action icon if present on
   // the window.
   virtual void UpdatePageActionIcon(PageActionIconType type) = 0;
diff -r -u --color up/chromium/chrome/browser/ui/browser_window_state.cc nw/chromium/chrome/browser/ui/browser_window_state.cc
--- up/chromium/chrome/browser/ui/browser_window_state.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_window_state.cc	2024-08-26 19:32:19.254587179 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/ui/browser_window_state.h"
 
+#include "content/nw/src/nw_base.h"
+
 #include <stddef.h>
 
 #include <string_view>
@@ -42,6 +44,8 @@
 }  // namespace
 
 std::string GetWindowName(const Browser* browser) {
+  if (browser->is_type_popup() && !browser->windows_key().empty())
+    return browser->windows_key();
   switch (browser->type()) {
     case Browser::TYPE_NORMAL:
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -108,11 +112,16 @@
 }
 
 bool SavedBoundsAreContentBounds(const Browser* browser) {
+  return !browser->is_type_devtools();
+#if 0
   // Applications other than web apps (such as devtools) save their window size.
   // Web apps, on the other hand, have the same behavior as popups, and save
   // their content bounds.
   return !browser->is_type_normal() && !browser->is_type_devtools() &&
          !browser->is_trusted_source();
+  // bounds should be content bounds for NW.js apps
+         //!browser->is_trusted_source();
+#endif
 }
 
 void SaveWindowPlacement(const Browser* browser,
@@ -142,14 +151,15 @@
   }
 }
 
-void GetSavedWindowBoundsAndShowState(const Browser* browser,
+bool GetSavedWindowBoundsAndShowState(const Browser* browser,
                                       gfx::Rect* bounds,
                                       ui::WindowShowState* show_state) {
   DCHECK(browser);
   DCHECK(bounds);
   DCHECK(show_state);
+
   *bounds = browser->override_bounds();
-  WindowSizer::GetBrowserWindowBoundsAndShowState(*bounds, browser, bounds,
+  bool ret = WindowSizer::GetBrowserWindowBoundsAndShowState(*bounds, browser, bounds,
                                                   show_state);
 
   const base::CommandLine& parsed_command_line =
@@ -157,6 +167,7 @@
 
   internal::UpdateWindowBoundsAndShowStateFromCommandLine(parsed_command_line,
                                                           bounds, show_state);
+  return ret;
 }
 
 namespace internal {
diff -r -u --color up/chromium/chrome/browser/ui/browser_window_state.h nw/chromium/chrome/browser/ui/browser_window_state.h
--- up/chromium/chrome/browser/ui/browser_window_state.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_window_state.h	2024-08-26 19:32:19.254587179 +0000
@@ -65,7 +65,7 @@
 // Return the |bounds| for the browser window to be used upon creation.
 // The |show_state| variable will receive the desired initial show state for
 // the window.
-void GetSavedWindowBoundsAndShowState(const Browser* browser,
+bool GetSavedWindowBoundsAndShowState(const Browser* browser,
                                       gfx::Rect* bounds,
                                       ui::WindowShowState* show_state);
 
diff -r -u --color up/chromium/chrome/browser/ui/chrome_pages.cc nw/chromium/chrome/browser/ui/chrome_pages.cc
--- up/chromium/chrome/browser/ui/chrome_pages.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/chrome_pages.cc	2024-08-26 19:32:19.254587179 +0000
@@ -96,7 +96,7 @@
 namespace chrome {
 namespace {
 
-const char kHashMark[] = "#";
+//const char kHashMark[] = "#";
 
 void FocusWebContents(Browser* browser) {
   auto* const contents = browser->tab_strip_model()->GetActiveWebContents();
@@ -203,6 +203,7 @@
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH) && BUILDFLAG(GOOGLE_CHROME_BRANDING)
 }
 
+#if 0
 std::string GenerateContentSettingsExceptionsSubPage(ContentSettingsType type) {
   // In MD Settings, the exceptions no longer have a separate subpage.
   // This list overrides the group names defined in site_settings_helper for the
@@ -234,6 +235,7 @@
        override ? *override
                 : site_settings::ContentSettingsTypeToGroupName(type)});
 }
+#endif
 
 bool SiteGURLIsValid(const GURL& url) {
   url::Origin site_origin = url::Origin::Create(url);
@@ -459,15 +461,19 @@
 
 void ShowContentSettingsExceptions(Browser* browser,
                                    ContentSettingsType content_settings_type) {
+#if 0
   ShowSettingsSubPage(
       browser, GenerateContentSettingsExceptionsSubPage(content_settings_type));
+#endif
 }
 
 void ShowContentSettingsExceptionsForProfile(
     Profile* profile,
     ContentSettingsType content_settings_type) {
+#if 0
   ShowSettingsSubPageForProfile(
       profile, GenerateContentSettingsExceptionsSubPage(content_settings_type));
+#endif
 }
 
 void ShowSiteSettings(Browser* browser, const GURL& url) {
@@ -490,10 +496,12 @@
 
 void ShowContentSettings(Browser* browser,
                          ContentSettingsType content_settings_type) {
+#if 0
   ShowSettingsSubPage(
       browser, base::StrCat({kContentSettingsSubPage, kHashMark,
                              site_settings::ContentSettingsTypeToGroupName(
                                  content_settings_type)}));
+#endif
 }
 
 void ShowClearBrowsingDataDialog(Browser* browser) {
diff -r -u --color up/chromium/chrome/browser/ui/cocoa/main_menu_builder.mm nw/chromium/chrome/browser/ui/cocoa/main_menu_builder.mm
--- up/chromium/chrome/browser/ui/cocoa/main_menu_builder.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/cocoa/main_menu_builder.mm	2024-08-26 19:32:19.262587183 +0000
@@ -21,6 +21,8 @@
 #import "ui/base/l10n/l10n_util_mac.h"
 #include "ui/strings/grit/ui_strings.h"
 
+#pragma clang diagnostic ignored "-Wunused-function"
+
 namespace chrome {
 namespace {
 
@@ -42,7 +44,7 @@
                   .string_format_1(product_name)
                   .tag(IDC_ABOUT)
                   .target(app_delegate)
-                  .action(@selector(orderFrontStandardAboutPanel:)),
+                  /*.action(@selector(orderFrontStandardAboutPanel:))*/,
               Item().is_separator(),
               Item(IDS_PREFERENCES)
                   .tag(IDC_OPTIONS)
@@ -60,10 +62,6 @@
                   .command_id(IDC_IMPORT_SETTINGS)
                   .remove_if(is_pwa),
               Item().is_separator(),
-              Item(IDS_SERVICES_MAC)
-                  .tag(-1)
-                  .submenu({}),
-              Item().is_separator(),
               Item(IDS_HIDE_APP_MAC)
                   .string_format_1(product_name)
                   .tag(IDC_HIDE_APP)
@@ -205,6 +203,7 @@
               Item(IDS_EDIT_SELECT_ALL_MAC)
                   .tag(IDC_CONTENT_CONTEXT_SELECTALL)
                   .action(@selector(selectAll:)),
+#if 0
               Item().is_separator(),
               Item(IDS_EDIT_FIND_SUBMENU_MAC)
                   .tag(IDC_FIND_MENU)
@@ -270,6 +269,7 @@
               }),
             // The "Start Dictation..." and "Emoji & Symbols" items are
             // inserted by AppKit.
+#endif
           })
           .Build();
   // clang-format on
@@ -571,15 +571,8 @@
   NSMenu* main_menu = [[NSMenu alloc] initWithTitle:@""];
   for (auto* builder : {
            &BuildAppMenu,
-           &BuildFileMenu,
            &BuildEditMenu,
-           &BuildViewMenu,
-           &BuildHistoryMenu,
-           &BuildBookmarksMenu,
-           &BuildPeopleMenu,
-           &BuildTabMenu,
            &BuildWindowMenu,
-           &BuildHelpMenu,
        }) {
     auto item = builder(nsapp, app_delegate, product_name, is_pwa);
     if (item) {
diff -r -u --color up/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.h nw/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.h
--- up/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.h	2024-08-26 19:32:19.262587183 +0000
@@ -38,7 +38,7 @@
 
  protected:
   // Overridden from StatusIcon.
-  void UpdatePlatformContextMenu(StatusIconMenuModel* model) override;
+  void UpdatePlatformContextMenu(ui::MenuModel* model) override;
 
  private:
   FRIEND_TEST_ALL_PREFIXES(StatusIconMacTest, CreateMenu);
diff -r -u --color up/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.mm nw/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.mm
--- up/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.mm	2024-08-26 19:32:19.262587183 +0000
@@ -103,7 +103,7 @@
   return menu_ != nil;
 }
 
-void StatusIconMac::UpdatePlatformContextMenu(StatusIconMenuModel* model) {
+void StatusIconMac::UpdatePlatformContextMenu(ui::MenuModel* model) {
   if (!model) {
     menu_ = nil;
   } else {
diff -r -u --color up/chromium/chrome/browser/ui/dialogs/outdated_upgrade_bubble.cc nw/chromium/chrome/browser/ui/dialogs/outdated_upgrade_bubble.cc
--- up/chromium/chrome/browser/ui/dialogs/outdated_upgrade_bubble.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/dialogs/outdated_upgrade_bubble.cc	2024-08-26 19:32:19.270587188 +0000
@@ -35,7 +35,9 @@
 
 // For ChromeOS Lacros, browser updates are done via system services, thus
 // we redirect to the safetyCheck page that interacts with these. On other
-// platforms it may be possible to download an updated browser via a site.
+// platforms it may be possible to download an updated browser via a
+// site.
+#if 0
 const char* kUpdateBrowserRedirectUrl =
 #if BUILDFLAG(IS_CHROMEOS_LACROS)
     // The URL to be used to update Lacros-Chrome when auto-update failed
@@ -46,7 +48,7 @@
     // too long.
     "https://www.google.com/chrome";
 #endif
-
+#endif
 bool g_upgrade_bubble_is_showing = false;
 
 void OnWindowClosing() {
@@ -107,6 +109,7 @@
 }  // namespace
 
 void ShowOutdatedUpgradeBubble(Browser* browser, bool auto_update_enabled) {
+#if 0
   if (g_upgrade_bubble_is_showing)
     return;
 
@@ -144,4 +147,5 @@
       auto_update_enabled
           ? base::UserMetricsAction("OutdatedUpgradeBubble.Show")
           : base::UserMetricsAction("OutdatedUpgradeBubble.ShowNoAU"));
+#endif
 }
diff -r -u --color up/chromium/chrome/browser/ui/exclusive_access/fullscreen_controller.cc nw/chromium/chrome/browser/ui/exclusive_access/fullscreen_controller.cc
--- up/chromium/chrome/browser/ui/exclusive_access/fullscreen_controller.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/exclusive_access/fullscreen_controller.cc	2024-08-26 19:32:19.274587190 +0000
@@ -1,6 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "chrome/browser/ui/exclusive_access/fullscreen_controller.h"
 
@@ -477,6 +478,7 @@
 }
 
 bool FullscreenController::HandleUserPressedEscape() {
+  return false;
   WebContents* const active_web_contents =
       exclusive_access_manager()->context()->GetWebContentsForExclusiveAccess();
   if (IsFullscreenWithinTab(active_web_contents)) {
diff -r -u --color up/chromium/chrome/browser/ui/media_router/media_router_ui_service.cc nw/chromium/chrome/browser/ui/media_router/media_router_ui_service.cc
--- up/chromium/chrome/browser/ui/media_router/media_router_ui_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/media_router/media_router_ui_service.cc	2024-08-26 19:32:19.298587203 +0000
@@ -23,7 +23,9 @@
     Profile* profile,
     std::unique_ptr<MediaRouterActionController> action_controller)
     : profile_(profile),
+#if defined(NWJS_SDK)
       action_controller_(std::move(action_controller)),
+#endif
       profile_pref_registrar_(std::make_unique<PrefChangeRegistrar>()) {
   profile_pref_registrar_->Init(profile->GetPrefs());
   profile_pref_registrar_->Add(
@@ -45,7 +47,11 @@
 }
 
 MediaRouterActionController* MediaRouterUIService::action_controller() {
+#if defined(NWJS_SDK)
   return action_controller_.get();
+#else
+  return nullptr;
+#endif
 }
 
 void MediaRouterUIService::AddObserver(Observer* observer) {
@@ -58,10 +64,12 @@
 
 void MediaRouterUIService::ConfigureService() {
   if (MediaRouterEnabled(profile_)) {
+#if defined(NWJS_SDK)
     if (!action_controller_) {
       action_controller_ =
           std::make_unique<MediaRouterActionController>(profile_);
     }
+#endif
 #if BUILDFLAG(IS_CHROMEOS)
     if (GlobalMediaControlsCastStartStopEnabled(profile_)) {
       // Ensure that MediaNotificationService is instantiated so that it can
@@ -77,7 +85,9 @@
 void MediaRouterUIService::DisableService() {
   for (auto& observer : observers_)
     observer.OnServiceDisabled();
+#if defined(NWJS_SDK)
   action_controller_.reset();
+#endif
 }
 
 }  // namespace media_router
diff -r -u --color up/chromium/chrome/browser/ui/media_router/media_router_ui_service.h nw/chromium/chrome/browser/ui/media_router/media_router_ui_service.h
--- up/chromium/chrome/browser/ui/media_router/media_router_ui_service.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/media_router/media_router_ui_service.h	2024-08-26 19:32:19.298587203 +0000
@@ -53,7 +53,9 @@
   void DisableService();
 
   raw_ptr<Profile> profile_;
+#if defined(NWJS_SDK)
   std::unique_ptr<MediaRouterActionController> action_controller_;
+#endif
   std::unique_ptr<PrefChangeRegistrar> profile_pref_registrar_;
 
   base::ObserverList<Observer>::Unchecked observers_;
diff -r -u --color up/chromium/chrome/browser/ui/sad_tab.cc nw/chromium/chrome/browser/ui/sad_tab.cc
--- up/chromium/chrome/browser/ui/sad_tab.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/sad_tab.cc	2024-08-26 19:32:19.322587215 +0000
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/sad_tab.h"
 
+#include "chrome/browser/ui/browser_commands.h"
 #include <vector>
 
 #include "base/metrics/histogram_macros.h"
@@ -217,8 +218,12 @@
                                          : IDS_KILLED_TAB_FEEDBACK_MESSAGE),
             std::string(kCategoryTagCrash), std::string());
       } else {
-        web_contents_->GetController().Reload(content::ReloadType::NORMAL,
-                                              true);
+        Browser* browser = chrome::FindBrowserWithTab(web_contents_);
+        if (browser) {
+          chrome::CloseTab(browser);
+        } else
+        web_contents_->Close(); //GetController().Reload(content::ReloadType::NORMAL,
+                                //              true);
       }
       break;
     case Action::HELP_LINK:
diff -r -u --color up/chromium/chrome/browser/ui/scoped_tabbed_browser_displayer.cc nw/chromium/chrome/browser/ui/scoped_tabbed_browser_displayer.cc
--- up/chromium/chrome/browser/ui/scoped_tabbed_browser_displayer.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/scoped_tabbed_browser_displayer.cc	2024-08-26 19:32:19.326587218 +0000
@@ -14,7 +14,7 @@
   browser_ = FindTabbedBrowser(profile, false);
   if (!browser_ && Browser::GetCreationStatusForProfile(profile) ==
                        Browser::CreationStatus::kOk) {
-    Browser::CreateParams params(profile, /*user_gesture=*/true);
+    Browser::CreateParams params(Browser::TYPE_POPUP, profile, /*user_gesture=*/true);
     browser_ = Browser::Create(params);
   }
 }
diff -r -u --color up/chromium/chrome/browser/ui/startup/startup_browser_creator.cc nw/chromium/chrome/browser/ui/startup/startup_browser_creator.cc
--- up/chromium/chrome/browser/ui/startup/startup_browser_creator.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/startup/startup_browser_creator.cc	2024-08-26 19:32:19.334587222 +0000
@@ -3,6 +3,11 @@
 // found in the LICENSE file.
 
 #include "chrome/browser/ui/startup/startup_browser_creator.h"
+#include "chrome/browser/spellchecker/spellcheck_factory.h"
+#include "content/nw/src/common/shell_switches.h"
+#include "content/public/common/content_features.h"
+
+#include "extensions/browser/extension_registry.h"
 
 #include <stddef.h>
 
@@ -97,6 +102,15 @@
 #include "extensions/common/switches.h"
 #include "printing/buildflags/buildflags.h"
 
+#include "extensions/browser/extension_system.h"
+#include "chrome/browser/extensions/component_loader.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/common/extensions/extension_constants.h"
+#include "chrome/grit/browser_resources.h"
+#include "extensions/common/constants.h"
+#include "chrome/browser/ui/extensions/app_launch_params.h"
+#include "chrome/browser/ui/extensions/application_launch.h"
+
 #if BUILDFLAG(IS_CHROMEOS_ASH)
 #include "ash/constants/ash_switches.h"
 #include "chrome/browser/ash/app_mode/app_launch_utils.h"
@@ -1204,8 +1218,8 @@
     // chrome to shut down.
     // TODO(jackhou): Do this properly once keep-alive is handled by the
     // background page of apps. Tracked at http://crbug.com/175381
-    if (chrome::GetBrowserCount(privacy_safe_profile) != 0)
-      return true;
+    //if (chrome::GetBrowserCount(privacy_safe_profile) != 0)
+    return true;
   }
 
   // Check for --load-and-launch-app.
@@ -1227,6 +1241,54 @@
       return true;
   }
 
+  if (process_startup != chrome::startup::IsProcessStartup::kYes)
+    return true;
+  if (command_line.HasSwitch(switches::kEnableSpellChecking))
+    SpellcheckServiceFactory::GetForContext(profile_info.profile);
+
+  const base::CommandLine::StringVector& params = command_line.GetArgs();
+  if (command_line.HasSwitch("nwapp")) {
+	  if (!apps::AppLoadService::Get(profile_info.profile)->LoadAndLaunch(
+		  base::FilePath(command_line.GetSwitchValueNative("nwapp")), command_line, cur_dir)) {
+		  return false;
+	  }
+	  return true;
+  }
+
+  if (!command_line.HasSwitch("nwjs-test-mode")) {
+    if (params.size() > 0) {
+      if (!apps::AppLoadService::Get(profile_info.profile)->LoadAndLaunch(
+                                                             base::FilePath(params[0]), command_line, cur_dir)) {
+        return false;
+      }
+      return true;
+    } else {
+      extensions::ExtensionService* extension_service =
+        extensions::ExtensionSystem::Get(profile_info.profile)->extension_service();
+      extensions::ExtensionRegistry* extension_registry =
+        extensions::ExtensionRegistry::Get(profile_info.profile);
+      extensions::ComponentLoader* component_loader = extension_service->component_loader();
+      std::string id;
+      if (base::FeatureList::IsEnabled(::features::kNWNewWin)) {
+        id = component_loader->GetExtensionID(IDR_NWJS_DEFAPP_MANIFEST_NEWWIN,
+                                                         base::FilePath(FILE_PATH_LITERAL("nwjs_newwin_app")));
+      } else {
+        id = component_loader->GetExtensionID(IDR_NWJS_DEFAPP_MANIFEST,
+                                                         base::FilePath(FILE_PATH_LITERAL("nwjs_default_app")));
+      }
+
+      LOG(INFO) << "loading default app: " << id;
+      const extensions::Extension* extension = extension_registry->GetExtensionById(id, extensions::ExtensionRegistry::EVERYTHING);
+      if (!extension) {
+        LOG(FATAL) << "Failed to load default app";
+      }
+      OpenApplication(profile_info.profile,
+                      apps::AppLaunchParams(extension->id(), apps::LaunchContainer::kLaunchContainerWindow,
+                                            WindowOpenDisposition::NEW_WINDOW, apps::LaunchSource::kFromChromeInternal));
+      return true;
+    }
+  }
+
 #if BUILDFLAG(IS_WIN)
   if (command_line.HasSwitch(switches::kWinJumplistAction)) {
     // `switches::kWinJumplistAction` is expected to be set together with a
diff -r -u --color up/chromium/chrome/browser/ui/tab_contents/core_tab_helper.cc nw/chromium/chrome/browser/ui/tab_contents/core_tab_helper.cc
--- up/chromium/chrome/browser/ui/tab_contents/core_tab_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/tab_contents/core_tab_helper.cc	2024-08-26 19:32:19.338587224 +0000
@@ -695,6 +695,7 @@
 
 void CoreTabHelper::MaybeSetSearchArgsForImageTranslate(
     TemplateURLRef::SearchTermsArgs& search_args) {
+#if 0
   ChromeTranslateClient* chrome_translate_client =
       ChromeTranslateClient::FromWebContents(web_contents());
   if (!chrome_translate_client) {
@@ -712,6 +713,7 @@
           language_state.current_language();
     }
   }
+#endif
 }
 
 void CoreTabHelper::PostContentToURL(TemplateURLRef::PostContent post_content,
diff -r -u --color up/chromium/chrome/browser/ui/tab_helpers.cc nw/chromium/chrome/browser/ui/tab_helpers.cc
--- up/chromium/chrome/browser/ui/tab_helpers.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/tab_helpers.cc	2024-08-26 19:32:19.338587224 +0000
@@ -389,7 +389,7 @@
   ChromeRLZTrackerWebContentsObserver::CreateForWebContentsIfNeeded(
       web_contents);
 #endif
-  ChromeTranslateClient::CreateForWebContents(web_contents);
+  //ChromeTranslateClient::CreateForWebContents(web_contents);
   client_hints::ClientHintsWebContentsObserver::CreateForWebContents(
       web_contents);
   commerce::CommerceTabHelper::CreateForWebContents(
@@ -545,10 +545,12 @@
     SupervisedUserNavigationObserver::CreateForWebContents(web_contents);
   }
   HttpErrorTabHelper::CreateForWebContents(web_contents);
+#if 0
   sync_sessions::SyncSessionsRouterTabHelper::CreateForWebContents(
       web_contents,
       sync_sessions::SyncSessionsWebContentsRouterFactory::GetForProfile(
           profile));
+#endif
   TabUIHelper::CreateForWebContents(web_contents);
   tasks::TaskTabHelper::CreateForWebContents(web_contents);
   tpcd::metadata::TpcdMetadataDevtoolsObserver::CreateForWebContents(
diff -r -u --color up/chromium/chrome/browser/ui/translate_browser_action_listener.cc nw/chromium/chrome/browser/ui/translate_browser_action_listener.cc
--- up/chromium/chrome/browser/ui/translate_browser_action_listener.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/translate_browser_action_listener.cc	2024-08-26 19:32:19.358587235 +0000
@@ -22,13 +22,14 @@
   TabStripModel* tab_strip_model = browser_->tab_strip_model();
 
   tab_strip_model->RemoveObserver(this);
-  RemoveTranslationObserver(tab_strip_model->GetActiveWebContents());
+  //RemoveTranslationObserver(tab_strip_model->GetActiveWebContents());
 }
 
 void TranslateBrowserActionListener::OnTabStripModelChanged(
     TabStripModel* tab_strip_model,
     const TabStripModelChange& change,
     const TabStripSelectionChange& selection) {
+#if 0
   if (selection.active_tab_changed()) {
     RemoveTranslationObserver(selection.old_contents);
     AddTranslationObserver(selection.new_contents);
@@ -47,6 +48,7 @@
       action_item->ClearProperty(kActionItemUnderlineIndicatorKey);
     }
   }
+#endif
 }
 
 void TranslateBrowserActionListener::AddTranslationObserver(
@@ -73,6 +75,7 @@
 
 void TranslateBrowserActionListener::OnIsPageTranslatedChanged(
     content::WebContents* source) {
+#if 0
   DCHECK(browser_->tab_strip_model()->GetActiveWebContents() == source);
 
   actions::ActionItem* action_item = actions::ActionManager::Get().FindAction(
@@ -83,4 +86,5 @@
                                       .IsPageTranslated();
   action_item->SetProperty(kActionItemUnderlineIndicatorKey,
                            is_page_translated);
+#endif
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/accelerator_table.cc nw/chromium/chrome/browser/ui/views/accelerator_table.cc
--- up/chromium/chrome/browser/ui/views/accelerator_table.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/accelerator_table.cc	2024-08-26 19:32:19.362587237 +0000
@@ -45,9 +45,11 @@
 //      item with the appropriate modifier.
 //   2) Update GetShortcutsNotPresentInMainMenu() in
 //      global_keyboard_shortcuts_mac.mm.
-#if !BUILDFLAG(IS_CHROMEOS)
+    { ui::VKEY_F4, ui::EF_ALT_DOWN, IDC_CLOSE_WINDOW },
+#if 0
     {ui::VKEY_F7, ui::EF_NONE, IDC_CARET_BROWSING_TOGGLE},
 #endif
+#if 0
     {ui::VKEY_ESCAPE, ui::EF_NONE, IDC_CLOSE_FIND_OR_STOP},
 
 #if !BUILDFLAG(IS_MAC)
@@ -250,6 +252,7 @@
     {ui::VKEY_OEM_PLUS, ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN, IDC_ZOOM_PLUS},
 #endif  // !BUILDFLAG(IS_CHROMEOS)
 #endif  // !BUILDFLAG(IS_MAC)
+#endif
 };
 
 const AcceleratorMapping kDevToolsAcceleratorMap[] = {
@@ -305,6 +308,9 @@
                          std::end(kAcceleratorMap));
 
     bool enable_devtools = true;
+#if !defined(NWJS_SDK)
+    enable_devtools = false;
+#endif
 #if BUILDFLAG(IS_CHROMEOS_ASH)
     // In Ash, DevTools is disabled by default if lacros is the only browser, in
     // order not to confuse users by opening Ash browser windows.
diff -r -u --color up/chromium/chrome/browser/ui/views/apps/app_window_desktop_window_tree_host_win.cc nw/chromium/chrome/browser/ui/views/apps/app_window_desktop_window_tree_host_win.cc
--- up/chromium/chrome/browser/ui/views/apps/app_window_desktop_window_tree_host_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/app_window_desktop_window_tree_host_win.cc	2024-08-26 19:32:19.366587239 +0000
@@ -29,6 +29,9 @@
 bool AppWindowDesktopWindowTreeHostWin::GetClientAreaInsets(
     gfx::Insets* insets,
     HMONITOR monitor) const {
+#if 1
+  return false;
+#else
   // The inset added below is only necessary for the native glass frame, i.e.
   // not for colored frames drawn by Chrome, or when DWM is disabled.
   // In fullscreen the frame is not visible.
@@ -39,6 +42,7 @@
   *insets = app_window_->frame_view()->GetClientAreaInsets(monitor);
 
   return true;
+#endif
 }
 
 bool AppWindowDesktopWindowTreeHostWin::GetDwmFrameInsetsInPixels(
diff -r -u --color up/chromium/chrome/browser/ui/views/apps/app_window_frame_view_win.cc nw/chromium/chrome/browser/ui/views/apps/app_window_frame_view_win.cc
--- up/chromium/chrome/browser/ui/views/apps/app_window_frame_view_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/app_window_frame_view_win.cc	2024-08-26 19:32:19.366587239 +0000
@@ -43,6 +43,9 @@
 }
 
 gfx::Rect AppWindowFrameViewWin::GetBoundsForClientView() const {
+#if 1
+  return bounds();
+#else
   if (widget_->IsFullscreen()) {
     return bounds();
   }
@@ -51,6 +54,7 @@
   return gfx::Rect(insets.left(), insets.top(),
                    std::max(0, width() - insets.left() - insets.right()),
                    std::max(0, height() - insets.top() - insets.bottom()));
+#endif
 }
 
 gfx::Rect AppWindowFrameViewWin::GetWindowBoundsForClientBounds(
@@ -81,6 +85,11 @@
     return HTNOWHERE;
   }
 
+  int client_component = widget_->client_view()->NonClientHitTest(point);
+  if (client_component != HTNOWHERE) {
+    return client_component;
+  }
+
   // Check the frame first, as we allow a small area overlapping the contents
   // to be used for resize handles.
   bool can_ever_resize = widget_->widget_delegate()
@@ -97,11 +106,6 @@
     return frame_component;
   }
 
-  int client_component = widget_->client_view()->NonClientHitTest(point);
-  if (client_component != HTNOWHERE) {
-    return client_component;
-  }
-
   // Caption is a safe default.
   return HTCAPTION;
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.cc nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.cc
--- up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.cc	2024-08-26 19:32:19.366587239 +0000
@@ -34,14 +34,25 @@
 #include "ui/views/controls/webview/webview.h"
 #include "ui/views/widget/widget.h"
 
+#if defined(NWJS_SDK)
+#include "base/command_line.h"
+#include "chrome/browser/devtools/devtools_window.h"
+#include "content/nw/src/common/shell_switches.h"
+#endif
+
+#include "ui/display/screen.h"
+
 using extensions::AppWindow;
 
 namespace {
 
 const AcceleratorMapping kAppWindowAcceleratorMap[] = {
-  { ui::VKEY_W, ui::EF_CONTROL_DOWN, IDC_CLOSE_WINDOW },
-  { ui::VKEY_W, ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN, IDC_CLOSE_WINDOW },
+  //  { ui::VKEY_W, ui::EF_CONTROL_DOWN, IDC_CLOSE_WINDOW },
+  //  { ui::VKEY_W, ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN, IDC_CLOSE_WINDOW },
   { ui::VKEY_F4, ui::EF_ALT_DOWN, IDC_CLOSE_WINDOW },
+#if defined(NWJS_SDK)
+  { ui::VKEY_F12, ui::EF_NONE, IDC_DEV_TOOLS_TOGGLE },
+#endif
 };
 
 // These accelerators will only be available in kiosk mode. These allow the
@@ -110,6 +121,10 @@
     views::Widget* widget) {
 }
 
+bool ChromeNativeAppWindowViews::NWCanClose(bool user_force) const {
+  return app_window()->NWCanClose(user_force);
+}
+
 void ChromeNativeAppWindowViews::InitializeDefaultWindow(
     const AppWindow::CreateParams& create_params) {
   views::Widget::InitParams init_params(
@@ -145,6 +160,15 @@
       init_param_bounds.IsEmpty()
           ? create_params.GetInitialWindowBounds(frame_insets)
           : init_param_bounds;
+#if defined(OS_LINUX)
+  if (create_params.GetContentMinimumSize(frame_insets).IsEmpty() &&
+      create_params.GetContentMaximumSize(frame_insets).IsEmpty() &&
+      !create_params.resizable) { //NWJS#6592
+    gfx::Size size(create_params.content_spec.bounds.width(),
+                   create_params.content_spec.bounds.height());
+    SetContentSizeConstraints(size, size);
+  } else
+#endif
   SetContentSizeConstraints(create_params.GetContentMinimumSize(frame_insets),
                             create_params.GetContentMaximumSize(frame_insets));
   if (!window_bounds.IsEmpty()) {
@@ -152,6 +176,11 @@
     bool position_specified =
         window_bounds.x() != BoundsSpecification::kUnspecifiedPosition &&
         window_bounds.y() != BoundsSpecification::kUnspecifiedPosition;
+    if (create_params.position == AppWindow::POS_MOUSE) {
+      gfx::Point cursor_pos(display::Screen::GetScreen()->GetCursorScreenPoint());
+      window_bounds.set_origin(cursor_pos);
+      widget()->SetBounds(window_bounds);
+    } else {
     if (!position_specified) {
 #if BUILDFLAG(IS_MAC)
       // On Mac, this will call NativeWidgetMac's CenterWindow() which relies
@@ -167,6 +196,15 @@
     } else {
       widget()->SetBounds(window_bounds);
     }
+    }
+  } else {
+    if (create_params.position == AppWindow::POS_CENTER)
+      widget()->CenterWindow(gfx::Size(640, 480));
+    else if (create_params.position == extensions::AppWindow::POS_MOUSE) {
+      gfx::Point cursor_pos(display::Screen::GetScreen()->GetCursorScreenPoint());
+      gfx::Rect bounds(cursor_pos, gfx::Size(640, 480));
+      widget()->SetBounds(bounds);
+    }
   }
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -238,6 +276,9 @@
 // views::WidgetDelegate implementation.
 
 ui::ImageModel ChromeNativeAppWindowViews::GetWindowAppIcon() {
+  gfx::Image icon_override = app_window()->icon_override();
+  if (!icon_override.IsEmpty())
+    return ui::ImageModel::FromImageSkia(*icon_override.ToImageSkia());
   // Resulting icon is cached in aura::client::kAppIconKey window property.
   const gfx::Image& custom_image = GetCustomImage();
   if (app_window()->app_icon_url().is_valid() &&
@@ -271,6 +312,9 @@
 }
 
 ui::ImageModel ChromeNativeAppWindowViews::GetWindowIcon() {
+  gfx::Image icon_override = app_window()->icon_override();
+  if (!icon_override.IsEmpty())
+    return ui::ImageModel::FromImageSkia(*icon_override.ToImageSkia());
   // Resulting icon is cached in aura::client::kWindowIconKey window property.
   content::WebContents* web_contents = app_window()->web_contents();
   if (web_contents) {
@@ -304,6 +348,14 @@
   auto iter = accelerator_table.find(accelerator);
   CHECK(iter != accelerator_table.end(), base::NotFatalUntil::M130);
   int command_id = iter->second;
+#if defined(NWJS_SDK)
+  content::WebContents* web_contents;
+  bool enable_devtools = true;
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableDevTools))
+    enable_devtools = false;
+#endif
   switch (command_id) {
     case IDC_CLOSE_WINDOW:
       Close();
@@ -319,22 +371,40 @@
     case IDC_ZOOM_PLUS:
       zoom::PageZoom::Zoom(web_view()->GetWebContents(), content::PAGE_ZOOM_IN);
       return true;
+#if defined(NWJS_SDK)
     case IDC_DEV_TOOLS:
-      DevToolsWindow::OpenDevToolsWindow(
-          web_view()->GetWebContents(), DevToolsToggleAction::Show(),
-          DevToolsOpenedByAction::kMainMenuOrMainShortcut);
+      if (!enable_devtools)
+        return true;
+      web_contents = app_window()->web_contents();
+      if (web_contents) {
+        DevToolsWindow::OpenDevToolsWindow(web_contents, DevToolsOpenedByAction::kConsoleShortcut);
+      }
       return true;
     case IDC_DEV_TOOLS_CONSOLE:
+      if (!enable_devtools)
+        return true;
       DevToolsWindow::OpenDevToolsWindow(
           web_view()->GetWebContents(),
           DevToolsToggleAction::ShowConsolePanel(),
           DevToolsOpenedByAction::kConsoleShortcut);
       return true;
     case IDC_DEV_TOOLS_INSPECT:
+      if (!enable_devtools)
+        return true;
       DevToolsWindow::OpenDevToolsWindow(
           web_view()->GetWebContents(), DevToolsToggleAction::Inspect(),
           DevToolsOpenedByAction::kInspectorModeShortcut);
       return true;
+    case IDC_DEV_TOOLS_TOGGLE:
+      if (!enable_devtools)
+        return true;
+      web_contents = app_window()->web_contents();
+      if (web_contents) {
+        DevToolsWindow::OpenDevToolsWindow(web_contents, DevToolsToggleAction::Toggle(),
+					   DevToolsOpenedByAction::kInspectorModeShortcut);
+      }
+      return true;
+#endif
     default:
       NOTREACHED_NORETURN() << "Unknown accelerator sent to app window.";
   }
diff -r -u --color up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.h nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.h
--- up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.h	2024-08-26 19:32:19.366587239 +0000
@@ -54,6 +54,7 @@
       views::Widget* widget) override;
   bool WidgetHasHitTestMask() const override;
   void GetWidgetHitTestMask(SkPath* mask) const override;
+  bool NWCanClose(bool user_force = false) const override;
 
   // views::View implementation.
   bool AcceleratorPressed(const ui::Accelerator& accelerator) override;
diff -r -u --color up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc
--- up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc	2024-08-26 19:32:19.366587239 +0000
@@ -39,6 +39,7 @@
     case ui::SHOW_STATE_NORMAL:
     case ui::SHOW_STATE_MAXIMIZED:
     case ui::SHOW_STATE_FULLSCREEN:
+    case ui::SHOW_STATE_HIDDEN:
       return restore_state;
 
     case ui::SHOW_STATE_DEFAULT:
diff -r -u --color up/chromium/chrome/browser/ui/views/autofill/popup/popup_base_view.cc nw/chromium/chrome/browser/ui/views/autofill/popup/popup_base_view.cc
--- up/chromium/chrome/browser/ui/views/autofill/popup/popup_base_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/autofill/popup/popup_base_view.cc	2024-08-26 19:32:19.374587244 +0000
@@ -9,6 +9,10 @@
 #include <string_view>
 #include <utility>
 
+#include "chrome/browser/apps/platform_apps/app_window_registry_util.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "extensions/browser/app_window/native_app_window.h"
+
 #include "base/dcheck_is_on.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
diff -r -u --color up/chromium/chrome/browser/ui/views/chrome_views_delegate.cc nw/chromium/chrome/browser/ui/views/chrome_views_delegate.cc
--- up/chromium/chrome/browser/ui/views/chrome_views_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/chrome_views_delegate.cc	2024-08-26 19:32:19.386587250 +0000
@@ -7,6 +7,8 @@
 #include <memory>
 
 #include "base/check_op.h"
+#include "content/nw/src/nw_content.h"
+
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/browser_process.h"
@@ -98,6 +100,7 @@
   window_preferences.Set("right", bounds.right());
   window_preferences.Set("bottom", bounds.bottom());
   window_preferences.Set("maximized", show_state == ui::SHOW_STATE_MAXIMIZED);
+  window_preferences.Set("fullscreen", show_state == ui::SHOW_STATE_FULLSCREEN);
 
   gfx::Rect work_area(display::Screen::GetScreen()
                           ->GetDisplayNearestView(window->GetNativeView())
@@ -128,8 +131,11 @@
 
   bounds->SetRect(*left, *top, *right - *left, *bottom - *top);
 
-  const bool maximized = dictionary.FindBool("maximized").value_or(false);
+  bool maximized = dictionary.FindBool("maximized").value_or(false);
+  bool fullscreen = dictionary.FindBool("fullscreen").value_or(false);
   *show_state = maximized ? ui::SHOW_STATE_MAXIMIZED : ui::SHOW_STATE_NORMAL;
+  if (fullscreen)
+    *show_state = ui::SHOW_STATE_FULLSCREEN;
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   AdjustSavedWindowPlacementChromeOS(widget, bounds);
diff -r -u --color up/chromium/chrome/browser/ui/views/chrome_views_delegate_linux.cc nw/chromium/chrome/browser/ui/views/chrome_views_delegate_linux.cc
--- up/chromium/chrome/browser/ui/views/chrome_views_delegate_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/chrome_views_delegate_linux.cc	2024-08-26 19:32:19.386587250 +0000
@@ -8,6 +8,8 @@
 #include "base/feature_list.h"
 #include "base/nix/xdg_util.h"
 #include "build/branding_buildflags.h"
+#include "content/nw/src/nw_content.h"
+
 #include "chrome/browser/ui/views/native_widget_factory.h"
 #include "chrome/common/channel_info.h"
 #include "chrome/grit/chrome_unscaled_resources.h"
@@ -82,6 +84,9 @@
 
 #if BUILDFLAG(IS_LINUX)
 gfx::ImageSkia* ChromeViewsDelegate::GetDefaultWindowIcon() const {
+  gfx::ImageSkia* ret = nw::GetAppIcon();
+  if (ret)
+    return ret;
   ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
   return rb.GetImageSkiaNamed(GetWindowIconResourceId());
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/constrained_web_dialog_delegate_views.cc nw/chromium/chrome/browser/ui/views/constrained_web_dialog_delegate_views.cc
--- up/chromium/chrome/browser/ui/views/constrained_web_dialog_delegate_views.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/constrained_web_dialog_delegate_views.cc	2024-08-26 19:32:19.390587252 +0000
@@ -213,6 +213,7 @@
 
   // ui::WebDialogWebContentsDelegate:
   void CloseContents(content::WebContents* source) override {
+    if (view_->GetWidget())
     view_->GetWidget()->Close();
   }
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_caption_button_container_win.cc nw/chromium/chrome/browser/ui/views/frame/browser_caption_button_container_win.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_caption_button_container_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_caption_button_container_win.cc	2024-08-26 19:32:19.414587266 +0000
@@ -62,7 +62,7 @@
       close_button_(AddChildView(CreateCaptionButton(
           base::BindRepeating(&BrowserFrame::CloseWithReason,
                               base::Unretained(frame_view_->frame()),
-                              views::Widget::ClosedReason::kCloseButtonClicked),
+                              views::Widget::ClosedReason::kCloseButtonClicked, false),
           frame_view_,
           VIEW_ID_CLOSE_BUTTON,
           IDS_APP_ACCNAME_CLOSE))) {
@@ -142,8 +142,13 @@
 
 void BrowserCaptionButtonContainer::ResetWindowControls() {
   minimize_button_->SetState(views::Button::STATE_NORMAL);
-  maximize_button_->SetState(views::Button::STATE_NORMAL);
-  restore_button_->SetState(views::Button::STATE_NORMAL);
+  if (frame_view_->browser_view()->CanMaximize()) {
+    maximize_button_->SetState(views::Button::STATE_NORMAL);
+    restore_button_->SetState(views::Button::STATE_NORMAL);
+  } else {
+    maximize_button_->SetState(views::Button::STATE_DISABLED);
+    restore_button_->SetState(views::Button::STATE_DISABLED);
+  }
   close_button_->SetState(views::Button::STATE_NORMAL);
   InvalidateLayout();
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc nw/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc	2024-08-26 19:32:19.418587268 +0000
@@ -293,7 +293,7 @@
     const views::Widget::InitParams& params) {
   DesktopWindowTreeHostLinux::Init(std::move(params));
 
-#if defined(USE_DBUS_MENU)
+#if 0 //defined(USE_DBUS_MENU)
   // We have now created our backing X11 window.  We now need to (possibly)
   // alert the desktop environment that there's a menu bar attached to it.
   if (CreateGlobalMenuBar()) {
@@ -310,7 +310,7 @@
 }
 
 void BrowserDesktopWindowTreeHostLinux::CloseNow() {
-#if defined(USE_DBUS_MENU)
+#if 0//defined(USE_DBUS_MENU)
   dbus_appmenu_.reset();
 #endif
   DesktopWindowTreeHostLinux::CloseNow();
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc nw/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc	2024-08-26 19:32:19.418587268 +0000
@@ -313,6 +313,11 @@
 bool BrowserDesktopWindowTreeHostWin::GetClientAreaInsets(
     gfx::Insets* insets,
     HMONITOR monitor) const {
+  //NWJS#7221, this is called during NCCALCSIZE handler
+  //without this, it will lead to a window with white bg shown
+  //initially during first ShowWindow call.
+  if (browser_view_->browser()->is_transparent())
+    return false;
   // Always use default insets for opaque frame.
   if (!ShouldUseNativeFrame())
     return false;
@@ -328,7 +333,7 @@
     // In fullscreen mode there is no frame.
     *insets = gfx::Insets();
   } else {
-    const int frame_thickness = ui::GetFrameThickness(monitor);
+    const int frame_thickness = browser_view_->CanResize() ? ui::GetFrameThickness(monitor) : 1;
     // Reduce the non-client border size; UpdateDWMFrame() will instead extend
     // the border into the window client area. For maximized windows, Windows
     // outdents the window rect from the screen's client rect by
@@ -495,6 +500,10 @@
   // context of the BrowserView destructor.
   if (!browser_view_->browser())
     return false;
+  if (browser_view_->browser()->is_transparent())
+    return true;
+  if (browser_view_->browser()->is_frameless())
+    return false;
 
   // We don't theme popup or app windows, so regardless of whether or not a
   // theme is active for normal browser windows, we don't want to use the custom
@@ -508,6 +517,8 @@
 
 bool BrowserDesktopWindowTreeHostWin::ShouldWindowContentsBeTransparent()
     const {
+  if (browser_view_->browser()->is_transparent())
+    return true;
   return !ShouldBrowserCustomDrawTitlebar(browser_view_) &&
          views::DesktopWindowTreeHostWin::ShouldWindowContentsBeTransparent();
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_frame.cc nw/chromium/chrome/browser/ui/views/frame/browser_frame.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_frame.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_frame.cc	2024-08-26 19:32:19.418587268 +0000
@@ -5,6 +5,15 @@
 #include "chrome/browser/ui/views/frame/browser_frame.h"
 
 #include <memory>
+
+#if defined(USE_AURA)
+#if defined(OS_WIN)
+#include "ui/views/win/hwnd_util.h"
+#endif
+#include "ui/aura/window.h"
+#include "chrome/browser/ui/views/apps/app_window_easy_resize_window_targeter.h"
+#endif
+
 #include <utility>
 
 #include "base/command_line.h"
@@ -114,8 +123,8 @@
 ////////////////////////////////////////////////////////////////////////////////
 // BrowserFrame, public:
 
-BrowserFrame::BrowserFrame(BrowserView* browser_view)
-    : native_browser_frame_(nullptr),
+BrowserFrame::BrowserFrame(BrowserView* browser_view, bool frameless)
+    : frameless_(frameless), native_browser_frame_(nullptr),
       root_view_(nullptr),
       browser_frame_view_(nullptr),
       browser_view_(browser_view) {
@@ -127,11 +136,20 @@
 
 BrowserFrame::~BrowserFrame() {}
 
-void BrowserFrame::InitBrowserFrame() {
+bool BrowserFrame::InitBrowserFrame() {
+  bool got_saved_bounds = false;
   native_browser_frame_ =
       NativeBrowserFrameFactory::CreateNativeBrowserFrame(this, browser_view_);
   views::Widget::InitParams params = native_browser_frame_->GetWidgetParams();
   params.name = "BrowserFrame";
+  if (frameless_)
+    params.remove_standard_frame = true;
+  if (browser_view_->browser()->is_transparent())
+    params.opacity = views::Widget::InitParams::WindowOpacity::kTranslucent;
+  if (browser_view_->browser()->initial_ontop())
+    params.z_order = ui::ZOrderLevel::kFloatingWindow;
+  if (browser_view_->browser()->initial_allvisible())
+    params.visible_on_all_workspaces = true;
   params.delegate = browser_view_;
   params.headless_mode = headless::IsHeadlessMode();
 
@@ -157,14 +175,14 @@
 
   if (native_browser_frame_->ShouldRestorePreviousBrowserWidgetState()) {
     if (browser->is_type_normal() || browser->is_type_devtools() ||
-        browser->is_type_app()) {
+        browser->is_type_app() || browser->is_type_popup()) {
       // Typed panel/popup can only return a size once the widget has been
       // created.
       // DevTools counts as a popup, but DevToolsWindow::CreateDevToolsBrowser
       // ensures there is always a size available. Without this, the tools
       // launch on the wrong display and can have sizing issues when
       // repositioned to the saved bounds in Widget::SetInitialBounds.
-      chrome::GetSavedWindowBoundsAndShowState(browser, &params.bounds,
+      got_saved_bounds = chrome::GetSavedWindowBoundsAndShowState(browser, &params.bounds,
                                                &params.show_state);
 
       params.workspace = browser->initial_workspace();
@@ -190,10 +208,24 @@
   SetNativeTheme(ui::NativeTheme::GetInstanceForNativeUi());
 #endif
 
+#if defined(USE_AURA)
+  if (frameless_) {
+#if 0
+    HWND hwnd = views::HWNDForWidget(GetTopLevelWidget());
+    int current_style = ::GetWindowLong(hwnd, GWL_STYLE);
+    ::SetWindowLong(hwnd, GWL_STYLE, current_style | WS_CAPTION);
+#endif
+    aura::Window* window = browser_view_->GetWidget()->GetNativeWindow();
+    window->SetEventTargeter(std::make_unique<AppWindowEasyResizeWindowTargeter>(
+      gfx::Insets(5), browser_view_));
+  }
+#endif
+
   if (!native_browser_frame_->UsesNativeSystemMenu()) {
     DCHECK(non_client_view());
     non_client_view()->set_context_menu_controller(this);
   }
+  return got_saved_bounds;
 }
 
 int BrowserFrame::GetMinimizeButtonOffset() const {
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_frame.h nw/chromium/chrome/browser/ui/views/frame/browser_frame.h
--- up/chromium/chrome/browser/ui/views/frame/browser_frame.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_frame.h	2024-08-26 19:32:19.418587268 +0000
@@ -58,7 +58,7 @@
 // This is a virtual interface that allows system specific browser frames.
 class BrowserFrame : public views::Widget, public views::ContextMenuController {
  public:
-  explicit BrowserFrame(BrowserView* browser_view);
+  explicit BrowserFrame(BrowserView* browser_view, bool frameless = false);
 
   BrowserFrame(const BrowserFrame&) = delete;
   BrowserFrame& operator=(const BrowserFrame&) = delete;
@@ -72,7 +72,7 @@
 #endif
 
   // Initialize the frame (creates the underlying native window).
-  void InitBrowserFrame();
+  bool InitBrowserFrame();
 
   // Determine the distance of the left edge of the minimize button from the
   // left edge of the window. Used in our Non-Client View's Layout.
@@ -170,6 +170,7 @@
   void SetTabDragKind(TabDragKind tab_drag_kind);
   TabDragKind tab_drag_kind() const { return tab_drag_kind_; }
 
+  bool frameless() { return frameless_; }
  protected:
   // views::Widget:
   void OnNativeThemeUpdated(ui::NativeTheme* observed_theme) override;
@@ -189,6 +190,7 @@
   // Regenerate the frame on theme change if necessary. Returns true if
   // regenerated.
   bool RegenerateFrameOnThemeChange(BrowserThemeChangeType theme_change_type);
+  bool frameless_;
 
   // Returns true if the browser instance belongs to an incognito profile.
   bool IsIncognitoBrowser() const;
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_frame_mac.mm nw/chromium/chrome/browser/ui/views/frame/browser_frame_mac.mm
--- up/chromium/chrome/browser/ui/views/frame/browser_frame_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_frame_mac.mm	2024-08-26 19:32:19.418587268 +0000
@@ -4,6 +4,7 @@
 
 #import "chrome/browser/ui/views/frame/browser_frame_mac.h"
 
+#include "ui/display/display.h"
 #import "base/apple/foundation_util.h"
 #include "base/memory/raw_ptr.h"
 #include "chrome/app/chrome_command_ids.h"
@@ -143,6 +144,7 @@
 // BrowserFrameMac, views::NativeWidgetMac implementation:
 
 int32_t BrowserFrameMac::SheetOffsetY() {
+  return 0; //NWJS#7349
   // ModalDialogHost::GetDialogPosition() is relative to the host view. In
   // practice, this ends up being the widget's content view.
   web_modal::WebContentsModalDialogHost* dialog_host =
@@ -376,8 +378,16 @@
     // Hosted apps draw their own window title.
     if (browser_view_->GetIsWebAppType())
       params->window_title_hidden = true;
+  } else if (browser_view_->browser()->is_frameless()) {
+    params->window_class = remote_cocoa::mojom::WindowClass::kFrameless;
+    params->style_mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable |
+                         NSWindowStyleMaskMiniaturizable |
+                         NSWindowStyleMaskResizable |
+                         NSWindowStyleMaskFullSizeContentView;
   } else {
     params->window_class = remote_cocoa::mojom::WindowClass::kDefault;
+    if (widget_params.remove_standard_frame)
+      params->style_mask = NSWindowStyleMaskBorderless;
   }
   params->animation_enabled = true;
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_frame_view_win.cc nw/chromium/chrome/browser/ui/views/frame/browser_frame_view_win.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_frame_view_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_frame_view_win.cc	2024-08-26 19:32:19.418587268 +0000
@@ -265,6 +265,14 @@
   }
 }
 
+gfx::Size BrowserFrameViewWin::GetMaximumSize() const {
+  gfx::Size max_size(browser_view()->GetMaximumSize());
+  if (max_size.height() > 0 || max_size.width() > 0)
+    max_size.Enlarge(0, GetTopInset(false));
+
+  return max_size;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // BrowserFrameViewWin, views::NonClientFrameView implementation:
 
@@ -276,14 +284,21 @@
     const gfx::Rect& client_bounds) const {
   HWND hwnd = views::HWNDForWidget(frame());
   if (!browser_view()->GetTabStripVisible() && hwnd) {
-    // If we don't have a tabstrip, we're either a popup or an app window, in
-    // which case we have a standard size non-client area and can just use
-    // AdjustWindowRectEx to obtain it. We check for a non-null window handle in
-    // case this gets called before the window is actually created.
-    RECT rect = client_bounds.ToRECT();
-    AdjustWindowRectEx(&rect, GetWindowLong(hwnd, GWL_STYLE), FALSE,
-                       GetWindowLong(hwnd, GWL_EXSTYLE));
-    return gfx::Rect(rect);
+    if (ShouldBrowserCustomDrawTitlebar(browser_view())) {
+      const int top_inset = GetTopInset(false);
+      const int thickness = std::floor(
+        FrameTopBorderThicknessPx(false) /
+        display::win::ScreenWin::GetScaleFactorForHWND(hwnd));
+      return gfx::Rect(std::max(0, client_bounds.x()),
+        std::max(0, client_bounds.y() - top_inset),
+        client_bounds.width() + 2 * thickness, client_bounds.height() + top_inset + thickness);
+    }
+    else {
+      RECT rect = client_bounds.ToRECT();
+      AdjustWindowRectEx(&rect, GetWindowLong(hwnd, GWL_STYLE), FALSE,
+        GetWindowLong(hwnd, GWL_EXSTYLE));
+      return gfx::Rect(rect);
+    }
   }
 
   const int top_inset = GetTopInset(false);
@@ -308,6 +323,8 @@
   // If the point isn't within our bounds, then it's in the native portion of
   // the frame so again Windows can figure it out.
   if (!bounds().Contains(point)) {
+    if (browser_view()->size_constraints().HasFixedSize())
+      return HTCAPTION;
     return HTNOWHERE;
   }
 
@@ -532,6 +549,10 @@
     return 0;
   }
 
+#if 0
+  if (!browser_view()->CanResize() && !restored)
+    return 0;
+#endif
   // Note that this method assumes an equal resize handle thickness on all
   // sides of the window.
   // TODO(dfried): Consider having it return a gfx::Insets object instead.
@@ -602,6 +623,8 @@
   // FrameTopBorderThickness()) and floor(system dsf) pixels when restored.
   // Unfortunately we can't represent either of those at hidpi without using
   // non-integral dips, so we return the closest reasonable values instead.
+  if (!browser_view()->CanResize() && IsMaximized())
+    return 1;
   if (IsMaximized()) {
     return FrameTopBorderThickness(false);
   }
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_frame_view_win.h nw/chromium/chrome/browser/ui/views/frame/browser_frame_view_win.h
--- up/chromium/chrome/browser/ui/views/frame/browser_frame_view_win.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_frame_view_win.h	2024-08-26 19:32:19.418587268 +0000
@@ -45,6 +45,7 @@
   void UpdateThrobber(bool running) override;
   gfx::Size GetMinimumSize() const override;
   void WindowControlsOverlayEnabledChanged() override;
+  gfx::Size GetMaximumSize() const override;
 
   // views::NonClientFrameView:
   gfx::Rect GetBoundsForClientView() const override;
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc	2024-08-26 19:32:19.418587268 +0000
@@ -88,7 +88,7 @@
   }
 
 #if BUILDFLAG(IS_WIN)
-  if (frame->ShouldUseNativeFrame()) {
+  if (frame->ShouldUseNativeFrame() && !browser_view->browser()->is_transparent()) {
     return std::make_unique<BrowserFrameViewWin>(frame, browser_view);
   }
 #endif
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h
--- up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h	2024-08-26 19:32:19.418587268 +0000
@@ -71,6 +71,7 @@
   // views::View:
   gfx::Size GetMinimumSize() const override;
   void PaintChildren(const views::PaintInfo& info) override;
+  gfx::Size GetMaximumSize() const override;
 
   // web_app::WebAppRegistrarObserver
   void OnAlwaysShowToolbarInFullscreenChanged(const webapps::AppId& app_id,
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm
--- up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm	2024-08-26 19:32:19.418587268 +0000
@@ -362,6 +362,9 @@
   // BrowserView::NonClientHitTest will return HTNOWHERE for points that hit
   // the native title bar. On Mac, we need to explicitly return HTCAPTION for
   // those points.
+  SkRegion* draggable_region = browser_view()->GetDraggableRegion();
+  if (draggable_region && draggable_region->contains(point.x(), point.y()))
+    return HTCAPTION;
   const int component = frame()->client_view()->NonClientHitTest(point);
   return (component == HTNOWHERE && bounds().Contains(point)) ? HTCAPTION
                                                               : component;
@@ -394,7 +397,7 @@
   // certain height, which empirically seems to be related to their *minimum*
   // width rather than their current width. This 4:3 ratio was chosen
   // empirically because it looks decent for both tabbed and untabbed browsers.
-  client_size.SetToMax(gfx::Size(0, (client_size.width() * 3) / 4));
+  //client_size.SetToMax(gfx::Size(0, (client_size.width() * 3) / 4));
 
   return client_size;
 }
@@ -430,6 +433,11 @@
   }
 }
 
+gfx::Size BrowserNonClientFrameViewMac::GetMaximumSize() const {
+  gfx::Size client_size = frame()->client_view()->GetMaximumSize();
+  return client_size;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // BrowserNonClientFrameViewMac, protected:
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_view.cc nw/chromium/chrome/browser/ui/views/frame/browser_view.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_view.cc	2024-08-26 19:32:19.422587270 +0000
@@ -1,9 +1,34 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "chrome/browser/ui/views/frame/browser_view.h"
 
+#include "chrome/browser/extensions/api/tabs/tabs_windows_api.h"
+#include "chrome/browser/extensions/api/tabs/windows_event_router.h"
+#include "chrome/browser/extensions/browser_extension_window_controller.h"
+#include "components/favicon/content/content_favicon_driver.h"
+#include "content/public/browser/render_widget_host.h"
+
+#if defined(OS_MAC)
+#include "content/nw/src/nw_content_mac.h"
+#endif
+
+#if defined(OS_WIN)
+#include <shobjidl.h>
+#include <dwmapi.h>
+
+#include "base/win/windows_version.h"
+#include "ui/base/win/hidden_window.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/icon_util.h"
+#include "ui/gfx/font_list.h"
+#include "ui/gfx/platform_font.h"
+#include "ui/display/win/dpi.h"
+#include "ui/views/win/hwnd_util.h"
+#endif
+
 #include <stdint.h>
 
 #include <memory>
@@ -320,6 +345,9 @@
 #include "chrome/browser/ui/views/promos/ios_promo_password_bubble.h"
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
 
+#include "extensions/browser/app_window/app_window.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+
 #if defined(USE_AURA)
 #include "chrome/browser/ui/views/theme_profile_key.h"
 #include "ui/aura/client/window_parenting_client.h"
@@ -414,6 +442,18 @@
 
 #endif  // DCHECK_IS_ON()
 
+SkRegion* RawDraggableRegionsToSkRegion(
+	const std::vector<blink::mojom::DraggableRegionPtr>& regions) {
+  SkRegion* sk_region = new SkRegion;
+  for (const blink::mojom::DraggableRegionPtr& region : regions) {
+    sk_region->op(
+                  SkIRect::MakeLTRB(region->bounds.x(), region->bounds.y(), region->bounds.right(),
+                                    region->bounds.bottom()),
+        region->draggable ? SkRegion::kUnion_Op : SkRegion::kDifference_Op);
+  }
+  return sk_region;
+}
+
 bool GetGestureCommand(ui::GestureEvent* event, int* command) {
   DCHECK(command);
   *command = 0;
@@ -883,6 +923,14 @@
   feature_promo_controller_ = CreateUserEducationResources(this);
 
   browser_->tab_strip_model()->AddObserver(this);
+  resizable_ = browser_->initial_resizable();
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable_) {
+    gfx::Size size = browser_->override_bounds().size();
+    size_constraints_.set_minimum_size(size);
+    size_constraints_.set_maximum_size(size);
+  }
+#endif
   immersive_mode_controller_ = chrome::CreateImmersiveModeController(this);
 
   // Top container holds tab strip region and toolbar and lives at the front of
@@ -928,10 +976,12 @@
   devtools_web_view->SetVisible(false);
 
   auto contents_web_view =
-      std::make_unique<ContentsWebView>(browser_->profile());
+    std::make_unique<ContentsWebView>(browser_->profile(), browser_->is_transparent());
   contents_web_view->SetID(VIEW_ID_TAB_CONTAINER);
 
   auto contents_container = std::make_unique<views::View>();
+  if (browser_->is_transparent())
+    contents_container->SetBackground(views::CreateSolidBackground(SK_ColorTRANSPARENT));
   devtools_web_view_ =
       contents_container->AddChildView(std::move(devtools_web_view));
   contents_web_view_ =
@@ -977,8 +1027,8 @@
   infobar_container_ =
       AddChildView(std::make_unique<InfoBarContainerView>(this));
 
-  status_bubble_ = std::make_unique<StatusBubbleViews>(contents_web_view_);
-  contents_web_view_->SetStatusBubble(status_bubble_.get());
+  //status_bubble_ = std::make_unique<StatusBubbleViews>(contents_web_view_);
+  //contents_web_view_->SetStatusBubble(status_bubble_.get());
 
   // Create do-nothing view for the sake of controlling the z-order of the find
   // bar widget.
@@ -1015,6 +1065,90 @@
   browser_->GetFeatures().InitPostBrowserViewConstruction(this);
 }
 
+void BrowserView::ForceClose() {
+  GetWidget()->Close(true);
+}
+bool BrowserView::NWCanClose(bool user_force) const {
+  return browser_->NWCanClose(user_force);
+}
+
+void BrowserView::UpdateDraggableRegions(
+   const std::vector<blink::mojom::DraggableRegionPtr>& regions) {
+  // Draggable region is not supported for non-frameless window.
+  if (!browser_->is_frameless())
+    return;
+
+  draggable_region_.reset(RawDraggableRegionsToSkRegion(regions));
+  //OnViewWasResized();
+}
+
+
+void BrowserView::SetShowInTaskbar(bool show) {
+#if defined(OS_WIN)
+  views::Widget* widget = GetWidget()->GetTopLevelWidget();
+
+  if (show == false && base::win::GetVersion() < base::win::Version::VISTA) {
+    // Change the owner of native window. Only needed on Windows XP.
+    ::SetParent(views::HWNDForWidget(widget),
+                ui::GetHiddenWindow());
+  }
+
+  Microsoft::WRL::ComPtr<ITaskbarList3> taskbar;
+  HRESULT result = ::CoCreateInstance(CLSID_TaskbarList, nullptr,
+                                      CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&taskbar));
+  if (FAILED(result)) {
+    VLOG(1) << "Failed creating a TaskbarList object: " << result;
+    return;
+  }
+
+  result = taskbar->HrInit();
+  if (FAILED(result)) {
+    LOG(ERROR) << "Failed initializing an ITaskbarList interface.";
+    return;
+  }
+
+  if (show)
+    result = taskbar->AddTab(views::HWNDForWidget(widget));
+  else
+    result = taskbar->DeleteTab(views::HWNDForWidget(widget));
+
+  if (FAILED(result)) {
+    LOG(ERROR) << "Failed to change the show in taskbar attribute";
+    return;
+  }
+#elif defined(OS_MAC)
+  NWSetNSWindowShowInTaskbar(browser()->window()->GetNativeWindow(), show);
+#endif
+}
+
+SkRegion* BrowserView::GetDraggableRegion() {
+  return draggable_region_.get();
+}
+
+void BrowserView::SetAllVisible(bool visible) {
+  frame_->SetVisibleOnAllWorkspaces(visible);
+}
+
+void BrowserView::SetResizable(bool resizable) {
+  resizable_ = resizable;
+  SetCanResize(resizable_);
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable) {
+    size_constraints_.set_minimum_size(GetContentsSize());
+    size_constraints_.set_maximum_size(GetContentsSize());
+  } else {
+    size_constraints_ = saved_size_constraints_;
+#if defined(OS_LINUX) //NWJS#6609
+    if (size_constraints_.HasFixedSize())
+      size_constraints_ = extensions::SizeConstraints();
+#endif
+  }
+#endif
+  GetWidget()->OnSizeConstraintsChanged();
+  frame_->non_client_view()->ResetWindowControls();
+  frame_->non_client_view()->LayoutImmediately();
+}
+
 BrowserView::~BrowserView() {
   browser_->GetFeatures().TearDownPreBrowserViewDestruction();
 
@@ -1341,7 +1475,7 @@
 }
 
 void BrowserView::Hide() {
-  // Not implemented.
+  frame_->Hide();
 }
 
 bool BrowserView::IsVisible() const {
@@ -1379,6 +1513,13 @@
   }
 }
 
+#if defined(OS_WIN)
+void BrowserView::SetPosition(const gfx::Point& pos) {
+  ExitFullscreen();
+  GetWidget()->SetPosition(pos);
+}
+#endif
+
 void BrowserView::Close() {
   frame_->Close();
 }
@@ -1409,8 +1550,7 @@
 }
 
 void BrowserView::SetZOrderLevel(ui::ZOrderLevel level) {
-  // Not implemented for browser windows.
-  NOTIMPLEMENTED();
+  frame_->SetZOrderLevel(level);
 }
 
 gfx::NativeWindow BrowserView::GetNativeWindow() const {
@@ -1765,6 +1905,7 @@
   // Update all the UI bits.
   UpdateTitleBar();
 
+#if 0
   if (old_contents) {
     TranslateBubbleController* translate_bubble_controller =
         TranslateBubbleController::FromWebContents(old_contents);
@@ -1772,6 +1913,7 @@
     if (translate_bubble_controller)
       translate_bubble_controller->CloseBubble();
   }
+#endif
 
   // This is only done once when the app is first opened so that there is only
   // one subscriber per web contents.
@@ -1951,12 +2093,12 @@
     const ExclusiveAccessBubbleParams& params,
     ExclusiveAccessBubbleHideCallback first_hide_callback) {
   // Trusted pinned mode does not allow to escape. So do not show the bubble.
-  bool is_trusted_pinned =
-      platform_util::IsBrowserLockedFullscreen(browser_.get());
+  //bool is_trusted_pinned =
+  //    platform_util::IsBrowserLockedFullscreen(browser_.get());
 
   // Whether we should remove the bubble if it exists, or not show the bubble.
   // TODO(jamescook): Figure out what to do with mouse-lock.
-  bool should_close_bubble = is_trusted_pinned;
+  bool should_close_bubble = true; //is_trusted_pinned;
   if (!params.has_download) {
     // ...TYPE_NONE indicates deleting the bubble, except when used with
     // download.
@@ -2108,9 +2250,11 @@
 
   browser_->WindowFullscreenStateChanged();
 
+  if (GetExclusiveAccessManager() && GetExclusiveAccessManager()->fullscreen_controller()) {
   GetExclusiveAccessManager()
       ->fullscreen_controller()
       ->FullscreenTransitionCompleted();
+  }
 
   if (base::FeatureList::IsEnabled(features::kAsyncFullscreenWindowState)) {
     ToolbarSizeChanged(false);
@@ -3154,6 +3298,7 @@
     return ShowTranslateBubbleResult::EDITABLE_FIELD_IS_ACTIVE;
   }
 
+#if 0
   ChromeTranslateClient::FromWebContents(web_contents)
       ->GetTranslateManager()
       ->GetLanguageState()
@@ -3177,12 +3322,14 @@
                             is_user_gesture ? TranslateBubbleView::USER_GESTURE
                                             : TranslateBubbleView::AUTOMATIC);
 
+#endif
   return ShowTranslateBubbleResult::SUCCESS;
 }
 
 void BrowserView::StartPartialTranslate(const std::string& source_language,
                                         const std::string& target_language,
                                         const std::u16string& text_selection) {
+#if 0
   // Show the Translate icon and enabled the associated command to show the
   // Translate UI.
   ChromeTranslateClient::FromWebContents(GetActiveWebContents())
@@ -3196,6 +3343,7 @@
                               toolbar_button_provider()->GetPageActionIconView(
                                   PageActionIconType::kTranslate),
                               source_language, target_language, text_selection);
+#endif
 }
 
 void BrowserView::ShowOneClickSigninConfirmation(
@@ -3533,7 +3681,11 @@
 // BrowserView, views::WidgetDelegate implementation:
 
 bool BrowserView::CanResize() const {
+#if defined(OS_MAC)
+  return resizable_;
+#else
   return WidgetDelegate::CanResize() && GetCanResizeFromWebAPI().value_or(true);
+#endif
 }
 
 bool BrowserView::CanFullscreen() const {
@@ -3542,8 +3694,7 @@
 }
 
 bool BrowserView::CanMaximize() const {
-  return WidgetDelegate::CanMaximize() &&
-         GetCanResizeFromWebAPI().value_or(true);
+  return resizable_ && size_constraints_.GetMaximumSize().IsEmpty() && !WidgetHasHitTestMask();
 }
 
 bool BrowserView::CanActivate() const {
@@ -3879,17 +4030,82 @@
 }
 
 ui::ImageModel BrowserView::GetWindowAppIcon() {
+#if 1
+  if (browser_->is_type_devtools()) {
+    WebContents* contents = browser_->tab_strip_model()->GetActiveWebContents();
+    DevToolsWindow* devtools_window =
+        DevToolsWindow::AsDevToolsWindow(contents);
+    if (devtools_window) {
+      WebContents* inspected_contents =
+          devtools_window->GetInspectedWebContents();
+      if (!inspected_contents)
+        return ui::ImageModel();
+      Browser* browser = chrome::FindBrowserWithTab(inspected_contents);
+      if (browser && !browser->icon_override().IsEmpty())
+        return ui::ImageModel::FromImage(browser->icon_override());
+      favicon::FaviconDriver* favicon_driver =
+          favicon::ContentFaviconDriver::FromWebContents(inspected_contents);
+      gfx::Image app_icon;
+      if (favicon_driver)
+        app_icon = favicon_driver->GetFavicon();
+      if (!app_icon.IsEmpty())
+        return ui::ImageModel::FromImage(app_icon);
+      Profile* profile =
+          Profile::FromBrowserContext(contents->GetBrowserContext());
+      extensions::AppWindowRegistry* registry =
+          extensions::AppWindowRegistry::Get(profile);
+      if (registry) {
+        extensions::AppWindow* app_window =
+            registry->GetAppWindowForWebContents(inspected_contents);
+        if (app_window)
+          return ui::ImageModel::FromImageSkia(app_window->custom_app_icon().AsImageSkia());
+      }
+    }
+  }
+#endif
   web_app::AppBrowserController* app_controller = browser()->app_controller();
   return app_controller ? app_controller->GetWindowAppIcon() : GetWindowIcon();
 }
 
 ui::ImageModel BrowserView::GetWindowIcon() {
+  gfx::Image icon_override = browser()->icon_override();
+  if (!icon_override.IsEmpty())
+    return ui::ImageModel::FromImageSkia(*icon_override.ToImageSkia());
   // Use the default icon for devtools.
-  if (browser_->is_type_devtools())
+  if (browser_->is_type_devtools()) {
+    WebContents* active_content = browser_->tab_strip_model()->GetActiveWebContents();
+    DevToolsWindow* devtools_window =
+        DevToolsWindow::AsDevToolsWindow(active_content);
+    if (devtools_window) {
+      WebContents* inspected_contents =
+          devtools_window->GetInspectedWebContents();
+      Browser* browser = chrome::FindBrowserWithTab(inspected_contents);
+      if (browser && !browser->icon_override().IsEmpty())
+        return ui::ImageModel::FromImageSkia(*browser->icon_override().ToImageSkia());
+      favicon::FaviconDriver* favicon_driver = nullptr;
+      if (inspected_contents)
+          favicon_driver = favicon::ContentFaviconDriver::FromWebContents(inspected_contents);
+      gfx::Image app_icon;
+      if (favicon_driver)
+        app_icon = favicon_driver->GetFavicon();
+      if (!app_icon.IsEmpty())
+        return ui::ImageModel::FromImageSkia(*app_icon.ToImageSkia());
+      Profile* profile =
+          Profile::FromBrowserContext(active_content->GetBrowserContext());
+      extensions::AppWindowRegistry* registry =
+          extensions::AppWindowRegistry::Get(profile);
+      if (registry) {
+        extensions::AppWindow* app_window =
+            registry->GetAppWindowForWebContents(inspected_contents);
+        if (app_window)
+          return ui::ImageModel::FromImageSkia(app_window->custom_app_icon().AsImageSkia());
+      }
+    }
     return ui::ImageModel();
+  }
 
   // Hosted apps always show their app icon.
-  web_app::AppBrowserController* app_controller = browser()->app_controller();
+  web_app::AppBrowserController* app_controller = browser_->app_controller();
   if (app_controller)
     return app_controller->GetWindowIcon();
 
@@ -3933,7 +4149,7 @@
   // If IsFullscreen() is true, we've just changed into fullscreen mode, and
   // we're catching the going-into-fullscreen sizing and positioning calls,
   // which we want to ignore.
-  return !IsFullscreen() && frame_->ShouldSaveWindowPlacement() &&
+  return /* !IsFullscreen() && */ frame_->ShouldSaveWindowPlacement() &&
          chrome::ShouldSaveWindowPlacement(browser_.get());
 }
 
@@ -3941,17 +4157,26 @@
                                       ui::WindowShowState show_state) {
   DCHECK(ShouldSaveWindowPlacement());
 
-  WidgetDelegate::SaveWindowPlacement(bounds, show_state);
   gfx::Rect saved_bounds = bounds;
   if (chrome::SavedBoundsAreContentBounds(browser_.get())) {
+#if 0
     // Invert the transformation done in GetSavedWindowPlacement().
     gfx::Size client_size =
         frame_->GetFrameView()->GetBoundsForClientView().size();
     if (IsToolbarVisible())
       client_size.Enlarge(0, -toolbar_->GetPreferredSize().height());
     saved_bounds.set_size(client_size);
+#endif
+    gfx::Rect client_bounds = gfx::Rect(1000, 1000);
+    gfx::Rect window_bounds =
+          frame_->non_client_view()->GetWindowBoundsForClientBounds(client_bounds);
+    gfx::Insets insets = window_bounds.InsetsFrom(client_bounds);
+    saved_bounds.Inset(insets);
+    saved_bounds.set_origin(bounds.origin());
   }
+  WidgetDelegate::SaveWindowPlacement(bounds, show_state);
   chrome::SaveWindowPlacement(browser_.get(), saved_bounds, show_state);
+  NativeWindowChanged();
 }
 
 bool BrowserView::GetSavedWindowPlacement(
@@ -3996,7 +4221,7 @@
     rect.AdjustToFit(display.work_area());
 
     *bounds = rect;
-    *show_state = ui::SHOW_STATE_NORMAL;
+    //*show_state = ui::SHOW_STATE_NORMAL;
   }
 
   // We return true because we can _always_ locate reasonable bounds using the
@@ -4093,6 +4318,13 @@
 }
 #endif  // IS_MAC
 
+void BrowserView::NativeWindowChanged() {
+  extensions::TabsWindowsAPI* tabs_window_api =
+    extensions::TabsWindowsAPI::Get(browser_->profile());
+  tabs_window_api->windows_event_router()->
+    OnWindowChanged(browser_ ? browser_->extension_window_controller() : nullptr);
+}
+
 void BrowserView::OnWidgetDestroying(views::Widget* widget) {
   DCHECK(widget_observation_.IsObservingSource(widget));
   widget_observation_.Reset();
@@ -4189,6 +4421,10 @@
   LocationBarView* location_bar_view = GetLocationBarView();
   if (location_bar_view)
     location_bar_view->GetOmniboxView()->CloseOmniboxPopup();
+  extensions::TabsWindowsAPI* tabs_window_api =
+    extensions::TabsWindowsAPI::Get(browser_->profile());
+  tabs_window_api->windows_event_router()->
+    OnWindowMove(browser_ ? browser_->extension_window_controller() : nullptr);
 }
 
 views::Widget* BrowserView::GetWidget() {
@@ -4303,6 +4539,18 @@
            WidgetOwnedByAnchorContainsPoint(point_in_contents_web_view_coords);
   }
 
+#if defined(USE_AURA)
+  WebContents* web_contents = GetActiveWebContents();
+  if (!web_contents)
+    return true;
+  if (child->Contains(web_contents->GetNativeView())) {
+    // App window should claim mouse events that fall within the draggable
+    // region.
+    return !draggable_region_.get() ||
+           !draggable_region_->contains(location.x(), location.y());
+  }
+#endif
+
   return true;
 }
 
@@ -4381,10 +4629,27 @@
   return GetBrowserViewLayout()->NonClientHitTest(point);
 }
 
+void BrowserView::SetMinimumSize(gfx::Size size) {
+  size_constraints_.set_minimum_size(size);
+  saved_size_constraints_ = size_constraints_;
+  GetWidget()->OnSizeConstraintsChanged();
+}
+
+void BrowserView::SetMaximumSize(gfx::Size size) {
+  size_constraints_.set_maximum_size(size);
+  saved_size_constraints_ = size_constraints_;
+  GetWidget()->OnSizeConstraintsChanged();
+}
+
 gfx::Size BrowserView::GetMinimumSize() const {
+  if (size_constraints_.HasMinimumSize())
+    return size_constraints_.GetMinimumSize();
   return GetBrowserViewLayout()->GetMinimumSize(this);
 }
 
+gfx::Size BrowserView::GetMaximumSize() const {
+  return size_constraints_.GetMaximumSize();
+}
 ///////////////////////////////////////////////////////////////////////////////
 // BrowserView, views::View overrides:
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_view.h nw/chromium/chrome/browser/ui/views/frame/browser_view.h
--- up/chromium/chrome/browser/ui/views/frame/browser_view.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_view.h	2024-08-26 19:32:19.422587270 +0000
@@ -11,6 +11,8 @@
 #include <string>
 #include <vector>
 
+#include "extensions/browser/app_window/size_constraints.h"
+
 #include "base/callback_list.h"
 #include "base/gtest_prod_util.h"
 #include "base/memory/raw_ptr.h"
@@ -156,6 +158,8 @@
   }
   BrowserFrame* frame() const { return frame_; }
 
+  const extensions::SizeConstraints& size_constraints() const { return size_constraints_; }
+
   // Returns a pointer to the BrowserView* interface implementation (an
   // instance of this object, typically) for a given native window, or null if
   // there is no such association.
@@ -443,11 +447,24 @@
   std::optional<bool> GetCanResizeFromWebAPI() const;
 
   // BrowserWindow:
+  void ForceClose() override;
+  void SetShowInTaskbar(bool) override;
+  void NativeWindowChanged() override;
+  void SetMinimumSize(gfx::Size) override;
+  void SetMaximumSize(gfx::Size) override;
+  void SetResizable(bool) override;
+  void SetAllVisible(bool) override;
+  void UpdateDraggableRegions(
+			      const std::vector<blink::mojom::DraggableRegionPtr>& regions) override;
+  SkRegion* GetDraggableRegion() override;
   void Show() override;
   void ShowInactive() override;
   void Hide() override;
   bool IsVisible() const override;
   void SetBounds(const gfx::Rect& bounds) override;
+#if defined(OS_WIN)
+  void SetPosition(const gfx::Point& pos) override;
+#endif
   void Close() override;
   void Activate() override;
   void Deactivate() override;
@@ -665,6 +682,7 @@
                                   ui::Accelerator* accelerator) const override;
 
   // views::WidgetDelegate:
+  bool NWCanClose(bool user_force = false) const override;
   bool CanResize() const override;
   bool CanFullscreen() const override;
   bool CanMaximize() const override;
@@ -726,6 +744,7 @@
   views::CloseRequestResult OnWindowCloseRequested() override;
   int NonClientHitTest(const gfx::Point& point) override;
   gfx::Size GetMinimumSize() const override;
+  gfx::Size GetMaximumSize() const override;
 
   // infobars::InfoBarContainer::Delegate:
   void InfoBarContainerStateChanged(bool is_animating) override;
@@ -901,12 +920,13 @@
   void CreateJumpList();
 #endif
 
+public:
   // Returns the BrowserViewLayout.
   BrowserViewLayout* GetBrowserViewLayout() const;
 
   // Returns the ContentsLayoutManager.
   ContentsLayoutManager* GetContentsLayoutManager() const;
-
+private:
   // Prepare to show the Bookmark Bar for the specified WebContents.
   // Returns true if the Bookmark Bar can be shown (i.e. it's supported for this
   // Browser type) and there should be a subsequent re-layout to show it.
@@ -1023,6 +1043,7 @@
   // and activates them. It returns true if it succeeded activating a bubble or
   // false otherwise.
   bool ActivateFirstInactiveBubbleForAccessibility();
+  std::unique_ptr<SkRegion> draggable_region_;
 
   // Notifies that window bounds changed to extensions if needed.
   void TryNotifyWindowBoundsChanged(const gfx::Rect& widget_bounds);
@@ -1039,6 +1060,9 @@
   // side panel. Should be called when the IPH backend is initialized or
   // whenever the touch mode changes.
   void MaybeShowReadingListInSidePanelIPH();
+  bool resizable_ = true;
+
+  extensions::SizeConstraints size_constraints_, saved_size_constraints_;
 
   // Attempts to show IPH promo for experimental AI.
   void MaybeShowExperimentalAIIPH();
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_view_layout.cc nw/chromium/chrome/browser/ui/views/frame/browser_view_layout.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_view_layout.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_view_layout.cc	2024-08-26 19:32:19.422587270 +0000
@@ -61,6 +61,8 @@
 // of the omnibox.
 const int kConstrainedWindowOverlap = 3;
 
+const int kMenuHeight = 25;
+
 // Combines View::ConvertPointToTarget and View::HitTest for a given |point|.
 // Converts |point| from |src| to |dst| and hit tests it against |dst|. The
 // converted |point| can then be retrieved and used for additional tests.
@@ -102,7 +104,7 @@
     views::View* view = browser_view_layout_->contents_container_;
     gfx::Rect rect = view->ConvertRectToWidget(view->GetLocalBounds());
     const int middle_x = rect.x() + rect.width() / 2;
-    const int top = browser_view_layout_->dialog_top_y_;
+    const int top = rect.y() + rect.height() / 2 - size.height() / 2; //browser_view_layout_->web_contents_modal_dialog_top_y_;
     return gfx::Point(middle_x - size.width() / 2, top);
   }
 
@@ -167,6 +169,7 @@
     views::View* contents_separator)
     : delegate_(std::move(delegate)),
       browser_view_(browser_view),
+      menu_bar_(nullptr),
       top_container_(top_container),
       web_app_frame_toolbar_(web_app_frame_toolbar),
       web_app_window_title_(web_app_window_title),
@@ -234,11 +237,14 @@
                       kMainBrowserContentsMinimumHeight)
           : kContentsMinimumSize);
 
-  const int min_height =
+  int min_height =
       delegate_->GetTopInsetInBrowserView() + tabstrip_size.height() +
       toolbar_size.height() + bookmark_bar_size.height() +
       infobar_container_size.height() + contents_size.height();
 
+  if (menu_bar_)
+    min_height += kMenuHeight;
+
   const int min_width = std::max(
       {tabstrip_size.width(), toolbar_size.width(), bookmark_bar_size.width(),
        infobar_container_size.width(), contents_size.width()});
@@ -402,6 +408,11 @@
   }
   top = LayoutToolbar(top);
 
+  if (menu_bar_) {
+    menu_bar_->SetBounds(0, top, browser_view_->width(), kMenuHeight);
+    top += kMenuHeight;
+  }
+
   top = LayoutBookmarkAndInfoBars(top, browser_view->y());
 
   // Top container requires updated toolbar and bookmark bar to compute bounds.
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_view_layout.h nw/chromium/chrome/browser/ui/views/frame/browser_view_layout.h
--- up/chromium/chrome/browser/ui/views/frame/browser_view_layout.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_view_layout.h	2024-08-26 19:32:19.422587270 +0000
@@ -99,6 +99,8 @@
   // this function only controls where it's drawn when it is in fact drawn.
   void SetContentBorderBounds(
       const std::optional<gfx::Rect>& region_capture_rect);
+  void set_menu_bar(views::View* menu_bar) { menu_bar_ = menu_bar; }
+  views::View* menu_bar() { return menu_bar_; }
 
   web_modal::WebContentsModalDialogHost* GetWebContentsModalDialogHost();
 
@@ -179,6 +181,7 @@
   // Child views that the layout manager manages.
   // NOTE: If you add a view, try to add it as a views::View, which makes
   // testing much easier.
+  raw_ptr<views::View> menu_bar_;
   const raw_ptr<views::View, AcrossTasksDanglingUntriaged> top_container_;
   const raw_ptr<WebAppFrameToolbarView, DanglingUntriaged>
       web_app_frame_toolbar_;
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_window_factory.cc nw/chromium/chrome/browser/ui/views/frame/browser_window_factory.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_window_factory.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_window_factory.cc	2024-08-26 19:32:19.422587270 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include <memory>
+#include "ui/display/screen.h"
 
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -51,6 +52,8 @@
 #endif
   // Create the view and the frame. The frame will attach itself via the view
   // so we don't need to do anything with the pointer.
+  bool frameless = browser->is_frameless();
+  std::string position = browser->initial_position();
   BrowserView* view = nullptr;
   BrowserFrame* browser_frame = nullptr;
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -64,10 +67,21 @@
   browser_frame = new BrowserFrameLacros(view);
 #endif
   if (!browser_frame)
-    browser_frame = new BrowserFrame(view);
+    browser_frame = new BrowserFrame(view, frameless);
   if (in_tab_dragging)
     browser_frame->SetTabDragKind(TabDragKind::kAllTabs);
-  browser_frame->InitBrowserFrame();
+  bool got_saved_bounds = browser_frame->InitBrowserFrame();
+
+  if (position == "mouse" && !got_saved_bounds) {
+      gfx::Point cursor_pos(display::Screen::GetScreen()->GetCursorScreenPoint());
+      gfx::Rect bounds = browser_frame->GetWindowBoundsInScreen();
+      bounds.set_origin(cursor_pos);
+      browser_frame->SetBounds(bounds);
+  }
+  if (position == "center" && !got_saved_bounds) {
+    gfx::Rect bounds = browser_frame->GetWindowBoundsInScreen();
+    browser_frame->CenterWindow(bounds.size());
+  }
 
 #if BUILDFLAG(IS_MAC)
   if (view->UsesImmersiveFullscreenMode()) {
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_window_property_manager_win.cc nw/chromium/chrome/browser/ui/views/frame/browser_window_property_manager_win.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_window_property_manager_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_window_property_manager_win.cc	2024-08-26 19:32:19.422587270 +0000
@@ -54,12 +54,13 @@
   std::wstring app_id =
       browser->is_type_app() || browser->is_type_app_popup() ||
               browser->is_type_devtools()
+       || true
           ? shell_integration::win::GetAppUserModelIdForApp(
                 base::UTF8ToWide(browser->app_name()), profile->GetPath())
           : shell_integration::win::GetAppUserModelIdForBrowser(
                 profile->GetPath());
   // Apps set their relaunch details based on app's details.
-  if (browser->is_type_app() || browser->is_type_app_popup()) {
+  if (browser->is_type_app() || browser->is_type_app_popup() || true) {
     ExtensionRegistry* registry = ExtensionRegistry::Get(profile);
     const extensions::Extension* extension = registry->GetExtensionById(
         web_app::GetAppIdFromApplicationName(browser->app_name()),
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/contents_web_view.cc nw/chromium/chrome/browser/ui/views/frame/contents_web_view.cc
--- up/chromium/chrome/browser/ui/views/frame/contents_web_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/contents_web_view.cc	2024-08-26 19:32:19.422587270 +0000
@@ -24,9 +24,11 @@
 DEFINE_CLASS_ELEMENT_IDENTIFIER_VALUE(ContentsWebView,
                                       kContentsWebViewElementId);
 
-ContentsWebView::ContentsWebView(content::BrowserContext* browser_context)
+ContentsWebView::ContentsWebView(content::BrowserContext* browser_context,
+                                 bool transparent)
     : views::WebView(browser_context),
-      status_bubble_(nullptr) {
+      status_bubble_(nullptr),
+      transparent_(transparent) {
   SetProperty(views::kElementIdentifierKey, kContentsWebViewElementId);
 }
 
@@ -85,15 +87,17 @@
   SkColor color = GetColorProvider()->GetColor(
       is_letterboxing() ? kColorWebContentsBackgroundLetterboxing
                         : kColorWebContentsBackground);
+  if (transparent_)
+    SetBackground(views::CreateSolidBackground(SK_ColorTRANSPARENT));
+  else
   SetBackground(background_visible_ ? views::CreateRoundedRectBackground(
                                           color, background_radii_)
                                     : nullptr);
-
   if (web_contents()) {
     content::RenderWidgetHostView* rwhv =
         web_contents()->GetRenderWidgetHostView();
     if (rwhv) {
-      rwhv->SetBackgroundColor(background_visible_ ? color
+      rwhv->SetBackgroundColor(background_visible_ && !transparent_ ? color
                                                    : SK_ColorTRANSPARENT);
     }
   }
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/contents_web_view.h nw/chromium/chrome/browser/ui/views/frame/contents_web_view.h
--- up/chromium/chrome/browser/ui/views/frame/contents_web_view.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/contents_web_view.h	2024-08-26 19:32:19.422587270 +0000
@@ -28,7 +28,7 @@
  public:
   DECLARE_CLASS_ELEMENT_IDENTIFIER_VALUE(kContentsWebViewElementId);
 
-  explicit ContentsWebView(content::BrowserContext* browser_context);
+  explicit ContentsWebView(content::BrowserContext* browser_context, bool transparent);
   ContentsWebView(const ContentsWebView&) = delete;
   ContentsWebView& operator=(const ContentsWebView&) = delete;
   ~ContentsWebView() override;
@@ -63,6 +63,7 @@
  private:
   void UpdateBackgroundColor();
   raw_ptr<StatusBubbleViews> status_bubble_;
+  bool transparent_;
 
   bool background_visible_ = true;
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
--- up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc	2024-08-26 19:32:19.426587272 +0000
@@ -127,6 +127,7 @@
     BrowserView* browser_view,
     OpaqueBrowserFrameViewLayout* layout)
     : BrowserNonClientFrameView(frame, browser_view),
+      frameless_(frame->frameless()),
       layout_(layout),
       window_icon_(nullptr),
       window_title_(nullptr),
@@ -142,6 +143,8 @@
     layout_->SetBorderlessModeEnabled(browser_view->IsBorderlessModeEnabled(),
                                       this);
   }
+  if (frameless_)
+    return;
   SetLayoutManager(std::unique_ptr<views::LayoutManager>(layout_));
 }
 
@@ -199,7 +202,7 @@
       close_button_,
       base::BindRepeating(&BrowserFrame::CloseWithReason,
                           base::Unretained(frame()),
-                          views::Widget::ClosedReason::kCloseButtonClicked),
+                          views::Widget::ClosedReason::kCloseButtonClicked, false),
       IDS_ACCNAME_CLOSE, VIEW_ID_CLOSE_BUTTON);
 
   // Initializing the TabIconView is expensive, so only do it if we need to.
@@ -294,19 +297,45 @@
   UpdateCaptionButtonPlaceholderContainerBackground();
   BrowserNonClientFrameView::OnThemeChanged();
 }
+
+gfx::Size OpaqueBrowserFrameView::GetMaximumSize() const {
+  return layout_->GetMaximumSize(this);
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // OpaqueBrowserFrameView, views::NonClientFrameView implementation:
 
 gfx::Rect OpaqueBrowserFrameView::GetBoundsForClientView() const {
+  if (frameless_)
+    return bounds();
   return layout_->client_view_bounds();
 }
 
 gfx::Rect OpaqueBrowserFrameView::GetWindowBoundsForClientBounds(
     const gfx::Rect& client_bounds) const {
+  if (frameless_) {
+    gfx::Rect window_bounds = client_bounds;
+    if (window_bounds.IsEmpty()) {
+      window_bounds.set_width(1);
+      window_bounds.set_height(1);
+    }
+    return window_bounds;
+  }
   return layout_->GetWindowBoundsForClientBounds(client_bounds);
 }
 
 int OpaqueBrowserFrameView::NonClientHitTest(const gfx::Point& point) {
+  if (frameless_) {
+    constexpr int kResizeAreaCornerSize = 16;
+    views::WidgetDelegate* delegate = frame()->widget_delegate();
+    if (!delegate)
+      return HTCAPTION;
+    int window_component = GetHTComponentForFrame(
+      point, gfx::Insets(5),
+      kResizeAreaCornerSize, kResizeAreaCornerSize, delegate->CanResize());
+    if (window_component != HTNOWHERE)
+      return window_component;
+  }
   int super_component = BrowserNonClientFrameView::NonClientHitTest(point);
   if (super_component != HTNOWHERE)
     return super_component;
@@ -314,6 +343,10 @@
   if (!bounds().Contains(point))
     return HTNOWHERE;
 
+  SkRegion* draggable_region = browser_view()->GetDraggableRegion();
+  if (draggable_region && draggable_region->contains(point.x(), point.y()))
+    return HTCAPTION;
+
   int frame_component = frame()->client_view()->NonClientHitTest(point);
 
   // See if we're in the sysmenu region.  We still have to check the tabstrip
@@ -395,10 +428,17 @@
 }
 
 void OpaqueBrowserFrameView::ResetWindowControls() {
+  if (frameless_)
+    return;
   BrowserNonClientFrameView::ResetWindowControls();
-  restore_button_->SetState(views::Button::STATE_NORMAL);
   minimize_button_->SetState(views::Button::STATE_NORMAL);
-  maximize_button_->SetState(views::Button::STATE_NORMAL);
+  if (browser_view()->CanMaximize()) {
+    restore_button_->SetState(views::Button::STATE_NORMAL);
+    maximize_button_->SetState(views::Button::STATE_NORMAL);
+  } else {
+    restore_button_->SetState(views::Button::STATE_DISABLED);
+    maximize_button_->SetState(views::Button::STATE_DISABLED);
+  }
   // The close button isn't affected by this constraint.
 }
 
@@ -408,6 +448,8 @@
 }
 
 void OpaqueBrowserFrameView::UpdateWindowTitle() {
+  if (frameless_)
+    return;
   if (!frame()->IsFullscreen() && ShouldShowWindowTitle()) {
     DeprecatedLayoutImmediately();
     if (window_title_) {
@@ -482,6 +524,10 @@
   return browser_view()->GetMinimumSize();
 }
 
+gfx::Size OpaqueBrowserFrameView::GetBrowserViewMaximumSize() const {
+  return browser_view()->GetMaximumSize();
+}
+
 bool OpaqueBrowserFrameView::ShouldShowCaptionButtons() const {
   return GetShowWindowTitleBar();
 }
@@ -599,7 +645,7 @@
 // views::View:
 void OpaqueBrowserFrameView::OnPaint(gfx::Canvas* canvas) {
   TRACE_EVENT0("views.frame", "OpaqueBrowserFrameView::OnPaint");
-  if (frame()->IsFullscreen())
+  if (frame()->IsFullscreen() || frameless_)
     return;  // Nothing is visible, so don't bother to paint.
 
   const bool active = ShouldPaintAsActive();
@@ -802,6 +848,8 @@
   if (frame()->IsFullscreen())
     return false;
 
+  if (frameless_)
+    return false;
   // Do not show caption buttons if the window manager is forcefully providing a
   // title bar (e.g., in Ubuntu Unity, if the window is maximized).
   return !views::ViewsDelegate::GetInstance()->WindowManagerProvidesTitleBar(
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.h nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.h
--- up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.h	2024-08-26 19:32:19.426587272 +0000
@@ -71,6 +71,7 @@
   gfx::Size GetMinimumSize() const override;
   void PaintAsActiveChanged() override;
   void OnThemeChanged() override;
+  gfx::Size GetMaximumSize() const override;
 
   // views::NonClientFrameView:
   gfx::Rect GetBoundsForClientView() const override;
@@ -95,6 +96,7 @@
   std::u16string GetWindowTitle() const override;
   int GetIconSize() const override;
   gfx::Size GetBrowserViewMinimumSize() const override;
+  gfx::Size GetBrowserViewMaximumSize() const override;
   bool ShouldShowCaptionButtons() const override;
   bool IsRegularOrGuestSession() const override;
   bool CanMaximize() const override;
@@ -215,6 +217,7 @@
   void UpdateCaptionButtonToolTipsForWindowControlsOverlay();
 #endif
 
+  bool frameless_;
   // Our layout manager also calculates various bounds.
   raw_ptr<OpaqueBrowserFrameViewLayout> layout_;
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
--- up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc	2024-08-26 19:32:19.426587272 +0000
@@ -110,16 +110,27 @@
   window_title_label.SetBoundsRect(bounds);
 }
 
+gfx::Size OpaqueBrowserFrameViewLayout::GetMaximumSize(
+         const views::View* host) const {
+  return GetMinimumSizeHelper(host, true);
+}
+
 gfx::Size OpaqueBrowserFrameViewLayout::GetMinimumSize(
-    const views::View* host) const {
-  // Ensure that we can fit the main browser view.
-  gfx::Size min_size = delegate_->GetBrowserViewMinimumSize();
+         const views::View* host) const {
+  return GetMinimumSizeHelper(host, false);
+}
+
+gfx::Size OpaqueBrowserFrameViewLayout::GetMinimumSizeHelper(
+         const views::View* host, bool max) const {
+  gfx::Size min_size = max? delegate_->GetBrowserViewMaximumSize() : delegate_->GetBrowserViewMinimumSize();
+  if (max && min_size.IsEmpty())
+    return min_size;
+
   if (delegate_->GetBorderlessModeEnabled()) {
     // In borderless mode the window doesn't have the window controls or tab
     // strip.
     return min_size;
   }
-
   // Ensure that we can, at minimum, hold our window controls and a tab strip.
   int top_width = minimum_size_for_buttons_;
   if (delegate_->IsTabStripVisible())
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h
--- up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h	2024-08-26 19:32:19.426587272 +0000
@@ -135,6 +135,8 @@
   // Called explicitly from OpaqueBrowserFrameView so we can't group it with
   // the other overrides.
   gfx::Size GetMinimumSize(const views::View* host) const override;
+  gfx::Size GetMaximumSize(const views::View* host) const;
+  gfx::Size GetMinimumSizeHelper(const views::View* host, bool max) const;
 
 
  protected:
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout_delegate.h nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout_delegate.h
--- up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout_delegate.h	2024-08-26 19:32:19.426587272 +0000
@@ -44,6 +44,7 @@
   // Returns the browser's minimum view size. Used because we need to calculate
   // the minimum size for the entire non-client area.
   virtual gfx::Size GetBrowserViewMinimumSize() const = 0;
+  virtual gfx::Size GetBrowserViewMaximumSize() const = 0;
 
   // Whether we should show the (minimize,maximize,close) buttons. This can
   // depend on the current state of the window (e.g., whether it is maximized).
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/system_menu_model_builder.cc nw/chromium/chrome/browser/ui/views/frame/system_menu_model_builder.cc
--- up/chromium/chrome/browser/ui/views/frame/system_menu_model_builder.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/system_menu_model_builder.cc	2024-08-26 19:32:19.426587272 +0000
@@ -117,6 +117,7 @@
 
 void SystemMenuModelBuilder::BuildSystemMenuForAppOrPopupWindow(
     ui::SimpleMenuModel* model) {
+#if 0
   model->AddItemWithStringId(IDC_BACK, IDS_CONTENT_CONTEXT_BACK);
   model->AddItemWithStringId(IDC_FORWARD, IDS_CONTENT_CONTEXT_FORWARD);
   model->AddItemWithStringId(IDC_RELOAD, IDS_APP_MENU_RELOAD);
@@ -163,6 +164,7 @@
   AppendMoveToDesksMenu(model);
 #endif
   AppendTeleportMenu(model);
+#endif
 }
 
 #if BUILDFLAG(IS_CHROMEOS)
diff -r -u --color up/chromium/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc nw/chromium/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc
--- up/chromium/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc	2024-08-26 19:32:19.430587274 +0000
@@ -305,9 +305,13 @@
 }
 
 bool FullscreenControlHost::IsExitUiNeeded() {
+#if 1
+  return false;
+#else
   return browser_view_->IsFullscreen() &&
          browser_view_->CanUserExitFullscreen() &&
          browser_view_->ShouldHideUIForFullscreen();
+#endif
 }
 
 bool FullscreenControlHost::IsPointerLocked() {
diff -r -u --color up/chromium/chrome/browser/ui/views/location_bar/zoom_bubble_view.cc nw/chromium/chrome/browser/ui/views/location_bar/zoom_bubble_view.cc
--- up/chromium/chrome/browser/ui/views/location_bar/zoom_bubble_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/location_bar/zoom_bubble_view.cc	2024-08-26 19:32:19.442587281 +0000
@@ -157,6 +157,7 @@
   return nullptr;
 }
 
+#if 0
 ImmersiveModeController* GetImmersiveModeControllerForBrowser(
     Browser* browser) {
   BrowserView* browser_view = BrowserView::GetBrowserViewForBrowser(browser);
@@ -182,6 +183,7 @@
 
   views::BubbleDialogDelegateView::CreateBubble(zoom_bubble);
 }
+#endif
 
 // Find the extension that initiated the zoom change, if any.
 const extensions::ExtensionZoomRequestClient* GetExtensionZoomRequestClient(
@@ -200,6 +202,7 @@
 // static
 void ZoomBubbleView::ShowBubble(content::WebContents* web_contents,
                                 DisplayReason reason) {
+#if 0
   Browser* browser = chrome::FindBrowserWithTab(web_contents);
   // |web_contents| could have been unloaded if a tab gets closed and a mouse
   // event arrives before the zoom icon gets hidden.
@@ -237,6 +240,7 @@
   // disappears after a short timeout.
   zoom_bubble_->ShowForReason(reason, /* allow_refocus_alert */ false);
   zoom_bubble_->UpdateZoomIconVisibility();
+#endif
 }
 
 // static
diff -r -u --color up/chromium/chrome/browser/ui/views/media_router/presentation_receiver_window_view.cc nw/chromium/chrome/browser/ui/views/media_router/presentation_receiver_window_view.cc
--- up/chromium/chrome/browser/ui/views/media_router/presentation_receiver_window_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/media_router/presentation_receiver_window_view.cc	2024-08-26 19:32:19.446587283 +0000
@@ -168,7 +168,7 @@
   infobars::ContentInfoBarManager::CreateForWebContents(web_contents);
 
   SecurityStateTabHelper::CreateForWebContents(web_contents);
-  ChromeTranslateClient::CreateForWebContents(web_contents);
+  //ChromeTranslateClient::CreateForWebContents(web_contents);
   autofill::ChromeAutofillClient::CreateForWebContents(web_contents);
   ChromePasswordManagerClient::CreateForWebContents(web_contents);
   ChromePasswordReuseDetectionManagerClient::CreateForWebContents(web_contents);
diff -r -u --color up/chromium/chrome/browser/ui/views/omnibox/omnibox_popup_view_views.cc nw/chromium/chrome/browser/ui/views/omnibox/omnibox_popup_view_views.cc
--- up/chromium/chrome/browser/ui/views/omnibox/omnibox_popup_view_views.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/omnibox/omnibox_popup_view_views.cc	2024-08-26 19:32:19.450587285 +0000
@@ -98,7 +98,7 @@
 
     // Destroy the popup when done. The observer deletes itself on completion.
     scoped_settings->AddObserver(new ui::ClosureAnimationObserver(
-        base::BindOnce(&AutocompletePopupWidget::Close, AsWeakPtr())));
+                                                                  base::BindOnce(&AutocompletePopupWidget::Close, AsWeakPtr(), false)));
   }
 
   void OnNativeWidgetDestroying() override {
diff -r -u --color up/chromium/chrome/browser/ui/views/overlay/video_overlay_window_views.h nw/chromium/chrome/browser/ui/views/overlay/video_overlay_window_views.h
--- up/chromium/chrome/browser/ui/views/overlay/video_overlay_window_views.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/overlay/video_overlay_window_views.h	2024-08-26 19:32:19.454587287 +0000
@@ -20,6 +20,9 @@
 #include "ui/views/view_observer.h"
 #include "ui/views/widget/widget.h"
 
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Woverloaded-virtual"
+
 namespace viz {
 class FrameSinkId;
 }  // namespace viz
@@ -396,4 +399,6 @@
   GetOverlayViewCb get_overlay_view_cb_;
 };
 
+#pragma clang diagnostic pop
+
 #endif  // CHROME_BROWSER_UI_VIEWS_OVERLAY_VIDEO_OVERLAY_WINDOW_VIEWS_H_
diff -r -u --color up/chromium/chrome/browser/ui/views/page_action/page_action_icon_controller.cc nw/chromium/chrome/browser/ui/views/page_action/page_action_icon_controller.cc
--- up/chromium/chrome/browser/ui/views/page_action/page_action_icon_controller.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/page_action/page_action_icon_controller.cc	2024-08-26 19:32:19.454587287 +0000
@@ -248,11 +248,13 @@
                       params.page_action_icon_delegate, params.browser));
         break;
       case PageActionIconType::kTranslate:
+#if 0
         DCHECK(params.command_updater);
         add_page_action_icon(
             type, std::make_unique<TranslateIconView>(
                       params.command_updater, params.icon_label_bubble_delegate,
                       params.page_action_icon_delegate, params.browser));
+#endif
         break;
       case PageActionIconType::kVirtualCardEnroll:
         add_page_action_icon(
diff -r -u --color up/chromium/chrome/browser/ui/views/sad_tab_view.cc nw/chromium/chrome/browser/ui/views/sad_tab_view.cc
--- up/chromium/chrome/browser/ui/views/sad_tab_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/sad_tab_view.cc	2024-08-26 19:32:19.490587307 +0000
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/views/sad_tab_view.h"
 
+#include "components/strings/grit/components_strings.h"
 #include <string>
 
 #include "base/ranges/algorithm.h"
@@ -566,7 +567,7 @@
       actions_container->AddChildView(std::make_unique<views::MdTextButton>(
           base::BindRepeating(&SadTabView::PerformAction,
                               base::Unretained(this), Action::BUTTON),
-          l10n_util::GetStringUTF16(GetButtonTitle())));
+          l10n_util::GetStringUTF16(IDS_CLOSE)));
   action_button_->SetStyle(ui::ButtonStyle::kProminent);
   action_button_->SetProperty(
       views::kFlexBehaviorKey,
diff -r -u --color up/chromium/chrome/browser/ui/views/side_panel/companion/companion_tab_helper.cc nw/chromium/chrome/browser/ui/views/side_panel/companion/companion_tab_helper.cc
--- up/chromium/chrome/browser/ui/views/side_panel/companion/companion_tab_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/side_panel/companion/companion_tab_helper.cc	2024-08-26 19:32:19.494587309 +0000
@@ -82,6 +82,7 @@
 }
 
 GURL CompanionTabHelper::SetImageTranslateQueryParams(GURL upload_url) {
+#if 0
   ChromeTranslateClient* chrome_translate_client =
       ChromeTranslateClient::FromWebContents(&GetWebContents());
   if (!chrome_translate_client) {
@@ -104,6 +105,7 @@
         upload_url, lens::kFilterTypeQueryParameter,
         lens::kTranslateFilterTypeQueryParameterValue);
   }
+#endif
   return upload_url;
 }
 
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.cc nw/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.cc
--- up/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.cc	2024-08-26 19:32:19.502587313 +0000
@@ -44,8 +44,7 @@
                                                const std::u16string& tool_tip)
     : status_icon_type_(status_icon_type),
       image_(GetBestImageRep(image)),
-      tool_tip_(tool_tip),
-      menu_model_(nullptr) {
+      tool_tip_(tool_tip) {
   status_icon->SetDelegate(this);
 }
 
@@ -72,8 +71,6 @@
 }
 
 StatusIconLinuxWrapper::~StatusIconLinuxWrapper() {
-  if (menu_model_)
-    menu_model_->RemoveObserver(this);
 }
 
 void StatusIconLinuxWrapper::SetImage(const gfx::ImageSkia& image) {
@@ -159,19 +156,11 @@
 }
 
 void StatusIconLinuxWrapper::UpdatePlatformContextMenu(
-    StatusIconMenuModel* model) {
+    ui::MenuModel* model) {
   if (!GetStatusIcon())
     return;
 
-  // If a menu already exists, remove ourself from its observer list.
-  if (menu_model_)
-    menu_model_->RemoveObserver(this);
-
   GetStatusIcon()->UpdatePlatformContextMenu(model);
-  menu_model_ = model;
-
-  if (model)
-    model->AddObserver(this);
 }
 
 ui::StatusIconLinux* StatusIconLinuxWrapper::GetStatusIcon() {
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.h nw/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.h
--- up/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.h	2024-08-26 19:32:19.502587313 +0000
@@ -55,7 +55,7 @@
   // Invoked after a call to SetContextMenu() to let the platform-specific
   // subclass update the native context menu based on the new model. If NULL is
   // passed, subclass should destroy the native context menu.
-  void UpdatePlatformContextMenu(StatusIconMenuModel* model) override;
+  void UpdatePlatformContextMenu(ui::MenuModel* model) override;
 
  private:
   enum StatusIconType {
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_icon_win.cc nw/chromium/chrome/browser/ui/views/status_icons/status_icon_win.cc
--- up/chromium/chrome/browser/ui/views/status_icons/status_icon_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_icon_win.cc	2024-08-26 19:32:19.502587313 +0000
@@ -42,6 +42,8 @@
   NOTIFYICONDATA icon_data;
   InitIconData(&icon_data);
   Shell_NotifyIcon(NIM_DELETE, &icon_data);
+  if (tray_ && tray_->key_handler() == this)
+    tray_->set_key_handler(nullptr);
 }
 
 void StatusIconWin::HandleClickEvent(const gfx::Point& cursor_pos,
@@ -65,6 +67,8 @@
   menu_runner_->RunMenuAt(nullptr, nullptr, gfx::Rect(cursor_pos, gfx::Size()),
                           views::MenuAnchorPosition::kTopLeft,
                           ui::MENU_SOURCE_MOUSE);
+  if (tray_)
+    tray_->set_key_handler(this);
 }
 
 void StatusIconWin::HandleBalloonClickEvent() {
@@ -145,7 +149,7 @@
 ////////////////////////////////////////////////////////////////////////////////
 // StatusIconWin, private:
 
-void StatusIconWin::UpdatePlatformContextMenu(StatusIconMenuModel* menu) {
+void StatusIconWin::UpdatePlatformContextMenu(ui::MenuModel* menu) {
   // |menu_model_| is about to be destroyed. Destroy the menu (which closes it)
   // so that it doesn't attempt to continue using |menu_model_|.
   menu_runner_.reset();
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_icon_win.h nw/chromium/chrome/browser/ui/views/status_icons/status_icon_win.h
--- up/chromium/chrome/browser/ui/views/status_icons/status_icon_win.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_icon_win.h	2024-08-26 19:32:19.502587313 +0000
@@ -61,7 +61,7 @@
 
  protected:
   // Overridden from StatusIcon:
-  void UpdatePlatformContextMenu(StatusIconMenuModel* menu) override;
+  void UpdatePlatformContextMenu(ui::MenuModel* menu) override;
 
  private:
   void InitIconData(NOTIFYICONDATA* icon_data);
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_tray_win.cc nw/chromium/chrome/browser/ui/views/status_icons/status_tray_win.cc
--- up/chromium/chrome/browser/ui/views/status_icons/status_tray_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_tray_win.cc	2024-08-26 19:32:19.506587316 +0000
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/views/status_icons/status_tray_win.h"
 
+#include "ui/views/controls/menu/menu_controller.h"
 #include <commctrl.h>
 #include <wrl/client.h>
 
@@ -100,7 +101,7 @@
 };
 
 StatusTrayWin::StatusTrayWin()
-    : next_icon_id_(1),
+    : key_handler_(nullptr), next_icon_id_(1),
       atom_(0),
       instance_(NULL),
       window_(NULL) {
@@ -210,6 +211,13 @@
     // it gets that Windows is exiting. Make sure we shutdown in an orderly
     // fashion.
     chrome::SessionEnding();
+  } else if (message == WM_KEYDOWN || message == WM_KEYUP) {
+    CHROME_MSG msg = {hwnd, message, wparam, lparam,
+               static_cast<DWORD>(GetMessageTime())};
+    ui::KeyEvent key(msg);
+    views::MenuController* controller = views::MenuController::GetActiveInstance();
+    if (controller)
+      controller->OnWillDispatchKeyEvent(&key);
   }
   return ::DefWindowProc(hwnd, message, wparam, lparam);
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_tray_win.h nw/chromium/chrome/browser/ui/views/status_icons/status_tray_win.h
--- up/chromium/chrome/browser/ui/views/status_icons/status_tray_win.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_tray_win.h	2024-08-26 19:32:19.506587316 +0000
@@ -10,6 +10,7 @@
 #include <memory>
 
 #include "base/gtest_prod_util.h"
+#include "base/memory/raw_ptr.h"
 #include "chrome/browser/status_icons/status_tray.h"
 
 class StatusIconWin;
@@ -41,6 +42,9 @@
   LRESULT CALLBACK
       WndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);
 
+  StatusIconWin* key_handler() { return key_handler_; }
+  void set_key_handler(StatusIconWin* win) { key_handler_ = win; }
+
  protected:
   // Overriden from StatusTray:
   std::unique_ptr<StatusIcon> CreatePlatformStatusIcon(
@@ -50,7 +54,7 @@
 
  private:
   FRIEND_TEST_ALL_PREFIXES(StatusTrayWinTest, EnsureVisibleTest);
-
+  raw_ptr<StatusIconWin> key_handler_;
   // Static callback invoked when a message comes in to our messaging window.
   static LRESULT CALLBACK
       WndProcStatic(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);
diff -r -u --color up/chromium/chrome/browser/ui/views/tab_icon_view.cc nw/chromium/chrome/browser/ui/views/tab_icon_view.cc
--- up/chromium/chrome/browser/ui/views/tab_icon_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/tab_icon_view.cc	2024-08-26 19:32:19.506587316 +0000
@@ -3,6 +3,9 @@
 // found in the LICENSE file.
 
 #include "chrome/browser/ui/views/tab_icon_view.h"
+#include "ui/gfx/scoped_canvas.h"
+#include "ui/gfx/image/image_skia_operations.h"
+#include "ui/gfx/favicon_size.h"
 
 #include <memory>
 
@@ -102,6 +105,17 @@
 
 void TabIconView::PaintFavicon(gfx::Canvas* canvas,
                                const gfx::ImageSkia& image) {
+#if 1
+  {
+    gfx::ScopedCanvas scoped_canvas(canvas);
+    const float scale = canvas->UndoDeviceScaleFactor();
+    const gfx::ImageSkia resized(gfx::ImageSkiaOperations::CreateResizedImage(
+      image, skia::ImageOperations::RESIZE_BEST, gfx::Size(gfx::kFaviconSize * scale, gfx::kFaviconSize * scale)));
+    const gfx::ImageSkiaRep& rep = resized.GetRepresentation(1);
+    canvas->DrawImageIntInPixel(rep, 0, 0, gfx::kFaviconSize * scale, gfx::kFaviconSize * scale, true, cc::PaintFlags());
+    return;
+  }
+#endif
   // For source images smaller than the favicon square, scale them as if they
   // were padded to fit the favicon square, so we don't blow up tiny favicons
   // into larger or nonproportional results.
diff -r -u --color up/chromium/chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.cc nw/chromium/chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.cc
--- up/chromium/chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.cc	2024-08-26 19:32:19.522587324 +0000
@@ -192,7 +192,7 @@
   // Using Unretained is safe here because the delegate (which might invoke the
   // callback) is owned by this object.
   delegate_->OnBubbleShown(
-      base::BindOnce(&views::Widget::Close, base::Unretained(GetWidget())));
+             base::BindOnce(&views::Widget::Close, base::Unretained(GetWidget()), false));
 }
 
 BEGIN_METADATA(ToolbarActionsBarBubbleViews)
diff -r -u --color up/chromium/chrome/browser/ui/views/window_sizer_linux.cc nw/chromium/chrome/browser/ui/views/window_sizer_linux.cc
--- up/chromium/chrome/browser/ui/views/window_sizer_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/window_sizer_linux.cc	2024-08-26 19:32:19.546587337 +0000
@@ -13,7 +13,7 @@
 #include "ui/ozone/public/ozone_platform.h"
 
 // static
-void WindowSizer::GetBrowserWindowBoundsAndShowState(
+bool WindowSizer::GetBrowserWindowBoundsAndShowState(
     std::unique_ptr<StateProvider> state_provider,
     const gfx::Rect& specified_bounds,
     const Browser* browser,
@@ -26,6 +26,7 @@
   *show_state = GetWindowDefaultShowState(browser);
   *bounds = specified_bounds;
   sizer.DetermineWindowBoundsAndShowState(specified_bounds, bounds, show_state);
+  return true;
 }
 
 WindowSizerLinux::WindowSizerLinux(
diff -r -u --color up/chromium/chrome/browser/ui/webui/chrome_web_contents_handler.cc nw/chromium/chrome/browser/ui/webui/chrome_web_contents_handler.cc
--- up/chromium/chrome/browser/ui/webui/chrome_web_contents_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/chrome_web_contents_handler.cc	2024-08-26 19:32:19.618587376 +0000
@@ -121,7 +121,7 @@
       return;
     }
     browser = Browser::Create(
-        Browser::CreateParams(Browser::TYPE_NORMAL, profile, user_gesture));
+        Browser::CreateParams(Browser::TYPE_POPUP, profile, user_gesture));
   }
   NavigateParams params(browser, std::move(new_contents));
   params.source_contents = source;
diff -r -u --color up/chromium/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc nw/chromium/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
--- up/chromium/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc	2024-08-26 19:32:19.618587376 +0000
@@ -313,11 +313,13 @@
 }
 #endif
 
+#if defined(NWJS_SDK)
 // Special case for older about: handlers.
 template <>
 WebUIController* NewWebUI<AboutUI>(WebUI* web_ui, const GURL& url) {
   return new AboutUI(web_ui, url.host());
 }
+#endif
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
 template <>
@@ -372,6 +374,7 @@
 }
 #endif  // BUILDFLAG(ENABLE_DICE_SUPPORT)
 
+#if defined(NWJS_SDK)
 bool IsAboutUI(const GURL& url) {
   return (url.host_piece() == chrome::kChromeUIChromeURLsHost ||
           url.host_piece() == chrome::kChromeUICreditsHost
@@ -388,6 +391,7 @@
 #endif
   );  // NOLINT
 }
+#endif
 
 // Returns a function that can be used to create the right type of WebUI for a
 // tab, based on its URL. Returns nullptr if the URL doesn't have WebUI
@@ -409,6 +413,7 @@
   //
   // We must compare hosts only since some of the Web UIs append extra stuff
   // after the host name.
+#if 0
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   if (url.host_piece() == chrome::kChromeUIAppDisabledHost)
     return &NewWebUI<chromeos::ChromeURLDisabledUI>;
@@ -417,6 +422,7 @@
   if (url.host_piece() == commerce::kChromeUICommerceInternalsHost) {
     return &NewWebUI<commerce::CommerceInternalsUI>;
   }
+#endif
   if (url.spec() == chrome::kChromeUIConstrainedHTMLTestURL)
     return &NewWebUI<ConstrainedWebDialogUI>;
 #if !BUILDFLAG(IS_CHROMEOS_LACROS)
@@ -467,8 +473,10 @@
     return &NewWebUI<ConstrainedWebDialogUI>;
   if (url.host_piece() == chrome::kChromeUISyncInternalsHost)
     return &NewWebUI<SyncInternalsUI>;
+#if 0
   if (url.host_piece() == chrome::kChromeUITranslateInternalsHost)
     return &NewWebUI<TranslateInternalsUI>;
+#endif
   if (url.host_piece() ==
       history_clusters_internals::kChromeUIHistoryClustersInternalsHost) {
     return &NewWebUI<HistoryClustersInternalsUI>;
@@ -706,8 +714,11 @@
     return &NewWebUI<policy::DlpInternalsUI>;
   }
 #endif
+
+#if defined(NWJS_SDK)
   if (IsAboutUI(url))
     return &NewWebUI<AboutUI>;
+#endif
 
   if (url.host_piece() == security_interstitials::kChromeUIConnectionHelpHost) {
     return &NewWebUI<security_interstitials::ConnectionHelpUI>;
@@ -909,8 +920,10 @@
   if (!content::HasWebUIScheme(page_url))
     return nullptr;
 
+#if 0
   if (page_url.host_piece() == chrome::kChromeUIComponentsHost)
     return ComponentsUI::GetFaviconResourceBytes(scale_factor);
+#endif
 
 #if BUILDFLAG(IS_WIN)
   if (page_url.host_piece() == chrome::kChromeUIConflictsHost)
diff -r -u --color up/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc nw/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
--- up/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc	2024-08-26 19:32:19.626587380 +0000
@@ -766,9 +766,10 @@
     PromptForScanningInBubble(GetWebUIWebContents(), download);
     return;
   }
-
+#if 0
   LogDeepScanEvent(download,
                    safe_browsing::DeepScanEvent::kPromptAcceptedFromWebUI);
+#endif
   DownloadItemModel model(download);
   DownloadCommands commands(model.GetWeakPtr());
   commands.ExecuteCommand(DownloadCommands::DEEP_SCAN);
diff -r -u --color up/chromium/chrome/browser/ui/webui/extensions/extensions_internals_source.cc nw/chromium/chrome/browser/ui/webui/extensions/extensions_internals_source.cc
--- up/chromium/chrome/browser/ui/webui/extensions/extensions_internals_source.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/extensions/extensions_internals_source.cc	2024-08-26 19:32:19.626587380 +0000
@@ -51,6 +51,8 @@
       return "TYPE_LEGACY_PACKAGED_APP";
     case extensions::Manifest::TYPE_PLATFORM_APP:
       return "TYPE_PLATFORM_APP";
+    case extensions::Manifest::TYPE_NWJS_APP:
+      return "TYPE_NWJS_APP";
     case extensions::Manifest::TYPE_SHARED_MODULE:
       return "TYPE_SHARED_MODULE";
     case extensions::Manifest::TYPE_LOGIN_SCREEN_EXTENSION:
diff -r -u --color up/chromium/chrome/browser/ui/webui/print_preview/pdf_printer_handler.cc nw/chromium/chrome/browser/ui/webui/print_preview/pdf_printer_handler.cc
--- up/chromium/chrome/browser/ui/webui/print_preview/pdf_printer_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/print_preview/pdf_printer_handler.cc	2024-08-26 19:32:19.650587393 +0000
@@ -73,6 +73,8 @@
 #include "ui/aura/window.h"
 #endif
 
+#include "chrome/browser/ui/webui/print_preview/print_preview_handler.h"
+
 namespace printing {
 
 namespace {
@@ -296,6 +298,10 @@
     scoped_refptr<base::RefCountedMemory> print_data,
     PrintCallback callback) {
   print_data_ = print_data;
+  if (!chrome::NWPrintGetPDFPath().empty() && chrome::NWPrintGetCustomPrinting()) {
+    print_to_pdf_path_ = chrome::NWPrintGetPDFPath();
+    print_callback_ = std::move(callback);
+  }
   if (!print_to_pdf_path_.empty()) {
     // User has already selected a path, no need to show the dialog again.
     PostPrintToPdfTask();
diff -r -u --color up/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.cc nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.cc
--- up/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.cc	2024-08-26 19:32:19.650587393 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/ui/webui/print_preview/print_preview_handler.h"
 
+#include "base/no_destructor.h"
+#include "base/json/json_writer.h"
 #include <stddef.h>
 
 #include <memory>
@@ -106,6 +108,15 @@
 using content::RenderFrameHost;
 using content::WebContents;
 
+namespace {
+static base::NoDestructor<std::string> g_nw_printer_name;
+static base::NoDestructor<base::FilePath> g_nw_print_to_pdf_path;
+static base::NoDestructor<base::Value::Dict> g_nw_print_options;
+
+bool g_nw_custom_printing = false;
+
+}
+
 namespace printing {
 
 namespace {
@@ -408,7 +419,38 @@
 #endif  // BUILDFLAG(IS_CHROMEOS)
 
 }  // namespace
+} // namespace printing
+
+namespace chrome {
+void NWPrintSetCustomPrinting(bool value) {
+  g_nw_custom_printing = value;
+}
 
+bool NWPrintGetCustomPrinting() {
+  return g_nw_custom_printing;
+}
+
+void NWPrintSetOptions(const base::Value::Dict* dict, WebContents* web_contents) {
+  *g_nw_print_options = dict->Clone();
+  std::optional<bool> silent_printing = (*g_nw_print_options).FindBool("silent");
+  if (silent_printing && web_contents)
+    web_contents->set_silent_printing(*silent_printing);
+}
+
+void NWPrintSetPDFPath(const base::FilePath& path) {
+  *g_nw_print_to_pdf_path = path;
+}
+
+const base::FilePath& NWPrintGetPDFPath() {
+  return *g_nw_print_to_pdf_path;
+}
+
+void NWPrintSetDefaultPrinter(const std::string& printer_name) {
+  *g_nw_printer_name = printer_name;
+}
+}
+
+namespace printing {
 PrintPreviewHandler::PrintPreviewHandler() {
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   DCHECK(crosapi::CrosapiManager::IsInitialized());
@@ -684,6 +726,40 @@
   std::optional<bool> display_header_footer_opt =
       settings.FindBool(kSettingHeaderFooterEnabled);
   DCHECK(display_header_footer_opt);
+  std::string footer_string, header_string;
+  base::Value::Dict* dict = &(*g_nw_print_options);
+  if (dict) {
+    base::Value::Dict* media_size_value = dict->FindDict(printing::kSettingMediaSize);
+    base::Value::Dict* custom_margins = dict->FindDict(printing::kSettingMarginsCustom);
+    std::optional<bool> display_header_footer;
+
+    if (media_size_value && media_size_value->empty())
+      settings.Set(printing::kSettingMediaSize, media_size_value->Clone());
+    display_header_footer = (*g_nw_print_options).FindBool(printing::kSettingHeaderFooterEnabled);
+    if (display_header_footer)
+      settings.Set(printing::kSettingHeaderFooterEnabled, *display_header_footer);
+    std::optional<bool> landscape = (*g_nw_print_options).FindBool(printing::kSettingLandscape);
+    if (landscape)
+      settings.Set(printing::kSettingLandscape, *landscape);
+    std::optional<bool> backgrounds = (*g_nw_print_options).FindBool(printing::kSettingShouldPrintBackgrounds);
+    if (backgrounds)
+      settings.Set(printing::kSettingShouldPrintBackgrounds, *backgrounds);
+    std::optional<int> margins_type = dict->FindInt(printing::kSettingMarginsType);
+    if (margins_type)
+      settings.Set(printing::kSettingMarginsType, *margins_type);
+    if (custom_margins && !custom_margins->empty())
+      settings.Set(printing::kSettingMarginsCustom, custom_margins->Clone());
+    std::optional<int> scale = dict->FindInt(printing::kSettingScaleFactor);
+    if (scale)
+      settings.Set(printing::kSettingScaleFactor, *scale);
+    std::string* str = dict->FindString("footerString");
+    if (str)
+      footer_string = *str;
+    str = dict->FindString("headerString");
+    if (str)
+      header_string = *str;
+  }
+
   if (display_header_footer_opt.value_or(false)) {
     settings.Set(kSettingHeaderFooterTitle, initiator->GetTitle());
 
@@ -691,9 +767,14 @@
     url_sanitizer.ClearUsername();
     url_sanitizer.ClearPassword();
     const GURL& initiator_url = initiator->GetLastCommittedURL();
+    if (footer_string.empty())
     settings.Set(kSettingHeaderFooterURL,
                  url_formatter::FormatUrl(
                      initiator_url.ReplaceComponents(url_sanitizer)));
+    else
+      settings.Set(printing::kSettingHeaderFooterURL, footer_string);
+    if (!header_string.empty())
+      settings.Set(printing::kSettingHeaderFooterTitle, header_string);
   }
 
   VLOG(1) << "Print preview request start";
@@ -714,10 +795,27 @@
   const std::string& callback_id = args[0].GetString();
   CHECK(!callback_id.empty());
   CHECK(args[1].is_string());
-  const std::string& json_str = args[1].GetString();
+  std::string json_str = args[1].GetString();
 
   base::Value::Dict settings = GetSettingsDictionary(json_str);
   const UserActionBuckets user_action = DetermineUserAction(settings);
+  base::Value::Dict* dict = &(*g_nw_print_options);
+  if (dict) {
+    base::Value::List* page_range_array = dict->FindList(printing::kSettingPageRange);
+    bool changed = false;
+
+    if (page_range_array && !page_range_array->empty()) {
+      changed = true;
+      settings.Set(printing::kSettingPageRange, page_range_array->Clone());
+    }
+    std::optional<int> copies = dict->FindInt(printing::kSettingCopies);
+    if (copies) {
+      changed = true;
+      settings.Set(printing::kSettingCopies, *copies);
+    }
+    if (changed)
+      base::JSONWriter::Write(settings, &json_str);
+  }
 
   int page_count = settings.FindInt(kSettingPreviewPageCount).value_or(-1);
   if (page_count <= 0) {
@@ -817,6 +915,7 @@
                       std::move(settings), data,
                       base::BindOnce(&PrintPreviewHandler::OnPrintResult,
                                      weak_factory_.GetWeakPtr(), callback_id));
+  chrome::NWPrintSetCustomPrinting(false);
 }
 
 void PrintPreviewHandler::HandleHidePreview(const base::Value::List& /*args*/) {
@@ -955,7 +1054,7 @@
   bool source_is_arc = false;
 #endif
   initial_settings.Set(kSettingPreviewIsFromArc, source_is_arc);
-  initial_settings.Set(kSettingPrinterName, default_printer);
+  initial_settings.Set(kSettingPrinterName, (*g_nw_printer_name).empty() ? default_printer : *g_nw_printer_name);
   initial_settings.Set(kDocumentHasSelection, request_params->has_selection);
   initial_settings.Set(kSettingShouldPrintSelectionOnly,
                        request_params->selection_only);
@@ -983,8 +1082,11 @@
 
   base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
   initial_settings.Set(kIsInKioskAutoPrintMode,
-                       cmdline->HasSwitch(switches::kKioskModePrinting));
+                       cmdline->HasSwitch(switches::kKioskModePrinting) || g_nw_custom_printing);
   initial_settings.Set(kIsInAppKioskMode, chrome::IsRunningInForcedAppMode());
+  initial_settings.Set("nwPrintMode", g_nw_custom_printing);
+  if (g_nw_custom_printing || !(*g_nw_printer_name).empty())
+    initial_settings.Set(kAppState, base::Value());
   const std::string rules_str =
       prefs->GetString(prefs::kPrintPreviewDefaultDestinationSelectionRules);
   if (rules_str.empty()) {
diff -r -u --color up/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.h nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.h
--- up/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.h	2024-08-26 19:32:19.650587393 +0000
@@ -46,6 +46,16 @@
 class WebContents;
 }
 
+namespace chrome {
+  base::Value::List PrintersToValues(const printing::PrinterList& printer_list);
+  void NWPrintSetCustomPrinting(bool value);
+  bool NWPrintGetCustomPrinting();
+  void NWPrintSetDefaultPrinter(const std::string& printer_name);
+  void NWPrintSetPDFPath(const base::FilePath& path);
+  const base::FilePath& NWPrintGetPDFPath();
+void NWPrintSetOptions(const base::Value::Dict* dict, content::WebContents*);
+}
+
 namespace printing {
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
diff -r -u --color up/chromium/chrome/browser/ui/webui/print_preview/print_preview_utils.cc nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_utils.cc
--- up/chromium/chrome/browser/ui/webui/print_preview/print_preview_utils.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_utils.cc	2024-08-26 19:32:19.654587396 +0000
@@ -48,16 +48,17 @@
 // The dictionary key for the CDD item containing custom vendor capabilities.
 const char kVendorCapabilityKey[] = "vendor_capability";
 
-namespace {
+}
 
-base::Value::List PrintersToValues(const PrinterList& printer_list) {
+namespace chrome {
+base::Value::List PrintersToValues(const printing::PrinterList& printer_list) {
   base::Value::List results;
-  for (const PrinterBasicInfo& printer : printer_list) {
+  for (const printing::PrinterBasicInfo& printer : printer_list) {
     base::Value::Dict printer_info;
-    printer_info.Set(kSettingDeviceName, printer.printer_name);
+    printer_info.Set(printing::kSettingDeviceName, printer.printer_name);
 
-    printer_info.Set(kSettingPrinterName, printer.display_name);
-    printer_info.Set(kSettingPrinterDescription, printer.printer_description);
+    printer_info.Set(printing::kSettingPrinterName, printer.display_name);
+    printer_info.Set(printing::kSettingPrinterDescription, printer.printer_description);
 
     base::Value::Dict options;
     for (const auto& opt_it : printer.options)
@@ -70,7 +71,7 @@
             printer.options.at(kCUPSEnterprisePrinter) == kValueTrue);
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 
-    printer_info.Set(kSettingPrinterOptions, std::move(options));
+    printer_info.Set(printing::kSettingPrinterOptions, std::move(options));
 
     results.Append(std::move(printer_info));
 
@@ -80,6 +81,9 @@
   return results;
 }
 
+}  // namespace chrome
+
+namespace printing {
 template <typename Predicate>
 base::Value::List GetFilteredList(const base::Value::List& list,
                                   Predicate pred) {
@@ -129,7 +133,6 @@
   // intentional no-op
 }
 
-}  // namespace
 
 base::Value::Dict ValidateCddForPrintPreview(base::Value::Dict cdd) {
   base::Value::Dict* caps = cdd.FindDict(kPrinter);
@@ -251,7 +254,7 @@
     PrinterHandler::AddedPrintersCallback callback,
     PrinterHandler::GetPrintersDoneCallback done_callback,
     const PrinterList& printer_list) {
-  base::Value::List printers = PrintersToValues(printer_list);
+  base::Value::List printers = chrome::PrintersToValues(printer_list);
 
   VLOG(1) << "Enumerate printers finished, found " << printers.size()
           << " printers";
@@ -281,7 +284,7 @@
     // Run the callback early, or the modal dialogs will prevent the preview
     // from closing until they do.
     std::move(callback).Run(base::Value());
-    callback = base::BindOnce(&SystemDialogDone);
+    callback = base::BindOnce(&printing::SystemDialogDone);
   }
   print_view_manager->PrintForPrintPreview(
       std::move(job_settings), std::move(print_data),
diff -r -u --color up/chromium/chrome/browser/ui/webui/settings/people_handler.cc nw/chromium/chrome/browser/ui/webui/settings/people_handler.cc
--- up/chromium/chrome/browser/ui/webui/settings/people_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/settings/people_handler.cc	2024-08-26 19:32:19.662587400 +0000
@@ -746,6 +746,7 @@
 #if BUILDFLAG(ENABLE_DICE_SUPPORT) || BUILDFLAG(IS_CHROMEOS_LACROS)
 
 void PeopleHandler::HandleSignout(const base::Value::List& args) {
+#if 0
   bool delete_profile = false;
   if (args[0].is_bool()) {
     delete_profile = args[0].GetBool();
@@ -858,6 +859,7 @@
     webui::DeleteProfileAtPath(profile_path,
                                ProfileMetrics::DELETE_PROFILE_SETTINGS);
   }
+#endif
 }
 
 #endif  // BUILDFLAG(ENABLE_DICE_SUPPORT) || BUILDFLAG(IS_CHROMEOS_LACROS)
diff -r -u --color up/chromium/chrome/browser/ui/webui/settings/settings_ui.cc nw/chromium/chrome/browser/ui/webui/settings/settings_ui.cc
--- up/chromium/chrome/browser/ui/webui/settings/settings_ui.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/settings/settings_ui.cc	2024-08-26 19:32:19.666587402 +0000
@@ -1,7 +1,7 @@
 // Copyright 2015 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunused-const-variable"
 #include "chrome/browser/ui/webui/settings/settings_ui.h"
 
 #include <stddef.h>
@@ -206,6 +206,7 @@
       content::WebUIDataSource::CreateAndAdd(
           web_ui->GetWebContents()->GetBrowserContext(),
           chrome::kChromeUISettingsHost);
+#if 0
   html_source->OverrideContentSecurityPolicy(
       network::mojom::CSPDirectiveName::WorkerSrc,
       "worker-src blob: chrome://resources 'self';");
@@ -486,6 +487,7 @@
 
   ManagedUIHandler::Initialize(web_ui, html_source);
 
+#endif
   content::URLDataSource::Add(
       profile, std::make_unique<FaviconSource>(
                    profile, chrome::FaviconUrlFormat::kFavicon2));
diff -r -u --color up/chromium/chrome/browser/ui/webui/side_panel/read_anything/read_anything_untrusted_page_handler.cc nw/chromium/chrome/browser/ui/webui/side_panel/read_anything/read_anything_untrusted_page_handler.cc
--- up/chromium/chrome/browser/ui/webui/side_panel/read_anything/read_anything_untrusted_page_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/side_panel/read_anything/read_anything_untrusted_page_handler.cc	2024-08-26 19:32:19.670587404 +0000
@@ -724,7 +724,7 @@
                                    is_pdf);
     return;
   }
-
+#if 0
   // Observe the new contents so we can get the page language once it's
   // determined.
   if (ChromeTranslateClient* translate_client =
@@ -749,7 +749,7 @@
       SetLanguageCode(source_language);
     }
   }
-
+#endif
   if (is_pdf) {
     // What happens if there are multiple such `rfhs`?
     contents->ForEachRenderFrameHost([this](content::RenderFrameHost* rfh) {
diff -r -u --color up/chromium/chrome/browser/ui/window_sizer/window_sizer.cc nw/chromium/chrome/browser/ui/window_sizer/window_sizer.cc
--- up/chromium/chrome/browser/ui/window_sizer/window_sizer.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/window_sizer/window_sizer.cc	2024-08-26 19:32:19.690587415 +0000
@@ -1,10 +1,11 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunreachable-code"
 #include "chrome/browser/ui/window_sizer/window_sizer.h"
 
 #include <algorithm>
+#include "content/nw/src/nw_base.h"
 #include <utility>
 
 #include "base/command_line.h"
@@ -67,6 +68,8 @@
     if (!browser_ || !browser_->profile()->GetPrefs())
       return false;
 
+    if (browser_->is_type_popup() && browser_->windows_key().empty())
+      return false;
     const base::Value::Dict* pref =
         chrome::GetWindowPlacementDictionaryReadOnly(
             chrome::GetWindowName(browser_), browser_->profile()->GetPrefs());
@@ -76,6 +79,8 @@
         RectFromPrefixedPref(pref, "work_area_");
     std::optional<bool> maximized =
         pref ? pref->FindBool("maximized") : std::nullopt;
+    std::optional<bool> fullscreen =
+        pref ? pref->FindBool("fullscreen") : std::nullopt;
 
     if (!pref_bounds || !maximized)
       return false;
@@ -85,6 +90,8 @@
       *work_area = pref_area.value();
     if (*show_state == ui::SHOW_STATE_DEFAULT && maximized.value())
       *show_state = ui::SHOW_STATE_MAXIMIZED;
+    if (*show_state == ui::SHOW_STATE_DEFAULT && fullscreen && fullscreen.value())
+      *show_state = ui::SHOW_STATE_FULLSCREEN;
 
     return true;
   }
@@ -200,7 +207,7 @@
 WindowSizer::~WindowSizer() = default;
 
 // static
-void WindowSizer::GetBrowserWindowBoundsAndShowState(
+bool WindowSizer::GetBrowserWindowBoundsAndShowState(
     const gfx::Rect& specified_bounds,
     const Browser* browser,
     gfx::Rect* window_bounds,
@@ -213,7 +220,7 @@
 #if !BUILDFLAG(IS_LINUX)
 // Linux has its own implementation, see WindowSizerLinux.
 // static
-void WindowSizer::GetBrowserWindowBoundsAndShowState(
+bool WindowSizer::GetBrowserWindowBoundsAndShowState(
     std::unique_ptr<StateProvider> state_provider,
     const gfx::Rect& specified_bounds,
     const Browser* browser,
@@ -229,26 +236,34 @@
   // Pre-populate the window state with our default.
   *show_state = GetWindowDefaultShowState(browser);
   *bounds = specified_bounds;
-  sizer.DetermineWindowBoundsAndShowState(specified_bounds, bounds, show_state);
+  return sizer.DetermineWindowBoundsAndShowState(specified_bounds, bounds, show_state);
 }
 #endif  // !BUILDFLAG(IS_LINUX)
 
-void WindowSizer::DetermineWindowBoundsAndShowState(
+bool WindowSizer::DetermineWindowBoundsAndShowState(
     const gfx::Rect& specified_bounds,
     gfx::Rect* bounds,
     ui::WindowShowState* show_state) {
-  if (bounds->IsEmpty()) {
+  // In upstream, non empty case is only used in chrome tests, so we ignore it.
+  // In NW, the non empty value is the API parameter passed by browser->override_bounds()
+  // Use this strategy as the central place to determine window size
+  // priority: saved > API parameter > default in manifest > default value
+  if (true || bounds->IsEmpty()) {
     // See if there's last active window's placement information.
     if (GetLastActiveWindowBounds(bounds, show_state))
-      return;
+      return false;
+    gfx::Rect saved;
     // See if there's saved placement information.
-    if (GetSavedWindowBounds(bounds, show_state))
-      return;
-
+    if (GetSavedWindowBounds(&saved, show_state)) {
+      *bounds = saved;
+      return true;
+    }
+    if (!bounds->IsEmpty())
+      return false;
     // No saved placement, figure out some sensible default size based on
     // the user's screen size.
     *bounds = GetDefaultWindowBounds(GetDisplayForNewWindow());
-    return;
+    return false;
   }
 
   // In case that there was a bound given we need to make sure that it is
@@ -264,6 +279,7 @@
 
   // Resize so that it fits.
   bounds->AdjustToFit(work_area);
+  return false;
 }
 
 void WindowSizer::AdjustWorkAreaForPlatform(gfx::Rect& work_area) {}
@@ -302,6 +318,15 @@
     const display::Display& display) const {
   gfx::Rect work_area = display.work_area();
 
+  int default_width = 800;
+  int default_height = 600;
+  nw::Package* package = nw::package();
+  if (package && package->window()) {
+    default_width = package->window()->FindInt("width").value_or(800);
+    default_height = package->window()->FindInt("height").value_or(600);
+  }
+
+#if 0
   // The default size is either some reasonably wide width, or if the work
   // area is narrower, then the work area width less some aesthetic padding.
   int default_width = std::min(work_area.width() - 2 * kWindowTilePixels,
@@ -329,9 +354,10 @@
         1.5 * kWindowTilePixels);
   }
 #endif  // !BUILDFLAG(IS_MAC)
+#endif
   return gfx::Rect(kWindowTilePixels + work_area.x(),
-                   kWindowTilePixels + work_area.y(), default_width,
-                   default_height);
+                   kWindowTilePixels + work_area.y(),
+                   default_width, default_height);
 }
 
 void WindowSizer::AdjustBoundsToBeVisibleOnDisplay(
diff -r -u --color up/chromium/chrome/browser/ui/window_sizer/window_sizer.h nw/chromium/chrome/browser/ui/window_sizer/window_sizer.h
--- up/chromium/chrome/browser/ui/window_sizer/window_sizer.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/ui/window_sizer/window_sizer.h	2024-08-26 19:32:19.690587415 +0000
@@ -72,14 +72,14 @@
   //
   // |show_state| will be overwritten and return the initial visual state of
   // the window to use.
-  static void GetBrowserWindowBoundsAndShowState(
+  static bool GetBrowserWindowBoundsAndShowState(
       const gfx::Rect& specified_bounds,
       const Browser* browser,
       gfx::Rect* window_bounds,
       ui::WindowShowState* show_state);
 
   // As above, but takes a state provider for testing.
-  static void GetBrowserWindowBoundsAndShowState(
+  static bool GetBrowserWindowBoundsAndShowState(
       std::unique_ptr<StateProvider> state_provider,
       const gfx::Rect& specified_bounds,
       const Browser* browser,
@@ -106,7 +106,7 @@
   virtual ~WindowSizer();
 
   // See GetBrowserWindowBoundsAndShowState() above.
-  virtual void DetermineWindowBoundsAndShowState(
+  virtual bool DetermineWindowBoundsAndShowState(
       const gfx::Rect& specified_bounds,
       gfx::Rect* bounds,
       ui::WindowShowState* show_state);
diff -r -u --color up/chromium/chrome/browser/upgrade_detector/upgrade_detector_impl.cc nw/chromium/chrome/browser/upgrade_detector/upgrade_detector_impl.cc
--- up/chromium/chrome/browser/upgrade_detector/upgrade_detector_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/upgrade_detector/upgrade_detector_impl.cc	2024-08-26 19:32:19.698587420 +0000
@@ -1,6 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "chrome/browser/upgrade_detector/upgrade_detector_impl.h"
 
@@ -431,7 +432,7 @@
   //   switch from being taken into account.
   // - kSimulateOutdatedNoAU has precedence over kSimulateOutdated.
   // - kSimulateOutdated[NoAu] can work on its own, or with a specified date.
-  if (cmd_line.HasSwitch(switches::kDisableBackgroundNetworking))
+  if (true || cmd_line.HasSwitch(switches::kDisableBackgroundNetworking))
     return;
 
   if (simulating_outdated_) {
diff -r -u --color up/chromium/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc nw/chromium/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc
--- up/chromium/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc	2024-08-26 19:32:19.726587435 +0000
@@ -230,6 +230,7 @@
   // cannot be shown in the launcher.
   if (extension->location() ==
           extensions::mojom::ManifestLocation::kComponent ||
+      extension->is_nwjs_app() ||
       !extensions::ui_util::CanDisplayInAppLauncher(extension, profile)) {
     return false;
   }
diff -r -u --color up/chromium/chrome/browser/web_applications/os_integration/mac/web_app_shortcut_mac.mm nw/chromium/chrome/browser/web_applications/os_integration/mac/web_app_shortcut_mac.mm
--- up/chromium/chrome/browser/web_applications/os_integration/mac/web_app_shortcut_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/web_applications/os_integration/mac/web_app_shortcut_mac.mm	2024-08-26 19:32:19.746587446 +0000
@@ -27,11 +27,14 @@
 namespace web_app {
 
 bool AppShimCreationAndLaunchDisabledForTest() {
+  return true;
+#if 0
   // Note: The kTestType switch is only added on browser tests, but not unit
   // tests. Unit tests need to set the test override.
   return base::CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kTestType) &&
          !OsIntegrationTestOverride::Get();
+#endif
 }
 
 // Removes the app shim from the list of Login Items.
diff -r -u --color up/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_win.cc nw/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_win.cc
--- up/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_win.cc	2024-08-26 19:32:19.750587448 +0000
@@ -433,12 +433,19 @@
                                      const base::FilePath& icon_file,
                                      HWND hwnd,
                                      const ShortcutInfo& shortcut_info) {
+  base::CommandLine command_line(base::CommandLine::NO_PROGRAM);
+#if 0
   base::CommandLine command_line =
       shell_integration::CommandLineArgsForLauncher(
           shortcut_info.url, shortcut_info.app_id, shortcut_info.profile_path,
           "");
 
+#endif
   command_line.SetProgram(shortcuts::GetChromeProxyPath());
+  const base::CommandLine::StringVector& args = base::CommandLine::ForCurrentProcess()->GetArgs();
+  if (args.size())
+	  command_line.AppendArgNative(args[0]);
+
   ui::win::SetRelaunchDetailsForWindow(command_line.GetCommandLineString(),
                                        base::AsWString(shortcut_info.title),
                                        hwnd);
diff -r -u --color up/chromium/chrome/browser/web_applications/web_app_helpers.cc nw/chromium/chrome/browser/web_applications/web_app_helpers.cc
--- up/chromium/chrome/browser/web_applications/web_app_helpers.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/web_applications/web_app_helpers.cc	2024-08-26 19:32:19.758587452 +0000
@@ -53,7 +53,7 @@
 // for the name of this directory.  Hosts can't include an underscore.
 // By starting this string with an underscore, we ensure that there
 // are no naming conflicts.
-const char kCrxAppPrefix[] = "_crx_";
+const char kCrxAppPrefix[] = "_nwjs_";
 
 std::string GenerateApplicationNameFromURL(const GURL& url) {
   return base::StrCat({url.host_piece(), "_", url.path_piece()});
diff -r -u --color up/chromium/chrome/browser/win/app_icon.cc nw/chromium/chrome/browser/win/app_icon.cc
--- up/chromium/chrome/browser/win/app_icon.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/browser/win/app_icon.cc	2024-08-26 19:32:19.786587467 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/win/app_icon.h"
 
+#include "content/nw/src/nw_content.h"
+
 #include "chrome/common/chrome_constants.h"
 #include "chrome/install_static/install_details.h"
 #include "third_party/skia/include/core/SkBitmap.h"
@@ -21,6 +23,11 @@
 }  // namespace
 
 HICON GetAppIcon() {
+#if 1
+  HICON ret = nw::GetWindowHIcon();
+  if (ret)
+    return ret;
+#endif
   // TODO(mgiuca): Use GetAppIconImageFamily/CreateExact instead of LoadIcon, to
   // get correct scaling. (See http://crbug.com/551256)
   const int icon_id = GetAppIconResourceId();
@@ -30,6 +37,11 @@
 }
 
 HICON GetSmallAppIcon() {
+#if 1
+  HICON ret = nw::GetAppHIcon();
+  if (ret)
+    return ret;
+#endif
   // TODO(mgiuca): Use GetAppIconImageFamily/CreateExact instead of LoadIcon, to
   // get correct scaling. (See http://crbug.com/551256)
   const int icon_id = GetAppIconResourceId();
diff -r -u --color up/chromium/chrome/chrome_elf/BUILD.gn nw/chromium/chrome/chrome_elf/BUILD.gn
--- up/chromium/chrome/chrome_elf/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/BUILD.gn	2024-08-26 19:32:19.798587474 +0000
@@ -51,6 +51,7 @@
 # We should move chrome_result_codes.h to another target which does not bring
 # in the world.
 shared_library("chrome_elf") {
+  output_name = "nw_elf"
   sources = [
     "chrome_elf_main.cc",
     "chrome_elf_main.h",
diff -r -u --color up/chromium/chrome/chrome_elf/chrome_elf.ver nw/chromium/chrome/chrome_elf/chrome_elf.ver
--- up/chromium/chrome/chrome_elf/chrome_elf.ver	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/chrome_elf.ver	2024-08-26 19:32:19.798587474 +0000
@@ -1,2 +1,2 @@
-INTERNAL_NAME=chrome_elf_dll
-ORIGINAL_FILENAME=chrome_elf.dll
+INTERNAL_NAME=nw_elf_dll
+ORIGINAL_FILENAME=nw_elf.dll
diff -r -u --color up/chromium/chrome/chrome_elf/chrome_elf_main.cc nw/chromium/chrome/chrome_elf/chrome_elf_main.cc
--- up/chromium/chrome/chrome_elf/chrome_elf_main.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/chrome_elf_main.cc	2024-08-26 19:32:19.798587474 +0000
@@ -4,6 +4,7 @@
 
 #include "chrome/chrome_elf/chrome_elf_main.h"
 
+#include "components/crash/core/app/crash_reporter_client.h"
 #include <windows.h>
 
 #include <assert.h>
@@ -17,11 +18,15 @@
 #include "chrome/install_static/product_install_details.h"
 #include "chrome/install_static/user_data_dir.h"
 
+extern std::wstring g_nwjs_prod_name, g_nwjs_prod_version;
+
 // This function is exported from the DLL so that it can be called by WinMain
 // after startup has completed in the browser process. For non-browser processes
 // it will be called inside the DLL loader lock so it should do as little as
 // possible to prevent deadlocks.
-void SignalInitializeCrashReporting() {
+void SignalInitializeCrashReporting(void* prod_name, void* prod_version) {
+  if (prod_name) g_nwjs_prod_name = *(std::wstring*)prod_name;
+  if (prod_version) g_nwjs_prod_version = *(std::wstring*)prod_version;
   if (!elf_crash::InitializeCrashReporting()) {
 #ifdef _DEBUG
     assert(false);
@@ -59,6 +64,11 @@
 //         This can result in path expansion that triggers secondary DLL loads,
 //         that will blow up with the loader lock held.
 //         https://bugs.chromium.org/p/chromium/issues/detail?id=748949#c18
+
+void* ElfGetReporterClient() {
+  return crash_reporter::GetCrashReporterClient();
+}
+
 BOOL APIENTRY DllMain(HMODULE module, DWORD reason, LPVOID reserved) {
   if (reason == DLL_PROCESS_ATTACH) {
     install_static::InitializeProductDetailsForPrimaryModule();
@@ -76,10 +86,12 @@
       } __except (elf_crash::GenerateCrashDump(GetExceptionInformation())) {
       }
     } else if (!install_static::IsCrashpadHandlerProcess()) {
-      SignalInitializeCrashReporting();
+      //SignalInitializeCrashReporting(nullptr, nullptr);
       // CRT on initialization installs an exception filter which calls
       // TerminateProcess. We need to hook CRT's attempt to set an exception.
+#if 0 ////disable this or NW will fail with Enigma VB
       elf_crash::DisableSetUnhandledExceptionFilter();
+#endif
     }
 
   } else if (reason == DLL_PROCESS_DETACH) {
diff -r -u --color up/chromium/chrome/chrome_elf/chrome_elf_main.h nw/chromium/chrome/chrome_elf/chrome_elf_main.h
--- up/chromium/chrome/chrome_elf/chrome_elf_main.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/chrome_elf_main.h	2024-08-26 19:32:19.798587474 +0000
@@ -22,7 +22,7 @@
 // This function is a temporary workaround for https://crbug.com/655788. We
 // need to come up with a better way to initialize crash reporting that can
 // happen inside DllMain().
-void SignalInitializeCrashReporting();
+  void SignalInitializeCrashReporting(void*, void*);
 void SignalChromeElf();
 
 // Sets the metrics client ID in crash keys.
@@ -37,5 +37,5 @@
 bool IsExtensionPointDisableSet();
 
 }  // extern "C"
-
+extern "C" void* ElfGetReporterClient();
 #endif  // CHROME_CHROME_ELF_CHROME_ELF_MAIN_H_
diff -r -u --color up/chromium/chrome/chrome_elf/chrome_elf_x64.def nw/chromium/chrome/chrome_elf/chrome_elf_x64.def
--- up/chromium/chrome/chrome_elf/chrome_elf_x64.def	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/chrome_elf_x64.def	2024-08-26 19:32:19.798587474 +0000
@@ -1,9 +1,10 @@
 ; Copyright 2013 The Chromium Authors
 ; Use of this source code is governed by a BSD-style license that can be
 ; found in the LICENSE file.
-LIBRARY  "chrome_elf.dll"
+LIBRARY  "nw_elf.dll"
 
 EXPORTS
+  ElfGetReporterClient
   ; When functions are added to this file, they must also be added to
   ; chrome_elf_x86.def and chrome_elf_arm64.def
 
diff -r -u --color up/chromium/chrome/chrome_elf/chrome_elf_x86.def nw/chromium/chrome/chrome_elf/chrome_elf_x86.def
--- up/chromium/chrome/chrome_elf/chrome_elf_x86.def	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/chrome_elf_x86.def	2024-08-26 19:32:19.798587474 +0000
@@ -1,7 +1,8 @@
 ; Copyright 2013 The Chromium Authors
 ; Use of this source code is governed by a BSD-style license that can be
 ; found in the LICENSE file.
-LIBRARY  "chrome_elf.dll"
+
+LIBRARY  "nw_elf.dll"
 
 EXPORTS
   ; When functions are added to this file, they must also be added to
@@ -43,3 +44,4 @@
 
   ; From chrome/chrome_elf/third_party_dlls/main.cc
   IsThirdPartyInitialized
+  ElfGetReporterClient
diff -r -u --color up/chromium/chrome/chrome_paks.gni nw/chromium/chrome/chrome_paks.gni
--- up/chromium/chrome/chrome_paks.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/chrome_paks.gni	2024-08-26 19:32:19.802587476 +0000
@@ -94,7 +94,7 @@
       deps += [ "//extensions:extensions_browser_resources" ]
     }
 
-    output = "${invoker.output_dir}/chrome_${percent}_percent.pak"
+    output = "${invoker.output_dir}/nw_${percent}_percent.pak"
   }
 }
 
@@ -153,6 +153,12 @@
     if (defined(invoker.additional_paks)) {
       sources += invoker.additional_paks
     }
+    if (nwjs_sdk) {
+      sources += [
+        "$root_gen_dir/content/browser/tracing/tracing_resources.pak",
+        "$root_gen_dir/content/browser/devtools/devtools_resources.pak",
+      ]
+    }
 
     if (!is_android) {
       # New paks should be added here by default.
@@ -200,8 +206,6 @@
         "$root_gen_dir/chrome/web_app_internals_resources.pak",
         "$root_gen_dir/chrome/webui_gallery_resources.pak",
         "$root_gen_dir/chrome/whats_new_resources.pak",
-        "$root_gen_dir/content/browser/devtools/devtools_resources.pak",
-        "$root_gen_dir/content/browser/tracing/tracing_resources.pak",
         "$root_gen_dir/content/traces_internals_resources.pak",
       ]
       deps += [
diff -r -u --color up/chromium/chrome/common/BUILD.gn nw/chromium/chrome/common/BUILD.gn
--- up/chromium/chrome/common/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/BUILD.gn	2024-08-26 19:32:19.802587476 +0000
@@ -229,8 +229,8 @@
     "//components/services/heap_profiling/public/cpp",
     "//components/strings",
     "//components/supervised_user/core/common",
-    "//components/translate/content/common",
-    "//components/translate/core/common",
+    #"//components/translate/content/common",
+    #"//components/translate/core/common",
     "//components/url_formatter",
     "//components/variations",
     "//components/variations/net",
@@ -345,6 +345,7 @@
       "//components/app_constants",
     ]
     public_deps += [
+      "//content/nw/src/api:nw_api",
       "//chrome/common/extensions/api",
       "//chrome/common/extensions/api:extensions_features",
       "//extensions:extensions_resources",
diff -r -u --color up/chromium/chrome/common/apps/platform_apps/api/_api_features.json nw/chromium/chrome/common/apps/platform_apps/api/_api_features.json
--- up/chromium/chrome/common/apps/platform_apps/api/_api_features.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/apps/platform_apps/api/_api_features.json	2024-08-26 19:32:19.802587476 +0000
@@ -7,10 +7,6 @@
 // well as feature.h, simple_feature.h, and feature_provider.h.
 
 {
-  "arcAppsPrivate": {
-    "dependencies": ["permission:arcAppsPrivate"],
-    "contexts": ["privileged_extension"]
-  },
   "browser": {
     "dependencies": ["permission:browser"],
     "contexts": ["privileged_extension"]
diff -r -u --color up/chromium/chrome/common/child_process_logging_win.cc nw/chromium/chrome/common/child_process_logging_win.cc
--- up/chromium/chrome/common/child_process_logging_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/child_process_logging_win.cc	2024-08-26 19:32:19.802587476 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "chrome/common/child_process_logging.h"
+#include "chrome/chrome_elf/chrome_elf_main.h"
 
 #include <windows.h>
 
diff -r -u --color up/chromium/chrome/common/chrome_constants.cc nw/chromium/chrome/common/chrome_constants.cc
--- up/chromium/chrome/common/chrome_constants.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/chrome_constants.cc	2024-08-26 19:32:19.802587476 +0000
@@ -33,9 +33,9 @@
 
 #if BUILDFLAG(IS_WIN)
 const base::FilePath::CharType kBrowserProcessExecutableName[] =
-    FPL("chrome.exe");
+    FPL("nw.exe");
 const base::FilePath::CharType kHelperProcessExecutableName[] =
-    FPL("chrome.exe");
+    FPL("nw.exe");
 #elif BUILDFLAG(IS_MAC)
 const base::FilePath::CharType kBrowserProcessExecutableName[] =
     FPL(PRODUCT_FULLNAME_STRING);
@@ -47,7 +47,7 @@
 const base::FilePath::CharType kHelperProcessExecutableName[] =
     FPL("sandboxed_process");
 #elif BUILDFLAG(IS_POSIX)
-const base::FilePath::CharType kBrowserProcessExecutableName[] = FPL("chrome");
+const base::FilePath::CharType kBrowserProcessExecutableName[] = FPL("nw");
 // Helper processes end up with a name of "exe" due to execing via
 // /proc/self/exe.  See bug 22703.
 const base::FilePath::CharType kHelperProcessExecutableName[] = FPL("exe");
@@ -55,9 +55,9 @@
 
 #if BUILDFLAG(IS_WIN)
 const base::FilePath::CharType kBrowserProcessExecutablePath[] =
-    FPL("chrome.exe");
+    FPL("nw.exe");
 const base::FilePath::CharType kHelperProcessExecutablePath[] =
-    FPL("chrome.exe");
+    FPL("nw.exe");
 #elif BUILDFLAG(IS_MAC)
 const base::FilePath::CharType kBrowserProcessExecutablePath[] =
     FPL(PRODUCT_FULLNAME_STRING ".app/Contents/MacOS/" PRODUCT_FULLNAME_STRING);
@@ -76,8 +76,8 @@
 const base::FilePath::CharType kBrowserProcessExecutablePath[] = FPL("chrome");
 const base::FilePath::CharType kHelperProcessExecutablePath[] = FPL("chrome");
 #elif BUILDFLAG(IS_POSIX)
-const base::FilePath::CharType kBrowserProcessExecutablePath[] = FPL("chrome");
-const base::FilePath::CharType kHelperProcessExecutablePath[] = FPL("chrome");
+const base::FilePath::CharType kBrowserProcessExecutablePath[] = FPL("nw");
+const base::FilePath::CharType kHelperProcessExecutablePath[] = FPL("nw");
 #endif  // OS_*
 
 #if BUILDFLAG(IS_MAC)
@@ -89,11 +89,11 @@
 #endif  // BUILDFLAG(IS_MAC)
 
 #if BUILDFLAG(IS_WIN)
-const base::FilePath::CharType kBrowserResourcesDll[] = FPL("chrome.dll");
-const base::FilePath::CharType kElfDll[] = FPL("chrome_elf.dll");
+const base::FilePath::CharType kBrowserResourcesDll[] = FPL("nw.dll");
+const base::FilePath::CharType kElfDll[] = FPL("nw_elf.dll");
 const base::FilePath::CharType kStatusTrayWindowClass[] =
-    FPL("Chrome_StatusTrayWindow");
-#endif  // BUILDFLAG(IS_WIN)
+    FPL("NWJS_StatusTrayWindow");
+#endif  // defined(OS_WIN)
 
 const char kInitialProfile[] = "Default";
 const char kMultiProfileDirPrefix[] = "Profile ";
diff -r -u --color up/chromium/chrome/common/chrome_content_client.cc nw/chromium/chrome/common/chrome_content_client.cc
--- up/chromium/chrome/common/chrome_content_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/chrome_content_client.cc	2024-08-26 19:32:19.802587476 +0000
@@ -2,8 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "content/nw/src/browser/nw_extensions_browser_hooks.h"
 #include "chrome/common/chrome_content_client.h"
 
+#include "components/crash/core/app/crash_reporter_client.h"
 #include <stdint.h>
 
 #include <memory>
@@ -103,6 +105,8 @@
 #include "chrome/common/media/chrome_media_drm_bridge_client.h"
 #endif
 
+#include "content/nw/src/common/nw_content_common_hooks.h"
+
 namespace {
 
 #if BUILDFLAG(ENABLE_NACL)
@@ -199,6 +203,17 @@
   return {url::Origin::Create(GURL(chrome::kChromeUIPrintURL))};
 }
 
+void ChromeContentClient::LoadNWAppAsExtension(base::Value::Dict* manifest,
+                                               const base::FilePath& path,
+                                               std::string* error) {
+  nw::LoadNWAppAsExtensionHook(manifest, path, error);
+}
+
+void ChromeContentClient::SetNWReportURL(const GURL& url) {
+  static crash_reporter::CrashKeyString<1024> nwjs_url("url-nwjs");
+  nwjs_url.Set(url.possibly_invalid_spec());
+}
+
 void ChromeContentClient::AddContentDecryptionModules(
     std::vector<content::CdmInfo>* cdms,
     std::vector<media::CdmHostFilePath>* cdm_host_file_paths) {
diff -r -u --color up/chromium/chrome/common/chrome_content_client.h nw/chromium/chrome/common/chrome_content_client.h
--- up/chromium/chrome/common/chrome_content_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/chrome_content_client.h	2024-08-26 19:32:19.802587476 +0000
@@ -43,6 +43,9 @@
 
   ChromeContentClient();
   ~ChromeContentClient() override;
+  void LoadNWAppAsExtension(base::Value::Dict* manifest,
+                            const base::FilePath& path,
+                            std::string* error) override;
 
   // The methods below are called by child processes to set the function
   // pointers for built-in plugins. We avoid linking these plugins into
@@ -56,6 +59,7 @@
 #endif
 
   void SetActiveURL(const GURL& url, std::string top_origin) override;
+  void SetNWReportURL(const GURL& url) override;
   void SetGpuInfo(const gpu::GPUInfo& gpu_info) override;
   void AddPlugins(std::vector<content::ContentPluginInfo>* plugins) override;
   std::vector<url::Origin> GetPdfInternalPluginAllowedOrigins() override;
diff -r -u --color up/chromium/chrome/common/chrome_features.cc nw/chromium/chrome/common/chrome_features.cc
--- up/chromium/chrome/common/chrome_features.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/chrome_features.cc	2024-08-26 19:32:19.806587478 +0000
@@ -1290,7 +1290,7 @@
 #if BUILDFLAG(IS_ANDROID) && !BUILDFLAG(ENABLE_ANDROID_SITE_ISOLATION)
              base::FEATURE_DISABLED_BY_DEFAULT
 #else
-             base::FEATURE_ENABLED_BY_DEFAULT
+      base::FEATURE_DISABLED_BY_DEFAULT
 #endif
 );
 
diff -r -u --color up/chromium/chrome/common/chrome_paths.cc nw/chromium/chrome/common/chrome_paths.cc
--- up/chromium/chrome/common/chrome_paths.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/chrome_paths.cc	2024-08-26 19:32:19.806587478 +0000
@@ -383,7 +383,7 @@
     // was shipped along with chrome.  The value can be overridden
     // if it is installed via component updater.
     case chrome::DIR_PNACL_COMPONENT:
-#if BUILDFLAG(IS_MAC)
+#if 0
       // PNaCl really belongs in the InternalPluginsDirectory but actually
       // copying it there would result in the files also being shipped, which
       // we don't want yet. So for now, just find them in the directory where
diff -r -u --color up/chromium/chrome/common/chrome_paths_linux.cc nw/chromium/chrome/common/chrome_paths_linux.cc
--- up/chromium/chrome/common/chrome_paths_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/chrome_paths_linux.cc	2024-08-26 19:32:19.806587478 +0000
@@ -18,6 +18,8 @@
 #include "chrome/common/channel_info.h"
 #include "chrome/common/chrome_paths_internal.h"
 
+#include "content/nw/src/nw_base.h"
+
 namespace chrome {
 
 using base::nix::GetXDGDirectory;
@@ -89,14 +91,16 @@
         GetXDGDirectory(env.get(), kXdgConfigHomeEnvVar, kDotConfigDir);
   }
 
-#if BUILDFLAG(GOOGLE_CHROME_FOR_TESTING_BRANDING)
+#if 0 //BUILDFLAG(GOOGLE_CHROME_FOR_TESTING_BRANDING)
   std::string data_dir_basename = "google-chrome-for-testing";
-#elif BUILDFLAG(GOOGLE_CHROME_BRANDING)
+#elif 0 //BUILDFLAG(GOOGLE_CHROME_BRANDING)
   std::string data_dir_basename = "google-chrome";
 #else
-  std::string data_dir_basename = "chromium";
+  std::string data_dir_basename = nw::package()->GetName();
 #endif
-  *result = config_dir.Append(data_dir_basename + GetChannelSuffixForDataDir());
+
+  *result = config_dir.Append(nw::package()->GetName());
+  //*result = config_dir.Append(data_dir_basename + GetChannelSuffixForDataDir());
   return true;
 }
 
diff -r -u --color up/chromium/chrome/common/chrome_paths_mac.mm nw/chromium/chrome/common/chrome_paths_mac.mm
--- up/chromium/chrome/common/chrome_paths_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/chrome_paths_mac.mm	2024-08-26 19:32:19.806587478 +0000
@@ -19,6 +19,8 @@
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_paths_internal.h"
 
+#include "content/nw/src/nw_base.h"
+
 namespace {
 
 // Return an NSBundle* as the internal implementation of
@@ -60,7 +62,7 @@
 #elif BUILDFLAG(GOOGLE_CHROME_BRANDING)
       product_dir_name = "Google/Chrome";
 #else
-      product_dir_name = "Chromium";
+    product_dir_name = "nwjs";
 #endif
     }
 
@@ -70,6 +72,7 @@
   }
 }
 
+#if 0
 // ProductDirName returns the name of the directory inside
 // ~/Library/Application Support that should hold the product application
 // data. This can be overridden by setting the CrProductDirName key in the
@@ -91,6 +94,7 @@
       ProductDirNameForBundle(chrome::OuterAppBundle());
   return std::string(product_dir_name);
 }
+#endif
 
 bool GetDefaultUserDataDirectoryForProduct(const std::string& product_dir,
                                            base::FilePath* result) {
@@ -107,7 +111,7 @@
 namespace chrome {
 
 bool GetDefaultUserDataDirectory(base::FilePath* result) {
-  return GetDefaultUserDataDirectoryForProduct(ProductDirName(), result);
+  return GetDefaultUserDataDirectoryForProduct(nw::package()->GetName(), result);
 }
 
 bool GetUserDocumentsDirectory(base::FilePath* result) {
diff -r -u --color up/chromium/chrome/common/chrome_paths_win.cc nw/chromium/chrome/common/chrome_paths_win.cc
--- up/chromium/chrome/common/chrome_paths_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/chrome_paths_win.cc	2024-08-26 19:32:19.806587478 +0000
@@ -19,6 +19,8 @@
 #include "chrome/install_static/install_util.h"
 #include "components/nacl/common/nacl_switches.h"
 
+#include "content/nw/src/nw_base.h"
+
 namespace chrome {
 
 namespace {
@@ -45,7 +47,8 @@
 bool GetDefaultUserDataDirectory(base::FilePath* result) {
   if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, result))
     return false;
-  *result = result->Append(install_static::GetChromeInstallSubDirectory());
+  if (nw::package()) //FIXME: crashpad initialized early in cr49
+    *result = result->Append(base::FilePath::FromUTF8Unsafe(nw::package()->GetName()));
   *result = result->Append(chrome::kUserDataDirname);
   return true;
 }
diff -r -u --color up/chromium/chrome/common/extensions/api/BUILD.gn nw/chromium/chrome/common/extensions/api/BUILD.gn
--- up/chromium/chrome/common/extensions/api/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/BUILD.gn	2024-08-26 19:32:19.810587481 +0000
@@ -89,7 +89,10 @@
 json_features("api_features") {
   feature_type = "APIFeature"
   method_name = "AddChromeAPIFeatures"
-  sources = [ "_api_features.json" ]
+  sources = [
+    "../../../../content/nw/src/api/_api_features.json",
+    "_api_features.json",
+  ]
   visibility = [ ":extensions_features" ]
 }
 
diff -r -u --color up/chromium/chrome/common/extensions/api/_api_features.json nw/chromium/chrome/common/extensions/api/_api_features.json
--- up/chromium/chrome/common/extensions/api/_api_features.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/_api_features.json	2024-08-26 19:32:19.810587481 +0000
@@ -28,28 +28,6 @@
     "contexts": ["privileged_extension"],
     "platforms": ["chromeos", "lacros"]
   },
-  "action": {
-    "dependencies": ["manifest:action"],
-    "contexts": ["privileged_extension"]
-  },
-  "action.openPopup": [{
-    "channel": "stable",
-    // TODO(https://crbug.com/40057101): Remove this guard after the feature
-    // has been in stable for a milestone or two.
-    "feature_flag": "ApiActionOpenPopup"
-  }, {
-    "channel": "stable",
-    "location": "policy"
-  }],
-  "action.isEnabled": {
-    "channel": "stable"
-  },
-  "action.getBadgeTextColor": {
-    "channel": "stable"
-  },
-  "action.setBadgeTextColor": {
-    "channel": "stable"
-  },
   "activityLogPrivate": [{
     "dependencies": ["permission:activityLogPrivate"],
     "contexts": ["privileged_extension"]
@@ -512,30 +490,6 @@
     "contexts": ["privileged_extension"],
     "disallow_for_service_workers": true
   },
-  "fileManagerPrivate": [{
-    "dependencies": ["permission:fileManagerPrivate"],
-    "contexts": ["privileged_extension"]
-  }, {
-    "channel": "stable",
-    "contexts": ["webui"],
-    "matches": [
-      "chrome://file-manager/*",
-      "chrome://webui-test/*"
-    ]
-  }],
-  "fileManagerPrivateInternal": [{
-    "internal": true,
-    "dependencies": ["permission:fileManagerPrivate"],
-    "contexts": ["privileged_extension"]
-  }, {
-    "internal": true,
-    "channel": "stable",
-    "contexts": ["webui"],
-    "matches": [
-      "chrome://file-manager/*",
-      "chrome://webui-test/*"
-    ]
-  }],
   "fileSystemProvider": [{
     "dependencies": ["permission:fileSystemProvider"],
     "contexts": ["privileged_extension"]
@@ -621,6 +575,8 @@
   }, {
     "channel": "stable",
     "contexts": ["webui"],
+    "dependencies": ["permission:usersPrivate"],
+    "platforms": ["chromeos"],
     "matches": [
       // TODO(maybelle): Audit and remove chrome://settings or
       // chrome://os-settings as appropriate
@@ -809,10 +765,6 @@
     "dependencies": ["permission:rtcPrivate"],
     "contexts": ["privileged_extension"]
   },
-  "safeBrowsingPrivate": {
-    "dependencies": ["permission:safeBrowsingPrivate"],
-    "contexts": ["privileged_extension"]
-  },
   "scripting": {
     "dependencies": ["permission:scripting"],
     "contexts": ["privileged_extension"]
@@ -973,31 +925,10 @@
     "dependencies": ["permission:ttsEngine"],
     "contexts": ["privileged_extension"]
   },
-  "usersPrivate": [{
-    "dependencies": ["permission:usersPrivate"],
-    "contexts": ["privileged_extension"],
-    "platforms": ["chromeos"]
-  }, {
-    "channel": "stable",
-    "contexts": ["webui"],
-    "matches": [
-      "chrome://os-settings/*"
-    ]
-  }],
   "virtualKeyboardPrivate": {
     "dependencies": ["permission:virtualKeyboardPrivate"],
     "contexts": ["privileged_extension"]
   },
-  "wallpaper": [{
-    "dependencies": ["permission:wallpaper"],
-    "contexts": ["privileged_extension"]
-  }, {
-    "channel": "stable",
-    "contexts": ["webui"],
-    "matches": [
-      "chrome://file-manager/*"
-    ]
-  }],
   "webAuthenticationProxy": {
     "dependencies": ["permission:webAuthenticationProxy"],
     "contexts": ["privileged_extension"]
diff -r -u --color up/chromium/chrome/common/extensions/api/_permission_features.json nw/chromium/chrome/common/extensions/api/_permission_features.json
--- up/chromium/chrome/common/extensions/api/_permission_features.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/_permission_features.json	2024-08-26 19:32:19.810587481 +0000
@@ -217,16 +217,7 @@
   ],
   "developerPrivate": {
     "channel": "stable",
-    "extension_types": ["platform_app"],
-    "allowlist": [
-        "AE27D69DBE571F4B1694F05C89B710C646792231", // Published ADT.
-        "FA0501B579070BB9CBD4FCAEC8CB0EDF22BA2F04", // Apps Editor published.
-        "4A4EA121622FCA3D78ED2AB534197F43D7189EE0", // Spark nightly build.
-        "9FDE6E7F06FCFA11D9A05041C7FF6D8AE662F5D1", // Spark release.
-        "50B4A905D522C06E27CA6D099E3E54BDA1F152C5", // Spark Beta channel.
-        "BA0C8BB92084C9741312D90D3EA882526853455F", // Spark dev channel.
-        "5F57A9AE8DFF5D6BB09DF8606270402612E871E5"  // http://crbug.com/422624
-    ]
+    "extension_types": ["platform_app"]
   },
   "devtools": {
     "channel": "stable",
@@ -609,6 +600,7 @@
   }],
   "webcamPrivate": {
     "channel": "stable",
+    "platforms": ["chromeos"],
     "extension_types": ["extension", "platform_app"],
     "allowlist": [
       "E703483CEF33DEC18B4B6DD84B5C776FB9182BDB",  // http://crbug.com/891460
@@ -630,25 +622,7 @@
     },
     {
       "channel": "stable",
-      "extension_types": ["platform_app"],
-      "allowlist": [
-        "AE27D69DBE571F4B1694F05C89B710C646792231", // Published ADT
-        // TODO(grv): clean up once Apps developer tool is published.
-        "5107DE9024C329EEA9C9A72D94C16723790C6422",  // Apps Developer Tool.
-        "8C0B1873FFFB65E4D0F4D772879F7304CEF125C2",  // Apps Editor old.
-        "FA0501B579070BB9CBD4FCAEC8CB0EDF22BA2F04",  // Apps Editor published.
-        "EE17C698905F7F2E6DDC87C9C30F11E164C829F4",  // Watchdog (Activity Log)
-        "90113DA9516526D24DAF156C629CC41C049E8882",  // Watchdog Test Version
-        "4A4EA121622FCA3D78ED2AB534197F43D7189EE0",  // Spark nightly build.
-        "9FDE6E7F06FCFA11D9A05041C7FF6D8AE662F5D1",  // Spark release.
-        "50B4A905D522C06E27CA6D099E3E54BDA1F152C5",  // Spark Beta channel.
-        "BA0C8BB92084C9741312D90D3EA882526853455F",  // Spark dev channel.
-        "5F57A9AE8DFF5D6BB09DF8606270402612E871E5",  // http://crbug.com/422624
-        "46578A13607D38F1DC8E280C4F499FB0A2F9565C",  // http://crbug.com/819404
-        "898FB5A39687D210766B8998BA4530B99C9E6586",  // http://crbug.com/819404
-        "82F30B65397BC3E4ADE627BBD857AB8A58210648",  // http://crbug.com/819404
-        "C74B2AF138F9EDECD04D0965AB36CA66C8290466"   // http://crbug.com/957772
-      ]
+      "extension_types": ["platform_app"]
     },
     {
       "channel": "stable",
@@ -837,6 +811,7 @@
   "rtcPrivate": {
     "channel": "stable",
     "extension_types": ["extension", "legacy_packaged_app"],
+    "platforms": ["chromeos"],
     "allowlist": [
       "53041A2FA309EECED01FFC751E7399186E860B2C",  // Google Talk prod
       "A74A4D44C7CFCD8844830E6140C8D763E12DD8F3",  // Google Talk beta
@@ -963,7 +938,7 @@
   ],
   "tabCapture": {
     "channel": "stable",
-    "extension_types": ["extension", "legacy_packaged_app"]
+    "extension_types": ["extension", "legacy_packaged_app", "platform_app"]
   },
   "terminalPrivate": {
     "channel": "stable",
diff -r -u --color up/chromium/chrome/common/extensions/api/tabs.json nw/chromium/chrome/common/extensions/api/tabs.json
--- up/chromium/chrome/common/extensions/api/tabs.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/tabs.json	2024-08-26 19:32:19.822587487 +0000
@@ -53,6 +53,7 @@
           "index": {"type": "integer", "minimum": -1, "description": "The zero-based index of the tab within its window."},
           "groupId": {"type": "integer", "minimum": -1, "description": "The ID of the group that the tab belongs to."},
           "windowId": {"type": "integer", "minimum": -1, "description": "The ID of the window that contains the tab."},
+          "mainFrameToken": {"type": "string", "description": "The ID of the main frame of the tab"},
           "openerTabId": {"type": "integer", "minimum": 0, "optional": true, "description": "The ID of the tab that opened this tab, if any. This property is only present if the opener tab still exists."},
           "selected": {"type": "boolean", "description": "Whether the tab is selected.", "deprecated": "Please use $(ref:tabs.Tab.highlighted)."},
           "lastAccessed": {"type": "number", "optional": true, "description": "The last time the tab was accessed as the number of milliseconds since epoch."},
@@ -72,6 +73,11 @@
             "optional": true,
             "description": "The tab's loading status."
           },
+          "nwstatus": {
+            "$ref": "TabStatus",
+            "optional": true,
+            "description": "The tab's loading status."
+          },
           "incognito": {"type": "boolean", "description": "Whether the tab is in an incognito window."},
           "width": {"type": "integer", "optional": true, "description": "The width of the tab in pixels."},
           "height": {"type": "integer", "optional": true, "description": "The height of the tab in pixels."},
@@ -1121,6 +1127,11 @@
             "name": "changeInfo",
             "description": "Lists the changes to the state of the tab that was updated.",
             "properties": {
+              "nwstatus": {
+                "type": "string",
+                "optional": true,
+                "description": "The status of the tab. Can be either <em>loading</em> or <em>complete</em>."
+              },
               "status": {
                 "$ref": "TabStatus",
                 "optional": true,
diff -r -u --color up/chromium/chrome/common/extensions/api/web_navigation.json nw/chromium/chrome/common/extensions/api/web_navigation.json
--- up/chromium/chrome/common/extensions/api/web_navigation.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/web_navigation.json	2024-08-26 19:32:19.822587487 +0000
@@ -244,6 +244,7 @@
               "processId": {"type": "integer", "description": "The ID of the process that runs the renderer for this frame."},
               "frameId": {"type": "integer", "description": "0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab."},
               "parentFrameId": {"type": "integer", "description": "The ID of the parent frame, or <code>-1</code> if this is the main frame."},
+              "routingId": {"type": "integer", "description": ""},
               "timeStamp": {"type": "number", "description": "The time when the page's DOM was fully constructed, in milliseconds since the epoch."},
               "documentId": {"type": "string", "description": "A UUID of the document loaded."},
               "parentDocumentId": {"type": "string", "optional": true, "description": "A UUID of the parent document owning this frame. This is not set if there is no parent."},
diff -r -u --color up/chromium/chrome/common/extensions/api/webview_tag.json nw/chromium/chrome/common/extensions/api/webview_tag.json
--- up/chromium/chrome/common/extensions/api/webview_tag.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/webview_tag.json	2024-08-26 19:32:19.822587487 +0000
@@ -920,6 +920,13 @@
         "parameters": []
       },
       {
+        "name": "getGuestId",
+        "type": "function",
+        "returns": { "type": "integer" },
+        "description": "",
+        "parameters": []
+      },
+      {
         "name": "getUserAgent",
         "type": "function",
         "returns": { "type": "string" },
@@ -1163,6 +1170,41 @@
           }
         ]
       },
+      {
+	"name": "showDevTools",
+	"type": "function",
+	"description": "Open or close devtools for this webview.",
+	"parameters": [
+          {
+            "type": "boolean",
+            "name": "show",
+            "description" : "show or close."
+          },
+          {
+            "type": "object",
+            "name": "container",
+            "description" : "where to show the devtools, should be a webview",
+            "optional": true
+          }
+        ]
+      },
+      {
+	"name": "inspectElementAt",
+	"type": "function",
+	"description": "inpsect element in this webview in devtools opened previously.",
+	"parameters": [
+          {
+            "type": "integer",
+            "name": "x",
+            "description" : "coordinate x of the element."
+          },
+          {
+            "type": "integer",
+            "name": "y",
+            "description" : "coordinate y of the element"
+          }
+        ]
+      },
       {
         "name": "terminate",
         "type": "function",
diff -r -u --color up/chromium/chrome/common/extensions/api/windows.json nw/chromium/chrome/common/extensions/api/windows.json
--- up/chromium/chrome/common/extensions/api/windows.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/windows.json	2024-08-26 19:32:19.826587489 +0000
@@ -50,6 +50,9 @@
           "name": "maximized",
           "description": "Maximized window state."
         }, {
+          "name": "hidden",
+          "description": "Hidden window state."
+        }, {
           "name": "fullscreen",
           "description": "Fullscreen window state."
         }, {
@@ -64,6 +67,10 @@
         "properties": {
           "id": {"type": "integer", "optional": true, "minimum": 0, "description": "The ID of the window. Window IDs are unique within a browser session. In some circumstances a window may not be assigned an <code>ID</code> property; for example, when querying windows using the $(ref:sessions) API, in which case a session ID may be present."},
           "focused": {"type": "boolean", "description": "Whether the window is currently the focused window."},
+          "maxWidth": {"type": "integer", "optional": true, "description": ""},  
+          "maxHeight": {"type": "integer", "optional": true, "description": ""},  
+          "minWidth": {"type": "integer", "optional": true, "description": ""},  
+          "minHeight": {"type": "integer", "optional": true, "description": ""},  
           "top": {"type": "integer", "optional": true, "description": "The offset of the window from the top edge of the screen in pixels. In some circumstances a window may not be assigned a <code>top</code> property; for example, when querying closed windows from the $(ref:sessions) API."},
           "left": {"type": "integer", "optional": true, "description": "The offset of the window from the left edge of the screen in pixels. In some circumstances a window may not be assigned a <code>left</code> property; for example, when querying closed windows from the $(ref:sessions) API."},
           "width": {"type": "integer", "optional": true, "description": "The width of the window, including the frame, in pixels. In some circumstances a window may not be assigned a <code>width</code> property; for example, when querying closed windows from the $(ref:sessions) API."},
@@ -81,6 +88,9 @@
             "description": "The state of this browser window."
           },
           "alwaysOnTop": {"type": "boolean", "description": "Whether the window is set to be always on top."},
+          "showInTaskbar": {"type": "boolean", "optional": true, "description": "Whether the window is set to be always on top."},
+          "resizable": {"type": "boolean", "optional": true, "description": "Whether the window is resizable"},
+          "allVisible": {"type": "boolean", "optional": true, "description": "Whether the window is set to be visible on all workspaces."},
           "sessionId": {"type": "string", "optional": true, "description": "The session ID used to uniquely identify a window, obtained from the $(ref:sessions) API."}
         }
       },
@@ -221,12 +231,33 @@
                   {"type": "array", "items": {"type": "string"}}
                 ]
               },
+              "id": {"type":"string", "optional": true, "description": ""},
               "tabId": {"type": "integer", "minimum": 0, "optional": true, "description": "The ID of the tab to add to the new window."},
+              "maxWidth": {"type": "integer", "optional": true, "description": ""},  
+              "maxHeight": {"type": "integer", "optional": true, "description": ""},  
+              "minWidth": {"type": "integer", "optional": true, "description": ""},  
+              "minHeight": {"type": "integer", "optional": true, "description": ""},  
               "left": {"type": "integer", "optional": true, "description": "The number of pixels to position the new window from the left edge of the screen. If not specified, the new window is offset naturally from the last focused window. This value is ignored for panels."},
               "top": {"type": "integer", "optional": true, "description": "The number of pixels to position the new window from the top edge of the screen. If not specified, the new window is offset naturally from the last focused window. This value is ignored for panels."},
               "width": {"type": "integer", "minimum": 0, "optional": true, "description": "The width in pixels of the new window, including the frame. If not specified, defaults to a natural width."},
               "height": {"type": "integer", "minimum": 0, "optional": true, "description": "The height in pixels of the new window, including the frame. If not specified, defaults to a natural height."},
               "focused": {"type": "boolean", "optional": true, "description": "If <code>true</code>, opens an active window. If <code>false</code>, opens an inactive window."},
+              "hidden": {"type": "boolean", "optional": true, "description": ""},
+              "frameless": {"type": "boolean", "optional": true, "description": ""},
+              "kiosk": {"type": "boolean", "optional": true, "description": ""},
+              "alphaEnabled": {"type": "boolean", "optional": true, "description": ""},
+              "new_instance": {"type": "boolean", "optional": true, "description": ""},
+              "mixed_context": {"type": "boolean", "optional": true, "description": ""},
+              "block_parser": {"type":"boolean", "optional": true, "description": ""},
+              "inject_js_start": {"type":"string", "optional": true, "description": ""},
+              "inject_js_end": {"type":"string", "optional": true, "description": ""},
+              "alwaysOnTop": {"type": "boolean", "optional": true, "description": "Whether the window is set to be always on top."},
+              "showInTaskbar": {"type": "boolean", "optional": true, "description": "Whether the window is set to be always on top."},
+              "allVisible": {"type": "boolean", "optional": true, "description": "Whether the window is visible on all workspaces"},
+              "resizable": {"type": "boolean", "optional": true, "description": "Whether the window is resizable"},
+              "title":{"type":"string", "optional": true, "description": ""},
+              "icon":{"type":"string", "optional": true, "description": ""},
+              "position":{"type":"string", "optional": true, "description": ""},
               "incognito": {"type": "boolean", "optional": true, "description": "Whether the new window should be an incognito window."},
               "type": {
                 "$ref": "CreateType",
@@ -268,11 +299,23 @@
             "type": "object",
             "name": "updateInfo",
             "properties": {
+              "show": {"type": "boolean", "optional": true, "description": ""},
+              "resizable": {"type": "boolean", "optional": true, "description": "Whether the window is resizable"},
+              "allVisible": {"type": "boolean", "optional": true, "description": "Whether the window is visible on all workspaces"},
+              "alwaysOnTop": {"type": "boolean", "optional": true, "description": "Whether the window is set to be always on top."},
+              "showInTaskbar": {"type": "boolean", "optional": true, "description": "Whether the window is set to be always on top."},
+              "maxWidth": {"type": "integer", "optional": true, "description": ""},  
+              "maxHeight": {"type": "integer", "optional": true, "description": ""},  
+              "minWidth": {"type": "integer", "optional": true, "description": ""},  
+              "minHeight": {"type": "integer", "optional": true, "description": ""},  
               "left": {"type": "integer", "optional": true, "description": "The offset from the left edge of the screen to move the window to in pixels. This value is ignored for panels."},
               "top": {"type": "integer", "optional": true, "description": "The offset from the top edge of the screen to move the window to in pixels. This value is ignored for panels."},
+              "innerWidth": {"type": "integer", "optional": true, "description": ""},  
+              "innerHeight": {"type": "integer", "optional": true, "description": ""},  
               "width": {"type": "integer", "minimum": 0, "optional": true, "description": "The width to resize the window to in pixels. This value is ignored for panels."},
               "height": {"type": "integer", "minimum": 0, "optional": true, "description": "The height to resize the window to in pixels. This value is ignored for panels."},
               "focused": {"type": "boolean", "optional": true, "description": "If <code>true</code>, brings the window to the front; cannot be combined with the state 'minimized'. If <code>false</code>, brings the next window in the z-order to the front; cannot be combined with the state 'fullscreen' or 'maximized'."},
+              "position": {"type":"string", "optional": true, "description": ""},  
               "drawAttention": {"type": "boolean", "optional": true, "description": "If <code>true</code>, causes the window to be displayed in a manner that draws the user's attention to the window, without changing the focused window. The effect lasts until the user changes focus to the window. This option has no effect if the window already has focus. Set to <code>false</code> to cancel a previous <code>drawAttention</code> request."},
               "state": {
                 "$ref": "WindowState",
@@ -304,6 +347,46 @@
     ],
     "events": [
       {
+        "name": "onMove",
+        "type": "function",
+        "description": "Fired when a window is moving.",
+        "filters": [
+          {
+            "name": "windowTypes",
+            "type": "array",
+            "items": { "$ref": "WindowType" },
+            "description": "Conditions that the window's type being created must satisfy. By default it satisfies <code>['normal', 'popup']</code>."
+          }
+        ],
+        "parameters": [
+          {
+            "$ref": "Window",
+            "name": "window",
+            "description": "Details of the created window."
+          }
+        ]
+      },
+      {
+        "name": "onWindowChanged",
+        "type": "function",
+        "description": "Fired when a window is changed.",
+        "filters": [
+          {
+            "name": "windowTypes",
+            "type": "array",
+            "items": { "$ref": "WindowType" },
+            "description": "Conditions that the window's type being created must satisfy. By default it satisfies <code>['normal', 'popup']</code>."
+          }
+        ],
+        "parameters": [
+          {
+            "$ref": "Window",
+            "name": "window",
+            "description": "Details of the created window."
+          }
+        ]
+      },
+      {
         "name": "onCreated",
         "type": "function",
         "description": "Fired when a window is created.",
@@ -324,6 +407,23 @@
         ]
       },
       {
+        "name": "onRemoving",
+        "type": "function",
+        "description": "Fired when a window wants to be closed.",
+        "filters": [
+          {
+            "name": "windowTypes",
+            "type": "array",
+            "items": { "$ref": "WindowType" },
+            "description": "Conditions that the window's type being removed must satisfy. By default it satisfies <code>['normal', 'popup']</code>."
+          }
+        ],
+        "parameters": [
+          {"type": "integer", "name": "windowId", "minimum": 0, "description": "token of the top frame in the removed window."},
+          {"type": "string", "optional": true, "name": "flag", "description": ""}
+        ]
+      },
+      {
         "name": "onRemoved",
         "type": "function",
         "description": "Fired when a window is removed (closed).",
diff -r -u --color up/chromium/chrome/common/extensions/chrome_extensions_api_provider.cc nw/chromium/chrome/common/extensions/chrome_extensions_api_provider.cc
--- up/chromium/chrome/common/extensions/chrome_extensions_api_provider.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/extensions/chrome_extensions_api_provider.cc	2024-08-26 19:32:19.826587489 +0000
@@ -5,6 +5,7 @@
 #include "chrome/common/extensions/chrome_extensions_api_provider.h"
 
 #include <string_view>
+#include "content/nw/src/api/generated_schemas.h"
 
 #include "chrome/common/extensions/api/api_features.h"
 #include "chrome/common/extensions/api/generated_schemas.h"
@@ -13,6 +14,7 @@
 #include "chrome/common/extensions/chrome_manifest_handlers.h"
 #include "chrome/common/extensions/permissions/chrome_api_permissions.h"
 #include "chrome/grit/common_resources.h"
+#include "extensions/grit/extensions_resources.h"
 #include "extensions/common/features/json_feature_provider_source.h"
 #include "extensions/common/permissions/permissions_info.h"
 
@@ -43,16 +45,20 @@
 void ChromeExtensionsAPIProvider::AddAPIJSONSources(
     JSONFeatureProviderSource* json_source) {
   json_source->LoadJSON(IDR_CHROME_EXTENSION_API_FEATURES);
+  json_source->LoadJSON(IDR_NW_EXTENSION_API_FEATURES);
 }
 
 bool ChromeExtensionsAPIProvider::IsAPISchemaGenerated(
     const std::string& name) {
-  return api::ChromeGeneratedSchemas::IsGenerated(name);
+  return api::ChromeGeneratedSchemas::IsGenerated(name) || nwapi::nwjsGeneratedSchemas::IsGenerated(name);
 }
 
 std::string_view ChromeExtensionsAPIProvider::GetAPISchema(
     const std::string& name) {
-  return api::ChromeGeneratedSchemas::Get(name);
+  std::string_view chrome_schema = api::ChromeGeneratedSchemas::Get(name);
+  if (!chrome_schema.empty())
+    return chrome_schema;
+  return nwapi::nwjsGeneratedSchemas::Get(name);
 }
 
 void ChromeExtensionsAPIProvider::RegisterPermissions(
diff -r -u --color up/chromium/chrome/common/extensions/chrome_extensions_client.cc nw/chromium/chrome/common/extensions/chrome_extensions_client.cc
--- up/chromium/chrome/common/extensions/chrome_extensions_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/extensions/chrome_extensions_client.cc	2024-08-26 19:32:19.826587489 +0000
@@ -39,6 +39,8 @@
 #include "ui/base/l10n/l10n_util.h"
 #include "url/gurl.h"
 
+#include "content/nw/src/api/generated_schemas.h"
+
 namespace extensions {
 
 namespace {
diff -r -u --color up/chromium/chrome/common/extensions/sync_helper.cc nw/chromium/chrome/common/extensions/sync_helper.cc
--- up/chromium/chrome/common/extensions/sync_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/extensions/sync_helper.cc	2024-08-26 19:32:19.830587491 +0000
@@ -41,6 +41,7 @@
     case Manifest::TYPE_HOSTED_APP:
     case Manifest::TYPE_LEGACY_PACKAGED_APP:
     case Manifest::TYPE_PLATFORM_APP:
+    case Manifest::TYPE_NWJS_APP:
     case Manifest::TYPE_THEME:
       return true;
 
diff -r -u --color up/chromium/chrome/common/features.gni nw/chromium/chrome/common/features.gni
--- up/chromium/chrome/common/features.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/features.gni	2024-08-26 19:32:19.834587494 +0000
@@ -107,6 +107,7 @@
 # Every grit target in //chrome should apply these defines so that the
 # proper build flags can be set.
 chrome_grit_defines = [
+  "nwjs_sdk=$nwjs_sdk",
   "enable_arcore=$enable_arcore",
   "enable_cardboard=$enable_cardboard",
   "enable_compose=$enable_compose",
diff -r -u --color up/chromium/chrome/common/logging_chrome.cc nw/chromium/chrome/common/logging_chrome.cc
--- up/chromium/chrome/common/logging_chrome.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/common/logging_chrome.cc	2024-08-26 19:32:19.834587494 +0000
@@ -21,6 +21,7 @@
 #define IPC_LOG_TABLE_ADD_ENTRY(msg_id, logger) \
   content::RegisterIPCLogger(msg_id, logger)
 #include "chrome/common/all_messages.h"
+#include "extensions/common/extension_messages.h"
 #endif
 
 #if BUILDFLAG(IS_WIN)
diff -r -u --color up/chromium/chrome/install_static/chromium_install_modes.cc nw/chromium/chrome/install_static/chromium_install_modes.cc
--- up/chromium/chrome/install_static/chromium_install_modes.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/install_static/chromium_install_modes.cc	2024-08-26 19:32:19.870587513 +0000
@@ -16,7 +16,7 @@
 
 const wchar_t kCompanyPathName[] = L"";
 
-const wchar_t kProductPathName[] = L"Chromium";
+const wchar_t kProductPathName[] = L"nwjs";
 
 const size_t kProductPathNameLength = _countof(kProductPathName) - 1;
 
@@ -34,8 +34,8 @@
         .logo_suffix = L"",  // No logo suffix for the primary install mode.
         .app_guid =
             L"",  // Empty app_guid since no integration with Google Update.
-        .base_app_name = L"Chromium",              // A distinct base_app_name.
-        .base_app_id = L"Chromium",                // A distinct base_app_id.
+        .base_app_name = L"nwjs",              // A distinct base_app_name.
+        .base_app_id = L"nwjs",                // A distinct base_app_id.
         .browser_prog_id_prefix = L"ChromiumHTM",  // Browser ProgID prefix.
         .browser_prog_id_description =
             L"Chromium HTML Document",         // Browser ProgID description.
diff -r -u --color up/chromium/chrome/install_static/install_util.cc nw/chromium/chrome/install_static/install_util.cc
--- up/chromium/chrome/install_static/install_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/install_static/install_util.cc	2024-08-26 19:32:19.870587513 +0000
@@ -26,6 +26,8 @@
 #include "chrome/install_static/user_data_dir.h"
 #include "components/nacl/common/buildflags.h"
 
+std::wstring g_nwjs_prod_name, g_nwjs_prod_version;
+
 namespace install_static {
 
 enum class ProcessType {
@@ -96,6 +98,7 @@
   va_end(args);
 }
 
+#if 0
 bool GetLanguageAndCodePageFromVersionResource(const char* version_resource,
                                                WORD* language,
                                                WORD* code_page) {
@@ -173,6 +176,7 @@
   }
   return false;
 }
+#endif
 
 bool DirectoryExists(const std::wstring& path) {
   DWORD file_attributes = ::GetFileAttributes(path.c_str());
@@ -487,7 +491,10 @@
     path->append(kCompanyPathName);
     path->push_back(L'\\');
   }
-  path->append(kProductPathName, kProductPathNameLength);
+  if (!g_nwjs_prod_name.empty())
+    path->append(g_nwjs_prod_name);
+  else
+    path->append(kProductPathName, kProductPathNameLength);
   if (!include_suffix)
     return *path;
   return path->append(mode.install_suffix);
@@ -598,10 +605,10 @@
   assert(channel_name);
 
   // Default values in case we don't find a version resource.
-  *product_name = L"Chrome";
-  *version = L"0.0.0.0-devel";
+  *product_name = g_nwjs_prod_name;
+  *version = g_nwjs_prod_version;
   special_build->clear();
-
+#if 0
   DWORD dummy = 0;
   DWORD length = ::GetFileVersionInfoSize(exe_path.c_str(), &dummy);
   if (length) {
@@ -620,6 +627,7 @@
     }
   }
   *channel_name = GetChromeChannelName(/*with_extended_stable=*/true);
+#endif
 }
 
 version_info::Channel GetChromeChannel() {
diff -r -u --color up/chromium/chrome/installer/linux/BUILD.gn nw/chromium/chrome/installer/linux/BUILD.gn
--- up/chromium/chrome/installer/linux/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/installer/linux/BUILD.gn	2024-08-26 19:32:19.874587515 +0000
@@ -31,15 +31,15 @@
 assert(is_linux)
 
 packaging_files_executables = [
-  "$root_out_dir/chrome",
+  "$root_out_dir/nw",
   "$root_out_dir/chrome_crashpad_handler",
   "$root_out_dir/chrome_management_service",
   "$root_out_dir/chrome_sandbox",
 ]
 
 packaging_files_shlibs = [
-  "$root_out_dir/libEGL.so",
-  "$root_out_dir/libGLESv2.so",
+  "$root_out_dir/lib/libEGL.so",
+  "$root_out_dir/lib/libGLESv2.so",
 ]
 
 if (bundle_widevine_cdm) {
@@ -48,16 +48,16 @@
 }
 
 if (angle_shared_libvulkan && !is_chromeos) {
-  packaging_files_shlibs += [ "$root_out_dir/libvulkan.so.1" ]
+  packaging_files_shlibs += [ "$root_out_dir/lib/libvulkan.so.1" ]
 }
 
 if (enable_swiftshader) {
-  packaging_files_shlibs += [ "$root_out_dir/libvk_swiftshader.so" ]
+  packaging_files_shlibs += [ "$root_out_dir/lib/libvk_swiftshader.so" ]
 }
 
 if (build_with_internal_optimization_guide) {
   packaging_files_shlibs +=
-      [ "$root_out_dir/liboptimization_guide_internal.so" ]
+      [ "$root_out_dir/lib/liboptimization_guide_internal.so" ]
 }
 
 packaging_files_binaries = packaging_files_executables + packaging_files_shlibs
@@ -160,7 +160,7 @@
 }
 
 strip_binary("strip_chrome_binary") {
-  binary_input = "$root_out_dir/chrome"
+  binary_input = "$root_out_dir/nw"
   deps = [ "//chrome" ]
 }
 
@@ -180,22 +180,22 @@
 }
 
 strip_binary("strip_libEGL_shlib") {
-  binary_input = "$root_out_dir/libEGL.so"
+  binary_input = "$root_out_dir/lib/libEGL.so"
   deps = [ "//third_party/angle:libEGL" ]
 }
 
 strip_binary("strip_libGLESv2_shlib") {
-  binary_input = "$root_out_dir/libGLESv2.so"
+  binary_input = "$root_out_dir/lib/libGLESv2.so"
   deps = [ "//third_party/angle:libGLESv2" ]
 }
 
 strip_binary("strip_libvulkan_shlib") {
-  binary_input = "$root_out_dir/libvulkan.so.1"
+  binary_input = "$root_out_dir/lib/libvulkan.so.1"
   deps = [ "//third_party/vulkan-loader/src:libvulkan" ]
 }
 
 strip_binary("strip_libvk_swiftshader.shlib") {
-  binary_input = "$root_out_dir/libvk_swiftshader.so"
+  binary_input = "$root_out_dir/lib/libvk_swiftshader.so"
   deps = [ "//third_party/swiftshader/src/Vulkan:swiftshader_libvulkan" ]
 }
 
@@ -381,6 +381,9 @@
     "//third_party/angle:libEGL",
     "//third_party/angle:libGLESv2",
   ]
+  if (is_linux) {
+    public_deps += [ "//chrome:xdg_mime" ]
+  }
   if (bundle_widevine_cdm) {
     public_deps += [ "//third_party/widevine/cdm" ]
   }
diff -r -u --color up/chromium/chrome/installer/linux/common/installer.include nw/chromium/chrome/installer/linux/common/installer.include
--- up/chromium/chrome/installer/linux/common/installer.include	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/installer/linux/common/installer.include	2024-08-26 19:32:19.874587515 +0000
@@ -156,9 +156,9 @@
   # we should flag all installer files in FILES.cfg and get them from there, so
   # there's only one place people need to keep track of such things (and in
   # only the public repository).
-  if [ -r "${OUTPUTDIR}/chrome_100_percent.pak" ]; then
-    install -m 644 "${OUTPUTDIR}/chrome_100_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
-    install -m 644 "${OUTPUTDIR}/chrome_200_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
+  if [ -r "${OUTPUTDIR}/nw_100_percent.pak" ]; then
+    install -m 644 "${OUTPUTDIR}/nw_100_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
+    install -m 644 "${OUTPUTDIR}/nw_200_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
   else
     install -m 644 "${OUTPUTDIR}/theme_resources_100_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
     install -m 644 "${OUTPUTDIR}/ui_resources_100_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
diff -r -u --color up/chromium/chrome/installer/mini_installer/BUILD.gn nw/chromium/chrome/installer/mini_installer/BUILD.gn
--- up/chromium/chrome/installer/mini_installer/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/installer/mini_installer/BUILD.gn	2024-08-26 19:32:19.882587519 +0000
@@ -143,8 +143,8 @@
   release_file = "chrome.release"
 
   inputs = [
-    "$root_out_dir/chrome.dll",
-    "$root_out_dir/chrome.exe",
+    "$root_out_dir/nw.dll",
+    "$root_out_dir/nw.exe",
     "$root_out_dir/locales/en-US.pak",
     "$root_out_dir/setup.exe",
     "//chrome/tools/build/win/makecab.py",
diff -r -u --color up/chromium/chrome/installer/mini_installer/chrome.release nw/chromium/chrome/installer/mini_installer/chrome.release
--- up/chromium/chrome/installer/mini_installer/chrome.release	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/installer/mini_installer/chrome.release	2024-08-26 19:32:19.882587519 +0000
@@ -6,42 +6,44 @@
 #
 # Chrome Application dir entries, sorted alphabetically.
 #
-chrome.exe: %(ChromeDir)s\
-chrome_proxy.exe: %(ChromeDir)s\
+nw.exe: %(ChromeDir)s\
+nw_proxy.exe: %(ChromeDir)s\
 #
 # Chrome version dir assembly manifest.
 # The name of this file must match the name of the version dir, so we cannot
 # hard-code it.
 # // TODO(caitkp): Find a way to do this without wildcards.
 #
-*.*.*.*.manifest: %(VersionDir)s\
+*.*.*.*.manifest: %(ChromeDir)s\
 #
 # Chrome version dir entries, sorted alphabetically.
 #
-chrome.dll: %(VersionDir)s\
-chrome_100_percent.pak: %(VersionDir)s\
-chrome_child.dll: %(VersionDir)s\
-chrome_elf.dll: %(VersionDir)s\
-chrome_pwa_launcher.exe: %(VersionDir)s\
-chrome_wer.dll: %(VersionDir)s\
-d3dcompiler_47.dll: %(VersionDir)s\
-eventlog_provider.dll: %(VersionDir)s\
-icudtl.dat: %(VersionDir)s\
-libEGL.dll: %(VersionDir)s\
-libGLESv2.dll: %(VersionDir)s\
-mojo_core.dll: %(VersionDir)s\
-notification_helper.exe: %(VersionDir)s\
-optimization_guide_internal.dll: %(VersionDir)s\
-resources.pak: %(VersionDir)s\
-vk_swiftshader.dll: %(VersionDir)s\
-vk_swiftshader_icd.json: %(VersionDir)s\
-vulkan-1.dll: %(VersionDir)s\
-v8_context_snapshot.bin: %(VersionDir)s\
+nw.dll: %(ChromeDir)s\
+nw_100_percent.pak: %(ChromeDir)s\
+nw_child.dll: %(ChromeDir)s\
+nw_elf.dll: %(ChromeDir)s\
+chrome_pwa_launcher.exe: %(ChromeDir)s\
+chrome_wer.dll: %(ChromeDir)s\
+d3dcompiler_47.dll: %(ChromeDir)s\
+eventlog_provider.dll: %(ChromeDir)s\
+icudtl.dat: %(ChromeDir)s\
+libEGL.dll: %(ChromeDir)s\
+libGLESv2.dll: %(ChromeDir)s\
+mojo_core.dll: %(ChromeDir)s\
+notification_helper.exe: %(ChromeDir)s\
+optimization_guide_internal.dll: %(ChromeDir)s\
+resources.pak: %(ChromeDir)s\
+node.dll: %(ChromeDir)s\
+vk_swiftshader.dll: %(ChromeDir)s\
+vk_swiftshader_icd.json: %(ChromeDir)s\
+vulkan-1.dll: %(ChromeDir)s\
+v8_context_snapshot.bin: %(ChromeDir)s\
+
 #
 # Sub directories living in the version dir
 #
-Extensions\*.*: %(VersionDir)s\Extensions\
-locales\*.pak: %(VersionDir)s\Locales
+Extensions\*.*: %(ChromeDir)s\Extensions\
+locales\*.pak: %(ChromeDir)s\Locales
 
 #
 # VisualElements sub-dir.
@@ -49,8 +51,9 @@
 # All or none of the *Logo*.png files need to be present as the creation of
 # VisualElementsManifest.xml is based on the existence of
 # %(VersionDir)\VisualElements.
-Logo.png: %(VersionDir)s\VisualElements\
-SmallLogo.png: %(VersionDir)s\VisualElements\
+
+Logo.png: %(ChromeDir)s\VisualElements\
+SmallLogo.png: %(ChromeDir)s\VisualElements\
 
 #
 # Privacy Sandbox Attestation
@@ -65,7 +68,7 @@
 MEIPreload\preloaded_data.pb: %(VersionDir)s\MEIPreload\
 
 [HIDPI]
-chrome_200_percent.pak: %(VersionDir)s\
+nw_200_percent.pak: %(ChromeDir)s\
 
 [FFMPEG]
 ffmpeg.dll: %(VersionDir)s\
@@ -96,24 +99,24 @@
 #
 # Widevine CDM sub-dir
 #
-WidevineCdm\manifest.json: %(VersionDir)s\WidevineCdm\
-WidevineCdm\LICENSE: %(VersionDir)s\WidevineCdm\
-WidevineCdm\_platform_specific\win_x86\widevinecdm.dll: %(VersionDir)s\WidevineCdm\_platform_specific\win_x86\
-WidevineCdm\_platform_specific\win_x86\widevinecdm.dll.sig: %(VersionDir)s\WidevineCdm\_platform_specific\win_x86\
-WidevineCdm\_platform_specific\win_x64\widevinecdm.dll: %(VersionDir)s\WidevineCdm\_platform_specific\win_x64\
-WidevineCdm\_platform_specific\win_x64\widevinecdm.dll.sig: %(VersionDir)s\WidevineCdm\_platform_specific\win_x64\
-WidevineCdm\_platform_specific\win_arm64\widevinecdm.dll: %(VersionDir)s\WidevineCdm\_platform_specific\win_arm64\
-WidevineCdm\_platform_specific\win_arm64\widevinecdm.dll.sig: %(VersionDir)s\WidevineCdm\_platform_specific\win_arm64\
+WidevineCdm\manifest.json: %(ChromeDir)s\WidevineCdm\
+WidevineCdm\LICENSE: %(ChromeDir)s\WidevineCdm\
+WidevineCdm\_platform_specific\win_x86\widevinecdm.dll: %(ChromeDir)s\WidevineCdm\_platform_specific\win_x86\
+WidevineCdm\_platform_specific\win_x86\widevinecdm.dll.sig: %(ChromeDir)s\WidevineCdm\_platform_specific\win_x86\
+WidevineCdm\_platform_specific\win_x64\widevinecdm.dll: %(ChromeDir)s\WidevineCdm\_platform_specific\win_x64\
+WidevineCdm\_platform_specific\win_x64\widevinecdm.dll.sig: %(ChromeDir)s\WidevineCdm\_platform_specific\win_x64\
+WidevineCdm\_platform_specific\win_arm64\widevinecdm.dll: %(ChromeDir)s\WidevineCdm\_platform_specific\win_arm64\
+WidevineCdm\_platform_specific\win_arm64\widevinecdm.dll.sig: %(ChromeDir)s\WidevineCdm\_platform_specific\win_arm64\
 
 [SNAPSHOTBLOB]
 # The snapshot_blob.bin V8 snapshot is needed in builds that don't use
 # v8_context_snapshot.bin, such as Linux-Windows cross-builds.
 # It has its own section here so that it's only included when necessary.
-snapshot_blob.bin: %(VersionDir)s\
+snapshot_blob.bin: %(ChromeDir)s\
 
 [DXC]
 # Only include the DXC dlls if dawn_use_built_dxc is enabled. When this flag is false,
 # these DLLs may be present in the build dir if Dawn tests are built, in which case we
 # do not want to include them in the installer.
-dxcompiler.dll: %(VersionDir)s\
-dxil.dll: %(VersionDir)s\
+dxcompiler.dll: %(ChromeDir)s\
+dxil.dll: %(ChromeDir)s\
diff -r -u --color up/chromium/chrome/installer/util/google_update_settings.cc nw/chromium/chrome/installer/util/google_update_settings.cc
--- up/chromium/chrome/installer/util/google_update_settings.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/installer/util/google_update_settings.cc	2024-08-26 19:32:19.898587528 +0000
@@ -1,6 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunused-function"
 
 #include "chrome/installer/util/google_update_settings.h"
 
@@ -242,10 +243,14 @@
 }
 
 bool GoogleUpdateSettings::GetCollectStatsConsent() {
+#if 1
+  return false;
+#else
   return GetCollectStatsConsentImpl(
              &install_static::GetClientStateKeyPath,
              &install_static::GetClientStateMediumKeyPath) ==
          google_update::TRISTATE_TRUE;
+#endif
 }
 
 bool GoogleUpdateSettings::SetCollectStatsConsent(bool consented) {
diff -r -u --color up/chromium/chrome/installer/util/util_constants.cc nw/chromium/chrome/installer/util/util_constants.cc
--- up/chromium/chrome/installer/util/util_constants.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/installer/util/util_constants.cc	2024-08-26 19:32:19.902587530 +0000
@@ -215,8 +215,8 @@
 // TODO(gab): Rename setup.exe itself altogether and use the same binary for
 // Active Setup.
 const wchar_t kActiveSetupExe[] = L"chrmstp.exe";
-const wchar_t kChromeDll[] = L"chrome.dll";
-const wchar_t kChromeExe[] = L"chrome.exe";
+const wchar_t kChromeDll[] = L"nw.dll";
+const wchar_t kChromeExe[] = L"nw.exe";
 const wchar_t kChromeNewExe[] = L"new_chrome.exe";
 const wchar_t kChromeOldExe[] = L"old_chrome.exe";
 const wchar_t kChromeProxyExe[] = L"chrome_proxy.exe";
diff -r -u --color up/chromium/chrome/renderer/BUILD.gn nw/chromium/chrome/renderer/BUILD.gn
--- up/chromium/chrome/renderer/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/renderer/BUILD.gn	2024-08-26 19:32:19.902587530 +0000
@@ -127,6 +127,7 @@
   deps = [
     "//base/allocator:buildflags",
     "//build:chromeos_buildflags",
+    "//content/nw:nw_renderer",
     "//chrome:resources",
     "//chrome:strings",
     "//chrome/common",
@@ -194,9 +195,9 @@
     "//components/subresource_filter/content/renderer",
     "//components/subresource_filter/core/common",
     "//components/supervised_user/core/common:buildflags",
-    "//components/translate/content/renderer",
+    #"//components/translate/content/renderer",
     "//components/translate/core/common",
-    "//components/translate/core/language_detection",
+    #"//components/translate/core/language_detection",
     "//components/visitedlink/renderer",
     "//components/web_cache/renderer",
     "//components/webapps/renderer",
diff -r -u --color up/chromium/chrome/renderer/chrome_content_renderer_client.cc nw/chromium/chrome/renderer/chrome_content_renderer_client.cc
--- up/chromium/chrome/renderer/chrome_content_renderer_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/renderer/chrome_content_renderer_client.cc	2024-08-26 19:32:19.910587534 +0000
@@ -256,6 +256,9 @@
 #include "chrome/renderer/media/chrome_key_systems.h"
 #endif
 
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/common/shell_switches.h"
+
 using autofill::AutofillAgent;
 using autofill::PasswordAutofillAgent;
 using autofill::PasswordGenerationAgent;
@@ -396,6 +399,15 @@
 
 ChromeContentRendererClient::~ChromeContentRendererClient() {}
 
+void ChromeContentRendererClient::willHandleNavigationPolicy(content::RenderFrame* rv,
+                                                             blink::WebFrame* frame,
+                                                             const blink::WebURLRequest& request,
+                                                             blink::WebNavigationPolicy* policy,
+                                                             blink::WebString* manifest,
+                                                             bool new_win) {
+  nw::willHandleNavigationPolicy(rv, frame, request, policy, manifest, new_win);
+}
+
 void ChromeContentRendererClient::RenderThreadStarted() {
   RenderThread* thread = RenderThread::Get();
 
@@ -451,9 +463,11 @@
       WebString::FromASCII(extensions::kExtensionScheme));
 #endif
 
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
 #if BUILDFLAG(ENABLE_SPELLCHECK)
-  if (!spellcheck_)
+  if (!spellcheck_ && command_line->HasSwitch(switches::kEnableSpellChecking)) {
     InitSpellCheck();
+  }
 #endif
 
   subresource_filter_ruleset_dealer_ =
@@ -469,7 +483,6 @@
   blink::WebScriptController::RegisterExtension(
       extensions_v8::LoadTimesExtension::Get());
 
-  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
   if (command_line->HasSwitch(variations::switches::kEnableBenchmarking)) {
     blink::WebScriptController::RegisterExtension(
         extensions_v8::BenchmarkingExtension::Get());
@@ -755,6 +768,7 @@
   }
 
 #if BUILDFLAG(ENABLE_SPELLCHECK)
+  if (command_line->HasSwitch(switches::kEnableSpellChecking))
   new SpellCheckProvider(render_frame, spellcheck_.get());
 
 #if BUILDFLAG(HAS_SPELLCHECK_PANEL)
@@ -1654,6 +1668,10 @@
   return false;
 }
 
+base::FilePath ChromeContentRendererClient::GetRootPath() {
+  return nw::GetRootPathRenderer();
+}
+
 void ChromeContentRendererClient::RunScriptsAtDocumentStart(
     content::RenderFrame* render_frame) {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
diff -r -u --color up/chromium/chrome/renderer/chrome_content_renderer_client.h nw/chromium/chrome/renderer/chrome_content_renderer_client.h
--- up/chromium/chrome/renderer/chrome_content_renderer_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/renderer/chrome_content_renderer_client.h	2024-08-26 19:32:19.910587534 +0000
@@ -96,6 +96,13 @@
 
   ~ChromeContentRendererClient() override;
 
+  base::FilePath GetRootPath() override;
+  void willHandleNavigationPolicy(content::RenderFrame* rv,
+                                  blink::WebFrame* frame,
+                                  const blink::WebURLRequest& request,
+                                  blink::WebNavigationPolicy* policy,
+                                  blink::WebString* manifest,
+                                  bool new_win) override;
   void RenderThreadStarted() override;
   void ExposeInterfacesToBrowser(mojo::BinderMap* binders) override;
   void RenderFrameCreated(content::RenderFrame* render_frame) override;
diff -r -u --color up/chromium/chrome/renderer/chrome_content_settings_agent_delegate.cc nw/chromium/chrome/renderer/chrome_content_settings_agent_delegate.cc
--- up/chromium/chrome/renderer/chrome_content_settings_agent_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/renderer/chrome_content_settings_agent_delegate.cc	2024-08-26 19:32:19.910587534 +0000
@@ -140,8 +140,10 @@
 }
 
 std::optional<bool> ChromeContentSettingsAgentDelegate::AllowMutationEvents() {
+#if 0
   if (IsPlatformApp())
     return false;
+#endif
   return std::nullopt;
 }
 
diff -r -u --color up/chromium/chrome/renderer/chrome_render_frame_observer.cc nw/chromium/chrome/renderer/chrome_render_frame_observer.cc
--- up/chromium/chrome/renderer/chrome_render_frame_observer.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/renderer/chrome_render_frame_observer.cc	2024-08-26 19:32:19.910587534 +0000
@@ -200,8 +200,10 @@
 #if !BUILDFLAG(IS_ANDROID)
   SetVisualQueryClassifierAgent();
 #endif
+#if 0
   translate_agent_ =
       new translate::TranslateAgent(render_frame, ISOLATED_WORLD_ID_TRANSLATE);
+#endif
 }
 
 ChromeRenderFrameObserver::~ChromeRenderFrameObserver() = default;
@@ -238,16 +240,19 @@
   // Let translate_agent do any preparatory work for loading a URL.
   if (!translate_agent_)
     return;
-
+#if 0
   translate_agent_->PrepareForUrl(
       render_frame()->GetWebFrame()->GetDocument().Url());
+#endif
 }
 
 void ChromeRenderFrameObserver::DidSetPageLifecycleState(
     bool restoring_from_bfcache) {
+#if 0
   if (restoring_from_bfcache && translate_agent_) {
     translate_agent_->RenewPageRegistration();
   }
+#endif
 }
 
 void ChromeRenderFrameObserver::DidFinishLoad() {
@@ -613,7 +618,7 @@
 }
 
 void ChromeRenderFrameObserver::SetClientSidePhishingDetection() {
-#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
+#if 0 //BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   phishing_classifier_ = safe_browsing::PhishingClassifierDelegate::Create(
       render_frame(), nullptr);
   phishing_image_embedder_ =
@@ -637,6 +642,7 @@
 
 bool ChromeRenderFrameObserver::ShouldCapturePageTextForTranslateOrPhishing(
     blink::WebMeaningfulLayout layout_type) const {
+  return false;
   WebLocalFrame* frame = render_frame()->GetWebFrame();
   if (!frame) {
     return false;
@@ -721,12 +727,14 @@
             .Utf16());
   }
 
+#if 0
   // Language detection should run only once. Parsing finishes before the page
   // loads, so attempt detection here first.
   if (translate_agent_ &&
       (layout_type == blink::WebMeaningfulLayout::kFinishedParsing)) {
     translate_agent_->PageCaptured(contents);
   }
+#endif
 
   if (text_callback) {
     std::move(text_callback).Run(contents);
diff -r -u --color up/chromium/chrome/renderer/chrome_render_frame_observer.h nw/chromium/chrome/renderer/chrome_render_frame_observer.h
--- up/chromium/chrome/renderer/chrome_render_frame_observer.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/renderer/chrome_render_frame_observer.h	2024-08-26 19:32:19.910587534 +0000
@@ -5,6 +5,7 @@
 #ifndef CHROME_RENDERER_CHROME_RENDER_FRAME_OBSERVER_H_
 #define CHROME_RENDERER_CHROME_RENDER_FRAME_OBSERVER_H_
 
+#pragma clang diagnostic ignored "-Wunused-private-field"
 #include <string>
 #include <vector>
 
diff -r -u --color up/chromium/chrome/renderer/extensions/chrome_extensions_renderer_client.cc nw/chromium/chrome/renderer/extensions/chrome_extensions_renderer_client.cc
--- up/chromium/chrome/renderer/extensions/chrome_extensions_renderer_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/renderer/extensions/chrome_extensions_renderer_client.cc	2024-08-26 19:32:19.914587537 +0000
@@ -8,6 +8,8 @@
 #include <optional>
 #include <utility>
 
+#include "content/nw/src/nw_content.h"
+
 #include "base/command_line.h"
 #include "base/functional/bind.h"
 #include "base/lazy_instance.h"
@@ -113,6 +115,7 @@
   if (!extension_dispatcher_) {
     extension_dispatcher_ = std::make_unique<extensions::Dispatcher>(
         std::move(api_providers_));
+    nw::ExtensionDispatcherCreated(extension_dispatcher_.get());
   }
   extension_dispatcher_->OnRenderThreadStarted(thread);
   permissions_policy_delegate_ =
diff -r -u --color up/chromium/chrome/renderer/extensions/resource_request_policy.cc nw/chromium/chrome/renderer/extensions/resource_request_policy.cc
--- up/chromium/chrome/renderer/extensions/resource_request_policy.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/renderer/extensions/resource_request_policy.cc	2024-08-26 19:32:19.914587537 +0000
@@ -108,7 +108,10 @@
   // resources:
 
   // Empty urls (needed for some edge cases when we have empty urls).
-  if (frame_url.is_empty())
+  // NWJS: about:blank here when load iframe in document-start-end
+  // case starting from cr53
+    bool is_empty_origin = frame_url.is_empty() || frame_url == GURL(url::kAboutBlankURL);
+  if (is_empty_origin)
     return true;
 
   // Extensions requesting their own resources (frame_url check is for images,
diff -r -u --color up/chromium/chrome/renderer/url_loader_throttle_provider_impl.cc nw/chromium/chrome/renderer/url_loader_throttle_provider_impl.cc
--- up/chromium/chrome/renderer/url_loader_throttle_provider_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/renderer/url_loader_throttle_provider_impl.cc	2024-08-26 19:32:19.922587541 +0000
@@ -171,6 +171,7 @@
   DCHECK(!is_frame_resource ||
          type_ == blink::URLLoaderThrottleProviderType::kFrame);
 
+#if 0
   if (!is_frame_resource) {
     if (pending_safe_browsing_) {
       safe_browsing_.Bind(std::move(pending_safe_browsing_));
@@ -191,6 +192,7 @@
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
     throttles.emplace_back(std::move(throttle));
   }
+#endif
 
   if (type_ == blink::URLLoaderThrottleProviderType::kFrame &&
       !is_frame_resource && local_frame_token.has_value()) {
diff -r -u --color up/chromium/chrome/test/BUILD.gn nw/chromium/chrome/test/BUILD.gn
--- up/chromium/chrome/test/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/BUILD.gn	2024-08-26 19:32:19.954587558 +0000
@@ -176,8 +176,8 @@
     "../browser/profiles/keep_alive/profile_keep_alive_waiter.h",
     "../browser/profiles/profile_test_util.cc",
     "../browser/profiles/profile_test_util.h",
-    "../browser/safe_browsing/test_safe_browsing_database_helper.cc",
-    "../browser/safe_browsing/test_safe_browsing_database_helper.h",
+    #"../browser/safe_browsing/test_safe_browsing_database_helper.cc",
+    #"../browser/safe_browsing/test_safe_browsing_database_helper.h",
     "../browser/search_engines/template_url_service_factory_test_util.cc",
     "../browser/search_engines/template_url_service_factory_test_util.h",
     "../browser/search_engines/template_url_service_test_util.cc",
@@ -190,8 +190,8 @@
     "../browser/signin/identity_test_environment_profile_adaptor.h",
     "../browser/signin/test_signin_client_builder.cc",
     "../browser/signin/test_signin_client_builder.h",
-    "../browser/subresource_filter/subresource_filter_browser_test_harness.cc",
-    "../browser/subresource_filter/subresource_filter_browser_test_harness.h",
+    #"../browser/subresource_filter/subresource_filter_browser_test_harness.cc",
+    #"../browser/subresource_filter/subresource_filter_browser_test_harness.h",
     "../browser/tpcd/experiment/mock_experiment_manager.cc",
     "../browser/tpcd/experiment/mock_experiment_manager.h",
     "../browser/tpcd/support/trial_test_utils.cc",
@@ -377,9 +377,9 @@
     "//components/reporting/storage:test_support",
     "//components/reporting/util:status_macros",
     "//components/reporting/util:test_callbacks_support",
-    "//components/safe_browsing/content/renderer/phishing_classifier:unit_tests_support",
-    "//components/safe_browsing/core/browser/db:v4_database",
-    "//components/safe_browsing/core/common",
+    #"//components/safe_browsing/content/renderer/phishing_classifier:unit_tests_support",
+    #"//components/safe_browsing/core/browser/db:v4_database",
+    #"//components/safe_browsing/core/common",
     "//components/security_interstitials/content:security_interstitial_page",
     "//components/security_interstitials/core:unsafe_resource",
     "//components/segmentation_platform/public",
@@ -404,7 +404,7 @@
     "//chrome:strings",
     "//chrome/browser:browser_process",
     "//chrome/browser:test_support",
-    "//chrome/browser/safe_browsing",
+    #"//chrome/browser/safe_browsing",
     "//chrome/browser/supervised_user:test_support",
     "//chrome/child",
     "//chrome/common:non_code_constants",
@@ -448,7 +448,7 @@
     "//components/policy/core/browser",
     "//components/policy/core/common:test_support",
     "//components/prefs:test_support",
-    "//components/privacy_sandbox:test_support",
+    #"//components/privacy_sandbox:test_support",
     "//components/profile_metrics",
     "//components/safe_browsing/core/browser/db:database_manager",
     "//components/safe_browsing/core/browser/db:v4_test_util",
@@ -701,8 +701,8 @@
       "../browser/ui/views/performance_controls/test_support/memory_saver_unit_test_mixin.h",
       "../browser/ui/webui/identity_internals_ui_browsertest.cc",
       "../browser/ui/webui/identity_internals_ui_browsertest.h",
-      "../browser/ui/webui/net_internals/net_internals_ui_browsertest.cc",
-      "../browser/ui/webui/net_internals/net_internals_ui_browsertest.h",
+      #"../browser/ui/webui/net_internals/net_internals_ui_browsertest.cc",
+      #"../browser/ui/webui/net_internals/net_internals_ui_browsertest.h",
       "../browser/ui/webui/test_support/webui_interactive_test_mixin.h",
       "../browser/webapps/installable/ml_promotion_browsertest_base.cc",
       "../browser/webapps/installable/ml_promotion_browsertest_base.h",
@@ -1329,7 +1329,7 @@
       "//chrome/android:delegate_public_impl_java",
       "//chrome/browser/autofill",
       "//chrome/browser/browsing_data:constants",
-      "//chrome/browser/dips:browser_tests",
+      #"//chrome/browser/dips:browser_tests",
       "//chrome/browser/flags:flags_android",
       "//chrome/browser/ip_protection:browser_tests",
       "//chrome/browser/metrics:test_support",
@@ -1364,7 +1364,7 @@
       "//components/page_content_annotations/core",
       "//components/page_load_metrics/browser:test_support",
       "//components/page_load_metrics/browser/observers/ad_metrics:test_support",
-      "//components/privacy_sandbox:privacy_sandbox",
+      #"//components/privacy_sandbox:privacy_sandbox",
       "//components/privacy_sandbox:privacy_sandbox_prefs",
       "//components/privacy_sandbox:tracking_protection_onboarding",
       "//components/privacy_sandbox:tracking_protection_prefs",
@@ -1787,7 +1787,7 @@
       "//chrome/browser/companion/visual_query:visual_query",
       "//chrome/browser/devtools",
       "//chrome/browser/devtools:test_support",
-      "//chrome/browser/dips:browser_tests",
+      #"//chrome/browser/dips:browser_tests",
       "//chrome/browser/favicon",
       "//chrome/browser/first_party_sets",
       "//chrome/browser/headless:browser_tests",
@@ -1840,12 +1840,12 @@
       "//chrome/browser/ui/views/bubble",
       "//chrome/browser/ui/views/side_panel",
       "//chrome/browser/ui/views/side_panel:side_panel_enums",
-      "//chrome/browser/ui/web_applications:browser_tests",
+      #"//chrome/browser/ui/web_applications:browser_tests",
       "//chrome/browser/ui/webui",
-      "//chrome/browser/ui/webui/privacy_sandbox:mojo_bindings",
+      #"//chrome/browser/ui/webui/privacy_sandbox:mojo_bindings",
       "//chrome/browser/ui/webui/top_chrome",
-      "//chrome/browser/web_applications:browser_tests",
-      "//chrome/browser/web_applications:prevent_close_test_support",
+      #"//chrome/browser/web_applications:browser_tests",
+      #"//chrome/browser/web_applications:prevent_close_test_support",
       "//chrome/browser/web_applications:web_applications_test_support",
       "//chrome/browser/web_applications/extensions",
       "//chrome/browser/webaudio:browser_tests",
@@ -1856,7 +1856,7 @@
       "//chrome/renderer",
       "//chrome/renderer/companion/visual_query:browser_tests",
       "//chrome/services/removable_storage_writer:lib",
-      "//chrome/test/data/webui:resources_grit",
+      #"//chrome/test/data/webui:resources_grit",
       "//chrome/test/data/webui/mojo:mojo_bindings",
       "//chrome/test/media_router/access_code_cast:access_code_cast_integration_base",
       "//chrome/test/payments:test_support",
@@ -2032,7 +2032,7 @@
       "//components/safe_browsing/content/common:interfaces_shared_cpp_sources",
       "//components/safe_browsing/content/renderer",
       "//components/safe_browsing/content/renderer/phishing_classifier",
-      "//components/safe_browsing/content/renderer/phishing_classifier:unit_tests_support",
+      #"//components/safe_browsing/content/renderer/phishing_classifier:unit_tests_support",
       "//components/safe_browsing/core/browser:verdict_cache_manager",
       "//components/safe_browsing/core/browser/db:metadata_proto",
       "//components/safe_browsing/core/browser/db:test_database_manager",
@@ -2134,7 +2134,7 @@
       "//content/test:test_support",
       "//crypto:test_support",
       "//device/bluetooth:mocks",
-      "//device/fido:cablev2_test_util",
+      #"//device/fido:cablev2_test_util",
       "//device/fido:test_support",
       "//google_apis:test_support",
       "//media:media_buildflags",
@@ -3256,9 +3256,9 @@
       ]
 
       deps += [
-        "//chrome/browser/apps/link_capturing:app_service_browser_tests",
-        "//chrome/browser/ui/web_applications:app_service_browser_tests",
-        "//chrome/browser/web_applications:app_service_browser_tests",
+        #"//chrome/browser/apps/link_capturing:app_service_browser_tests",
+        #"//chrome/browser/ui/web_applications:app_service_browser_tests",
+        #"//chrome/browser/web_applications:app_service_browser_tests",
         "//components/live_caption:live_translate",
       ]
       if (!is_win || target_cpu != "arm64") {
@@ -4277,7 +4277,7 @@
         # TODO(rockot) bug 505926: The chrome_extensions_browsertests_sources
         # target should be deleted and this line removed. See the
         # chrome_extensions_browsertests_sources target for more.
-        "//extensions:chrome_extensions_browsertests_sources",
+        #"//extensions:chrome_extensions_browsertests_sources",
         "//extensions/browser:test_support",
         "//extensions/browser/api/storage:settings_namespace",
         "//extensions/browser/updater",
@@ -5433,6 +5433,25 @@
           [ "../browser/ui/webui/whats_new/whats_new_fetcher_browsertest.cc" ]
       deps += [ "//chrome/browser/ui/webui/whats_new:mojo_bindings" ]
     }
+
+    sources = []
+    sources = [ 
+      "../../content/nw/src/nwjs_browsertest.cc",
+      "../browser/ui/test/test_browser_dialog.cc",
+      "../browser/ui/test/test_browser_dialog.h",
+      "../browser/ui/test/test_browser_ui.cc",
+      "../browser/ui/test/test_browser_ui.h",
+      "../browser/extensions/extension_apitest.cc",
+      "../browser/extensions/extension_browsertest.cc",
+      "../browser/apps/platform_apps/app_browsertest_util.cc",
+      "../browser/apps/platform_apps/app_browsertest_util.h",
+      "../browser/pdf/pdf_extension_test.cc",
+      "../browser/pdf/pdf_extension_test_base.cc",
+      "../browser/renderer_context_menu/render_view_context_menu_browsertest_util.cc",
+      "../browser/renderer_context_menu/render_view_context_menu_browsertest_util.h",
+      "../browser/extensions/browsertest_util.cc",
+      "../browser/extensions/browsertest_util.h",
+    ]
   }
 }
 
@@ -5633,9 +5652,9 @@
       "//chrome/browser/sync",
       "//chrome/browser/themes",
       "//chrome/browser/ui:browser_element_identifiers",
-      "//chrome/browser/ui/web_applications:app_service_browser_tests",
-      "//chrome/browser/web_applications:app_service_browser_tests",
-      "//chrome/browser/web_applications:prevent_close_test_support",
+      #"//chrome/browser/ui/web_applications:app_service_browser_tests",
+      #"//chrome/browser/web_applications:app_service_browser_tests",
+      #"//chrome/browser/web_applications:prevent_close_test_support",
       "//chrome/browser/web_applications:web_applications_test_support",
       "//chrome/browser/web_applications/app_service:test_support",
       "//chrome/test/media_router/access_code_cast:access_code_cast_integration_base",
@@ -6705,7 +6724,7 @@
     "//chrome/browser/browsing_data:constants",
     "//chrome/browser/crash_upload_list:unit_tests",
     "//chrome/browser/devtools",
-    "//chrome/browser/dips:unit_tests",
+    #"//chrome/browser/dips:unit_tests",
     "//chrome/browser/favicon",
     "//chrome/browser/fingerprinting_protection",
     "//chrome/browser/first_party_sets",
@@ -10589,12 +10608,12 @@
       "../browser/ui/views/side_panel/side_panel_test_utils.h",
       "../browser/ui/views/tabs/tab_hover_card_test_util.cc",
       "../browser/ui/views/tabs/tab_hover_card_test_util.h",
-      "../browser/ui/views/web_apps/web_app_integration_test_driver.cc",
-      "../browser/ui/views/web_apps/web_app_integration_test_driver.h",
-      "../browser/ui/views/web_apps/web_app_link_capturing_test_utils.cc",
-      "../browser/ui/views/web_apps/web_app_link_capturing_test_utils.h",
-      "../browser/ui/web_applications/test/web_app_navigation_browsertest.cc",
-      "../browser/ui/web_applications/test/web_app_navigation_browsertest.h",
+      #"../browser/ui/views/web_apps/web_app_integration_test_driver.cc",
+      #"../browser/ui/views/web_apps/web_app_integration_test_driver.h",
+      #"../browser/ui/views/web_apps/web_app_link_capturing_test_utils.cc",
+      #"../browser/ui/views/web_apps/web_app_link_capturing_test_utils.h",
+      #"../browser/ui/web_applications/test/web_app_navigation_browsertest.cc",
+      #"../browser/ui/web_applications/test/web_app_navigation_browsertest.h",
       "../browser/ui/webui/signin/login_ui_test_utils.cc",
       "../browser/ui/webui/signin/login_ui_test_utils.h",
       "../browser/web_applications/test/profile_test_helper.cc",
@@ -10696,8 +10715,8 @@
       "//chrome/common:non_code_constants",
       "//chrome/common/profiler",
       "//chrome/renderer",
-      "//chrome/test/data/webui:resources",
-      "//chrome/test/data/webui/mojo:mojo_bindings",
+      #"//chrome/test/data/webui:resources",
+      #"//chrome/test/data/webui/mojo:mojo_bindings",
       "//components/account_id",
       "//components/autofill/content/browser",
       "//components/autofill/content/browser:test_support",
diff -r -u --color up/chromium/chrome/test/base/test_browser_window.cc nw/chromium/chrome/test/base/test_browser_window.cc
--- up/chromium/chrome/test/base/test_browser_window.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/base/test_browser_window.cc	2024-08-26 19:32:19.978587571 +0000
@@ -69,6 +69,13 @@
 
 TestBrowserWindow::TestBrowserWindow() = default;
 
+void TestBrowserWindow::UpdateDraggableRegions(
+    const std::vector<blink::mojom::DraggableRegionPtr>& regions) {
+}
+SkRegion* TestBrowserWindow::GetDraggableRegion() {
+  return nullptr;
+}
+
 TestBrowserWindow::~TestBrowserWindow() = default;
 
 void TestBrowserWindow::Close() {
diff -r -u --color up/chromium/chrome/test/base/test_browser_window.h nw/chromium/chrome/test/base/test_browser_window.h
--- up/chromium/chrome/test/base/test_browser_window.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/base/test_browser_window.h	2024-08-26 19:32:19.978587571 +0000
@@ -60,7 +60,16 @@
   TestBrowserWindow& operator=(const TestBrowserWindow&) = delete;
   ~TestBrowserWindow() override;
 
+  void SetShowInTaskbar(bool) override {}
+  void SetResizable(bool) override {}
+  void SetAllVisible(bool) override {}
+  void SetMinimumSize(gfx::Size) override {}
+  void SetMaximumSize(gfx::Size) override {}
+  void NativeWindowChanged() override {}
   // BrowserWindow:
+  void UpdateDraggableRegions(
+	      const std::vector<blink::mojom::DraggableRegionPtr>& regions) override;
+  SkRegion* GetDraggableRegion() override;
   void Show() override {}
   void ShowInactive() override {}
   void Hide() override {}
diff -r -u --color up/chromium/chrome/test/base/test_browser_window_aura.cc nw/chromium/chrome/test/base/test_browser_window_aura.cc
--- up/chromium/chrome/test/base/test_browser_window_aura.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/base/test_browser_window_aura.cc	2024-08-26 19:32:19.978587571 +0000
@@ -55,6 +55,14 @@
   return native_window_.get();
 }
 
+void TestBrowserWindowAura::UpdateDraggableRegions(
+   const std::vector<blink::mojom::DraggableRegionPtr>& regions) {
+}
+
+SkRegion* TestBrowserWindowAura::GetDraggableRegion() {
+  return nullptr;
+}
+
 void TestBrowserWindowAura::Show() {
   native_window_->Show();
 }
diff -r -u --color up/chromium/chrome/test/base/test_browser_window_aura.h nw/chromium/chrome/test/base/test_browser_window_aura.h
--- up/chromium/chrome/test/base/test_browser_window_aura.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/base/test_browser_window_aura.h	2024-08-26 19:32:19.978587571 +0000
@@ -27,6 +27,9 @@
   ~TestBrowserWindowAura() override;
 
   // TestBrowserWindow overrides:
+  void UpdateDraggableRegions(
+      const std::vector<blink::mojom::DraggableRegionPtr>& regions) override;
+  SkRegion* GetDraggableRegion() override;
   gfx::NativeWindow GetNativeWindow() const override;
   void Show() override;
   void Hide() override;
diff -r -u --color up/chromium/chrome/test/base/testing_browser_process.h nw/chromium/chrome/test/base/testing_browser_process.h
--- up/chromium/chrome/test/base/testing_browser_process.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/base/testing_browser_process.h	2024-08-26 19:32:19.978587571 +0000
@@ -149,6 +149,7 @@
   void StartAutoupdateTimer() override {}
 #endif
 
+
   component_updater::ComponentUpdateService* component_updater() override;
   MediaFileSystemRegistry* media_file_system_registry() override;
 
diff -r -u --color up/chromium/chrome/test/chromedriver/capabilities.cc nw/chromium/chrome/test/chromedriver/capabilities.cc
--- up/chromium/chrome/test/chromedriver/capabilities.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/capabilities.cc	2024-08-26 19:32:19.982587574 +0000
@@ -556,6 +556,20 @@
   return Status(kOk);
 }
 
+Status ParseArguments(const base::Value& option,
+                     Capabilities* capabilities) {
+  if (!option.is_list())
+    return Status(kUnknownError, "must be a list");
+  for (auto& val: option.GetList()) {
+    std::string arg_string;
+    if (!val.is_string())
+      return Status(kUnknownError, "each argument must be a string");
+    arg_string = val.GetString();
+    capabilities->arguments.push_back(arg_string);
+  }
+  return Status(kOk);
+}
+
 Status ParseExtensions(const base::Value& option, Capabilities* capabilities) {
   if (!option.is_list())
     return Status(kInvalidArgument, "must be a list");
@@ -873,6 +887,7 @@
         base::BindRepeating(&ParseNetAddress, &capabilities->debugger_address);
   } else {
     parser_map["args"] = base::BindRepeating(&ParseSwitches);
+    parser_map["nwargs"] = base::BindRepeating(&ParseArguments);
     parser_map["binary"] =
         base::BindRepeating(&ParseFilePath, &capabilities->binary);
     parser_map["detach"] =
diff -r -u --color up/chromium/chrome/test/chromedriver/capabilities.h nw/chromium/chrome/test/chromedriver/capabilities.h
--- up/chromium/chrome/test/chromedriver/capabilities.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/capabilities.h	2024-08-26 19:32:19.982587574 +0000
@@ -172,6 +172,7 @@
   // Time to wait for extension background page to appear. If 0, no waiting.
   base::TimeDelta extension_load_timeout;
 
+  std::vector<std::string> arguments;
   std::unique_ptr<base::Value::Dict> local_state;
 
   std::string log_path;
diff -r -u --color up/chromium/chrome/test/chromedriver/chrome/chrome_finder.cc nw/chromium/chrome/test/chromedriver/chrome/chrome_finder.cc
--- up/chromium/chrome/test/chromedriver/chrome/chrome_finder.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/chrome/chrome_finder.cc	2024-08-26 19:32:19.982587574 +0000
@@ -31,7 +31,7 @@
 
 namespace {
 
-#if BUILDFLAG(IS_WIN)
+#if 0
 void GetApplicationDirs(std::vector<base::FilePath>* locations) {
   std::vector<base::FilePath> installation_locations;
   base::FilePath local_app_data, program_files, program_files_x86,
@@ -58,7 +58,7 @@
         installation_locations[i].Append(L"Chromium\\Application"));
   }
 }
-#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#elif 0
 void GetApplicationDirs(std::vector<base::FilePath>* locations) {
   // TODO: Respect users' PATH variables.
   // Until then, we use an approximation of the most common defaults.
@@ -117,8 +117,8 @@
 #if BUILDFLAG(IS_WIN)
     base::FilePath(chrome::kBrowserProcessExecutablePath),
         base::FilePath(FILE_PATH_LITERAL(
-            "chrome.exe")),  // Chrome for Testing or Google Chrome
-        base::FilePath(FILE_PATH_LITERAL("chromium.exe")),
+            "nw.exe")),  // Chrome for Testing or Google Chrome
+        base::FilePath(FILE_PATH_LITERAL("nw.exe")),
 #elif BUILDFLAG(IS_MAC)
     base::FilePath(chrome::kBrowserProcessExecutablePath),
         base::FilePath(
@@ -127,9 +127,7 @@
         base::FilePath(chrome::kChromiumBrowserProcessExecutablePath),
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
     base::FilePath(chrome::kBrowserProcessExecutablePath),
-        base::FilePath("chrome"),  // Chrome for Testing or Google Chrome
-        base::FilePath("google-chrome"), base::FilePath("chromium"),
-        base::FilePath("chromium-browser"),
+        base::FilePath("nw"),  // Chrome for Testing or Google Chrome
 #else
     // it will compile but won't work on other OSes
     base::FilePath()
@@ -175,7 +173,7 @@
 
 }  // namespace internal
 
-#if BUILDFLAG(IS_MAC)
+#if 0
 void GetApplicationDirs(std::vector<base::FilePath>* locations);
 #endif
 
@@ -233,8 +231,10 @@
   }
 
   std::vector<base::FilePath> locations;
-  GetApplicationDirs(&locations);
   GetPathsFromEnvironment(&locations);
+  base::FilePath exe_path;
+  base::PathService::Get(base::DIR_EXE, &exe_path);
+  locations.push_back(exe_path);
   bool found =
       internal::FindExe(exists_func, browser_exes, locations, browser_exe);
   if (!found) {
diff -r -u --color up/chromium/chrome/test/chromedriver/chrome/chrome_impl.cc nw/chromium/chrome/test/chromedriver/chrome/chrome_impl.cc
--- up/chromium/chrome/test/chromedriver/chrome/chrome_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/chrome/chrome_impl.cc	2024-08-26 19:32:19.982587574 +0000
@@ -18,6 +18,7 @@
 #include "base/values.h"
 #include "chrome/test/chromedriver/chrome/browser_info.h"
 #include "chrome/test/chromedriver/chrome/chrome.h"
+#include "base/strings/string_util.h"
 #include "chrome/test/chromedriver/chrome/devtools_client.h"
 #include "chrome/test/chromedriver/chrome/devtools_client_impl.h"
 #include "chrome/test/chromedriver/chrome/devtools_event_listener.h"
@@ -105,13 +106,25 @@
   } while (status.code() == kTargetDetached);
   if (status.IsError())
     return status;
+  std::string ret;
   for (int i = views_info.GetSize() - 1; i >= 0; --i) {
     const WebViewInfo& view = views_info.Get(i);
-    if (view.type == WebViewInfo::kPage) {
-      *web_view_id = view.id;
-      return Status(kOk);
+    if (view.type == WebViewInfo::kPage ||
+        view.type == WebViewInfo::kApp ||
+        (view.type == WebViewInfo::kOther &&
+         !base::StartsWith(view.url, "chrome-extension://", base::CompareCase::SENSITIVE) &&
+         !base::StartsWith(view.url, "about:blank", base::CompareCase::SENSITIVE))) {
+      ret = view.id;
+      if (view.type != WebViewInfo::kOther) {
+        *web_view_id = view.id;
+        return Status(kOk);
+      }
     }
   }
+  if (!ret.empty()) {
+    *web_view_id = ret;
+    return Status(kOk);
+  }
   return Status(kUnknownError, "unable to discover open window in chrome");
 }
 
@@ -150,7 +163,17 @@
 }
 
 bool ChromeImpl::IsBrowserWindow(const WebViewInfo& view) const {
-  return base::Contains(window_types_, view.type);
+  return base::Contains(window_types_, view.type) ||
+         (view.type == WebViewInfo::kOther &&
+          (view.url == "" || view.url == "about:blank" ||
+           //          base::StartsWith(view.url, "chrome-extension://",
+           //                 base::CompareCase::SENSITIVE) ||
+           base::StartsWith(view.url, "file://",
+                            base::CompareCase::SENSITIVE) ||
+           base::StartsWith(view.url, "http://",
+                            base::CompareCase::SENSITIVE) ||
+           base::StartsWith(view.url, "https://",
+                            base::CompareCase::SENSITIVE)));
 }
 
 Status ChromeImpl::UpdateWebViews(const WebViewsInfo& views_info,
diff -r -u --color up/chromium/chrome/test/chromedriver/chrome/console_logger.cc nw/chromium/chrome/test/chromedriver/chrome/console_logger.cc
--- up/chromium/chrome/test/chromedriver/chrome/console_logger.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/chrome/console_logger.cc	2024-08-26 19:32:19.982587574 +0000
@@ -120,11 +120,11 @@
       if (!url->empty())
         origin = *url;
       int line = call_frame->FindInt("lineNumber").value_or(-1);
-      if (line < 0)
-        return Status(kUnknownError, "missing or invalid lineNumber");
+      //if (line < 0)
+      //  return Status(kUnknownError, "missing or invalid lineNumber");
       int column = call_frame->FindInt("columnNumber").value_or(-1);
-      if (column < 0)
-        return Status(kUnknownError, "missing or invalid columnNumber");
+      //if (column < 0)
+      //  return Status(kUnknownError, "missing or invalid columnNumber");
       line_column = base::StringPrintf("%d:%d", line, column);
     }
   }
diff -r -u --color up/chromium/chrome/test/chromedriver/chrome_launcher.cc nw/chromium/chrome/test/chromedriver/chrome_launcher.cc
--- up/chromium/chrome/test/chromedriver/chrome_launcher.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/chrome_launcher.cc	2024-08-26 19:32:19.990587578 +0000
@@ -80,6 +80,8 @@
 #include "chrome/test/chromedriver/keycode_text_conversion.h"
 #endif
 
+#include "base/strings/string_number_conversions.h"
+
 namespace {
 
 const char* const kCommonSwitches[] = {
@@ -88,6 +90,7 @@
     "allow-pre-commit-input",
 };
 
+#if 0
 const char* const kDesktopSwitches[] = {
     "disable-hang-monitor",
     "disable-prompt-on-repost",
@@ -102,6 +105,7 @@
     "test-type=webdriver",
     "no-service-autorun",
 };
+#endif
 
 #if BUILDFLAG(IS_WIN)
 
@@ -217,7 +221,7 @@
       return Status(kInvalidArgument, "user data dir can not be empty");
     user_data_dir = base::FilePath(user_data_dir_value);
   } else {
-    command.AppendArg("data:,");
+    //command.AppendArg("data:,");
     if (!user_data_dir_temp_dir.CreateUniqueTempDir()) {
       return Status(kUnknownError, "cannot create temp dir for user data dir");
     }
@@ -258,6 +262,10 @@
   }
 
   switches.AppendToCommandLine(&command);
+
+  for (size_t i = 0; i < capabilities.arguments.size(); i++)
+    command.AppendArg(capabilities.arguments[i]);
+
   prepared_command = command;
   return Status(kOk);
 }
@@ -320,13 +328,21 @@
     const DevToolsEndpoint& endpoint,
     network::mojom::URLLoaderFactory* factory,
     const Capabilities& capabilities,
-    const Timeout& timeout,
+    const Timeout& timeout0,
     ChromeType ct,
     std::unique_ptr<DevToolsHttpClient>& user_client,
     bool& retry,
     std::string fp = "") {
-  std::unique_ptr<DevToolsHttpClient> client;
+  Timeout timeout(timeout0);
+  int wait_time = 0;
   base::CommandLine* cmd_line = base::CommandLine::ForCurrentProcess();
+  if (cmd_line->HasSwitch("launch-timeout")) {
+    std::string s_timeout = cmd_line->GetSwitchValueASCII("launch-timeout");
+    base::StringToInt(s_timeout, &wait_time);
+    timeout = Timeout(base::Seconds(wait_time));
+  }
+
+  std::unique_ptr<DevToolsHttpClient> client;
   if (cmd_line->HasSwitch("devtools-replay")) {
     base::CommandLine::StringType log_path =
         cmd_line->GetSwitchValueNative("devtools-replay");
@@ -364,7 +380,10 @@
     if (status.IsError())
       return status;
     for (size_t i = 0; i < views_info.GetSize(); ++i) {
-      if (views_info.Get(i).type == WebViewInfo::kPage) {
+      if (views_info.Get(i).type == WebViewInfo::kPage ||
+          views_info.Get(i).type == WebViewInfo::kApp
+          || (views_info.Get(i).type == WebViewInfo::kOther &&
+              !base::StartsWith(views_info.Get(i).url, "chrome-extension://", base::CompareCase::SENSITIVE))) { //node-remote page
         user_client = std::move(client);
         return Status(kOk);
       }
@@ -937,6 +956,7 @@
   for (auto* common_switch : kCommonSwitches) {
     switches.SetUnparsedSwitch(common_switch);
   }
+#if 0 //FIXME if enabled, chromedriver cannot find chrome on windows
   for (auto* desktop_switch : kDesktopSwitches) {
     switches.SetUnparsedSwitch(desktop_switch);
   }
@@ -945,6 +965,7 @@
     switches.SetUnparsedSwitch(win_desktop_switch);
   }
 #endif
+#endif
   return switches;
 }
 
diff -r -u --color up/chromium/chrome/test/chromedriver/element_commands.cc nw/chromium/chrome/test/chromedriver/element_commands.cc
--- up/chromium/chrome/test/chromedriver/element_commands.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/element_commands.cc	2024-08-26 19:32:19.990587578 +0000
@@ -45,54 +45,6 @@
 
 const std::set<std::string> kNontypeableControlTypes = {"color"};
 
-const std::unordered_set<std::string> kBooleanAttributes = {
-    "allowfullscreen",
-    "allowpaymentrequest",
-    "allowusermedia",
-    "async",
-    "autofocus",
-    "autoplay",
-    "checked",
-    "compact",
-    "complete",
-    "controls",
-    "declare",
-    "default",
-    "defaultchecked",
-    "defaultselected",
-    "defer",
-    "disabled",
-    "ended",
-    "formnovalidate",
-    "hidden",
-    "indeterminate",
-    "iscontenteditable",
-    "ismap",
-    "itemscope",
-    "loop",
-    "multiple",
-    "muted",
-    "nohref",
-    "nomodule",
-    "noresize",
-    "noshade",
-    "novalidate",
-    "nowrap",
-    "open",
-    "paused",
-    "playsinline",
-    "pubdate",
-    "readonly",
-    "required",
-    "reversed",
-    "scoped",
-    "seamless",
-    "seeking",
-    "selected",
-    "truespeed",
-    "typemustmatch",
-    "willvalidate"};
-
 namespace {
 
 Status FocusToElement(
@@ -1002,10 +954,11 @@
     return Status(kInvalidArgument, "missing 'name'");
 
   // In legacy mode, use old behavior for backward compatibility.
-  if (!session->w3c_compliant) {
-    return GetElementAttribute(session, web_view, element_id, *attribute_name,
+  //if (!session->w3c_compliant) {
+  return GetElementAttribute(session, web_view, element_id, *attribute_name,
                                value);
-  }
+  //}
+#if 0
 
   base::Value::List args;
   args.Append(CreateElement(element_id));
@@ -1016,6 +969,7 @@
           ? "(elem, attribute) => elem.hasAttribute(attribute) ? 'true' : null"
           : "(elem, attribute) => elem.getAttribute(attribute)",
       args, value);
+#endif
 }
 
 Status ExecuteGetElementValueOfCSSProperty(
diff -r -u --color up/chromium/chrome/test/data/webui/BUILD.gn nw/chromium/chrome/test/data/webui/BUILD.gn
--- up/chromium/chrome/test/data/webui/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/BUILD.gn	2024-08-26 19:32:20.962588105 +0000
@@ -423,15 +423,15 @@
     "optimization_guide_internals:build_grdp",
     "password_manager:build_grdp",
     "password_manager_internals:build_grdp",
-    "privacy_sandbox:build_grdp",
-    "privacy_sandbox/internals:build_grdp",
+    #"privacy_sandbox:build_grdp",
+    #"privacy_sandbox/internals:build_grdp",
     "privacy_sandbox/internals/private_state_tokens:build_grdp",
     "privacy_sandbox/internals/related_website_sets:build_grdp",
     "sandbox:build_grdp",
     "settings:build_grdp",
-    "side_panel:build_grdp",
-    "side_panel/customize_chrome:build_grdp",
-    "side_panel/read_anything:build_grdp",
+    #"side_panel:build_grdp",
+    #"side_panel/customize_chrome:build_grdp",
+    #"side_panel/read_anything:build_grdp",
     "support_tool:build_grdp",
     "sync_internals:build_grdp",
     "tab_search:build_grdp",
@@ -477,15 +477,15 @@
     "$target_gen_dir/optimization_guide_internals/resources.grdp",
     "$target_gen_dir/password_manager/resources.grdp",
     "$target_gen_dir/password_manager_internals/resources.grdp",
-    "$target_gen_dir/privacy_sandbox/internals/resources.grdp",
+    #"$target_gen_dir/privacy_sandbox/internals/resources.grdp",
+    #"$target_gen_dir/privacy_sandbox/resources.grdp",
     "$target_gen_dir/privacy_sandbox/internals/private_state_tokens/resources.grdp",
     "$target_gen_dir/privacy_sandbox/internals/related_website_sets/resources.grdp",
-    "$target_gen_dir/privacy_sandbox/resources.grdp",
     "$target_gen_dir/sandbox/resources.grdp",
     "$target_gen_dir/settings/resources.grdp",
-    "$target_gen_dir/side_panel/customize_chrome/resources.grdp",
-    "$target_gen_dir/side_panel/read_anything/resources.grdp",
-    "$target_gen_dir/side_panel/resources.grdp",
+    #"$target_gen_dir/side_panel/customize_chrome/resources.grdp",
+    #"$target_gen_dir/side_panel/read_anything/resources.grdp",
+    #"$target_gen_dir/side_panel/resources.grdp",
     "$target_gen_dir/support_tool/resources.grdp",
     "$target_gen_dir/sync_internals/resources.grdp",
     "$target_gen_dir/tab_search/resources.grdp",
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/destination_dialog_test.ts nw/chromium/chrome/test/data/webui/print_preview/destination_dialog_test.ts
--- up/chromium/chrome/test/data/webui/print_preview/destination_dialog_test.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/destination_dialog_test.ts	2024-08-26 19:32:21.054588155 +0000
@@ -121,7 +121,7 @@
         false /* pdfPrinterDisabled */, false /* saveToDriveDisabled */,
         'FooDevice' /* printerName */,
         '' /* serializedDefaultDestinationSelectionRulesStr */,
-        [makeRecentDestination(destinations[4]!)] /* recentDestinations */);
+        [makeRecentDestination(destinations[4]!)] /* recentDestinations */, false);
     await whenPrinterListReady;
     whenPrinterListReady = nativeLayer.waitForGetPrinters(1);
     // This should trigger 1 new getPrinters() call, for extension printers.
@@ -145,7 +145,7 @@
             '' /* serializedDefaultDestinationSelectionRulesStr */, [
               makeRecentDestination(destinations[4]!),
               makeRecentDestination(extensionDestinations[0]!),
-            ] /* recentDestinations */);
+            ] /* recentDestinations */, false);
         await whenAllPreloaded;
         finishSetup();
         flush();
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/destination_search_test.ts nw/chromium/chrome/test/data/webui/print_preview/destination_search_test.ts
--- up/chromium/chrome/test/data/webui/print_preview/destination_search_test.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/destination_search_test.ts	2024-08-26 19:32:21.054588155 +0000
@@ -33,7 +33,7 @@
         false /* pdfPrinterDisabled */, true /* saveToDriveDisabled */,
         'FooDevice' /* printerName */,
         '' /* serializedDefaultDestinationSelectionRulesStr */,
-        [] /* recentDestinations */);
+        [] /* recentDestinations */, false);
 
     dialog = document.createElement('print-preview-destination-dialog');
     dialog.destinationStore = destinationStore;
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/destination_store_test.ts nw/chromium/chrome/test/data/webui/print_preview/destination_store_test.ts
--- up/chromium/chrome/test/data/webui/print_preview/destination_store_test.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/destination_store_test.ts	2024-08-26 19:32:21.054588155 +0000
@@ -94,7 +94,7 @@
         initialSettings.pdfPrinterDisabled, saveToDriveDisabled,
         initialSettings.printerName,
         initialSettings.serializedDefaultDestinationSelectionRulesStr,
-        recentDestinations);
+        recentDestinations, false);
     return expectPrinterFailure ? Promise.resolve() : Promise.race([
       nativeLayer.whenCalled('getPrinterCapabilities'),
       whenCapabilitiesReady,
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/invalid_settings_test.ts nw/chromium/chrome/test/data/webui/print_preview/invalid_settings_test.ts
--- up/chromium/chrome/test/data/webui/print_preview/invalid_settings_test.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/invalid_settings_test.ts	2024-08-26 19:32:21.054588155 +0000
@@ -21,6 +21,7 @@
   let nativeLayer: NativeLayerStub;
 
   const initialSettings: NativeInitialSettings = {
+    nwPrintMode: false,
     isInKioskAutoPrintMode: false,
     isInAppKioskMode: false,
     thousandsDelimiter: ',',
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/print_preview_app_test.ts nw/chromium/chrome/test/data/webui/print_preview/print_preview_app_test.ts
--- up/chromium/chrome/test/data/webui/print_preview/print_preview_app_test.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/print_preview_app_test.ts	2024-08-26 19:32:21.058588157 +0000
@@ -23,6 +23,7 @@
   let pluginProxy: TestPluginProxy;
 
   const initialSettings: NativeInitialSettings = {
+    nwPrintMode: false,
     isInKioskAutoPrintMode: false,
     isInAppKioskMode: false,
     thousandsDelimiter: ',',
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/print_preview_test_utils.ts nw/chromium/chrome/test/data/webui/print_preview/print_preview_test_utils.ts
--- up/chromium/chrome/test/data/webui/print_preview/print_preview_test_utils.ts	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/print_preview_test_utils.ts	2024-08-26 19:32:21.058588157 +0000
@@ -16,6 +16,7 @@
     NativeInitialSettings {
   return {
     isInKioskAutoPrintMode: false,
+    nwPrintMode: false,
     isInAppKioskMode: false,
     pdfPrinterDisabled: false,
     thousandsDelimiter: ',',
diff -r -u --color up/chromium/chrome/test/include_js_tests.gni nw/chromium/chrome/test/include_js_tests.gni
--- up/chromium/chrome/test/include_js_tests.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/test/include_js_tests.gni	2024-08-26 19:32:21.106588183 +0000
@@ -1,8 +1,8 @@
 import("//build/config/sanitizers/sanitizers.gni")
 
 if (!is_android) {
-  include_js_tests = !(is_asan || is_msan || is_tsan || is_cfi)
+  include_js_tests = false #!(is_asan || is_msan || is_tsan || is_cfi)
 
   # Tests using js2gtest don't work in cross builds, https://crbug.com/1010561
-  include_js2gtest_tests = include_js_tests && !(is_win && host_os != "win")
+  include_js2gtest_tests = false #include_js_tests && !(is_win && host_os != "win")
 }
diff -r -u --color up/chromium/chrome/utility/BUILD.gn nw/chromium/chrome/utility/BUILD.gn
--- up/chromium/chrome/utility/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/utility/BUILD.gn	2024-08-26 19:32:21.194588231 +0000
@@ -47,7 +47,7 @@
     "//components/password_manager/services/csv_password:lib",
     "//components/safe_browsing:buildflags",
     "//components/search_engines",
-    "//components/services/language_detection",
+    #"//components/services/language_detection",
     "//components/services/paint_preview_compositor",
     "//components/services/patch:lib",
     "//components/services/unzip:lib",
diff -r -u --color up/chromium/chrome/utility/services.cc nw/chromium/chrome/utility/services.cc
--- up/chromium/chrome/utility/services.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/chrome/utility/services.cc	2024-08-26 19:32:21.202588235 +0000
@@ -156,12 +156,14 @@
   return std::make_unique<unzip::UnzipperImpl>(std::move(receiver));
 }
 
+#if 0
 auto RunLanguageDetectionService(
     mojo::PendingReceiver<language_detection::mojom::LanguageDetectionService>
         receiver) {
   return std::make_unique<language_detection::LanguageDetectionServiceImpl>(
       std::move(receiver));
 }
+#endif
 
 auto RunWebAppOriginAssociationParser(
     mojo::PendingReceiver<webapps::mojom::WebAppOriginAssociationParser>
@@ -456,7 +458,7 @@
 void RegisterMainThreadServices(mojo::ServiceFactory& services) {
   services.Add(RunFilePatcher);
   services.Add(RunUnzipper);
-  services.Add(RunLanguageDetectionService);
+  //services.Add(RunLanguageDetectionService);
   services.Add(RunWebAppOriginAssociationParser);
   services.Add(RunCSVPasswordParser);
 
diff -r -u --color up/chromium/components/about_ui/resources/about_credits.css nw/chromium/components/about_ui/resources/about_credits.css
--- up/chromium/components/about_ui/resources/about_credits.css	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/about_ui/resources/about_credits.css	2024-08-26 19:32:21.766588541 +0000
@@ -80,7 +80,6 @@
 .license {
   border-radius: 3px;
   clear: both;
-  display: none;
   padding: 16px;
 }
 .license h3 {
diff -r -u --color up/chromium/components/autofill/core/browser/data_model/phone_number.cc nw/chromium/components/autofill/core/browser/data_model/phone_number.cc
--- up/chromium/components/autofill/core/browser/data_model/phone_number.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/autofill/core/browser/data_model/phone_number.cc	2024-08-26 19:32:21.838588547 +0000
@@ -7,6 +7,7 @@
 #include <limits.h>
 
 #include <algorithm>
+#include <cctype>
 
 #include "base/check_op.h"
 #include "base/feature_list.h"
diff -r -u --color up/chromium/components/component_updater/component_updater_service.h nw/chromium/components/component_updater/component_updater_service.h
--- up/chromium/components/component_updater/component_updater_service.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/component_updater/component_updater_service.h	2024-08-26 19:32:22.110588508 +0000
@@ -28,6 +28,10 @@
 class SmartDimComponentIntegrationTest;
 }
 
+namespace extensions {
+class NwAppUpdateComponentFunction;
+}
+
 namespace policy {
 class ComponentUpdaterPolicyTest;
 }
@@ -222,6 +226,7 @@
   virtual ~OnDemandUpdater() = default;
 
  private:
+  friend class extensions::NwAppUpdateComponentFunction;
   friend class OnDemandTester;
   friend class policy::ComponentUpdaterPolicyTest;
   friend class ::ComponentsHandler;
diff -r -u --color up/chromium/components/content_settings/core/browser/content_settings_registry.cc nw/chromium/components/content_settings/core/browser/content_settings_registry.cc
--- up/chromium/components/content_settings/core/browser/content_settings_registry.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/content_settings/core/browser/content_settings_registry.cc	2024-08-26 19:32:22.126588506 +0000
@@ -150,7 +150,7 @@
            ContentSettingsInfo::EXCEPTIONS_ON_SECURE_ORIGINS_ONLY);
 
   Register(ContentSettingsType::NOTIFICATIONS, "notifications",
-           CONTENT_SETTING_ASK, WebsiteSettingsInfo::UNSYNCABLE,
+           CONTENT_SETTING_ALLOW, WebsiteSettingsInfo::UNSYNCABLE,
            /*allowlisted_primary_schemes=*/{},
            /*valid_settings=*/
            {CONTENT_SETTING_ALLOW, CONTENT_SETTING_BLOCK, CONTENT_SETTING_ASK},
diff -r -u --color up/chromium/components/cookie_config/cookie_store_util.h nw/chromium/components/cookie_config/cookie_store_util.h
--- up/chromium/components/cookie_config/cookie_store_util.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/cookie_config/cookie_store_util.h	2024-08-26 19:32:22.134588505 +0000
@@ -15,6 +15,7 @@
 // this platform.
 std::unique_ptr<net::CookieCryptoDelegate> GetCookieCryptoDelegate();
 
+void SetEnableCookieCrypto(bool enable);
 }  // namespace cookie_config
 
 #endif  // COMPONENTS_COOKIE_CONFIG_COOKIE_STORE_UTIL_H_
diff -r -u --color up/chromium/components/crash/core/app/breakpad_linux.cc nw/chromium/components/crash/core/app/breakpad_linux.cc
--- up/chromium/components/crash/core/app/breakpad_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/crash/core/app/breakpad_linux.cc	2024-08-26 19:32:22.142588503 +0000
@@ -788,17 +788,33 @@
       StringFromPrefixAndUint("/dev/fd/", upload_status_fd, allocator);
 
   static const char kWgetBinary[] = "/usr/bin/wget";
+  char* const upload_url = reinterpret_cast<char*>(allocator->Alloc(1024));
+  *upload_url='\0';
+  int i = 1;
+  do {
+    char key_name[17];
+    my_strlcpy(key_name, "url-nwjs__", sizeof(key_name));
+    my_uitos(key_name + 10, i, my_uint_len(i));
+    key_name[10 + my_uint_len(i)] = '\0';
+    const char* chunk = crash_reporter::internal::GetCrashKeyStorage()->GetValueForKey(key_name);
+    if (!chunk)
+      break;
+    my_strlcat(upload_url, chunk, 1024);
+    i++;
+  } while(true);
+  //WriteLog("UPLOAD_URL", 10);
+  //WriteLog(upload_url, my_strlen(upload_url));
   const char* args[] = {
-      kWgetBinary,
-      header_content_encoding,
-      header_content_type,
-      post_file,
-      g_upload_url,
-      "--timeout=10",  // Set a timeout so we don't hang forever.
-      "--tries=1",     // Don't retry if the upload fails.
-      "-O",            // Output reply to the file descriptor path.
-      status_fd_path,
-      nullptr,
+    kWgetBinary,
+    header_content_encoding,
+    header_content_type,
+    post_file,
+    upload_url,
+    "--timeout=10",  // Set a timeout so we don't hang forever.
+    "--tries=1",     // Don't retry if the upload fails.
+    "-O",  // Output reply to the file descriptor path.
+    status_fd_path,
+    nullptr,
   };
   static const char msg[] = "Cannot upload crash dump: cannot exec "
                             "/usr/bin/wget\n";
diff -r -u --color up/chromium/components/crash/core/app/crash_reporter_client.cc nw/chromium/components/crash/core/app/crash_reporter_client.cc
--- up/chromium/components/crash/core/app/crash_reporter_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/crash/core/app/crash_reporter_client.cc	2024-08-26 19:32:22.142588503 +0000
@@ -42,6 +42,10 @@
     const std::string& client_guid) {}
 #endif
 
+void CrashReporterClient::SetUploadDump(bool upload) {
+  enable_upload_ = upload;
+}
+
 #if BUILDFLAG(IS_WIN)
 bool CrashReporterClient::ShouldCreatePipeName(
     const std::wstring& process_type) {
@@ -89,7 +93,7 @@
 }
 #endif
 
-#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_POSIX)
 void CrashReporterClient::GetProductNameAndVersion(const char** product_name,
                                                    const char** version) {
 }
diff -r -u --color up/chromium/components/crash/core/app/crash_reporter_client.h nw/chromium/components/crash/core/app/crash_reporter_client.h
--- up/chromium/components/crash/core/app/crash_reporter_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/crash/core/app/crash_reporter_client.h	2024-08-26 19:32:22.142588503 +0000
@@ -26,7 +26,7 @@
 // runtime.
 void SetCrashReporterClient(CrashReporterClient* client);
 
-#if defined(CRASH_IMPLEMENTATION)
+#if 1
 // The components's embedder API should only be used by the component.
 CrashReporterClient* GetCrashReporterClient();
 #endif
@@ -48,6 +48,7 @@
   virtual void SetCrashReporterClientIdFromGUID(const std::string& client_guid);
 #endif
 
+  virtual void SetUploadDump(bool);
 #if BUILDFLAG(IS_WIN)
   // Returns true if the pipe name to connect to breakpad should be computed and
   // stored in the process's environment block. By default, returns true for the
@@ -96,7 +97,7 @@
   virtual bool GetShouldDumpLargerDumps();
 #endif
 
-#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_POSIX)
   // Returns a textual description of the product type and version to include
   // in the crash report. Neither out parameter should be set to NULL.
   // TODO(jperaza): Remove the 2-parameter overload of this method once all
@@ -213,6 +214,10 @@
 
   // Returns true if breakpad should run in the given process type.
   virtual bool EnableBreakpadForProcess(const std::string& process_type);
+
+  bool enable_upload_;
+  std::string product_name_;
+  std::string product_version_;
 };
 
 }  // namespace crash_reporter
diff -r -u --color up/chromium/components/crash/core/app/crashpad_mac.mm nw/chromium/components/crash/core/app/crashpad_mac.mm
--- up/chromium/components/crash/core/app/crashpad_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/crash/core/app/crashpad_mac.mm	2024-08-26 19:32:22.142588503 +0000
@@ -149,11 +149,20 @@
 
       // Is there a way to recover if this fails?
       CrashReporterClient* crash_reporter_client = GetCrashReporterClient();
+      const char* product_name = "";
+      const char* version = "";
+
+      crash_reporter_client->GetProductNameAndVersion(&product_name, &version);
       crash_reporter_client->GetCrashDumpLocation(database_path);
       crash_reporter_client->GetCrashMetricsLocation(&metrics_path);
 
       std::string url = crash_reporter_client->GetUploadUrl();
 
+      std::map<std::string, std::string> process_annotations;
+      process_annotations["prod"] = product_name;
+      process_annotations["ver"] = version;
+      process_annotations["plat"] = std::string("OS X");
+
       std::vector<std::string> arguments;
 
       if (crash_reporter_client->ShouldMonitorCrashHandlerExpensively()) {
@@ -174,9 +183,10 @@
             "--reset-own-crash-exception-port-to-system-default");
       }
 
+      
       bool result = GetCrashpadClient().StartHandler(
           handler_path, *database_path, metrics_path, url,
-          GetProcessSimpleAnnotations(), arguments, true, false);
+          process_annotations, arguments, true, false);
 
       // If this is an initial client that's not the browser process, it's
       // important to sever the connection to any existing handler. If
diff -r -u --color up/chromium/components/crx_file/id_util.cc nw/chromium/components/crx_file/id_util.cc
--- up/chromium/components/crx_file/id_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/crx_file/id_util.cc	2024-08-26 19:32:22.178588498 +0000
@@ -88,6 +88,7 @@
 }
 
 bool IdIsValid(std::string_view id) {
+#if 0
   // Verify that the id is legal.
   if (id.size() != (crx_file::id_util::kIdSize * 2)) {
     return false;
@@ -100,6 +101,7 @@
     }
   }
 
+#endif
   return true;
 }
 
diff -r -u --color up/chromium/components/embedder_support/user_agent_utils.cc nw/chromium/components/embedder_support/user_agent_utils.cc
--- up/chromium/components/embedder_support/user_agent_utils.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/embedder_support/user_agent_utils.cc	2024-08-26 19:32:22.254588487 +0000
@@ -6,6 +6,7 @@
 
 #include <string>
 #include <vector>
+#include "content/nw/src/common/nw_content_common_hooks.h"
 
 #include "base/command_line.h"
 #include "base/debug/stack_trace.h"
@@ -303,6 +304,11 @@
     return custom_ua.value();
   }
 
+  std::string user_agent;
+  if (nw::GetUserAgentFromManifest(&user_agent)) {
+    return user_agent;
+  }
+
   return GetUserAgentInternal(user_agent_reduction);
 }
 
diff -r -u --color up/chromium/components/favicon/core/favicon_driver_impl.cc nw/chromium/components/favicon/core/favicon_driver_impl.cc
--- up/chromium/components/favicon/core/favicon_driver_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/favicon/core/favicon_driver_impl.cc	2024-08-26 19:32:22.314588478 +0000
@@ -33,7 +33,7 @@
         favicon_service_, this, FaviconDriverObserver::TOUCH_LARGEST));
   } else {
     handlers_.push_back(std::make_unique<FaviconHandler>(
-        favicon_service_, this, FaviconDriverObserver::NON_TOUCH_16_DIP));
+        favicon_service_, this, FaviconDriverObserver::NON_TOUCH_LARGEST));
   }
 }
 
diff -r -u --color up/chromium/components/gcm_driver/gcm_driver_desktop.cc nw/chromium/components/gcm_driver/gcm_driver_desktop.cc
--- up/chromium/components/gcm_driver/gcm_driver_desktop.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/gcm_driver/gcm_driver_desktop.cc	2024-08-26 19:32:22.362588472 +0000
@@ -32,6 +32,8 @@
 #include "services/network/public/cpp/network_connection_tracker.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
 
+#include "content/nw/src/nw_base.h"
+
 namespace gcm {
 
 class GCMDriverDesktop::IOWorker : public GCMClient::Delegate {
@@ -1167,6 +1169,10 @@
   if (gcm_started_)
     return GCMClient::SUCCESS;
 
+#if defined(NDEBUG)
+  if (!nw::gcm_enabled())
+    return GCMClient::GCM_DISABLED;
+#endif
   // Have any app requested the service?
   if (app_handlers().empty())
     return GCMClient::UNKNOWN_ERROR;
diff -r -u --color up/chromium/components/gcm_driver/gcm_internals_helper.cc nw/chromium/components/gcm_driver/gcm_internals_helper.cc
--- up/chromium/components/gcm_driver/gcm_internals_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/gcm_driver/gcm_internals_helper.cc	2024-08-26 19:32:22.362588472 +0000
@@ -4,6 +4,7 @@
 
 #include "components/gcm_driver/gcm_internals_helper.h"
 
+#include "content/nw/src/nw_base.h"
 #include <memory>
 #include <utility>
 
@@ -121,7 +122,11 @@
 
     base::Value::Dict device_info;
     device_info.Set(kProfileServiceCreated, profile_service != nullptr);
-    device_info.Set(kGcmEnabled, true);
+#if defined(NDEBUG)
+    device_info.Set(kGcmEnabled, nw::gcm_enabled());
+#else
+    device_info.Set(kGcmEnabled, false);
+#endif
     device_info.Set(kGcmClientCreated, stats->gcm_client_created);
     device_info.Set(kGcmClientState, stats->gcm_client_state);
     device_info.Set(kConnectionClientCreated, stats->connection_client_created);
diff -r -u --color up/chromium/components/gcm_driver/instance_id/instance_id_driver.cc nw/chromium/components/gcm_driver/instance_id/instance_id_driver.cc
--- up/chromium/components/gcm_driver/instance_id/instance_id_driver.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/gcm_driver/instance_id/instance_id_driver.cc	2024-08-26 19:32:22.366588471 +0000
@@ -4,12 +4,27 @@
 
 #include "components/gcm_driver/instance_id/instance_id_driver.h"
 
+#include "base/metrics/field_trial.h"
+#include "base/strings/string_util.h"
 #include "build/build_config.h"
 #include "components/gcm_driver/gcm_driver.h"
 #include "components/gcm_driver/instance_id/instance_id.h"
 
 namespace instance_id {
 
+namespace {
+const char kInstanceIDFieldTrialName[] = "InstanceID";
+const char kInstanceIDFieldTrialDisabledGroupPrefix[] = "Disabled";
+}  // namespace
+
+// static
+bool InstanceIDDriver::IsInstanceIDEnabled() {
+  std::string group_name =
+      base::FieldTrialList::FindFullName(kInstanceIDFieldTrialName);
+  return !base::StartsWith(group_name, kInstanceIDFieldTrialDisabledGroupPrefix,
+                           base::CompareCase::INSENSITIVE_ASCII);
+}
+
 InstanceIDDriver::InstanceIDDriver(gcm::GCMDriver* gcm_driver)
     : gcm_driver_(gcm_driver) {
 }
diff -r -u --color up/chromium/components/gcm_driver/instance_id/instance_id_driver.h nw/chromium/components/gcm_driver/instance_id/instance_id_driver.h
--- up/chromium/components/gcm_driver/instance_id/instance_id_driver.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/gcm_driver/instance_id/instance_id_driver.h	2024-08-26 19:32:22.366588471 +0000
@@ -25,6 +25,9 @@
 // Create instances of this class with |InstanceIDProfileServiceFactory|.
 class InstanceIDDriver {
  public:
+  // Returns whether InstanceID is enabled.
+  static bool IsInstanceIDEnabled();
+
   explicit InstanceIDDriver(gcm::GCMDriver* gcm_driver);
 
   InstanceIDDriver(const InstanceIDDriver&) = delete;
diff -r -u --color up/chromium/components/gcm_driver/instance_id/instance_id_profile_service.cc nw/chromium/components/gcm_driver/instance_id/instance_id_profile_service.cc
--- up/chromium/components/gcm_driver/instance_id/instance_id_profile_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/gcm_driver/instance_id/instance_id_profile_service.cc	2024-08-26 19:32:22.366588471 +0000
@@ -6,12 +6,22 @@
 
 #include "base/check.h"
 #include "base/memory/ptr_util.h"
+#include "content/nw/src/nw_base.h"
 #include "components/gcm_driver/gcm_driver.h"
 #include "components/gcm_driver/gcm_profile_service.h"
 #include "components/gcm_driver/instance_id/instance_id_driver.h"
 
 namespace instance_id {
 
+// static
+bool InstanceIDProfileService::IsInstanceIDEnabled() {
+#if defined(NDEBUG)
+  return nw::gcm_enabled() && InstanceIDDriver::IsInstanceIDEnabled();
+#else
+  return InstanceIDDriver::IsInstanceIDEnabled();
+#endif
+}
+
 InstanceIDProfileService::InstanceIDProfileService(gcm::GCMDriver* driver,
                                                    bool is_off_the_record) {
   DCHECK(!is_off_the_record);
diff -r -u --color up/chromium/components/gcm_driver/instance_id/instance_id_profile_service.h nw/chromium/components/gcm_driver/instance_id/instance_id_profile_service.h
--- up/chromium/components/gcm_driver/instance_id/instance_id_profile_service.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/gcm_driver/instance_id/instance_id_profile_service.h	2024-08-26 19:32:22.366588471 +0000
@@ -20,6 +20,9 @@
 // Providing Instance ID support, via InstanceIDDriver, to a profile.
 class InstanceIDProfileService : public KeyedService {
  public:
+  // Returns whether InstanceID is enabled for |profile|.
+  static bool IsInstanceIDEnabled();
+
   InstanceIDProfileService(gcm::GCMDriver* driver, bool is_off_the_record);
 
   InstanceIDProfileService(const InstanceIDProfileService&) = delete;
diff -r -u --color up/chromium/components/guest_view/browser/guest_view_manager.cc nw/chromium/components/guest_view/browser/guest_view_manager.cc
--- up/chromium/components/guest_view/browser/guest_view_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/guest_view/browser/guest_view_manager.cc	2024-08-26 19:32:22.374588469 +0000
@@ -553,10 +553,9 @@
 
   // The embedder is trying to access a guest with a negative or zero
   // instance ID.
-  if (guest_instance_id <= kInstanceIDNone) {
-    bad_access_key.Set("Nonpositive");
-    return false;
-  }
+  if (guest_instance_id <= kInstanceIDNone)
+    return true; // the 'alert' case will fail when keeps clicking
+                 // 'detach' otherwise
 
   // The embedder is trying to access an instance ID that has not yet been
   // allocated by GuestViewManager. This could cause instance ID
@@ -576,6 +575,7 @@
 
   // MimeHandlerViewGuests (PDF) may be embedded in a cross-process frame.
   // Other than MimeHandlerViewGuest, all other guest types are only permitted
+#if 0
   // to run in the main frame or its local subframes.
   const int allowed_embedder_render_process_id =
       guest_view->CanBeEmbeddedInsideCrossProcessFrames()
@@ -586,7 +586,7 @@
     bad_access_key.Set("Bad embedder process");
     return false;
   }
-
+#endif
   return true;
 }
 
diff -r -u --color up/chromium/components/guest_view/browser/guest_view_manager.h nw/chromium/components/guest_view/browser/guest_view_manager.h
--- up/chromium/components/guest_view/browser/guest_view_manager.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/guest_view/browser/guest_view_manager.h	2024-08-26 19:32:22.374588469 +0000
@@ -213,7 +213,10 @@
   bool CanUseGuestInstanceID(int guest_instance_id);
 
   // Contains guests, mapping from their instance ids.
+public:
   using GuestInstanceMap = std::map<int, GuestViewBase*>;
+  const GuestInstanceMap& guests_by_instance_id() { return guests_by_instance_id_; }
+ protected:
   GuestInstanceMap guests_by_instance_id_;
 
   using WebContentsGuestViewMap =
diff -r -u --color up/chromium/components/gwp_asan/client/thread_local_state.h nw/chromium/components/gwp_asan/client/thread_local_state.h
--- up/chromium/components/gwp_asan/client/thread_local_state.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/gwp_asan/client/thread_local_state.h	2024-08-26 19:32:22.378588470 +0000
@@ -15,7 +15,7 @@
 // Also, `thread_local` goes through `emutls` on Android, which is slower than
 // `pthread_getspecific`.
 #define THREAD_LOCAL_STATE_USES_PARTITION_ALLOC_TLS
-#elif BUILDFLAG(IS_POSIX) && defined(COMPONENT_BUILD)
+#elif 0 //BUILDFLAG(IS_POSIX) && defined(COMPONENT_BUILD)
 // On POSIX platforms when built as component build, use of a `thread_local`
 // variable may or may not cause a call to `free()` depending on an
 // implementation of TLS. At least in case of glibc/glibc/elf/dl-tls.c,
@@ -55,8 +55,7 @@
   ALWAYS_INLINE static void SetState(uintptr_t value) { state_ = value; }
 
  private:
-  static thread_local uintptr_t state_
-      __attribute__((tls_model("initial-exec")));
+  static thread_local uintptr_t state_;
 #else
   ALWAYS_INLINE static uintptr_t GetState() {
     DCHECK(tls_key_);
diff -r -u --color up/chromium/components/input/render_widget_host_input_event_router.cc nw/chromium/components/input/render_widget_host_input_event_router.cc
--- up/chromium/components/input/render_widget_host_input_event_router.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/input/render_widget_host_input_event_router.cc	2024-08-26 19:32:22.422588463 +0000
@@ -7,6 +7,11 @@
 #include <algorithm>
 #include <deque>
 #include <memory>
+
+#include "content/public/browser/render_frame_host.h"
+#include "content/browser/renderer_host/render_frame_host_impl.h"
+#include "content/browser/renderer_host/input/touch_emulator_impl.h"
+
 #include <vector>
 
 #include "base/debug/crash_logging.h"
@@ -2048,8 +2053,14 @@
   }
   if (auto* cursor_manager = last_mouse_move_root_view_->GetCursorManager()) {
     for (auto it : owner_map_) {
-      if (it.second)
+      if (it.second) {
+	content::TouchEmulatorImpl* impl = static_cast<content::TouchEmulatorImpl*>(touch_emulator);
+        if (impl && impl->rfh_limit()) {
+          if (static_cast<content::RenderFrameHostImpl*>(impl->rfh_limit())->GetView()->GetInputWeakPtr().get() != it.second.get())
+            continue;
+        }
         cursor_manager->UpdateCursor(it.second.get(), cursor);
+      }
     }
   }
 }
diff -r -u --color up/chromium/components/javascript_dialogs/app_modal_dialog_manager.cc nw/chromium/components/javascript_dialogs/app_modal_dialog_manager.cc
--- up/chromium/components/javascript_dialogs/app_modal_dialog_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/javascript_dialogs/app_modal_dialog_manager.cc	2024-08-26 19:32:22.438588461 +0000
@@ -78,6 +78,8 @@
 std::u16string AppModalDialogManager::GetTitle(
     content::WebContents* web_contents,
     const url::Origin& alerting_frame_origin) {
+  return std::u16string();
+#if 0
   if (delegate_) {
     return delegate_->GetTitle(web_contents, alerting_frame_origin);
   }
@@ -86,6 +88,7 @@
   return GetSiteFrameTitle(
       web_contents->GetPrimaryMainFrame()->GetLastCommittedOrigin(),
       alerting_frame_origin);
+#endif
 }
 
 namespace {
@@ -168,7 +171,7 @@
   AppModalDialogQueue::GetInstance()->AddDialog(new AppModalDialogController(
       web_contents, &javascript_dialog_extra_data_, dialog_title, dialog_type,
       message_text, default_prompt_text,
-      ShouldDisplaySuppressCheckbox(extra_data),
+      false, //ShouldDisplaySuppressCheckbox(extra_data),
       false,  // is_before_unload_dialog
       false,  // is_reload
       base::BindOnce(&AppModalDialogManager::OnDialogClosed,
diff -r -u --color up/chromium/components/keep_alive_registry/keep_alive_registry.cc nw/chromium/components/keep_alive_registry/keep_alive_registry.cc
--- up/chromium/components/keep_alive_registry/keep_alive_registry.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/keep_alive_registry/keep_alive_registry.cc	2024-08-26 19:32:22.442588460 +0000
@@ -112,7 +112,8 @@
 
 void KeepAliveRegistry::Register(KeepAliveOrigin origin,
                                  KeepAliveRestartOption restart) {
-  CHECK(!is_shutting_down_);
+  //nw1 crash when quit from dock
+//  CHECK(!is_shutting_down_);
 
   bool old_keeping_alive = IsKeepingAlive();
   bool old_restart_allowed = IsRestartAllowed();
diff -r -u --color up/chromium/components/keep_alive_registry/keep_alive_registry.h nw/chromium/components/keep_alive_registry/keep_alive_registry.h
--- up/chromium/components/keep_alive_registry/keep_alive_registry.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/keep_alive_registry/keep_alive_registry.h	2024-08-26 19:32:22.442588460 +0000
@@ -77,10 +77,12 @@
   KeepAliveRegistry();
   ~KeepAliveRegistry();
 
+ public:
   // Add/Remove entries. Do not use directly, use ScopedKeepAlive instead.
   void Register(KeepAliveOrigin origin, KeepAliveRestartOption restart);
   void Unregister(KeepAliveOrigin origin, KeepAliveRestartOption restart);
 
+ private:
   // Methods called when a specific aspect of the state of the registry changes.
   void OnKeepAliveStateChanged(bool new_keeping_alive);
   void OnRestartAllowedChanged(bool new_restart_allowed);
diff -r -u --color up/chromium/components/media_router/browser/presentation/presentation_service_delegate_impl.cc nw/chromium/components/media_router/browser/presentation/presentation_service_delegate_impl.cc
--- up/chromium/components/media_router/browser/presentation/presentation_service_delegate_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/media_router/browser/presentation/presentation_service_delegate_impl.cc	2024-08-26 19:32:22.554588444 +0000
@@ -466,7 +466,9 @@
     const content::PresentationRequest& request,
     content::PresentationConnectionCallback success_cb,
     content::PresentationConnectionErrorCallback error_cb) {
+#if defined(NWJS_SDK)
   const auto& render_frame_host_id = request.render_frame_host_id;
+#endif
   const auto& presentation_urls = request.presentation_urls;
   if (presentation_urls.empty()) {
     std::move(error_cb).Run(PresentationError(
@@ -479,6 +481,8 @@
                           "Invalid presentation URL."));
     return;
   }
+
+#if defined(NWJS_SDK)
   auto presentation_context = std::make_unique<StartPresentationContext>(
       request,
       base::BindOnce(
@@ -494,6 +498,7 @@
       MediaRouterDialogController::GetOrCreateForWebContents(&GetWebContents());
   controller->ShowMediaRouterDialogForPresentation(
       std::move(presentation_context));
+#endif
 }
 
 void PresentationServiceDelegateImpl::ReconnectPresentation(
diff -r -u --color up/chromium/components/metrics/metrics_service.cc nw/chromium/components/metrics/metrics_service.cc
--- up/chromium/components/metrics/metrics_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/metrics/metrics_service.cc	2024-08-26 19:32:22.582588440 +0000
@@ -330,7 +330,7 @@
       client_(client),
       local_state_(local_state),
       recording_state_(UNSET),
-      test_mode_active_(false),
+      test_mode_active_(true),
       state_(CONSTRUCTED),
       idle_since_last_transmission_(false),
       session_id_(-1) {
@@ -429,9 +429,9 @@
 }
 
 void MetricsService::Start() {
-  HandleIdleSinceLastTransmission(false);
+  test_mode_active_ = true;
   EnableRecording();
-  EnableReporting();
+  DisableReporting();
 }
 
 void MetricsService::StartRecordingForTests() {
diff -r -u --color up/chromium/components/metrics/metrics_state_manager.cc nw/chromium/components/metrics/metrics_state_manager.cc
--- up/chromium/components/metrics/metrics_state_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/metrics/metrics_state_manager.cc	2024-08-26 19:32:22.582588440 +0000
@@ -427,6 +427,7 @@
   // so the command-line checks wouldn't be needed here.
   // Currently, kForceEnableMetricsReporting is used by Java UkmTest and
   // kMetricsRecordingOnly is used by Chromedriver tests.
+#if 0
   DCHECK(enabled_state_provider_->IsConsentGiven() ||
          IsMetricsReportingForceEnabled() || IsMetricsRecordingOnlyEnabled());
   if (!external_client_id_.empty()) {
@@ -439,6 +440,7 @@
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   std::string previous_client_id = client_id_;
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+#endif
   {
     std::string client_id_from_prefs = ReadClientId(local_state_);
     // If client id in prefs matches the cached copy, return early.
diff -r -u --color up/chromium/components/metrics_services_manager/metrics_services_manager.cc nw/chromium/components/metrics_services_manager/metrics_services_manager.cc
--- up/chromium/components/metrics_services_manager/metrics_services_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/metrics_services_manager/metrics_services_manager.cc	2024-08-26 19:32:22.594588439 +0000
@@ -1,6 +1,7 @@
 // Copyright 2014 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "components/metrics_services_manager/metrics_services_manager.h"
 
@@ -199,7 +200,7 @@
   DCHECK(thread_checker_.CalledOnValidThread());
   metrics::MetricsService* metrics = GetMetricsService();
 
-  if (metrics::IsMetricsRecordingOnlyEnabled()) {
+  if (true) { //metrics::IsMetricsRecordingOnlyEnabled()) {
     metrics->StartRecordingForTests();
     return;
   }
diff -r -u --color up/chromium/components/nacl/features.gni nw/chromium/components/nacl/features.gni
--- up/chromium/components/nacl/features.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/nacl/features.gni	2024-08-26 19:32:22.606588437 +0000
@@ -23,7 +23,7 @@
   # Enables Native Client support.
   #
   # NaCl is only supported on ChromeOS.
-  enable_nacl = checkout_nacl && _cpu_is_supported && target_os == "chromeos"
+  enable_nacl = false #checkout_nacl && _cpu_is_supported && target_os == "chromeos"
 }
 
 assert(!enable_nacl || checkout_nacl)
diff -r -u --color up/chromium/components/nacl/loader/BUILD.gn nw/chromium/components/nacl/loader/BUILD.gn
--- up/chromium/components/nacl/loader/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/nacl/loader/BUILD.gn	2024-08-26 19:32:22.606588437 +0000
@@ -142,6 +142,12 @@
     if (!export_libcxxabi_from_executables) {
       configs -= [ "//build/config/compiler:export_dynamic" ]
     }
+    if (is_linux) {
+      if (!is_component_build) {
+        # Set rpath to find our own libfreetype even in a non-component build.
+        configs += [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
+      }
+    }
 
     data_deps =
         [ "//native_client/src/trusted/service_runtime/linux:bootstrap" ]
diff -r -u --color up/chromium/components/nacl/loader/nacl_helper_linux.cc nw/chromium/components/nacl/loader/nacl_helper_linux.cc
--- up/chromium/components/nacl/loader/nacl_helper_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/nacl/loader/nacl_helper_linux.cc	2024-08-26 19:32:22.606588437 +0000
@@ -350,7 +350,7 @@
   }
   if (!have_to_reply)
     return false;
-  const std::vector<int> empty;  // We never send file descriptors back.
+  const std::vector<int> empty = std::vector<int>();  // We never send file descriptors back.
   if (!base::UnixDomainSocket::SendMsg(reply_fd, write_pickle.data(),
                                        write_pickle.size(), empty)) {
     LOG(ERROR) << "*** send() to zygote failed";
@@ -370,11 +370,13 @@
       &buf, sizeof(buf), &fds);
   // If the Zygote has started handling requests, we should be sandboxed via
   // the setuid sandbox.
+#if 0
   if (!nacl_sandbox->layer_one_enabled()) {
     LOG(ERROR) << "NaCl helper process running without a sandbox!\n"
       << "Most likely you need to configure your SUID sandbox "
       << "correctly";
   }
+#endif
   if (msglen == 0 || (msglen == -1 && errno == ECONNRESET)) {
     // EOF from the browser. Goodbye!
     _exit(0);
@@ -504,7 +506,7 @@
   nacl_sandbox->InitializeLayerOneSandbox();
   CHECK_EQ(is_init_process, nacl_sandbox->layer_one_enabled());
 
-  const std::vector<int> empty;
+  const std::vector<int> empty = std::vector<int>();
   // Send the zygote a message to let it know we are ready to help
   if (!base::UnixDomainSocket::SendMsg(kNaClZygoteDescriptor,
                                        kNaClHelperStartupAck,
diff -r -u --color up/chromium/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc nw/chromium/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc
--- up/chromium/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc	2024-08-26 19:32:22.606588437 +0000
@@ -183,7 +183,7 @@
   // have a single thread running here.
   DCHECK(!layer_one_sealed_);
   CHECK(IsSingleThreaded());
-  CheckForExpectedNumberOfOpenFds();
+  //CheckForExpectedNumberOfOpenFds();
 
   RestrictAddressSpaceUsage();
 
diff -r -u --color up/chromium/components/nacl/zygote/nacl_fork_delegate_linux.cc nw/chromium/components/nacl/zygote/nacl_fork_delegate_linux.cc
--- up/chromium/components/nacl/zygote/nacl_fork_delegate_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/nacl/zygote/nacl_fork_delegate_linux.cc	2024-08-26 19:32:22.610588436 +0000
@@ -409,7 +409,7 @@
   write_pickle.WriteInt(pid);
   write_pickle.WriteBool(known_dead);
 
-  const std::vector<int> empty_fds;
+  const std::vector<int> empty_fds = std::vector<int>();
   char reply_buf[kNaClMaxIPCMessageLength];
   ssize_t reply_size = 0;
   bool got_reply =
diff -r -u --color up/chromium/components/network_time/network_time_tracker.cc nw/chromium/components/network_time/network_time_tracker.cc
--- up/chromium/components/network_time/network_time_tracker.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/network_time/network_time_tracker.cc	2024-08-26 19:32:22.618588435 +0000
@@ -65,7 +65,7 @@
 #else
 BASE_FEATURE(kNetworkTimeServiceQuerying,
              "NetworkTimeServiceQuerying",
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT);
 #endif
 
 namespace {
diff -r -u --color up/chromium/components/omnibox/browser/search_provider.cc nw/chromium/components/omnibox/browser/search_provider.cc
--- up/chromium/components/omnibox/browser/search_provider.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/omnibox/browser/search_provider.cc	2024-08-26 19:32:22.666588428 +0000
@@ -1,7 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunreachable-code"
 #include "components/omnibox/browser/search_provider.h"
 
 #include <stddef.h>
@@ -887,7 +887,7 @@
 std::unique_ptr<network::SimpleURLLoader> SearchProvider::CreateSuggestLoader(
     const TemplateURL* template_url,
     const AutocompleteInput& input) {
-  if (!template_url || template_url->suggestions_url().empty())
+  if (true || !template_url || template_url->suggestions_url().empty())
     return nullptr;
 
   // Setting SuggestUrl the same as SearchUrl is a typical misconfiguration.
diff -r -u --color up/chromium/components/os_crypt/sync/keychain_password_mac.mm nw/chromium/components/os_crypt/sync/keychain_password_mac.mm
--- up/chromium/components/os_crypt/sync/keychain_password_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/os_crypt/sync/keychain_password_mac.mm	2024-08-26 19:32:22.718588421 +0000
@@ -31,8 +31,8 @@
 const char kDefaultServiceName[] = "Chrome Safe Storage";
 const char kDefaultAccountName[] = "Chrome";
 #else
-const char kDefaultServiceName[] = "Chromium Safe Storage";
-const char kDefaultAccountName[] = "Chromium";
+const char kDefaultServiceName[] = "NWJS Safe Storage";
+const char kDefaultAccountName[] = "nwjs";
 #endif
 
 // Generates a random password and adds it to the Keychain.  The added password
diff -r -u --color up/chromium/components/os_crypt/sync/os_crypt.h nw/chromium/components/os_crypt/sync/os_crypt.h
--- up/chromium/components/os_crypt/sync/os_crypt.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/os_crypt/sync/os_crypt.h	2024-08-26 19:32:22.718588421 +0000
@@ -278,7 +278,7 @@
   // The cached AES encryption key.
   std::unique_ptr<crypto::SymmetricKey> cached_encryption_key_;
   // TODO(dhollowa): Refactor to allow dependency injection of Keychain.
-  bool use_mock_keychain_ = false;
+  bool use_mock_keychain_ = true;
   // This flag is used to make the GetEncryptionKey method return NULL if used
   // along with mock Keychain.
   bool use_locked_mock_keychain_ = false;
diff -r -u --color up/chromium/components/os_crypt/sync/os_crypt_mac.mm nw/chromium/components/os_crypt/sync/os_crypt_mac.mm
--- up/chromium/components/os_crypt/sync/os_crypt_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/os_crypt/sync/os_crypt_mac.mm	2024-08-26 19:32:22.718588421 +0000
@@ -133,7 +133,7 @@
 
 void OSCryptImpl::SetRawEncryptionKey(const std::string& raw_key) {
   base::AutoLock auto_lock(OSCryptImpl::GetLock());
-  DCHECK(!cached_encryption_key_) << "Encryption key already set.";
+  //DCHECK(!cached_encryption_key_) << "Encryption key already set.";
   cached_encryption_key_ =
       crypto::SymmetricKey::Import(crypto::SymmetricKey::AES, raw_key);
   key_is_cached_ = true;
diff -r -u --color up/chromium/components/password_manager/core/browser/password_bubble_experiment.cc nw/chromium/components/password_manager/core/browser/password_bubble_experiment.cc
--- up/chromium/components/password_manager/core/browser/password_bubble_experiment.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/password_manager/core/browser/password_bubble_experiment.cc	2024-08-26 19:32:22.774588412 +0000
@@ -17,8 +17,11 @@
 }
 
 bool ShouldShowAutoSignInPromptFirstRunExperience(PrefService* prefs) {
+  return false; //NWJS#6809
+#if 0
   return !prefs->GetBoolean(
       password_manager::prefs::kWasAutoSignInFirstRunExperienceShown);
+#endif
 }
 
 void RecordAutoSignInPromptFirstRunExperienceWasShown(PrefService* prefs) {
diff -r -u --color up/chromium/components/password_manager/core/browser/password_form_manager.cc nw/chromium/components/password_manager/core/browser/password_form_manager.cc
--- up/chromium/components/password_manager/core/browser/password_form_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/password_manager/core/browser/password_form_manager.cc	2024-08-26 19:32:22.774588412 +0000
@@ -381,6 +381,12 @@
   return metrics_recorder_.get();
 }
 
+bool PasswordFormManager::IsPendingCredentialsOriginExtension() const {
+  if (GetPendingCredentials().url.SchemeIs("chrome-extension"))
+    return true;
+  return false;
+}
+
 base::span<const InteractionsStats> PasswordFormManager::GetInteractionsStats()
     const {
   return base::make_span(form_fetcher_->GetInteractionsStats());
diff -r -u --color up/chromium/components/password_manager/core/browser/password_form_manager.h nw/chromium/components/password_manager/core/browser/password_form_manager.h
--- up/chromium/components/password_manager/core/browser/password_form_manager.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/password_manager/core/browser/password_form_manager.h	2024-08-26 19:32:22.774588412 +0000
@@ -194,6 +194,7 @@
 
   bool IsNewLogin() const;
   FormFetcher* GetFormFetcher();
+  bool IsPendingCredentialsOriginExtension() const;
   void PresaveGeneratedPassword(const autofill::FormData& form_data,
                                 const std::u16string& generated_password);
   void PasswordNoLongerGenerated();
diff -r -u --color up/chromium/components/payments/content/payment_request.cc nw/chromium/components/payments/content/payment_request.cc
--- up/chromium/components/payments/content/payment_request.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/payments/content/payment_request.cc	2024-08-26 19:32:22.814588407 +0000
@@ -130,8 +130,9 @@
     return;
   }
 
-  bool allowed_origin =
+  bool allowed_origin = last_committed_url.SchemeIs("chrome-extension") ||
       UrlUtil::IsOriginAllowedToUseWebPaymentApis(last_committed_url);
+
   if (!allowed_origin) {
     reject_show_error_message_ = errors::kProhibitedOrigin;
   }
@@ -320,6 +321,7 @@
     manager->RecordActivationlessShow();
   }
 
+#if 0
   if (!delegate_->IsBrowserWindowActive()) {
     log_.Error(errors::kCannotShowInBackgroundTab);
     DCHECK(!has_recorded_completion_);
@@ -330,6 +332,7 @@
     ResetAndDeleteThis();
     return;
   }
+#endif
 
   if (wait_for_updated_details) {
     // Put |spec_| into uninitialized state, so the UI knows to show a spinner.
diff -r -u --color up/chromium/components/pdf/renderer/internal_plugin_renderer_helpers.cc nw/chromium/components/pdf/renderer/internal_plugin_renderer_helpers.cc
--- up/chromium/components/pdf/renderer/internal_plugin_renderer_helpers.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/pdf/renderer/internal_plugin_renderer_helpers.cc	2024-08-26 19:32:22.830588404 +0000
@@ -57,7 +57,7 @@
   }
 
   // Only create the in-process plugin within a PDF renderer.
-  CHECK(IsPdfRenderer());
+  //CHECK(IsPdfRenderer());
 
   // Origins allowed to embed the internal plugin are trusted (the PDF viewer
   // and Print Preview), and should never directly create the in-process plugin.
@@ -65,7 +65,7 @@
   //
   // See crbug.com/1259635 and crbug.com/1261758 for examples of previous bugs.
   CHECK(!delegate->IsAllowedOrigin(frame->GetSecurityOrigin()));
-  CHECK(parent_frame->IsWebRemoteFrame());
+  //CHECK(parent_frame->IsWebRemoteFrame());
 
   mojo::AssociatedRemote<pdf::mojom::PdfHost> pdf_host;
   render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
diff -r -u --color up/chromium/components/permissions/permission_context_base.cc nw/chromium/components/permissions/permission_context_base.cc
--- up/chromium/components/permissions/permission_context_base.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/permissions/permission_context_base.cc	2024-08-26 19:32:22.882588397 +0000
@@ -4,6 +4,9 @@
 
 #include "components/permissions/permission_context_base.h"
 
+#include "chrome/browser/chrome_content_browser_client.h"
+#include "extensions/browser/extension_registry.h"
+
 #include <stddef.h>
 
 #include <string>
@@ -170,6 +173,22 @@
   content::PermissionResult result = GetPermissionStatus(
       rfh, request_data.requesting_origin, request_data.embedding_origin);
 
+#if defined(NDEBUG)
+  content::WebContents* web_contents =
+    content::WebContents::FromRenderFrameHost(rfh);
+  extensions::ExtensionRegistry* extension_registry =
+    extensions::ExtensionRegistry::Get(web_contents->GetBrowserContext());
+  const extensions::Extension* extension =
+    extension_registry->enabled_extensions().GetByID(request_data.requesting_origin.host());
+  bool is_nw_origin = ChromeContentBrowserClient::IsNWURL(request_data.requesting_origin,
+							  web_contents->GetBrowserContext());
+  if (is_nw_origin || (extension && extension->is_nwjs_app())) {
+    result.status = PermissionStatus::GRANTED;
+  }
+#else
+  result.status = PermissionStatus::GRANTED;
+#endif
+
   bool status_ignorable = PermissionUtil::CanPermissionRequestIgnoreStatus(
       request_data, result.source);
 
diff -r -u --color up/chromium/components/permissions/permission_manager.cc nw/chromium/components/permissions/permission_manager.cc
--- up/chromium/components/permissions/permission_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/permissions/permission_manager.cc	2024-08-26 19:32:22.882588397 +0000
@@ -4,6 +4,8 @@
 
 #include "components/permissions/permission_manager.h"
 
+#include "extensions/browser/extension_registry.h"
+
 #include <memory>
 #include <utility>
 
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/bridged_content_view.h nw/chromium/components/remote_cocoa/app_shim/bridged_content_view.h
--- up/chromium/components/remote_cocoa/app_shim/bridged_content_view.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/bridged_content_view.h	2024-08-26 19:32:23.230588347 +0000
@@ -57,6 +57,9 @@
 @property(assign, nonatomic) BOOL drawMenuBackgroundForBlur;
 @property(strong, nonatomic) NSEvent* keyDownEventForTesting;
 
+// Used by g_force_cpu_draw
+@property(assign, nonatomic) CALayer* forceCPUDrawLayer;
+
 // Initialize the NSView -> views::View bridge. |viewToHost| must be non-NULL.
 - (instancetype)initWithBridge:(remote_cocoa::NativeWidgetNSWindowBridge*)bridge
                         bounds:(gfx::Rect)rect;
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/bridged_content_view.mm nw/chromium/components/remote_cocoa/app_shim/bridged_content_view.mm
--- up/chromium/components/remote_cocoa/app_shim/bridged_content_view.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/bridged_content_view.mm	2024-08-26 19:32:23.230588347 +0000
@@ -198,6 +198,7 @@
 @synthesize bridge = _bridge;
 @synthesize drawMenuBackgroundForBlur = _drawMenuBackgroundForBlur;
 @synthesize keyDownEventForTesting = _keyDownEvent;
+@synthesize forceCPUDrawLayer = forceCPUDrawLayer_;
 
 - (instancetype)initWithBridge:(remote_cocoa::NativeWidgetNSWindowBridge*)bridge
                         bounds:(gfx::Rect)bounds {
@@ -297,6 +298,17 @@
   return [super hitTest:point];
 }
 
+- (void)drawRect:(NSRect)dirty {
+  if (content::g_force_cpu_draw) {
+    CGContextRef ctx = (CGContextRef)[[NSGraphicsContext currentContext] CGContext];
+    CGContextClipToRect(ctx, NSRectToCGRect(dirty));
+    //get the flipped layer from forceCPUDrawLayer_ and do renderInContext
+    [forceCPUDrawLayer_ renderInContext:ctx];
+  } else {
+    [super drawRect:dirty];
+  }
+}
+
 - (void)processCapturedMouseEvent:(NSEvent*)theEvent {
   if (!_bridge)
     return;
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.h nw/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.h
--- up/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.h	2024-08-26 19:32:23.230588347 +0000
@@ -140,6 +140,7 @@
   // being reordered in (or out of) the screen list.
   void OnVisibilityChanged();
 
+  void OnWindowWillStartLiveResize();
   // Called by the NSWindowDelegate when the system colors change.
   void OnSystemColorsChanged();
 
@@ -257,6 +258,12 @@
   void SetCanAppearInExistingFullscreenSpaces(
       bool can_appear_in_existing_fullscreen_spaces) override;
   void SetMiniaturized(bool miniaturized) override;
+  void SetMaximized(bool maximized) override;
+  bool IsMaximized(bool* maximized) override;
+  void IsMaximized(IsMaximizedCallback callback) override;
+  void GetRestoredBounds(GetRestoredBoundsCallback callback) override;
+  bool GetRestoredBounds(gfx::Rect* bounds) override;
+  void SetRestoredBounds(const gfx::Rect& bounds) override;
   void SetSizeConstraints(const gfx::Size& min_size,
                           const gfx::Size& max_size,
                           bool is_resizable,
@@ -391,6 +398,8 @@
   // (and its compositor).
   gfx::Size content_dip_size_;
 
+  NSRect bounds_before_maximize_;
+
   // The size of the frame most recently *received from* the compositor. Note
   // that during resize (and showing new windows), this will lag behind
   // |content_dip_size_|, which is the frame size most recently *sent to* the
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm nw/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm
--- up/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm	2024-08-26 19:32:23.230588347 +0000
@@ -62,6 +62,10 @@
 using remote_cocoa::mojom::VisibilityTransition;
 using remote_cocoa::mojom::WindowVisibilityState;
 
+namespace content {
+  extern bool g_force_cpu_draw;
+}
+
 namespace {
 constexpr auto kUIPaintTimeout = base::Seconds(5);
 
@@ -193,6 +197,17 @@
 
 using RankMap = std::map<NSView*, int>;
 
+bool NSWindowIsMaximized(NSWindow* window) {
+  // -[NSWindow isZoomed] only works if the zoom button is enabled.
+  if ([[window standardWindowButton:NSWindowZoomButton] isEnabled])
+    return [window isZoomed];
+
+  // We don't attempt to distinguish between a window that has been explicitly
+  // maximized versus one that has just been dragged by the user to fill the
+  // screen. This is the same behavior as -[NSWindow isZoomed] above.
+  return NSEqualRects([window frame], [[window screen] visibleFrame]);
+}
+
 // Return the content size for a minimum or maximum widget size.
 gfx::Size GetClientSizeForWindowSize(NSWindow* window,
                                      const gfx::Size& window_size) {
@@ -497,6 +512,11 @@
 
   [[NSNotificationCenter defaultCenter]
       addObserver:window_delegate_
+         selector:@selector(onWindowWillStartLiveResize:)
+             name:NSWindowWillStartLiveResizeNotification
+           object:nil];
+  [[NSNotificationCenter defaultCenter]
+      addObserver:window_delegate_
          selector:@selector(onSystemColorsChanged:)
              name:NSSystemColorsDidChangeNotification
            object:nil];
@@ -561,8 +581,8 @@
 
   // A contentRect with zero width or height is a banned practice in ChromeMac,
   // due to unpredictable macOS treatment.
-  DCHECK(!clamped_content_size.IsEmpty())
-      << "Zero-sized windows not supported on Mac";
+  // DCHECK(!clamped_content_size.IsEmpty())
+  //    << "Zero-sized windows not supported on Mac";
 
   if (!window_visible_ && IsWindowModalSheet()) {
     // Window-Modal dialogs (i.e. sheets) are positioned by Cocoa when shown for
@@ -604,7 +624,8 @@
     const gfx::Size& content_size,
     const gfx::Size& minimum_content_size) {
   gfx::Rect new_window_bounds = gfx::ScreenRectFromNSRect([window_ frame]);
-  new_window_bounds.set_size(GetWindowSizeForClientSize(window_, content_size));
+
+  new_window_bounds.set_size(content_size); //GetWindowSizeForClientSize(window_, content_size));
   SetBounds(new_window_bounds, minimum_content_size, std::nullopt);
 
   // Note that this is not the precise center of screen, but it is the standard
@@ -655,7 +676,16 @@
   [compositor_view setWantsLayer:YES];
   [bridged_view_ addSubview:compositor_view];
 
-  [bridged_view_ setWantsLayer:YES];
+  if (content::g_force_cpu_draw) {
+    [compositor_view setLayer:nil];
+    [compositor_view setWantsLayer:NO];
+    //DisplayCALayerTree flipped_layer_
+    CALayer* flipped_layer = background_layer.sublayers[0];
+    [bridged_view_ setForceCPUDrawLayer:flipped_layer];
+    [flipped_layer setGeometryFlipped:NO];
+  } else {
+    [bridged_view_ setWantsLayer:YES];
+  }
   [window_ setContentView:bridged_view_];
 }
 
@@ -1153,6 +1183,12 @@
   UpdateWindowGeometry();
 }
 
+void NativeWidgetNSWindowBridge::OnWindowWillStartLiveResize() {
+  if (!NSWindowIsMaximized(window_) && !fullscreen_controller_.IsInFullscreenTransition()) {
+    bounds_before_maximize_ = [window_ frame];
+  }
+}
+
 void NativeWidgetNSWindowBridge::OnVisibilityChanged() {
   const bool window_visible = [window_ isVisible];
   if (window_visible_ == window_visible)
@@ -1551,6 +1587,44 @@
   window_.collectionBehavior = collectionBehavior;
 }
 
+bool NativeWidgetNSWindowBridge::IsMaximized(bool* maximized) {
+  *maximized = NSWindowIsMaximized(window_);
+  return true;
+}
+
+void NativeWidgetNSWindowBridge::IsMaximized(IsMaximizedCallback callback) {
+  bool maximized = false;
+  IsMaximized(&maximized);
+  std::move(callback).Run(maximized);
+}
+
+void NativeWidgetNSWindowBridge::SetRestoredBounds(const gfx::Rect& bounds) {
+  bounds_before_maximize_ = gfx::ScreenRectToNSRect(bounds);
+}
+
+bool NativeWidgetNSWindowBridge::GetRestoredBounds(gfx::Rect* bounds) {
+  *bounds = gfx::ScreenRectFromNSRect(bounds_before_maximize_);
+  return true;
+}
+
+void NativeWidgetNSWindowBridge::GetRestoredBounds(GetRestoredBoundsCallback callback) {
+  std::move(callback).Run(gfx::ScreenRectFromNSRect(bounds_before_maximize_));
+}
+
+void NativeWidgetNSWindowBridge::SetMaximized(bool maximized) {
+  if (!maximized) {
+    if (NSWindowIsMaximized(window_))
+      [window_ setFrame:bounds_before_maximize_ display:YES animate:YES];
+    return;
+  }
+  if (!NSWindowIsMaximized(window_))
+    [window_ setFrame:[[window_ screen] visibleFrame] display:YES animate:YES];
+
+  if ([window_ isMiniaturized])
+    [window_ deminiaturize:nil];
+}
+
+
 void NativeWidgetNSWindowBridge::SetMiniaturized(bool miniaturized) {
   // In headless mode the platform window is always hidden and WebKit
   // will not deminiaturize hidden windows. So instead of changing the window
@@ -1613,6 +1687,11 @@
   // the content display on-screen.
   display_ca_layer_tree_->UpdateCALayerTree(ca_layer_params);
 
+  if (content::g_force_cpu_draw) {
+    // this is to tell the NSView that the CALayer content has been updated
+    [bridged_view_ setNeedsDisplay:YES];
+  }
+
   if (ca_transaction_sync_suppressed_)
     ca_transaction_sync_suppressed_ = false;
 
@@ -1624,7 +1703,9 @@
 
 void NativeWidgetNSWindowBridge::SetIgnoresMouseEvents(
     bool ignores_mouse_events) {
-  [window_ setIgnoresMouseEvents:ignores_mouse_events];
+  if (!content::g_force_cpu_draw) {
+    [window_ setIgnoresMouseEvents:ignores_mouse_events];
+  }
 }
 
 void NativeWidgetNSWindowBridge::MakeFirstResponder() {
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/select_file_dialog_bridge.mm nw/chromium/components/remote_cocoa/app_shim/select_file_dialog_bridge.mm
--- up/chromium/components/remote_cocoa/app_shim/select_file_dialog_bridge.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/select_file_dialog_bridge.mm	2024-08-26 19:32:23.230588347 +0000
@@ -1,7 +1,8 @@
 // Copyright 2019 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunreachable-code"
+#pragma clang diagnostic ignored "-Wunused-variable"
 #include "components/remote_cocoa/app_shim/select_file_dialog_bridge.h"
 
 #import <AppKit/AppKit.h>
@@ -349,9 +350,10 @@
           base::SysUTF8ToNSString(default_path.BaseName().value());
     }
   }
-
+#if 0
   const bool keep_extension_visible =
       file_types ? file_types->keep_extension_visible : false;
+#endif
   if (type_ != SelectFileDialogType::kFolder &&
       type_ != SelectFileDialogType::kUploadFolder &&
       type_ != SelectFileDialogType::kExistingFolder) {
@@ -366,6 +368,9 @@
   }
 
   if (type_ == SelectFileDialogType::kSaveAsFile) {
+#if 1 //NWJS#6091: extension was hidden
+    panel_.extensionHidden = NO;
+#else
     // When file extensions are hidden and removing the extension from
     // the default filename gives one which still has an extension
     // that macOS recognizes, it will get confused and think the user
@@ -387,6 +392,7 @@
     // side-effect of setting the property to any value is that it turns off
     // the tag autosetter.
     panel_.showsTagField = YES;
+#endif
   } else {
     // This does not use ObjCCast because the underlying object could be a
     // non-exported AppKit type (https://crbug.com/41477018).
@@ -411,7 +417,7 @@
       }
 
       NSString* prompt =
-          (type_ == SelectFileDialogType::kUploadFolder)
+          (false && type_ == SelectFileDialogType::kUploadFolder)
               ? l10n_util::GetNSString(IDS_SELECT_UPLOAD_FOLDER_BUTTON_TITLE)
               : l10n_util::GetNSString(IDS_SELECT_FOLDER_BUTTON_TITLE);
       open_dialog.prompt = prompt;
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.h nw/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.h
--- up/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.h	2024-08-26 19:32:23.230588347 +0000
@@ -39,6 +39,7 @@
 // Notify that the system colors changed.
 - (void)onSystemColorsChanged:(NSNotification*)notification;
 
+- (void)onWindowWillStartLiveResize:(NSNotification*)notification;
 // Set the aspect ratio of the window. Window resizes will be constrained in an
 // attempt to maintain the aspect ratio.
 // Cocoa provides this functionality via the [NSWindow aspectRatio] property,
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.mm nw/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.mm
--- up/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.mm	2024-08-26 19:32:23.230588347 +0000
@@ -98,6 +98,10 @@
   _parent->OnVisibilityChanged();
 }
 
+- (void)onWindowWillStartLiveResize:(NSNotification*)notification {
+  _parent->OnWindowWillStartLiveResize();
+}
+
 - (void)onSystemColorsChanged:(NSNotification*)notification {
   _parent->OnSystemColorsChanged();
 }
diff -r -u --color up/chromium/components/remote_cocoa/common/native_widget_ns_window.mojom nw/chromium/components/remote_cocoa/common/native_widget_ns_window.mojom
--- up/chromium/components/remote_cocoa/common/native_widget_ns_window.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/remote_cocoa/common/native_widget_ns_window.mojom	2024-08-26 19:32:23.234588347 +0000
@@ -214,6 +214,10 @@
 
   // Zoom or un-zoom the window.
   SetZoomed(bool zoomed);
+  SetMaximized(bool maximized);
+  [Sync] IsMaximized() => (bool maximized);
+  [Sync] GetRestoredBounds() => (gfx.mojom.Rect bounds);
+  SetRestoredBounds(gfx.mojom.Rect bounds);
 
   // Called by NativeWidgetMac when the window size constraints change.
   SetSizeConstraints(gfx.mojom.Size min_size,
diff -r -u --color up/chromium/components/renderer_context_menu/context_menu_content_type.cc nw/chromium/components/renderer_context_menu/context_menu_content_type.cc
--- up/chromium/components/renderer_context_menu/context_menu_content_type.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/renderer_context_menu/context_menu_content_type.cc	2024-08-26 19:32:23.234588347 +0000
@@ -145,7 +145,7 @@
       return true;
 
     case ITEM_GROUP_DEVTOOLS_UNPACKED_EXT:
-      return false;
+      return true;
 
     case ITEM_GROUP_PRINT_PREVIEW:
 #if BUILDFLAG(ENABLE_PRINT_PREVIEW)
diff -r -u --color up/chromium/components/resources/BUILD.gn nw/chromium/components/resources/BUILD.gn
--- up/chromium/components/resources/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/resources/BUILD.gn	2024-08-26 19:32:23.246588344 +0000
@@ -160,3 +160,9 @@
     outputs = [ "{{bundle_resources_dir}}/{{source_file_part}}" ]
   }
 }
+
+copy("about_credits_nw") {
+  sources = [ about_credits_file ]
+  outputs = [ "$root_build_dir/credits.html" ]
+  deps = [ ":about_credits" ]
+}
diff -r -u --color up/chromium/components/safe_browsing/core/browser/db/v4_update_protocol_manager.cc nw/chromium/components/safe_browsing/core/browser/db/v4_update_protocol_manager.cc
--- up/chromium/components/safe_browsing/core/browser/db/v4_update_protocol_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/safe_browsing/core/browser/db/v4_update_protocol_manager.cc	2024-08-26 19:32:23.282588340 +0000
@@ -315,6 +315,7 @@
     return;
   }
 
+#if 0
   net::NetworkTrafficAnnotationTag traffic_annotation =
       net::DefineNetworkTrafficAnnotation("safe_browsing_v4_update", R"(
         semantics {
@@ -358,7 +359,7 @@
                      base::Unretained(this)));
 
   request_ = std::move(loader);
-
+#endif
   // Begin the update request timeout.
   timeout_timer_.Start(FROM_HERE, base::Seconds(kV4TimerUpdateWaitSecMax), this,
                        &V4UpdateProtocolManager::HandleTimeout);
diff -r -u --color up/chromium/components/search_provider_logos/logo_service_impl.cc nw/chromium/components/search_provider_logos/logo_service_impl.cc
--- up/chromium/components/search_provider_logos/logo_service_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/search_provider_logos/logo_service_impl.cc	2024-08-26 19:32:23.310588336 +0000
@@ -1,6 +1,7 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "components/search_provider_logos/logo_service_impl.h"
 
@@ -263,7 +264,7 @@
     base_url = doodle_url.DeprecatedGetOriginAsURL();
   }
 
-  if (!logo_url.is_valid() && !doodle_url.is_valid()) {
+  if (true) { //!logo_url.is_valid() && !doodle_url.is_valid()) {
     RunCallbacksWithDisabled(std::move(callbacks));
     return;
   }
diff -r -u --color up/chromium/components/services/storage/dom_storage/local_storage_impl.cc nw/chromium/components/services/storage/dom_storage/local_storage_impl.cc
--- up/chromium/components/services/storage/dom_storage/local_storage_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/services/storage/dom_storage/local_storage_impl.cc	2024-08-26 19:32:23.366588328 +0000
@@ -190,13 +190,13 @@
 
   // To avoid excessive IO we apply limits to the amount of data being written
   // and the frequency of writes.
-  static const size_t kMaxBytesPerHour = kPerStorageAreaQuota;
-  static constexpr int kMaxCommitsPerHour = 60;
+  //static const size_t kMaxBytesPerHour = std::numeric_limits<size_t>::max();
+  static constexpr int kMaxCommitsPerHour = std::numeric_limits<int32_t>::max();
 
   StorageAreaImpl::Options options;
-  options.max_size = kPerStorageAreaQuota + kPerStorageAreaOverQuotaAllowance;
+  options.max_size = std::numeric_limits<size_t>::max();
   options.default_commit_delay = kCommitDefaultDelaySecs;
-  options.max_bytes_per_hour = kMaxBytesPerHour;
+  options.max_bytes_per_hour = std::numeric_limits<int>::max();
   options.max_commits_per_hour = kMaxCommitsPerHour;
 #if BUILDFLAG(IS_ANDROID)
     options.cache_mode = StorageAreaImpl::CacheMode::KEYS_ONLY_WHEN_POSSIBLE;
diff -r -u --color up/chromium/components/sessions/core/session_service_commands.cc nw/chromium/components/sessions/core/session_service_commands.cc
--- up/chromium/components/sessions/core/session_service_commands.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/sessions/core/session_service_commands.cc	2024-08-26 19:32:23.386588325 +0000
@@ -165,9 +165,10 @@
   PERSISTED_SHOW_STATE_MAXIMIZED = 3,
   // SHOW_STATE_INACTIVE (4) never persisted.
   PERSISTED_SHOW_STATE_FULLSCREEN = 5,
-  PERSISTED_SHOW_STATE_DETACHED_DEPRECATED = 6,
-  PERSISTED_SHOW_STATE_DOCKED_DEPRECATED = 7,
-  PERSISTED_SHOW_STATE_END = 8,
+  // hidden not persisted
+  PERSISTED_SHOW_STATE_DETACHED_DEPRECATED = 7,
+  PERSISTED_SHOW_STATE_DOCKED_DEPRECATED = 8,
+  PERSISTED_SHOW_STATE_END = 9,
 };
 
 // TODO(crbug.com/40946710): Remove this around December 2024. This is part of a
@@ -198,6 +199,7 @@
       return PERSISTED_SHOW_STATE_FULLSCREEN;
     case ui::SHOW_STATE_DEFAULT:
     case ui::SHOW_STATE_INACTIVE:
+    case ui::SHOW_STATE_HIDDEN:
       return PERSISTED_SHOW_STATE_NORMAL;
 
     case ui::SHOW_STATE_END:
diff -r -u --color up/chromium/components/sessions/core/tab_restore_service_impl.cc nw/chromium/components/sessions/core/tab_restore_service_impl.cc
--- up/chromium/components/sessions/core/tab_restore_service_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/sessions/core/tab_restore_service_impl.cc	2024-08-26 19:32:23.386588325 +0000
@@ -186,6 +186,7 @@
   kSerializedShowStateMaximized = 3,
   kSerializedShowStateInactive = 4,
   kSerializedShowStateFullscreen = 5,
+  kSerializedShowStateHidden = 6,
 };
 
 // Converts a window show state to an integer. This function needs to be kept
@@ -204,6 +205,8 @@
       return kSerializedShowStateInactive;
     case ui::SHOW_STATE_FULLSCREEN:
       return kSerializedShowStateFullscreen;
+    case ui::SHOW_STATE_HIDDEN:
+      return kSerializedShowStateHidden;
     case ui::SHOW_STATE_END:
       // This should never happen.
       NOTREACHED_IN_MIGRATION();
@@ -235,6 +238,9 @@
     case kSerializedShowStateFullscreen:
       *show_state = ui::SHOW_STATE_FULLSCREEN;
       return true;
+    case kSerializedShowStateHidden:
+      *show_state = ui::SHOW_STATE_HIDDEN;
+      return true;
     case kSerializedShowStateInvalid:
     default:
       // Ignore unknown values. This could happen if the data is corrupt.
diff -r -u --color up/chromium/components/storage_monitor/portable_device_watcher_win.cc nw/chromium/components/storage_monitor/portable_device_watcher_win.cc
--- up/chromium/components/storage_monitor/portable_device_watcher_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/storage_monitor/portable_device_watcher_win.cc	2024-08-26 19:32:23.434588318 +0000
@@ -35,7 +35,7 @@
 namespace {
 
 // Name of the client application that communicates with the MTP device.
-const wchar_t kClientName[] = L"Chromium";
+const wchar_t kClientName[] = L"nwjs";
 
 // Returns true if |data| represents a class of portable devices.
 bool IsPortableDeviceStructure(LPARAM data) {
diff -r -u --color up/chromium/components/translate/content/browser/BUILD.gn nw/chromium/components/translate/content/browser/BUILD.gn
--- up/chromium/components/translate/content/browser/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/translate/content/browser/BUILD.gn	2024-08-26 19:32:24.058588228 +0000
@@ -34,7 +34,7 @@
     "//components/services/language_detection/public/cpp",
     "//components/services/language_detection/public/mojom",
     "//components/translate/core/browser:translate_model_service",
-    "//components/translate/core/language_detection:language_detection",
+    #"//components/translate/core/language_detection:language_detection",
     "//components/ukm/content",
     "//content/public/browser",
     "//content/public/common",
diff -r -u --color up/chromium/components/translate/core/language_detection/BUILD.gn nw/chromium/components/translate/core/language_detection/BUILD.gn
--- up/chromium/components/translate/core/language_detection/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/translate/core/language_detection/BUILD.gn	2024-08-26 19:32:24.066588227 +0000
@@ -40,7 +40,7 @@
     "//components/language/core/common",
     "//components/optimization_guide/core:features",
     "//components/translate/core/common",
-    "//third_party/cld_3/src/src:cld_3",
+    #"//third_party/cld_3/src/src:cld_3",
     "//third_party/flatbuffers",
     "//third_party/icu",
     "//third_party/libphonenumber:libphonenumber_without_metadata",
diff -r -u --color up/chromium/components/translate/translate_internals/translate_internals_handler.cc nw/chromium/components/translate/translate_internals/translate_internals_handler.cc
--- up/chromium/components/translate/translate_internals/translate_internals_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/translate/translate_internals/translate_internals_handler.cc	2024-08-26 19:32:24.070588226 +0000
@@ -162,6 +162,7 @@
 
 void TranslateInternalsHandler::OnRemovePrefItem(
     const base::Value::List& args) {
+#if 0
   std::unique_ptr<translate::TranslatePrefs> translate_prefs =
       GetTranslateClient()->GetTranslatePrefs();
 
@@ -192,6 +193,7 @@
   }
 
   SendPrefsToJs();
+#endif
 }
 
 void TranslateInternalsHandler::OnSetRecentTargetLanguage(
diff -r -u --color up/chromium/components/variations/service/BUILD.gn nw/chromium/components/variations/service/BUILD.gn
--- up/chromium/components/variations/service/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/variations/service/BUILD.gn	2024-08-26 19:32:24.130588217 +0000
@@ -12,7 +12,7 @@
   # Note: For Chrome-branded Android builds, this is always considered as set to
   # true (see below). This is done to avoid the binary size impact (~40 KiB) on
   # Android.
-  disable_fieldtrial_testing_config = false
+  disable_fieldtrial_testing_config = true
 
   # Set to true to make a build that force enables activation of field trial
   # tests specified in testing/variations/fieldtrial_testing_config.json.
diff -r -u --color up/chromium/components/viz/service/display/skia_renderer.cc nw/chromium/components/viz/service/display/skia_renderer.cc
--- up/chromium/components/viz/service/display/skia_renderer.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/viz/service/display/skia_renderer.cc	2024-08-26 19:32:24.190588209 +0000
@@ -1,7 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunused-variable"
 #include "components/viz/service/display/skia_renderer.h"
 
 #include <limits>
diff -r -u --color up/chromium/components/viz/service/display_embedder/software_output_device_win.cc nw/chromium/components/viz/service/display_embedder/software_output_device_win.cc
--- up/chromium/components/viz/service/display_embedder/software_output_device_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/viz/service/display_embedder/software_output_device_win.cc	2024-08-26 19:32:24.198588208 +0000
@@ -17,6 +17,7 @@
 #include "services/viz/privileged/mojom/compositing/layered_window_updater.mojom.h"
 #include "skia/ext/platform_canvas.h"
 #include "skia/ext/skia_utils_win.h"
+#include "ui/display/display.h"
 #include "ui/gfx/gdi_util.h"
 #include "ui/gfx/geometry/skia_conversions.h"
 #include "ui/gfx/win/hwnd_util.h"
diff -r -u --color up/chromium/components/web_modal/web_contents_modal_dialog_manager.cc nw/chromium/components/web_modal/web_contents_modal_dialog_manager.cc
--- up/chromium/components/web_modal/web_contents_modal_dialog_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/web_modal/web_contents_modal_dialog_manager.cc	2024-08-26 19:32:24.214588206 +0000
@@ -45,7 +45,7 @@
 
   if (child_dialogs_.size() == 1) {
     BlockWebContentsInteraction(true);
-    if (delegate_ && delegate_->IsWebContentsVisible(web_contents()))
+    if (!web_contents()->is_silent_printing() && delegate_ && delegate_->IsWebContentsVisible(web_contents()))
       child_dialogs_.back().manager->Show();
   }
 }
@@ -110,6 +110,9 @@
     return;
   }
 
+  if (!blocked && contents->is_silent_printing())
+    contents->set_silent_printing(false);
+
   if (blocked) {
     scoped_ignore_input_events_ = contents->IgnoreInputEvents(std::nullopt);
   } else {
diff -r -u --color up/chromium/components/webdata_services/web_data_service_wrapper.cc nw/chromium/components/webdata_services/web_data_service_wrapper.cc
--- up/chromium/components/webdata_services/web_data_service_wrapper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/components/webdata_services/web_data_service_wrapper.cc	2024-08-26 19:32:24.250588201 +0000
@@ -53,12 +53,14 @@
     autofill::AutofillWebDataBackend* autofill_backend) {
   DCHECK(db_task_runner->RunsTasksInCurrentSequence());
 
+#if 0
   autofill::AutocompleteSyncBridge::CreateForWebDataServiceAndBackend(
       autofill_web_data.get(), autofill_backend);
   autofill::AutofillProfileSyncBridge::CreateForWebDataServiceAndBackend(
       app_locale, autofill_backend, autofill_web_data.get());
   autofill::ContactInfoSyncBridge::CreateForWebDataServiceAndBackend(
       autofill_backend, autofill_web_data.get());
+#endif
 }
 
 void InitWalletSyncBridgesOnDBSequence(
diff -r -u --color up/chromium/content/BUILD.gn nw/chromium/content/BUILD.gn
--- up/chromium/content/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/BUILD.gn	2024-08-26 19:32:24.286588195 +0000
@@ -61,6 +61,7 @@
 # linking problems) for when check is enabled.
 
 content_shared_components = [
+  "//content/nw:nw_base",
   "//content/gpu:gpu_sources",
   "//content/public/browser:browser_sources",
   "//content/public/child:child_sources",
@@ -78,6 +79,9 @@
   component("content") {
     public_deps =
         content_shared_components + [ "//content/public/app:app_sources" ]
+    deps = [
+      "//content/nw:nw_content",
+    ]
   }
 } else {
   group("content") {
diff -r -u --color up/chromium/content/app/content_main.cc nw/chromium/content/app/content_main.cc
--- up/chromium/content/app/content_main.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/app/content_main.cc	2024-08-26 19:32:24.286588195 +0000
@@ -4,6 +4,8 @@
 
 #include "content/public/app/content_main.h"
 
+#include "content/nw/src/nw_base.h"
+
 #include "base/allocator/partition_alloc_support.h"
 #include "base/allocator/partition_allocator/src/partition_alloc/buildflags.h"
 #include "base/at_exit.h"
@@ -134,7 +136,7 @@
   }
 #endif
 
-#if !defined(OFFICIAL_BUILD) && BUILDFLAG(IS_WIN)
+#if 0
   base::RouteStdioToConsole(false);
   LoadLibraryA("dbghelp.dll");
 #endif
@@ -245,7 +247,7 @@
 
     base::EnableTerminationOnHeapCorruption();
 
-    base::SetProcessTitleFromCommandLine(argv);
+    //base::SetProcessTitleFromCommandLine(argv);
 #endif  // !BUILDFLAG(IS_ANDROID)
 
     InitTimeTicksAtUnixEpoch();
@@ -304,7 +306,7 @@
       return exit_code;
     }
 
-#if BUILDFLAG(IS_WIN)
+#if 0 //BUILDFLAG(IS_WIN)
     base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
     if (command_line->HasSwitch(switches::kHeadless)) {
       // When running in headless mode we want stdio routed however if
@@ -332,6 +334,11 @@
     CommonSubprocessInit();
   exit_code = content_main_runner->Run();
 
+  std::string type_switch =
+    base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(switches::kProcessType);
+  if (type_switch == "renderer")
+    exit_code = nw::ExitCodeHook();
+
 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_IOS)
   content_main_runner->Shutdown();
 #endif
diff -r -u --color up/chromium/content/app/content_main_runner_impl.cc nw/chromium/content/app/content_main_runner_impl.cc
--- up/chromium/content/app/content_main_runner_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/app/content_main_runner_impl.cc	2024-08-26 19:32:24.286588195 +0000
@@ -1104,10 +1104,10 @@
   DCHECK(is_initialized_);
   DCHECK(content_main_params_);
   DCHECK(!is_shutdown_);
-  const base::CommandLine* command_line =
-      base::CommandLine::ForCurrentProcess();
+  base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
   std::string process_type =
-      command_line->GetSwitchValueASCII(switches::kProcessType);
+      command_line.GetSwitchValueASCII(switches::kProcessType);
 
 #if defined(ADDRESS_SANITIZER)
   base::debug::AsanService::GetInstance()->Initialize();
@@ -1146,7 +1146,11 @@
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
   }
 
-  MainFunctionParams main_params(command_line);
+  if (process_type.empty()) {
+    command_line.AppendSwitch(sandbox::policy::switches::kNoSandbox);
+    command_line.AppendSwitch(switches::kNoZygote);
+  }
+  MainFunctionParams main_params(&command_line);
   main_params.ui_task = std::move(content_main_params_->ui_task);
   main_params.created_main_parts_closure =
       std::move(content_main_params_->created_main_parts_closure);
diff -r -u --color up/chromium/content/app_shim_remote_cocoa/ns_view_bridge_factory_impl.mm nw/chromium/content/app_shim_remote_cocoa/ns_view_bridge_factory_impl.mm
--- up/chromium/content/app_shim_remote_cocoa/ns_view_bridge_factory_impl.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/app_shim_remote_cocoa/ns_view_bridge_factory_impl.mm	2024-08-26 19:32:24.286588195 +0000
@@ -66,6 +66,8 @@
   NSAccessibilityRemoteUIElement* __strong remote_accessibility_element_;
   void OnMojoDisconnect() { delete this; }
 
+  content::RenderWidgetHostViewMac* GetRenderWidgetHostViewMac() override { return nullptr; }
+
   std::unique_ptr<blink::WebCoalescedInputEvent> TranslateEvent(
       const blink::WebInputEvent& web_event) {
     return std::make_unique<blink::WebCoalescedInputEvent>(
diff -r -u --color up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.h nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.h
--- up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.h	2024-08-26 19:32:24.286588195 +0000
@@ -24,6 +24,8 @@
 #include "ui/base/mojom/attributed_string.mojom-forward.h"
 #include "ui/display/display_observer.h"
 
+@class CALayer;
+
 namespace remote_cocoa {
 
 // Mojo bridge for a RenderWidgetHostViewMac's NSView. This class may be
@@ -96,6 +98,7 @@
   void DisplayPopupMenu(mojom::PopupMenuPtr menu,
                         DisplayPopupMenuCallback callback) override;
 
+  CALayer* GetBackgroundLayer();
  private:
   bool IsPopup() const { return !!popup_window_; }
 
diff -r -u --color up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.mm nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.mm
--- up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.mm	2024-08-26 19:32:24.286588195 +0000
@@ -33,6 +33,11 @@
 
 using blink::WebGestureEvent;
 
+namespace content {
+  extern bool g_support_transparency;
+  extern bool g_force_cpu_draw;
+}
+
 namespace remote_cocoa {
 
 RenderWidgetHostNSViewBridge::RenderWidgetHostNSViewBridge(
@@ -50,11 +55,17 @@
   background_layer_ = [[CALayer alloc] init];
   display_ca_layer_tree_ =
       std::make_unique<ui::DisplayCALayerTree>(background_layer_);
+  bool isOpaque = [cocoa_view_ isOpaque];
+  if (content::g_support_transparency) {
+    [background_layer_ setBackgroundColor: (isOpaque || !content::g_support_transparency) ?
+      CGColorGetConstantColor(kCGColorWhite) : CGColorGetConstantColor(kCGColorClear)];
+  }
+
   cocoa_view_.layer = background_layer_;
-  cocoa_view_.wantsLayer = YES;
+  cocoa_view_.wantsLayer = !content::g_force_cpu_draw;
 
   view_id_ = std::make_unique<remote_cocoa::ScopedNSViewIdMapping>(ns_view_id,
-                                                                   cocoa_view_);
+        cocoa_view_);
 }
 
 RenderWidgetHostNSViewBridge::~RenderWidgetHostNSViewBridge() {
@@ -163,6 +174,10 @@
   if (display_disabled_)
     return;
   display_ca_layer_tree_->UpdateCALayerTree(ca_layer_params);
+  if (content::g_force_cpu_draw) {
+    // this is to tell parent window, that the window content has been updated
+    [[cocoa_view_ superview] setNeedsDisplay:YES];
+  }
 }
 
 void RenderWidgetHostNSViewBridge::SetBackgroundColor(SkColor color) {
@@ -253,6 +268,11 @@
   [cocoa_view_ updateScreenProperties];
 }
 
+CALayer* RenderWidgetHostNSViewBridge::GetBackgroundLayer() {
+  assert(content::g_force_cpu_draw);
+  return background_layer_;
+}
+
 void RenderWidgetHostNSViewBridge::DisplayCursor(const ui::Cursor& cursor) {
   [cocoa_view_ updateCursor:ui::GetNativeCursor(cursor)];
 }
diff -r -u --color up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_host_helper.h nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_host_helper.h
--- up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_host_helper.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_host_helper.h	2024-08-26 19:32:24.286588195 +0000
@@ -24,12 +24,17 @@
 struct NativeWebKeyboardEvent;
 }  // namespace input
 
+namespace content {
+class RenderWidgetHostViewMac;
+}  // namespace content
+
 namespace remote_cocoa {
 
 namespace mojom {
 class RenderWidgetHostNSViewHost;
 }  // namespace mojom
 
+
 // An interface through which the NSView for a RenderWidgetHostViewMac is to
 // communicate with the RenderWidgetHostViewMac (potentially in another
 // process). Unlike mojom::RenderWidgetHostNSViewHost, this object is always
@@ -56,6 +61,8 @@
 
   // Return the currently focused accessibility element.
   virtual id GetFocusedBrowserAccessibilityElement() = 0;
+  virtual content::RenderWidgetHostViewMac* GetRenderWidgetHostViewMac() = 0;
+
 
   // Set the NSWindow that will be the accessibility parent of the NSView.
   virtual void SetAccessibilityWindow(NSWindow* window) = 0;
diff -r -u --color up/chromium/content/app_shim_remote_cocoa/render_widget_host_view_cocoa.mm nw/chromium/content/app_shim_remote_cocoa/render_widget_host_view_cocoa.mm
--- up/chromium/content/app_shim_remote_cocoa/render_widget_host_view_cocoa.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/app_shim_remote_cocoa/render_widget_host_view_cocoa.mm	2024-08-26 19:32:24.286588195 +0000
@@ -72,6 +72,10 @@
 using remote_cocoa::RenderWidgetHostNSViewHostHelper;
 using remote_cocoa::mojom::RenderWidgetHostNSViewHost;
 
+namespace content {
+  extern bool g_force_cpu_draw;
+}
+
 namespace {
 
 constexpr NSString* WebAutomaticQuoteSubstitutionEnabled =
@@ -94,6 +98,7 @@
   DummyHostHelper& operator=(const DummyHostHelper&) = delete;
 
  private:
+  content::RenderWidgetHostViewMac* GetRenderWidgetHostViewMac() override { return nullptr; }
   // RenderWidgetHostNSViewHostHelper implementation.
   id GetAccessibilityElement() override { return nil; }
   id GetRootBrowserAccessibilityElement() override { return nil; }
@@ -744,6 +749,19 @@
   return [super forwardingTargetForSelector:selector];
 }
 
+- (void)drawRect:(NSRect)dirty {
+  if (content::g_force_cpu_draw) {
+    CGContextRef ctx = (CGContextRef)[[NSGraphicsContext currentContext] CGContext];
+    CGContextClipToRect(ctx, NSRectToCGRect(dirty));
+    //High Sierra 10.13 fix, previously we use [self layer],
+    //since we have set the layer to nil in AcceleratedWidgetMac::GotSoftwareFrame,
+    //we access the layer "directly" which is the "background_layer()" (see RenderWidgetHostViewMac constructor)
+    [_hostHelper->GetRenderWidgetHostViewMac()->background_layer() renderInContext:ctx];
+  } else {
+    [super drawRect:dirty];
+  }
+}
+
 - (void)setCanBeKeyView:(BOOL)can {
   _canBeKeyView = can;
 }
@@ -1707,8 +1725,17 @@
 }
 
 - (void)setFrameSize:(NSSize)newSize {
+  //High Sierra 10.13 fix, RenderWidgetHostViewCocoa CALayer must be nil
+  //so we can do drawRect "manually"
+  //here, we temporarily assign back the layer during resize, so the background_layer() can be resized properly
+  if (content::g_force_cpu_draw)
+    [self setLayer:_hostHelper->GetRenderWidgetHostViewMac()->background_layer()];
+
   [super setFrameSize:newSize];
   [self sendViewBoundsInWindowToHost];
+
+  if (content::g_force_cpu_draw)
+    [self setLayer:nil];
 }
 
 - (BOOL)canBecomeKeyView {
diff -r -u --color up/chromium/content/browser/BUILD.gn nw/chromium/content/browser/BUILD.gn
--- up/chromium/content/browser/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/BUILD.gn	2024-08-26 19:32:24.290588194 +0000
@@ -1934,6 +1934,8 @@
     "renderer_host/view_transition_opt_in_state.h",
     "renderer_host/visible_time_request_trigger.cc",
     "renderer_host/visible_time_request_trigger.h",
+    "resolve_proxy_helper.cc",
+    "resolve_proxy_helper.h",
     "resource_context_impl.cc",
     "resource_context_impl.h",
     "resource_coordinator_service.cc",
diff -r -u --color up/chromium/content/browser/browser_main_loop.cc nw/chromium/content/browser/browser_main_loop.cc
--- up/chromium/content/browser/browser_main_loop.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/browser_main_loop.cc	2024-08-26 19:32:24.342588187 +0000
@@ -458,6 +458,8 @@
 // The currently-running BrowserMainLoop.  There can be one or zero.
 BrowserMainLoop* g_current_browser_main_loop = nullptr;
 
+bool g_browser_main_loop_shutting_down = false;
+
 #if BUILDFLAG(IS_ANDROID)
 
 namespace {
@@ -1006,6 +1008,7 @@
   if (parts_)
     result_code_ = parts_->PreMainMessageLoopRun();
 
+#if 1
   // ShellBrowserMainParts initializes a ShellBrowserContext with user data
   // directory only in PreMainMessageLoopRun(). First-Party Sets handler needs
   // to access this directory, hence triggering after this stage has run.
@@ -1015,6 +1018,7 @@
         FirstPartySetParser::ParseFromCommandLine(
             GetRelatedWebsiteSetSwitch()));
   }
+#endif
 
   variations::MaybeScheduleFakeCrash();
 
@@ -1147,8 +1151,9 @@
       base::BindOnce(base::IgnoreResult(
           &base::PermanentThreadAllowance::AllowBaseSyncPrimitives)));
 
-  if (RenderProcessHost::run_renderer_in_process())
-    RenderProcessHostImpl::ShutDownInProcessRenderer();
+#if 1 //defined(OS_ANDROID)
+  g_browser_main_loop_shutting_down = true;
+#endif
 
   base::features::MakeFreeNoOp(
       base::features::WhenFreeBecomesNoOp::kInShutDownThreads);
@@ -1159,6 +1164,9 @@
     parts_->PostMainMessageLoopRun();
   }
 
+  if (RenderProcessHost::run_renderer_in_process())
+    RenderProcessHostImpl::ShutDownInProcessRenderer();
+
   // Request shutdown to clean up allocated resources on the IO thread.
   if (midi_service_) {
     TRACE_EVENT0("shutdown", "BrowserMainLoop::Subsystem:MidiService");
diff -r -u --color up/chromium/content/browser/browser_plugin/browser_plugin_guest.cc nw/chromium/content/browser/browser_plugin/browser_plugin_guest.cc
--- up/chromium/content/browser/browser_plugin/browser_plugin_guest.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/browser_plugin/browser_plugin_guest.cc	2024-08-26 19:32:24.342588187 +0000
@@ -4,6 +4,10 @@
 
 #include "content/browser/browser_plugin/browser_plugin_guest.h"
 
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/common/shell_switches.h"
+#include "base/files/file_util.h"
+
 #include <stddef.h>
 
 #include <utility>
@@ -77,6 +81,24 @@
 
   // Also disable drag/drop navigations.
   renderer_prefs->can_accept_load_drops = false;
+
+  base::ScopedAllowBlocking allow_io;
+  nw::Package* package = nw::package();
+  std::string js_doc_start, js_doc_end;
+  std::string* str = package->root()->FindString(::switches::kmInjectJSDocStart);
+  if (str)
+    js_doc_start = *str;
+  if (!js_doc_start.empty()) {
+    std::string fpath = base::MakeAbsoluteFilePath(package->path()).AppendASCII(js_doc_start).AsUTF8Unsafe();
+    renderer_prefs->nw_inject_js_doc_start = fpath;
+  }
+  str = package->root()->FindString(::switches::kmInjectJSDocEnd);
+  if (str)
+    js_doc_end = *str;
+  if (!js_doc_end.empty()) {
+    std::string fpath = base::MakeAbsoluteFilePath(package->path()).AppendASCII(js_doc_end).AsUTF8Unsafe();
+    renderer_prefs->nw_inject_js_doc_end = fpath;
+  }
 }
 
 BrowserPluginGuest::~BrowserPluginGuest() = default;
diff -r -u --color up/chromium/content/browser/child_process_security_policy_impl.cc nw/chromium/content/browser/child_process_security_policy_impl.cc
--- up/chromium/content/browser/child_process_security_policy_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/child_process_security_policy_impl.cc	2024-08-26 19:32:24.354588186 +0000
@@ -362,7 +362,7 @@
       BrowsingInstanceDefaultIsolationStatesMap;
 
   explicit SecurityState(BrowserContext* browser_context)
-      : enabled_bindings_(0),
+    : grant_all_(false), enabled_bindings_(0),
         can_read_raw_cookies_(false),
         can_send_midi_(false),
         can_send_midi_sysex_(false),
@@ -407,6 +407,10 @@
     scheme_map_[scheme] = CommitRequestPolicy::kCommitAndRequest;
   }
 
+  void GrantAll() {
+    grant_all_ = true;
+  }
+
   void GrantRequestScheme(const std::string& scheme) {
     // Anything already in |scheme_map_| must have at least request permission
     // already. In that case, the emplace() below will be a no-op.
@@ -501,6 +505,8 @@
   bool CanCommitURL(const GURL& url) {
     DCHECK(!url.SchemeIsBlob() && !url.SchemeIsFileSystem())
         << "inner_url extraction should be done already.";
+    if (grant_all_)
+      return true;
     // Having permission to a scheme implies permission to all of its URLs.
     auto scheme_judgment = scheme_map_.find(url.scheme());
     if (scheme_judgment != scheme_map_.end() &&
@@ -548,6 +554,8 @@
     if (file.IsContentUri())
       return HasPermissionsForContentUri(file, permissions);
 #endif
+    if (grant_all_)
+      return true;
     if (!permissions || file.empty() || !file.IsAbsolute())
       return false;
     base::FilePath current_path = file.StripTrailingSeparators();
@@ -712,6 +720,8 @@
   // granted. There is no provision for revoking.
   SchemeMap scheme_map_;
 
+  bool grant_all_;
+
   // The map of URL origins to commit/request policies the child process has
   // been granted. There is no provision for revoking.
   OriginMap origin_map_;
@@ -861,7 +871,7 @@
   // IsWebSafeScheme(), and then eliminate the next two lines.
   RegisterWebSafeScheme(url::kBlobScheme);
   RegisterWebSafeScheme(url::kFileSystemScheme);
-
+  //RegisterWebSafeScheme("chrome-devtools");
   // We know about the following pseudo schemes and treat them specially.
   RegisterPseudoScheme(url::kAboutScheme);
   RegisterPseudoScheme(url::kJavaScriptScheme);
@@ -1063,6 +1073,15 @@
   }
 }
 
+void ChildProcessSecurityPolicyImpl::GrantAll(int child_id) {
+  base::AutoLock lock(lock_);
+  SecurityStateMap::iterator state = security_state_.find(child_id);
+  if (state == security_state_.end())
+    return;
+
+  state->second->GrantAll();
+}
+
 void ChildProcessSecurityPolicyImpl::GrantReadFile(int child_id,
                                                    const base::FilePath& file) {
   GrantPermissionsForFile(child_id, file, READ_FILE_GRANT);
diff -r -u --color up/chromium/content/browser/child_process_security_policy_impl.h nw/chromium/content/browser/child_process_security_policy_impl.h
--- up/chromium/content/browser/child_process_security_policy_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/child_process_security_policy_impl.h	2024-08-26 19:32:24.354588186 +0000
@@ -134,6 +134,7 @@
   static ChildProcessSecurityPolicyImpl* GetInstance();
 
   // ChildProcessSecurityPolicy implementation.
+  void GrantAll(int child_id) override;
   void RegisterWebSafeScheme(const std::string& scheme) override;
   void RegisterWebSafeIsolatedScheme(
       const std::string& scheme,
diff -r -u --color up/chromium/content/browser/devtools/devtools_http_handler.cc nw/chromium/content/browser/devtools/devtools_http_handler.cc
--- up/chromium/content/browser/devtools/devtools_http_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/devtools/devtools_http_handler.cc	2024-08-26 19:32:24.366588184 +0000
@@ -49,6 +49,8 @@
 #include "content/public/browser/devtools_frontend_host.h"
 #include "content/public/browser/devtools_manager_delegate.h"
 #include "content/public/browser/devtools_socket_factory.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
 #include "content/public/common/content_client.h"
 #include "content/public/common/content_switches.h"
 #include "content/public/common/url_constants.h"
@@ -80,10 +82,14 @@
 const base::FilePath::CharType kDevToolsActivePortFileName[] =
     FILE_PATH_LITERAL("DevToolsActivePort");
 
+#if defined(NWJS_SDK)
 const char kDevToolsHandlerThreadName[] = "Chrome_DevToolsHandlerThread";
+#endif
 
 const char kPageUrlPrefix[] = "/devtools/page/";
+#if defined(NWJS_SDK)
 const char kBrowserUrlPrefix[] = "/devtools/browser";
+#endif
 
 const char kTargetIdField[] = "id";
 const char kTargetParentIdField[] = "parentId";
@@ -728,6 +734,10 @@
   std::sort(agent_hosts.begin(), agent_hosts.end(), TimeComparator);
   base::Value::List list_value;
   for (auto& agent_host : agent_hosts) {
+    WebContents* web_contents = agent_host->GetWebContents();
+    if (web_contents && web_contents->GetPrimaryMainFrame())
+      if (!web_contents->GetPrimaryMainFrame()->context_created())
+        continue;
     if (agent_host->GetType() != DevToolsAgentHost::kTypeTab || for_tab) {
       list_value.Append(SerializeDescriptor(agent_host, host));
     }
@@ -833,6 +843,7 @@
     const base::FilePath& output_directory,
     const base::FilePath& debug_frontend_dir)
     : delegate_(delegate) {
+#if defined(NWJS_SDK)
   browser_guid_ =
       delegate_->IsBrowserTargetDiscoverable()
           ? kBrowserUrlPrefix
@@ -860,6 +871,7 @@
       base::SplitString(remote_allow_origins, ",", base::TRIM_WHITESPACE,
                         base::SPLIT_WANT_NONEMPTY);
   remote_allow_origins_.insert(origins.begin(), origins.end());
+#endif
 }
 
 void DevToolsHttpHandler::ServerStarted(
diff -r -u --color up/chromium/content/browser/devtools/protocol/emulation_handler.cc nw/chromium/content/browser/devtools/protocol/emulation_handler.cc
--- up/chromium/content/browser/devtools/protocol/emulation_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/devtools/protocol/emulation_handler.cc	2024-08-26 19:32:24.370588183 +0000
@@ -997,6 +997,7 @@
   if (touch_emulation_enabled_) {
     if (auto* touch_emulator = host_->GetRenderWidgetHost()->GetTouchEmulator(
             /*create_if_necessary=*/true)) {
+      touch_emulator->set_rfh_limit(host_->GetWeakPtr());
       touch_emulator->Enable(
           input::TouchEmulator::Mode::kEmulatingTouchFromMouse,
           TouchEmulationConfigurationToType(touch_emulation_configuration_));
@@ -1005,6 +1006,7 @@
     if (auto* touch_emulator = host_->GetRenderWidgetHost()->GetTouchEmulator(
             /*create_if_necessary=*/true)) {
       touch_emulator->Disable();
+      touch_emulator->set_rfh_limit(nullptr);
     }
   }
   GetWebContents()->SetForceDisableOverscrollContent(touch_emulation_enabled_);
diff -r -u --color up/chromium/content/browser/devtools/render_frame_devtools_agent_host.cc nw/chromium/content/browser/devtools/render_frame_devtools_agent_host.cc
--- up/chromium/content/browser/devtools/render_frame_devtools_agent_host.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/devtools/render_frame_devtools_agent_host.cc	2024-08-26 19:32:24.374588182 +0000
@@ -249,6 +249,8 @@
   }
   RenderProcessHost* rph = rfh->GetProcess();
   std::set<url::Origin> process_origins;
+  std::set<url::Origin> opaque_process_origins;
+  opaque_process_origins.insert(url::Origin());
   for (const auto& entry : g_agent_host_instances.Get()) {
     RenderFrameHostImpl* frame_host = entry.second->frame_host_;
     if (!frame_host)
@@ -263,7 +265,8 @@
   }
   GetNetworkService()->SetRawHeadersAccess(
       rph->GetID(),
-      std::vector<url::Origin>(process_origins.begin(), process_origins.end()));
+      std::vector<url::Origin>(opaque_process_origins.begin(),
+                               opaque_process_origins.end()));
 }
 
 RenderFrameDevToolsAgentHost::RenderFrameDevToolsAgentHost(
@@ -352,6 +355,9 @@
 #if BUILDFLAG(USE_VIZ_DEBUGGER)
   session->CreateAndAddHandler<protocol::VisualDebuggerHandler>();
 #endif
+  RenderWidgetHostViewBase* view =
+    static_cast<RenderWidgetHostViewBase*>(web_contents()->GetPrimaryMainFrame()->GetView());
+  if (!view->IsRenderWidgetHostViewChildFrame())
   if (!frame_tree_node_ || !frame_tree_node_->parent())
     session->CreateAndAddHandler<protocol::OverlayHandler>();
   session->CreateAndAddHandler<protocol::NetworkHandler>(
diff -r -u --color up/chromium/content/browser/gpu/gpu_process_host.cc nw/chromium/content/browser/gpu/gpu_process_host.cc
--- up/chromium/content/browser/gpu/gpu_process_host.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/gpu/gpu_process_host.cc	2024-08-26 19:32:24.402588178 +0000
@@ -758,7 +758,8 @@
       valid_(true),
       in_process_(false),
       kind_(kind),
-      process_launched_(false) {
+      process_launched_(false),
+      closing_(false) {
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kSingleProcess) ||
       base::CommandLine::ForCurrentProcess()->HasSwitch(
@@ -790,6 +791,7 @@
   if (in_process_gpu_thread_)
     DCHECK(process_);
 
+  closing_ = true;
   SendOutstandingReplies();
 
 #if BUILDFLAG(IS_MAC)
@@ -918,6 +920,8 @@
 bool GpuProcessHost::Init() {
   init_start_time_ = base::TimeTicks::Now();
 
+  if (in_process_ && closing_)
+    return true;
   TRACE_EVENT_INSTANT0("gpu", "LaunchGpuProcess", TRACE_EVENT_SCOPE_THREAD);
 
   process_->GetHost()->CreateChannelMojo();
diff -r -u --color up/chromium/content/browser/gpu/gpu_process_host.h nw/chromium/content/browser/gpu/gpu_process_host.h
--- up/chromium/content/browser/gpu/gpu_process_host.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/gpu/gpu_process_host.h	2024-08-26 19:32:24.402588178 +0000
@@ -247,6 +247,8 @@
   // The GPU process reported failure to initialize.
   bool did_fail_initialize_ = false;
 
+  bool closing_;
+
   // The total number of GPU process crashes.
   static base::subtle::Atomic32 gpu_crash_count_;
   static bool crashed_before_;
diff -r -u --color up/chromium/content/browser/interest_group/interest_group_auction.cc nw/chromium/content/browser/interest_group/interest_group_auction.cc
--- up/chromium/content/browser/interest_group/interest_group_auction.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/interest_group/interest_group_auction.cc	2024-08-26 19:32:24.426588175 +0000
@@ -1539,10 +1539,12 @@
       // owned by `generate_bid_client_receiver_set_`, deleting the bid isn't
       // sufficient.
       CloseBidStatePipes(*bid_states_[i]);
+#if 0
       if (bid_states_[i]->trace_id) {
         TRACE_EVENT_NESTABLE_ASYNC_INSTANT0("fledge", "bid_exceeds_size_limit",
                                             *bid_states_[i]->trace_id);
       }
+#endif
     }
     auction_->auction_metrics_recorder_->RecordBidsFilteredByPerBuyerLimits(
         bid_states_.size() - size_limit_);
@@ -1767,10 +1769,12 @@
     UMA_HISTOGRAM_BOOLEAN("Ads.InterestGroup.Auction.BidFiltered",
                           bid_filtered);
     if (bid_filtered) {
+#if 0
       if (state->trace_id) {
         TRACE_EVENT_NESTABLE_ASYNC_INSTANT0("fledge", "bid_filtered",
                                             *state->trace_id);
       }
+#endif
       // Record if there are other bidders, as if there are not, the next call
       // may delete `this`.
       bool other_bidders = (num_outstanding_bids_ > 1);
diff -r -u --color up/chromium/content/browser/media/capture/desktop_streams_registry_impl.cc nw/chromium/content/browser/media/capture/desktop_streams_registry_impl.cc
--- up/chromium/content/browser/media/capture/desktop_streams_registry_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/media/capture/desktop_streams_registry_impl.cc	2024-08-26 19:32:24.450588172 +0000
@@ -74,7 +74,7 @@
     int render_process_id,
     int render_frame_id,
     const url::Origin& origin,
-    const DesktopStreamRegistryType type) {
+    const DesktopStreamRegistryType type, bool nodejs) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
   auto it = approved_streams_.find(id);
@@ -84,9 +84,9 @@
   // render frame.
   if (it == approved_streams_.end() ||
       render_process_id != it->second.render_process_id ||
-      (it->second.restrict_to_render_frame_id &&
+      (!nodejs && it->second.restrict_to_render_frame_id &&
        render_frame_id != it->second.restrict_to_render_frame_id) ||
-      origin != it->second.origin || type != it->second.type) {
+      (!nodejs && origin != it->second.origin) || type != it->second.type) {
     return DesktopMediaID();
   }
 
diff -r -u --color up/chromium/content/browser/media/capture/desktop_streams_registry_impl.h nw/chromium/content/browser/media/capture/desktop_streams_registry_impl.h
--- up/chromium/content/browser/media/capture/desktop_streams_registry_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/media/capture/desktop_streams_registry_impl.h	2024-08-26 19:32:24.450588172 +0000
@@ -39,7 +39,7 @@
       int render_process_id,
       int render_frame_id,
       const url::Origin& origin,
-      const DesktopStreamRegistryType type) override;
+      const DesktopStreamRegistryType type, bool nodejs = false) override;
 
  private:
   // Type used to store list of accepted desktop media streams.
diff -r -u --color up/chromium/content/browser/renderer_host/ancestor_throttle.cc nw/chromium/content/browser/renderer_host/ancestor_throttle.cc
--- up/chromium/content/browser/renderer_host/ancestor_throttle.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/ancestor_throttle.cc	2024-08-26 19:32:24.502588164 +0000
@@ -248,6 +248,8 @@
   NavigationRequest* request = NavigationRequest::From(navigation_handle());
   network::mojom::XFrameOptionsValue disposition =
       request->response()->parsed_headers->xfo;
+  if (request->frame_tree_node()->frame_owner_properties().nwfaketop)
+    return CheckResult::PROCEED;
 
   // If 'X-Frame-Options' would potentially block the response, check whether
   // the 'frame-ancestors' CSP directive should take effect instead. See
@@ -355,7 +357,13 @@
       request, static_cast<RenderFrameHostImpl*>(
                    navigation_handle()->GetRenderFrameHost()));
 
+  if (static_cast<RenderFrameHostImpl*>(navigation_handle()->GetRenderFrameHost())->
+      frame_tree_node()->frame_owner_properties().nwfaketop)
+    return CheckResult::PROCEED;
+
   while (parent) {
+    if (parent->frame_tree_node()->frame_owner_properties().nwfaketop)
+      break;
     // CSP violations (if any) are reported via the disallowed ancestor of the
     // navigated frame (because while the throttle runs the navigation hasn't
     // committed yet and the target frame might not yet have a URLLoaderFactory
diff -r -u --color up/chromium/content/browser/renderer_host/input/touch_emulator_impl.cc nw/chromium/content/browser/renderer_host/input/touch_emulator_impl.cc
--- up/chromium/content/browser/renderer_host/input/touch_emulator_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/input/touch_emulator_impl.cc	2024-08-26 19:32:24.518588161 +0000
@@ -6,6 +6,8 @@
 
 #include <memory>
 #include <utility>
+#include "content/public/browser/render_frame_host.h"
+#include "content/browser/renderer_host/render_frame_host_impl.h"
 
 #include "base/containers/queue.h"
 #include "base/time/time.h"
@@ -72,6 +74,7 @@
 TouchEmulatorImpl::TouchEmulatorImpl(input::TouchEmulatorClient* client,
                                      float device_scale_factor)
     : client_(client),
+      rfh_limit_(nullptr),
       gesture_provider_config_type_(
           ui::GestureProviderConfigType::CURRENT_PLATFORM),
       double_tap_enabled_(true),
@@ -187,6 +190,11 @@
   if (!IsEnabled() || mode_ != Mode::kEmulatingTouchFromMouse)
     return false;
 
+  if (rfh_limit_) {
+    if (rfh_limit_->GetView() != target_view)
+      return false;
+  }
+
   UpdateCursor();
 
   if (mouse_event.button == WebMouseEvent::Button::kRight &&
diff -r -u --color up/chromium/content/browser/renderer_host/input/touch_emulator_impl.h nw/chromium/content/browser/renderer_host/input/touch_emulator_impl.h
--- up/chromium/content/browser/renderer_host/input/touch_emulator_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/input/touch_emulator_impl.h	2024-08-26 19:32:24.518588161 +0000
@@ -7,6 +7,8 @@
 
 #include <memory>
 
+#include "base/memory/weak_ptr.h"
+
 #include "base/containers/queue.h"
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
@@ -31,6 +33,10 @@
 
 namespace content {
 
+class RenderWidgetHostViewInput;
+class RenderFrameHost;
+class RenderFrameHostImpl;
+
 class CONTENT_EXPORT TouchEmulatorImpl : public input::TouchEmulator {
  public:
   TouchEmulatorImpl(input::TouchEmulatorClient* client,
@@ -58,6 +64,9 @@
   void Enable(Mode mode, ui::GestureProviderConfigType config_type);
   void Disable();
 
+  void set_rfh_limit(base::WeakPtr<RenderFrameHostImpl> rfh) { rfh_limit_ = rfh; }
+  RenderFrameHost* rfh_limit() const { return (RenderFrameHost*)rfh_limit_.get(); }
+
   // Returns |true| if the event was consumed. Consumed event should not
   // propagate any further.
   // TODO(dgozman): maybe pass latency info together with events.
@@ -120,6 +129,7 @@
 
   const raw_ptr<input::TouchEmulatorClient> client_;
 
+  base::WeakPtr<RenderFrameHostImpl> rfh_limit_;
   // Emulator is enabled iff gesture provider is created.
   // Disabled emulator does only process touch acks left from previous
   // emulation. It does not intercept any events.
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_controller_impl.cc nw/chromium/content/browser/renderer_host/navigation_controller_impl.cc
--- up/chromium/content/browser/renderer_host/navigation_controller_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_controller_impl.cc	2024-08-26 19:32:24.530588160 +0000
@@ -300,6 +300,7 @@
     return false;
   }
 
+#if 0 //nwjs: fails issue6229-webview-executeScript
   // Guests only support navigations to known-safe schemes. This check already
   // exists in the extensions layer, where it also dispatches proper events to
   // the guest's embedder (see WebViewGuest::LoadURLWithParams).  This check is
@@ -315,6 +316,7 @@
       return false;
     }
   }
+#endif
 
   return true;
 }
@@ -801,7 +803,7 @@
     BrowserContext* browser_context,
     FrameTree& frame_tree,
     NavigationControllerDelegate* delegate)
-    : frame_tree_(frame_tree),
+  : history_initiator_(nullptr), frame_tree_(frame_tree),
       browser_context_(browser_context),
       delegate_(delegate),
       ssl_manager_(this),
@@ -3363,6 +3365,12 @@
   // function.
   std::unique_ptr<PendingEntryRef> pending_entry_ref = ReferencePendingEntry();
 
+  FrameTreeNode* nwfaketop_node = nullptr;
+  if (history_initiator_) {
+    if (history_initiator_->frame_tree_node()->frame_owner_properties().nwfaketop)
+      nwfaketop_node = history_initiator_->frame_tree_node();
+  }
+
   // If there is a main-frame same-document history navigation, we may defer
   // the subframe history navigations in order to give JS in the main frame the
   // opportunity to cancel the entire traverse via the navigate event. In that
@@ -3399,6 +3407,8 @@
   // Send all the same document frame loads before the different document loads.
   for (auto& item : same_document_loads) {
     FrameTreeNode* frame = item->frame_tree_node();
+    if (nwfaketop_node && nwfaketop_node->current_frame_host()->IsDescendantOfWithinFrameTree(frame->current_frame_host()))
+      continue;
     // The request could be destroyed before `navigator().Navigate()` returns.
     base::WeakPtr<NavigationRequest> request = item->GetWeakPtr();
     frame->navigator().Navigate(std::move(item), reload_type);
@@ -3410,6 +3420,8 @@
   }
   for (auto& item : different_document_loads) {
     FrameTreeNode* frame = item->frame_tree_node();
+    if (nwfaketop_node && nwfaketop_node->current_frame_host()->IsDescendantOfWithinFrameTree(frame->current_frame_host()))
+      continue;
     base::WeakPtr<NavigationRequest> request = item->GetWeakPtr();
     frame->navigator().Navigate(std::move(item), reload_type);
     if (request && request->IsInPrimaryMainFrame()) {
@@ -4004,6 +4016,7 @@
           network::mojom::CSPDisposition::CHECK, std::vector<int>(),
           params.href_translate,
           false /* is_history_navigation_in_new_child_frame */,
+	  params.block_parser,
           params.input_start, network::mojom::RequestDestination::kEmpty);
 
   blink::mojom::CommitNavigationParamsPtr commit_params =
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_controller_impl.h nw/chromium/content/browser/renderer_host/navigation_controller_impl.h
--- up/chromium/content/browser/renderer_host/navigation_controller_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_controller_impl.h	2024-08-26 19:32:24.530588160 +0000
@@ -89,6 +89,7 @@
     base::WeakPtr<NavigationControllerImpl> controller_;
   };
 
+  void set_history_initiator(RenderFrameHostImpl* frame_host) { history_initiator_ = frame_host; }
   NavigationControllerImpl(BrowserContext* browser_context,
                            FrameTree& frame_tree,
                            NavigationControllerDelegate* delegate);
@@ -500,6 +501,7 @@
  private:
   friend class RestoreHelper;
 
+  raw_ptr<RenderFrameHostImpl> history_initiator_;
   FRIEND_TEST_ALL_PREFIXES(TimeSmoother, Basic);
   FRIEND_TEST_ALL_PREFIXES(TimeSmoother, SingleDuplicate);
   FRIEND_TEST_ALL_PREFIXES(TimeSmoother, ManyDuplicates);
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_entry_impl.cc nw/chromium/content/browser/renderer_host/navigation_entry_impl.cc
--- up/chromium/content/browser/renderer_host/navigation_entry_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_entry_impl.cc	2024-08-26 19:32:24.538588159 +0000
@@ -909,7 +909,7 @@
       network::mojom::SourceLocation::New(), has_started_from_context_menu(),
       has_user_gesture(), false /* has_text_fragment_token */,
       network::mojom::CSPDisposition::CHECK, std::vector<int>(), std::string(),
-      false /* is_history_navigation_in_new_child_frame */, input_start,
+      false /* is_history_navigation_in_new_child_frame */, false, input_start,
       network::mojom::RequestDestination::kEmpty);
 }
 
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_request.cc nw/chromium/content/browser/renderer_host/navigation_request.cc
--- up/chromium/content/browser/renderer_host/navigation_request.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_request.cc	2024-08-26 19:32:24.542588159 +0000
@@ -216,6 +216,11 @@
 #include "ui/android/window_android_compositor.h"
 #endif
 
+namespace nw {
+  typedef bool(*RphGuestFilterURLHookFn)(content::RenderProcessHost* rph, const GURL* url);
+  extern RphGuestFilterURLHookFn gRphGuestFilterURLHook;
+}
+
 namespace content {
 
 namespace {
@@ -1500,6 +1505,7 @@
           std::vector<int>() /* initiator_origin_trial_features */,
           std::string() /* href_translate */,
           false /* is_history_navigation_in_new_child_frame */,
+	  false,
           base::TimeTicks::Now() /* input_start */,
           network::mojom::RequestDestination::kEmpty);
   // Note that some params are set to default values (e.g. page_state set to
@@ -1939,6 +1945,16 @@
           common_params_->url);
       headers.MergeFrom(client_hints_headers);
     }
+    FrameTreeNode* node = frame_tree_node;
+    std::string user_agent_override = GetUserAgentOverride();
+    while (node) {
+      const std::string& nwuseragent = node->frame_owner_properties().nwuseragent;
+      if (!nwuseragent.empty()) {
+        user_agent_override = nwuseragent;
+        break;
+      }
+      node = FrameTreeNode::From(node->parent());
+    }
 
     // Add reduced accept language header.
     if (auto reduce_accept_lang_utils =
@@ -1966,7 +1982,7 @@
         &headers, common_params_->url, common_params_->navigation_type,
         ui::PageTransitionFromInt(common_params_->transition),
         controller->GetBrowserContext(), common_params_->method,
-        GetUserAgentOverride(), common_params_->initiator_origin,
+        user_agent_override, common_params_->initiator_origin,
         common_params_->referrer.get(), frame_tree_node);
 
     if (begin_params_->is_form_submission) {
@@ -5217,6 +5233,17 @@
   if (navigation_ui_data_)
     navigation_ui_data = navigation_ui_data_->Clone();
 
+  bool nw_trusted = false;
+  if (starting_site_instance_->IsGuest()) {
+    GURL dummy;
+    RenderFrameHostImpl* navigating_frame_host =
+      associated_rfh_type_ == AssociatedRenderFrameHostType::SPECULATIVE
+          ? frame_tree_node_->render_manager()->speculative_frame_host()
+          : frame_tree_node_->current_frame_host();
+    RenderProcessHost* render_process_host = navigating_frame_host->GetProcess();
+    if (nw::gRphGuestFilterURLHook && nw::gRphGuestFilterURLHook(render_process_host, &dummy))
+      nw_trusted = true;
+  }
   // Give DevTools a chance to override begin params (headers, skip SW)
   // before actually loading resource.
   bool report_raw_headers = false;
@@ -5313,7 +5340,7 @@
           std::move(serving_page_metrics_container),
           allow_cookies_from_browser_, navigation_id_,
           shared_storage_writable_eligible_, is_ad_tagged_,
-          force_no_https_upgrade_),
+          force_no_https_upgrade_, nw_trusted),
       std::move(navigation_ui_data), service_worker_handle_.get(),
       std::move(prefetched_signed_exchange_cache_), this, loader_type,
       CreateCookieAccessObserver(), CreateTrustTokenAccessObserver(),
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_request_info.cc nw/chromium/content/browser/renderer_host/navigation_request_info.cc
--- up/chromium/content/browser/renderer_host/navigation_request_info.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_request_info.cc	2024-08-26 19:32:24.542588159 +0000
@@ -39,7 +39,8 @@
     int64_t navigation_id,
     bool shared_storage_writable_eligible,
     bool is_ad_tagged,
-    bool force_no_https_upgrade)
+    bool force_no_https_upgrade,
+    bool nw_trusted)
     : common_params(std::move(common_params)),
       begin_params(std::move(begin_params)),
       sandbox_flags(sandbox_flags),
@@ -67,7 +68,8 @@
       navigation_id(navigation_id),
       shared_storage_writable_eligible(shared_storage_writable_eligible),
       is_ad_tagged(is_ad_tagged),
-      force_no_https_upgrade(force_no_https_upgrade) {}
+      force_no_https_upgrade(force_no_https_upgrade),
+      nw_trusted(nw_trusted) {}
 
 NavigationRequestInfo::~NavigationRequestInfo() {}
 
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_request_info.h nw/chromium/content/browser/renderer_host/navigation_request_info.h
--- up/chromium/content/browser/renderer_host/navigation_request_info.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_request_info.h	2024-08-26 19:32:24.542588159 +0000
@@ -60,7 +60,8 @@
       int64_t navigation_id,
       bool shared_storage_writable,
       bool is_ad_tagged,
-      bool force_no_https_upgrade);
+      bool force_no_https_upgrade,
+      bool nw_trust = false);
   NavigationRequestInfo(const NavigationRequestInfo& other) = delete;
   ~NavigationRequestInfo();
 
@@ -172,6 +173,8 @@
 
   // If true, the navigation will not be upgraded to HTTPS.
   bool force_no_https_upgrade;
+
+  bool nw_trusted;
 };
 
 }  // namespace content
diff -r -u --color up/chromium/content/browser/renderer_host/navigator.cc nw/chromium/content/browser/renderer_host/navigator.cc
--- up/chromium/content/browser/renderer_host/navigator.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigator.cc	2024-08-26 19:32:24.546588157 +0000
@@ -61,6 +61,11 @@
 #include "url/gurl.h"
 #include "url/url_util.h"
 
+namespace nw {
+  typedef bool(*RphGuestFilterURLHookFn)(content::RenderProcessHost* rph, const GURL* url);
+  extern RphGuestFilterURLHookFn gRphGuestFilterURLHook;
+}
+
 namespace content {
 
 namespace {
diff -r -u --color up/chromium/content/browser/renderer_host/render_frame_host_delegate.h nw/chromium/content/browser/renderer_host/render_frame_host_delegate.h
--- up/chromium/content/browser/renderer_host/render_frame_host_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_frame_host_delegate.h	2024-08-26 19:32:24.554588157 +0000
@@ -441,7 +441,7 @@
       int main_frame_widget_route_id,
       WindowOpenDisposition disposition,
       const blink::mojom::WindowFeatures& window_features,
-      bool user_gesture) {}
+      bool user_gesture, std::string manifest) {}
 
   // The main frame document element is ready. This happens when the document
   // has finished parsing.
diff -r -u --color up/chromium/content/browser/renderer_host/render_frame_host_impl.cc nw/chromium/content/browser/renderer_host/render_frame_host_impl.cc
--- up/chromium/content/browser/renderer_host/render_frame_host_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_frame_host_impl.cc	2024-08-26 19:32:24.554588157 +0000
@@ -1,9 +1,12 @@
 // Copyright 2013 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "content/browser/renderer_host/render_frame_host_impl.h"
 
+#include "content/public/browser/web_contents_delegate.h"
+
 #include <cstdint>
 #include <deque>
 #include <limits>
@@ -1848,6 +1851,14 @@
   return nullptr;
 }
 
+void RenderFrameHostImpl::SetNodeJS(bool node) {
+  nodejs_ = node;
+}
+
+void RenderFrameHostImpl::SetContextCreated(bool created) {
+  context_created_ = created;
+}
+
 RenderFrameHostImpl::RenderFrameHostImpl(
     SiteInstance* site_instance,
     scoped_refptr<RenderViewHostImpl> render_view_host,
@@ -1880,6 +1891,8 @@
       last_committed_url_derived_site_info_(
           site_instance_->GetBrowserContext()),
       routing_id_(routing_id),
+      nodejs_(false),
+      context_created_(false),
       beforeunload_timeout_delay_(kUnloadTimeout),
       frame_(std::move(frame_remote)),
       waiting_for_init_(renderer_initiated_creation_of_main_frame),
@@ -2263,6 +2276,21 @@
   return storage_key_;
 }
 
+bool RenderFrameHostImpl::nodejs() {
+  return nodejs_;
+}
+
+bool RenderFrameHostImpl::context_created() {
+  return context_created_;
+}
+
+bool RenderFrameHostImpl::skip_blocking_parser() const {
+  return skip_blocking_parser_;
+}
+void RenderFrameHostImpl::set_skip_blocking_parser(bool flag) {
+  skip_blocking_parser_ = flag;
+}
+
 int RenderFrameHostImpl::GetRoutingID() const {
   return routing_id_;
 }
@@ -3704,6 +3732,9 @@
   NavigationRequest* navigation_request =
       frame_tree_node()->navigation_request();
 
+  if (navigation_request) {
+    params->block_parser = navigation_request->common_params().block_parser;
+  }
   bool should_clear_browsing_instance_name =
       navigation_request &&
       (navigation_request->browsing_context_group_swap()
@@ -4490,7 +4521,8 @@
 
 const url::Origin& RenderFrameHostImpl::ComputeTopFrameOrigin(
     const url::Origin& frame_origin) const {
-  if (is_main_frame()) {
+  if (is_main_frame()
+      || frame_tree_node_->frame_owner_properties().nwfaketop) {
     return frame_origin;
   }
 
@@ -4522,8 +4554,9 @@
     bool is_credentialless,
     std::optional<base::UnguessableToken> fenced_frame_nonce_for_navigation) {
   net::IsolationInfo::RequestType request_type =
-      is_main_frame() ? net::IsolationInfo::RequestType::kMainFrame
-                      : net::IsolationInfo::RequestType::kSubFrame;
+    (is_main_frame() || frame_tree_node_->frame_owner_properties().nwfaketop)
+          ? net::IsolationInfo::RequestType::kMainFrame
+          : net::IsolationInfo::RequestType::kSubFrame;
   return ComputeIsolationInfoInternal(url::Origin::Create(destination),
                                       request_type, is_credentialless,
                                       fenced_frame_nonce_for_navigation);
@@ -4549,6 +4582,8 @@
     bool is_credentialless,
     std::optional<base::UnguessableToken> fenced_frame_nonce_for_navigation) {
   url::Origin top_frame_origin = ComputeTopFrameOrigin(frame_origin);
+  if (frame_tree_node_->frame_owner_properties().nwfaketop)
+    top_frame_origin = frame_tree_node_->current_frame_host()->GetLastCommittedOrigin();
   net::SchemefulSite top_frame_site = net::SchemefulSite(top_frame_origin);
 
   net::SiteForCookies candidate_site_for_cookies(top_frame_site);
@@ -4567,6 +4602,8 @@
     initial_rfh = this->parent_;
 
   for (const RenderFrameHostImpl* rfh = initial_rfh; rfh; rfh = rfh->parent_) {
+    if (rfh->frame_tree_node_->frame_owner_properties().nwfaketop)
+      break;
     const url::Origin& cur_origin =
         rfh == this ? frame_origin : rfh->last_committed_origin_;
     net::SchemefulSite cur_site = net::SchemefulSite(cur_origin);
@@ -6524,9 +6561,11 @@
     WindowOpenDisposition disposition,
     blink::mojom::WindowFeaturesPtr window_features,
     bool user_gesture,
+    const std::u16string& in_manifest,
     ShowCreatedWindowCallback callback) {
   // This needs to be sent to the opener frame's delegate since it stores
   // the handle to this class's associated RenderWidgetHostView.
+  std::string manifest = base::UTF16ToUTF8(in_manifest);
   RenderFrameHostImpl* opener_frame_host =
       FromFrameToken(GetProcess()->GetID(), opener_frame_token);
 
@@ -6540,7 +6579,7 @@
   }
   opener_frame_host->delegate()->ShowCreatedWindow(
       opener_frame_host, GetRenderWidgetHost()->GetRoutingID(), disposition,
-      *window_features, user_gesture);
+      *window_features, user_gesture, manifest);
   std::move(callback).Run();
 }
 
@@ -6791,7 +6830,7 @@
 
 void RenderFrameHostImpl::AllowBindings(int bindings_flags) {
   // Never grant any bindings to browser plugin guests.
-  if (GetProcess()->IsForGuestsOnly()) {
+  if (false && GetProcess()->IsForGuestsOnly()) {
     NOTREACHED_IN_MIGRATION() << "Never grant bindings to a guest process.";
     return;
   }
@@ -6905,6 +6944,8 @@
 
 bool RenderFrameHostImpl::IsFeatureEnabled(
     blink::mojom::PermissionsPolicyFeature feature) {
+  if (nodejs_)
+    return true; //NWJS#6696
   return permissions_policy_ && permissions_policy_->IsFeatureEnabledForOrigin(
                                     feature, GetLastCommittedOrigin());
 }
@@ -7513,8 +7554,10 @@
 
   // All frames are allowed to navigate the global history.
   if (delegate_->IsAllowedToGoToEntryAtOffset(offset)) {
+    frame_tree_->controller().set_history_initiator(this);
     frame_tree_->controller().GoToOffsetFromRenderer(
         offset, this, soft_navigation_heuristics_task_id);
+    frame_tree_->controller().set_history_initiator(nullptr);
   }
 }
 
@@ -7910,7 +7953,7 @@
 
   // Entering fullscreen generally requires a transient user activation signal,
   // or another feature-specific transient allowance.
-  if (delegate_->IsTransientActivationRequiredForHtmlFullscreen() &&
+  if (!nodejs_ && delegate_->IsTransientActivationRequiredForHtmlFullscreen() &&
       !HasSeenRecentXrOverlaySetup()) {
     // Reject requests made without transient user activation or a token.
     // TODO(lanwei): Investigate whether we can terminate the renderer when
@@ -11283,8 +11326,16 @@
     subresource_loader_factories->pending_default_factory() =
         std::move(pending_default_factory);
 
+    bool can_load_file_subresource = false;
+    WebContents* web_contents = WebContents::FromRenderFrameHost(this);
+    if (web_contents) {
+      auto* delegate = web_contents->GetDelegate();
+      if (delegate && delegate->CanLoadFileSubresource(common_params->url))
+        can_load_file_subresource = true;
+    }
+
     // Only documents from a file precursor scheme can load file subresoruces.
-    if (effective_scheme == url::kFileScheme) {
+    if (can_load_file_subresource || effective_scheme == url::kFileScheme) {
       // USER_BLOCKING because this scenario is exactly one of the examples
       // given by the doc comment for USER_BLOCKING: Loading and rendering a web
       // page after the user clicks a link.
@@ -11767,7 +11818,7 @@
   web_ui_->SetRenderFrameHost(this);
 
   // It is not expected for GuestView to be able to navigate to WebUI.
-  DCHECK(!GetProcess()->IsForGuestsOnly());
+  //DCHECK(!GetProcess()->IsForGuestsOnly());
 
   web_ui_type_ = new_web_ui_type;
 
@@ -13519,7 +13570,8 @@
   // Commits in the error page process must only be failures, otherwise
   // successful navigations could commit documents from origins different
   // than the chrome-error://chromewebdata/ one and violate expectations.
-  if (should_commit_error_page &&
+  // NWJS: different process model where the pages are in the same process
+  if (false && should_commit_error_page &&
       (navigation_request && !navigation_request->DidEncounterError())) {
     DEBUG_ALIAS_FOR_ORIGIN(origin_debug_alias, params->origin);
     bad_message::ReceivedBadMessage(
diff -r -u --color up/chromium/content/browser/renderer_host/render_frame_host_impl.h nw/chromium/content/browser/renderer_host/render_frame_host_impl.h
--- up/chromium/content/browser/renderer_host/render_frame_host_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_frame_host_impl.h	2024-08-26 19:32:24.558588156 +0000
@@ -416,10 +416,15 @@
   // RenderFrameHost
   const blink::StorageKey& GetStorageKey() const override;
   int GetRoutingID() const override;
+  bool skip_blocking_parser() const override;
+  void set_skip_blocking_parser(bool) override;
+
   const blink::LocalFrameToken& GetFrameToken() const override;
   const base::UnguessableToken& GetReportingSource() override;
 
   ui::AXTreeID GetAXTreeID() override;
+  bool nodejs() override;
+  bool context_created() override;
   SiteInstanceImpl* GetSiteInstance() const override;
   RenderProcessHost* GetProcess() const override;
   GlobalRenderFrameHostId GetGlobalId() const override;
@@ -2516,6 +2521,7 @@
                          WindowOpenDisposition disposition,
                          blink::mojom::WindowFeaturesPtr window_features,
                          bool user_gesture,
+                         const std::u16string& manifest,
                          ShowCreatedWindowCallback callback) override;
   void SetWindowRect(const gfx::Rect& bounds,
                      SetWindowRectCallback callback) override;
@@ -3372,8 +3378,9 @@
   // itself.
   // This does not consider inner frame trees (i.e. not accounting for fenced
   // frames or GuestView).
+ public:
   bool IsDescendantOfWithinFrameTree(RenderFrameHostImpl* ancestor);
-
+ private:
   // mojom::FrameHost:
   void CreateNewWindow(mojom::CreateNewWindowParamsPtr params,
                        CreateNewWindowCallback callback) override;
@@ -3451,6 +3458,9 @@
       std::vector<blink::mojom::LocationChangesPtr> changes,
       uint32_t reset_token);
 
+  void SetNodeJS(bool node) override;
+  void SetContextCreated(bool created) override;
+
   // mojom::DomAutomationControllerHost:
   void DomOperationResponse(const std::string& json_string) override;
 
@@ -4428,6 +4438,11 @@
   };
   RenderFrameState render_frame_state_ = RenderFrameState::kNeverCreated;
 
+  bool nodejs_;
+
+  bool context_created_;
+
+  bool skip_blocking_parser_ = true;
   // When the last BeforeUnload message was sent.
   base::TimeTicks send_before_unload_start_time_;
 
diff -r -u --color up/chromium/content/browser/renderer_host/render_frame_host_manager.cc nw/chromium/content/browser/renderer_host/render_frame_host_manager.cc
--- up/chromium/content/browser/renderer_host/render_frame_host_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_frame_host_manager.cc	2024-08-26 19:32:24.558588156 +0000
@@ -1952,7 +1952,7 @@
     //   same WebUI or reloading the same document.
     // * Newly created window with a RenderFrameHost which hasn't committed a
     //   navigation yet.
-    if (render_frame_host_->has_committed_any_navigation()) {
+    if (render_frame_host_->has_committed_any_navigation() && render_frame_host_->web_ui()) {
       // If |render_frame_host_| has committed at least one navigation and it
       // is in a WebUI SiteInstance, then it must have the exact same WebUI
       // type if it will be reused.
diff -r -u --color up/chromium/content/browser/renderer_host/render_process_host_impl.cc nw/chromium/content/browser/renderer_host/render_process_host_impl.cc
--- up/chromium/content/browser/renderer_host/render_process_host_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_process_host_impl.cc	2024-08-26 19:32:24.566588155 +0000
@@ -122,6 +122,7 @@
 #include "content/browser/renderer_host/render_widget_helper.h"
 #include "content/browser/renderer_host/renderer_sandboxed_process_launcher_delegate.h"
 #include "content/browser/renderer_host/spare_render_process_host_manager.h"
+#include "content/browser/resolve_proxy_helper.h"
 #include "content/browser/service_worker/service_worker_context_wrapper.h"
 #include "content/browser/site_info.h"
 #include "content/browser/site_instance_impl.h"
@@ -292,6 +293,15 @@
 #define MAYBEVLOG DVLOG
 #endif
 
+#include "content/nw/src/common/shell_switches.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
+namespace nw {
+typedef bool (*RphGuestFilterURLHookFn)(content::RenderProcessHost* rph, const GURL* url);
+CONTENT_EXPORT RphGuestFilterURLHookFn gRphGuestFilterURLHook = nullptr;
+void LoadNodeSymbols();
+}
+
 namespace content {
 
 namespace {
@@ -309,6 +319,8 @@
 base::Thread* g_in_process_thread = nullptr;
 
 RenderProcessHostFactory* g_render_process_host_factory_ = nullptr;
+RenderProcessHostImpl* g_main_host = nullptr;
+
 const char kSiteProcessMapKeyName[] = "content_site_process_map";
 
 RenderProcessHost::AnalyzeHungRendererFunction g_analyze_hung_renderer =
@@ -1343,6 +1355,7 @@
 #endif  // BUILDFLAG(ALLOW_OOP_VIDEO_DECODER)
 
   widget_helper_ = new RenderWidgetHelper();
+  resolve_proxy_helper_ = new ResolveProxyHelper(GetID());
 
   ChildProcessSecurityPolicyImpl::GetInstance()->Add(GetID(), browser_context);
 
@@ -1562,6 +1575,8 @@
       GetContentClient()->browser()->GetOriginTrialsSettings());
 
   if (run_renderer_in_process()) {
+    base::ScopedAllowBlocking allow_io;
+    nw::LoadNodeSymbols();
     DCHECK(g_renderer_main_thread_factory);
     // Crank up a thread and run the initialization there.  With the way that
     // messages flow between the browser and renderer, this thread is required
@@ -1583,6 +1598,8 @@
     // in-process plugins.
     options.message_pump_type = base::MessagePumpType::DEFAULT;
 #endif
+    options.message_pump_type = base::MessagePumpType::NODE;
+
     // As for execution sequence, this callback should have no any dependency
     // on starting in-process-render-thread.
     // So put it here to trigger ChannelMojo initialization earlier to enable
@@ -3108,6 +3125,18 @@
         blink::switches::kTouchTextSelectionStrategy_Direction);
   }
 
+  bool allow_nw = false;
+  if (IsForGuestsOnly()) {
+    if (nw::GetInWebViewApplyAttr(&allow_nw) && allow_nw)
+      command_line->AppendSwitch("nwjs-guest-nw");
+    else
+      command_line->AppendSwitch("nwjs-guest");
+  }
+
+  if (nw::MixedContext()) {
+    command_line->AppendSwitch("mixed-context");
+  }
+
 #if BUILDFLAG(IS_WIN)
   command_line->AppendSwitchASCII(
       switches::kDeviceScaleFactor,
@@ -3148,6 +3177,7 @@
   // Propagate the following switches to the renderer command line (along
   // with any associated values) if present in the browser command line.
   static const char* const kSwitchNames[] = {
+      "nwjs-test-mode",
       switches::kDisableInProcessStackTraces,
       sandbox::policy::switches::kDisableSeccompFilterSandbox,
       sandbox::policy::switches::kNoSandbox,
@@ -3160,6 +3190,9 @@
       sandbox::policy::switches::kEnableSandboxLogging,
 #endif
     switches::kAllowCommandLinePlugins,
+    switches::kDisableRAFThrottling,
+    switches::kEnableNodeWorker,
+    switches::kEnableSpellChecking,
     switches::kAllowLoopbackInPeerConnection,
     switches::kAudioBufferSize,
     switches::kAutoplayPolicy,
@@ -4073,6 +4106,16 @@
   GetAllHosts().AddWithID(host, host_id);
 }
 
+void RenderProcessHostImpl::set_main_host() {
+  g_main_host = this;
+}
+
+RenderProcessHostImpl* RenderProcessHostImpl::main_host() {
+  return g_main_host;
+}
+
+extern bool g_browser_main_loop_shutting_down;
+
 // static
 void RenderProcessHostImpl::UnregisterHost(int host_id) {
   RenderProcessHost* host = GetAllHosts().Lookup(host_id);
@@ -4094,6 +4137,12 @@
                           host->GetBrowserContext()->GetUserData(
                               kCommittedSiteProcessCountTrackerKey)));
 
+  if (g_main_host == host)
+    g_main_host = nullptr;
+
+  if (run_renderer_in_process() && g_browser_main_loop_shutting_down)
+    return; //or the following line will crash because browser context
+            //has been destroyed
   // Look up the map of site to process for the given browser_context,
   // in case we need to remove this process from it.  It will be registered
   // under any sites it rendered that use process-per-site mode.
@@ -4156,6 +4205,8 @@
     TRACE_EVENT2("navigation",
                  "RenderProcessHost::FilterURL - failed CanRequestURL",
                  "process_id", rph->GetID(), "url", url->spec());
+    if (nw::gRphGuestFilterURLHook && nw::gRphGuestFilterURLHook(rph, url))
+      return FilterURLResult::kAllowed;
     VLOG(1) << "Blocked URL " << url->spec();
     base::UmaHistogramEnumeration("BrowserRenderProcessHost.BlockedByFilterURL",
                                   BlockedURLReason::kFailedCanRequestURLCheck);
@@ -4440,8 +4491,11 @@
                                       .spare_render_process_host()) {
       continue;
     }
-    if (MayReuseAndIsSuitable(iter.GetCurrentValue(), site_instance))
+    if (MayReuseAndIsSuitable(iter.GetCurrentValue(), site_instance)) {
+      if (iter.GetCurrentValue() == g_main_host)
+        return g_main_host;
       suitable_renderers.push_back(iter.GetCurrentValue());
+    }
   }
 
   MAYBEVLOG(4) << __func__ << ": Found " << suitable_renderers.size()
@@ -4450,9 +4504,12 @@
 
   // Now pick a random suitable renderer, if we have any.
   if (!suitable_renderers.empty()) {
-    int suitable_count = static_cast<int>(suitable_renderers.size());
-    int random_index = base::RandInt(0, suitable_count - 1);
-    return suitable_renderers[random_index];
+    //int suitable_count = static_cast<int>(suitable_renderers.size());
+    //int random_index = base::RandInt(0, suitable_count - 1);
+    //return suitable_renderers[random_index];
+    //NWJS: reuse first renderer, the main process for valid nw.Window.open
+    //callback value. see also app_window_api.cc:416
+    return suitable_renderers[0];
   }
 
   return nullptr;
@@ -4497,6 +4554,11 @@
   // use process-per-site mode.  We cannot check whether the process has
   // appropriate bindings here, because the bindings have not yet been
   // granted.
+  // don't register process when we're opening new_instance window, or
+  // the map slot will be took over and following same-instance window
+  // opening will return null; NWJS#4691
+  if (!nw::PinningRenderer())
+    return;
   if (!site_instance->GetSiteInfo().is_empty())
     map->RegisterProcess(site_instance->GetSiteInfo(), process);
 }
@@ -4892,6 +4954,12 @@
   GpuProcessHost::GetHasGpuProcess(std::move(callback));
 }
 
+void RenderProcessHostImpl::ResolveProxy(
+    const GURL& url,
+    mojom::RendererHost::ResolveProxyCallback callback) {
+  resolve_proxy_helper_->ResolveProxy(url, std::move(callback));
+}
+
 void RenderProcessHostImpl::UpdateProcessPriorityInputs() {
   int32_t new_visible_widgets_count = 0;
   unsigned int new_frame_depth = kMaxFrameDepthForPriority;
diff -r -u --color up/chromium/content/browser/renderer_host/render_process_host_impl.h nw/chromium/content/browser/renderer_host/render_process_host_impl.h
--- up/chromium/content/browser/renderer_host/render_process_host_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_process_host_impl.h	2024-08-26 19:32:24.566588155 +0000
@@ -162,6 +162,7 @@
 class RenderProcessHostPriorityClients;
 class RenderProcessHostTestBase;
 class RenderWidgetHelper;
+class ResolveProxyHelper;
 class SiteInfo;
 class SiteInstance;
 class SiteInstanceImpl;
@@ -225,6 +226,8 @@
   RenderProcessHostImpl(const RenderProcessHostImpl& other) = delete;
   RenderProcessHostImpl& operator=(const RenderProcessHostImpl& other) = delete;
 
+  void set_main_host();
+  static RenderProcessHostImpl* main_host();
   // RenderProcessHost implementation (public portion).
   bool Init() override;
   void EnableSendQueue() override;
@@ -1013,6 +1016,9 @@
       uint64_t private_memory_footprint_bytes) override;
 #endif
   void HasGpuProcess(HasGpuProcessCallback callback) override;
+  void ResolveProxy(
+      const GURL& url,
+      mojom::RendererHost::ResolveProxyCallback callback) override;
 
   void CreateEmbeddedFrameSinkProvider(
       mojo::PendingReceiver<blink::mojom::EmbeddedFrameSinkProvider> receiver);
@@ -1312,6 +1318,8 @@
   // IO thread.
   scoped_refptr<RenderWidgetHelper> widget_helper_;
 
+  scoped_refptr<ResolveProxyHelper> resolve_proxy_helper_;
+
   // Used in single-process mode.
   std::unique_ptr<base::Thread> in_process_renderer_;
 
diff -r -u --color up/chromium/content/browser/renderer_host/render_view_host_delegate.cc nw/chromium/content/browser/renderer_host/render_view_host_delegate.cc
--- up/chromium/content/browser/renderer_host/render_view_host_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_view_host_delegate.cc	2024-08-26 19:32:24.566588155 +0000
@@ -6,6 +6,10 @@
 
 namespace content {
 
+RenderViewHostDelegate::RenderViewHostDelegate()
+  :skip_blocking_parser_(true) {
+}
+
 RenderViewHostDelegateView* RenderViewHostDelegate::GetDelegateView() {
   return nullptr;
 }
@@ -22,4 +26,11 @@
   return std::nullopt;
 }
 
+bool RenderViewHostDelegate::GetSkipBlockingParser() {
+  return skip_blocking_parser_;
+}
+
+void RenderViewHostDelegate::SetSkipBlockingParser(bool value) {
+  skip_blocking_parser_ = value;
+}
 }  // namespace content
diff -r -u --color up/chromium/content/browser/renderer_host/render_view_host_delegate.h nw/chromium/content/browser/renderer_host/render_view_host_delegate.h
--- up/chromium/content/browser/renderer_host/render_view_host_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_view_host_delegate.h	2024-08-26 19:32:24.566588155 +0000
@@ -49,6 +49,7 @@
 // WebContents type (see //renderer_host/DEPS).
 class RenderViewHostDelegate {
  public:
+  RenderViewHostDelegate();
   // Returns the current delegate associated with a feature. May return NULL if
   // there is no corresponding delegate.
   virtual RenderViewHostDelegateView* GetDelegateView();
@@ -80,6 +81,9 @@
   // JavaScript window.focus() method).
   virtual void Activate() {}
 
+  virtual bool GetSkipBlockingParser();
+  virtual void SetSkipBlockingParser(bool);
+
   // Returns true if RenderWidgets under this RenderViewHost will never be
   // user-visible and thus never need to generate pixels for display.
   virtual bool IsNeverComposited();
@@ -131,6 +135,8 @@
 
  protected:
   virtual ~RenderViewHostDelegate() {}
+ private:
+  bool skip_blocking_parser_;
 };
 
 }  // namespace content
diff -r -u --color up/chromium/content/browser/renderer_host/render_view_host_impl.cc nw/chromium/content/browser/renderer_host/render_view_host_impl.cc
--- up/chromium/content/browser/renderer_host/render_view_host_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_view_host_impl.cc	2024-08-26 19:32:24.566588155 +0000
@@ -562,6 +562,10 @@
       frame_tree_->controller()
           .GetSessionStorageNamespace(storage_partition_config_)
           ->id();
+  NavigationRequest* req = frame_tree_node->navigation_request();
+  if (req) {
+    params->skip_blocking_parser = !req->common_params().block_parser;
+  }
   params->hidden = frame_tree_->delegate()->IsHidden();
   params->never_composited = delegate_->IsNeverComposited();
   params->window_was_opened_by_another_window =
diff -r -u --color up/chromium/content/browser/renderer_host/render_widget_host_impl.cc nw/chromium/content/browser/renderer_host/render_widget_host_impl.cc
--- up/chromium/content/browser/renderer_host/render_widget_host_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_widget_host_impl.cc	2024-08-26 19:32:24.566588155 +0000
@@ -4,6 +4,8 @@
 
 #include "content/browser/renderer_host/render_widget_host_impl.h"
 
+#include "content/public/common/content_switches.h"
+
 #include <math.h>
 
 #include <algorithm>
@@ -794,9 +796,15 @@
   // Don't bother reporting hung state when we aren't active.
   StopInputEventAckTimeout();
 
+  // If we have bound the blink widget interface, then inform it that we are
+  // being hidden so it can reduce its resource utilization.
+  if (blink_widget_) {
+    if (!base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableRAFThrottling))
+    blink_widget_->WasHidden();
+  }
+  else if (pending_show_params_) {
   // Show/Hide state is not sent to the renderer when it has requested for us to
   // wait until it requests them via Init().
-  if (pending_show_params_) {
     pending_show_params_.reset();
   } else {
     // Widgets start out hidden, so we must have previously been shown to get
@@ -1347,7 +1355,11 @@
 
     if (auto* touch_emulator =
             GetTouchEmulator(/*create_if_necessary=*/false)) {
-      touch_emulator->CancelTouch();
+      if (touch_emulator->rfh_limit()) {
+        if (touch_emulator->rfh_limit()->GetView() == GetView())
+          touch_emulator->CancelTouch();
+      } else
+        touch_emulator->CancelTouch();
     }
   } else if (keyboard_lock_allowed_) {
     LockKeyboard();
diff -r -u --color up/chromium/content/browser/renderer_host/render_widget_host_view_mac.h nw/chromium/content/browser/renderer_host/render_widget_host_view_mac.h
--- up/chromium/content/browser/renderer_host/render_widget_host_view_mac.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_widget_host_view_mac.h	2024-08-26 19:32:24.574588153 +0000
@@ -103,6 +103,9 @@
     return ns_view_;
   }
 
+  // Used by g_force_cpu_draw
+  CALayer* background_layer() const;
+
   // |delegate| is used to separate out the logic from the NSResponder delegate.
   // |delegate| is retained by this class.
   // |delegate| should be set at most once.
@@ -329,6 +332,7 @@
   id GetRootBrowserAccessibilityElement() override;
   id GetFocusedBrowserAccessibilityElement() override;
   void SetAccessibilityWindow(NSWindow* window) override;
+  RenderWidgetHostViewMac* GetRenderWidgetHostViewMac() override;
   void ForwardKeyboardEvent(const input::NativeWebKeyboardEvent& key_event,
                             const ui::LatencyInfo& latency_info) override;
   void ForwardKeyboardEventWithCommands(
diff -r -u --color up/chromium/content/browser/renderer_host/render_widget_host_view_mac.mm nw/chromium/content/browser/renderer_host/render_widget_host_view_mac.mm
--- up/chromium/content/browser/renderer_host/render_widget_host_view_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_widget_host_view_mac.mm	2024-08-26 19:32:24.574588153 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "content/browser/renderer_host/render_widget_host_view_mac.h"
+#include "content/public/common/content_switches.h"
 
 #import <Carbon/Carbon.h>
 
@@ -87,6 +88,10 @@
 using blink::WebTouchEvent;
 
 namespace content {
+  extern bool g_force_cpu_draw;
+}
+
+namespace content {
 
 namespace {
 
@@ -374,6 +379,13 @@
   return nullptr;
 }
 
+CALayer* RenderWidgetHostViewMac::background_layer() const {
+  assert(content::g_force_cpu_draw);
+  if (in_process_ns_view_bridge_)
+    return in_process_ns_view_bridge_->GetBackgroundLayer();
+  return nil;
+}
+
 void RenderWidgetHostViewMac::SetDelegate(
     NSObject<RenderWidgetHostViewMacDelegate>* delegate) {
   [GetInProcessNSView() setResponderDelegate:delegate];
@@ -480,6 +492,7 @@
   is_visible_ = false;
   ns_view_->SetVisible(is_visible_);
   browser_compositor_->SetViewVisible(is_visible_);
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableRAFThrottling))
   WasOccluded();
 
   if (base::FeatureList::IsEnabled(::features::kHideDelegatedFrameHostMac)) {
@@ -555,6 +568,7 @@
     return;
 
   host()->WasHidden();
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableRAFThrottling))
   browser_compositor_->SetRenderWidgetHostIsHidden(true);
 }
 
@@ -1718,6 +1732,10 @@
   return true;
 }
 
+RenderWidgetHostViewMac* RenderWidgetHostViewMac::GetRenderWidgetHostViewMac() {
+  return this;
+}
+
 void RenderWidgetHostViewMac::SyncIsWidgetForMainFrame(
     SyncIsWidgetForMainFrameCallback callback) {
   bool is_for_main_frame;
Only in nw/chromium/content/browser: resolve_proxy_helper.cc
Only in nw/chromium/content/browser: resolve_proxy_helper.h
Only in nw/chromium/content/browser: resolve_proxy_helper_unittest.cc
diff -r -u --color up/chromium/content/browser/site_info.cc nw/chromium/content/browser/site_info.cc
--- up/chromium/content/browser/site_info.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/site_info.cc	2024-08-26 19:32:24.622588147 +0000
@@ -650,9 +650,11 @@
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK(isolation_context.browser_or_resource_context());
 
+#if 0
   // If --site-per-process is enabled, site isolation is enabled everywhere.
   if (SiteIsolationPolicy::UseDedicatedProcessesForAllSites())
     return true;
+#endif
 
   // If there is a COOP header request to require a dedicated process for this
   // SiteInfo, honor it.  Note that we have already checked other eligibility
@@ -850,7 +852,7 @@
       return origin.GetURL();
     }
 
-    site_url = GetSiteForOrigin(origin);
+    site_url = GetSiteForOrigin(origin, real_url);
 
     // Isolated origins should use the full origin as their site URL. A
     // subdomain of an isolated origin should also use that isolated origin's
@@ -918,10 +920,14 @@
 }
 
 // static
-GURL SiteInfo::GetSiteForOrigin(const url::Origin& origin) {
+GURL SiteInfo::GetSiteForOrigin(const url::Origin& origin, const GURL& real_url) {
   // Only keep the scheme and registered domain of |origin|.
   std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
       origin, net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
+  //NWJS: chrome-extension://test.foo.com was changed to foo.com
+  //without this
+  if (!real_url.is_empty() && real_url.SchemeIs("chrome-extension"))
+    domain = origin.host();
   return SchemeAndHostToSite(origin.scheme(),
                              domain.empty() ? origin.host() : domain);
 }
diff -r -u --color up/chromium/content/browser/site_info.h nw/chromium/content/browser/site_info.h
--- up/chromium/content/browser/site_info.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/site_info.h	2024-08-26 19:32:24.622588147 +0000
@@ -114,7 +114,7 @@
   // only translates an origin into a site (i.e., scheme and eTLD+1) and is
   // used internally by GetSiteForURLInternal().  For making process model
   // decisions, Create() should be used instead.
-  static GURL GetSiteForOrigin(const url::Origin& origin);
+  static GURL GetSiteForOrigin(const url::Origin& origin, const GURL& real_url = GURL());
 
   // Returns the site URL derived from an opaque data: origin. This has the form
   // data:<serialized nonce>. This is only to be called for data: URLs with
diff -r -u --color up/chromium/content/browser/site_instance_impl.cc nw/chromium/content/browser/site_instance_impl.cc
--- up/chromium/content/browser/site_instance_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/site_instance_impl.cc	2024-08-26 19:32:24.622588147 +0000
@@ -13,6 +13,8 @@
 #include "base/lazy_instance.h"
 #include "base/trace_event/typed_macros.h"
 #include "content/browser/bad_message.h"
+#include "content/nw/src/nw_content.h"
+#include "extensions/common/constants.h"
 #include "content/browser/child_process_security_policy_impl.h"
 #include "content/browser/isolated_origin_util.h"
 #include "content/browser/isolation_context.h"
@@ -423,7 +425,7 @@
   // new process will be assigned the next time GetProcess() gets called.
   if (!has_group()) {
     // Check if the ProcessReusePolicy should be updated.
-    if (ShouldUseProcessPerSite()) {
+    if (ShouldUseProcessPerSite() && nw::PinningRenderer()) {
       process_reuse_policy_ = ProcessReusePolicy::PROCESS_PER_SITE;
     } else if (process_reuse_policy_ == ProcessReusePolicy::PROCESS_PER_SITE) {
       process_reuse_policy_ = ProcessReusePolicy::DEFAULT;
@@ -735,14 +737,14 @@
 }
 
 scoped_refptr<SiteInstance> SiteInstanceImpl::GetRelatedSiteInstance(
-    const GURL& url) {
-  return GetRelatedSiteInstanceImpl(UrlInfo(UrlInfoInit(url)));
+                    const GURL& url, bool allow_default_instance) {
+  return GetRelatedSiteInstanceImpl(UrlInfo(UrlInfoInit(url)), allow_default_instance);
 }
 
 scoped_refptr<SiteInstanceImpl> SiteInstanceImpl::GetRelatedSiteInstanceImpl(
-    const UrlInfo& url_info) {
+      const UrlInfo& url_info, bool allow_default_instance) {
   return browsing_instance_->GetSiteInstanceForURL(
-      url_info, /* allow_default_instance */ true);
+      url_info, allow_default_instance);
 }
 
 scoped_refptr<SiteInstanceImpl>
diff -r -u --color up/chromium/content/browser/site_instance_impl.h nw/chromium/content/browser/site_instance_impl.h
--- up/chromium/content/browser/site_instance_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/site_instance_impl.h	2024-08-26 19:32:24.622588147 +0000
@@ -138,7 +138,7 @@
   // looking up an existing SiteInstance based on a GURL can use
   // GetRelatedSiteInstance (overridden from SiteInstance).
   scoped_refptr<SiteInstanceImpl> GetRelatedSiteInstanceImpl(
-      const UrlInfo& url_info);
+      const UrlInfo& url_info, bool allow_default_instance = true);
 
   // This function is used during navigation to get a SiteInstance in the same
   // CoopRelatedGroup. If the provided `url_info` matches one of the existing
@@ -168,7 +168,7 @@
   BrowserContext* GetBrowserContext() override;
   const GURL& GetSiteURL() override;
   const StoragePartitionConfig& GetStoragePartitionConfig() override;
-  scoped_refptr<SiteInstance> GetRelatedSiteInstance(const GURL& url) override;
+  scoped_refptr<SiteInstance> GetRelatedSiteInstance(const GURL& url, bool allow_default_instance = true) override;
   bool IsRelatedSiteInstance(const SiteInstance* instance) override;
   size_t GetRelatedActiveContentsCount() override;
   bool RequiresDedicatedProcess() override;
diff -r -u --color up/chromium/content/browser/url_loader_factory_params_helper.cc nw/chromium/content/browser/url_loader_factory_params_helper.cc
--- up/chromium/content/browser/url_loader_factory_params_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/url_loader_factory_params_helper.cc	2024-08-26 19:32:24.642588144 +0000
@@ -121,6 +121,11 @@
   params->trust_token_issuance_policy = trust_token_issuance_policy;
   params->trust_token_redemption_policy = trust_token_redemption_policy;
 
+  if (GetContentClient()->browser()->IsNWOrigin(origin, process->GetBrowserContext())) {
+    params->is_orb_enabled = false;
+    params->disable_web_security = true;
+  }
+
   // If we have a URLLoaderNetworkObserver, request loading state updates.
   if (url_loader_network_observer &&
       !base::FeatureList::IsEnabled(kInhibitLoadingStateUpdate)) {
diff -r -u --color up/chromium/content/browser/web_contents/file_chooser_impl.cc nw/chromium/content/browser/web_contents/file_chooser_impl.cc
--- up/chromium/content/browser/web_contents/file_chooser_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/web_contents/file_chooser_impl.cc	2024-08-26 19:32:24.646588143 +0000
@@ -162,12 +162,14 @@
   // Do not allow messages with absolute paths in them as this can permit a
   // renderer to coerce the browser to perform I/O on a renderer controlled
   // path.
+  #if 0
   if (params->default_file_name != params->default_file_name.BaseName()) {
     mojo::ReportBadMessage(
         "FileChooser: The default file name must not be an absolute path.");
     listener->FileSelectionCanceled();
     return;
   }
+  #endif
 
   // Don't allow page with open FileChooser to enter BackForwardCache to avoid
   // any unexpected behaviour from BackForwardCache.
diff -r -u --color up/chromium/content/browser/web_contents/web_contents_impl.cc nw/chromium/content/browser/web_contents/web_contents_impl.cc
--- up/chromium/content/browser/web_contents/web_contents_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/web_contents/web_contents_impl.cc	2024-08-26 19:32:24.646588143 +0000
@@ -18,6 +18,8 @@
 
 #include "base/allocator/partition_allocator/src/partition_alloc/buildflags.h"
 #include "base/check_op.h"
+#include "content/nw/src/nw_base.h"
+
 #include "base/command_line.h"
 #include "base/containers/contains.h"
 #include "base/containers/flat_set.h"
@@ -4767,10 +4769,12 @@
     AddWebContentsDestructionObserver(new_contents_impl);
   }
 
+  nw::SetCurrentNewWinManifest(params.nw_window_manifest);
+
   if (delegate_) {
     delegate_->WebContentsCreated(this, render_process_id,
                                   opener->GetRoutingID(), params.frame_name,
-                                  params.target_url, new_contents_impl);
+                                  params.target_url, new_contents_impl, params.nw_window_manifest);
   }
 
   observers_.NotifyObservers(&WebContentsObserver::DidOpenRequestedURL,
@@ -4789,9 +4793,23 @@
       base::WeakPtr<WebContentsImpl> weak_new_contents =
           new_contents_impl->weak_factory_.GetWeakPtr();
 
+      gfx::Rect initial_rect;
+      if (params.features->has_width)
+        initial_rect.set_width(params.features->bounds.width());
+      if (params.features->has_height)
+        initial_rect.set_height(params.features->bounds.height());
+      if (params.features->has_x)
+        initial_rect.set_x(params.features->bounds.x());
+      if (params.features->has_y)
+        initial_rect.set_y(params.features->bounds.y());
+
+      std::string manifest = base::UTF16ToUTF8(params.nw_window_manifest);
+      delegate_->set_tmp_manifest(manifest);
+      params.features->bounds = initial_rect;
       delegate_->AddNewContents(
           this, std::move(new_contents), params.target_url, params.disposition,
           *params.features, has_user_gesture, &was_blocked);
+      delegate_->set_tmp_manifest(std::string());
       // The delegate may delete |new_contents_impl| during AddNewContents().
       if (!weak_new_contents) {
         return nullptr;
@@ -4916,7 +4934,7 @@
     int main_frame_widget_route_id,
     WindowOpenDisposition disposition,
     const blink::mojom::WindowFeatures& window_features,
-    bool user_gesture) {
+    bool user_gesture, std::string manifest) {
   OPTIONAL_TRACE_EVENT2("content", "WebContentsImpl::ShowCreatedWindow",
                         "opener", opener, "main_frame_widget_route_id",
                         main_frame_widget_route_id);
@@ -4978,9 +4996,11 @@
       created->ResumeLoadingCreatedWebContents();
     }
 
+    delegate->set_tmp_manifest(manifest);
     delegate->AddNewContents(this, std::move(owned_created->contents),
                              std::move(owned_created->target_url), disposition,
                              adjusted_features, user_gesture, nullptr);
+    delegate->set_tmp_manifest(std::string());
   }
 }
 
@@ -10405,8 +10425,10 @@
   // the command line (to avoid flakiness in browser tests).
   const bool occlusion_is_disabled =
       base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kDisableBackgroundingOccludedWindowsForTesting);
-  if (occlusion_is_disabled && visibility == Visibility::OCCLUDED) {
+          switches::kDisableBackgroundingOccludedWindowsForTesting) ||
+      base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableRAFThrottling);
+  if (occlusion_is_disabled) { // && visibility == Visibility::OCCLUDED)
     visibility = Visibility::VISIBLE;
   }
 
diff -r -u --color up/chromium/content/browser/web_contents/web_contents_impl.h nw/chromium/content/browser/web_contents/web_contents_impl.h
--- up/chromium/content/browser/web_contents/web_contents_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/web_contents/web_contents_impl.h	2024-08-26 19:32:24.646588143 +0000
@@ -760,7 +760,7 @@
                          int main_frame_widget_route_id,
                          WindowOpenDisposition disposition,
                          const blink::mojom::WindowFeatures& window_features,
-                         bool user_gesture) override;
+                         bool user_gesture, std::string manifest) override;
   void PrimaryMainDocumentElementAvailable() override;
   void PassiveInsecureContentFound(const GURL& resource_url) override;
   bool ShouldAllowRunningInsecureContent(bool allowed_per_prefs,
diff -r -u --color up/chromium/content/browser/webui/url_data_manager_backend.cc nw/chromium/content/browser/webui/url_data_manager_backend.cc
--- up/chromium/content/browser/webui/url_data_manager_backend.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/webui/url_data_manager_backend.cc	2024-08-26 19:32:24.670588140 +0000
@@ -7,6 +7,8 @@
 #include <set>
 #include <utility>
 
+#include "content/nw/src/nw_content.h"
+
 #include "base/containers/contains.h"
 #include "base/functional/bind.h"
 #include "base/location.h"
@@ -40,6 +42,11 @@
 #include "ui/base/webui/i18n_source_stream.h"
 #include "url/url_util.h"
 
+namespace nw {
+typedef bool (*CheckStoragePartitionMatchesFn)(int render_process_id, const GURL& url);
+CONTENT_EXPORT CheckStoragePartitionMatchesFn gCheckStoragePartitionMatches = nullptr;
+}
+
 namespace content {
 
 namespace {
diff -r -u --color up/chromium/content/browser/worker_host/shared_worker_host.cc nw/chromium/content/browser/worker_host/shared_worker_host.cc
--- up/chromium/content/browser/worker_host/shared_worker_host.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/worker_host/shared_worker_host.cc	2024-08-26 19:32:24.674588139 +0000
@@ -304,6 +304,7 @@
   auto options = blink::mojom::WorkerOptions::New(
       instance_.script_type(), instance_.credentials_mode(), instance_.name());
   blink::mojom::SharedWorkerInfoPtr info(blink::mojom::SharedWorkerInfo::New(
+                                                                             instance_.nodejs(), instance_.root_path(),
       instance_.url(), std::move(options),
       mojo::Clone(content_security_policies_),
       std::move(outside_fetch_client_settings_object),
diff -r -u --color up/chromium/content/browser/worker_host/shared_worker_service_impl.cc nw/chromium/content/browser/worker_host/shared_worker_service_impl.cc
--- up/chromium/content/browser/worker_host/shared_worker_service_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/worker_host/shared_worker_service_impl.cc	2024-08-26 19:32:24.674588139 +0000
@@ -216,7 +216,9 @@
     return;
   }
   auto partition_domain = site_instance->GetPartitionDomain(storage_partition_);
-  SharedWorkerInstance instance(info->url, info->options->type,
+  SharedWorkerInstance instance(
+                                info->is_node_js, info->root_path,
+                                info->url, info->options->type,
                                 info->options->credentials, info->options->name,
                                 storage_key, creation_context_type,
                                 info->same_site_cookies);
diff -r -u --color up/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc nw/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc
--- up/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc	2024-08-26 19:32:24.678588139 +0000
@@ -1,6 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "content/browser/zygote_host/zygote_host_impl_linux.h"
 
@@ -33,6 +34,8 @@
 #include "content/public/common/zygote/zygote_handle.h"
 #endif  // BUILDFLAG(IS_CHROMEOS)
 
+#include "content/nw/src/common/shell_switches.h"
+
 namespace content {
 
 namespace {
@@ -82,7 +85,7 @@
 }
 
 void ZygoteHostImpl::Init(const base::CommandLine& command_line) {
-  if (command_line.HasSwitch(sandbox::policy::switches::kNoSandbox)) {
+  if (true || command_line.HasSwitch(sandbox::policy::switches::kNoSandbox)) {
     return;
   }
 
@@ -115,7 +118,7 @@
   } else if (!command_line.HasSwitch(
                  sandbox::policy::switches::kDisableSetuidSandbox) &&
              !sandbox_binary_.empty()) {
-    use_suid_sandbox_ = true;
+    use_suid_sandbox_ = false;
 
     // Use the SUID sandbox for adjusting OOM scores when we are using
     // the setuid sandbox. This is needed beacuse the processes are
diff -r -u --color up/chromium/content/child/child_thread_impl.cc nw/chromium/content/child/child_thread_impl.cc
--- up/chromium/content/child/child_thread_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/child/child_thread_impl.cc	2024-08-26 19:32:24.678588139 +0000
@@ -724,7 +724,7 @@
     source_ptr->Init(std::move(remote_power_monitor));
   }
 
-#if BUILDFLAG(IS_POSIX)
+#if 0 //BUILDFLAG(IS_POSIX)
   // Check that --process-type is specified so we don't do this in unit tests
   // and single-process mode.
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
diff -r -u --color up/chromium/content/common/content_switches_internal.cc nw/chromium/content/common/content_switches_internal.cc
--- up/chromium/content/common/content_switches_internal.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/common/content_switches_internal.cc	2024-08-26 19:32:24.682588139 +0000
@@ -94,7 +94,7 @@
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
   std::string title = "Google Chrome";
 #else   // BUILDFLAG(CHROMIUM_BRANDING)
-  std::string title = "Chromium";
+  std::string title = "NW.js";
 #endif  // BUILDFLAG(CHROMIUM_BRANDING)
   title += " ";
   title += label;  // makes attaching to process easier
diff -r -u --color up/chromium/content/common/features.cc nw/chromium/content/common/features.cc
--- up/chromium/content/common/features.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/common/features.cc	2024-08-26 19:32:24.686588138 +0000
@@ -449,7 +449,7 @@
 // at a time.
 BASE_FEATURE(kProcessSharingWithDefaultSiteInstances,
              "ProcessSharingWithDefaultSiteInstances",
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT); //nwjs#7197
 
 // Whether cross-site frames should get their own SiteInstance even when
 // strict site isolation is disabled. These SiteInstances will still be
diff -r -u --color up/chromium/content/common/frame.mojom nw/chromium/content/common/frame.mojom
--- up/chromium/content/common/frame.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/common/frame.mojom	2024-08-26 19:32:24.686588138 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 module content.mojom;
+import "mojo/public/mojom/base/string16.mojom";
 
 import "cc/mojom/browser_controls_state.mojom";
 import "content/common/frame_messages.mojom";
@@ -168,6 +169,8 @@
   // Indicates whether web or OS-level Attribution Reporting is supported. See
   // https://github.com/WICG/attribution-reporting-api/blob/main/app_to_web.md
   network.mojom.AttributionSupport attribution_support;
+
+  bool skip_blocking_parser;
 };
 
 // A union to distinguish between parameters specific to local main frame
@@ -341,6 +344,7 @@
   // Set if this frame corresponds to the main frame for a non top-level
   // FrameTree (GuestView, fenced frame etc.).
   bool is_for_nested_main_frame;
+  bool block_parser = false;
 };
 
 // Provided with each call to Frame::GetSerializedHtmlWithLocalLinks() so that
@@ -495,6 +499,8 @@
       blink.mojom.RemoteFrameInterfacesFromBrowser new_remote_frame_interfaces,
       blink.mojom.RemoteMainFrameInterfaces new_remote_main_frame_interfaces);
 
+  SetSkipBlockingParser(bool skip);
+
   GetInterfaceProvider(
       pending_receiver<service_manager.mojom.InterfaceProvider> interfaces);
 
@@ -546,6 +552,7 @@
 };
 
 struct CreateNewWindowParams {
+  mojo_base.mojom.String16 nw_window_manifest;
   // True if ContentRendererClient allows popups.  This is the case only for
   // extensions.
   bool allow_popup;
@@ -696,6 +703,8 @@
 // Implemented by the frame server (i.e. the browser process). For messages that
 // must be associated with the IPC channel.
 interface FrameHost {
+  SetNodeJS(bool node);
+  SetContextCreated(bool created);
   // Sent by the renderer to request the browser to create a new window. |reply|
   // is only non-null on when status == CreateNewWindowStatus::kSuccess.
   [Sync] CreateNewWindow(CreateNewWindowParams params)
diff -r -u --color up/chromium/content/common/renderer_host.mojom nw/chromium/content/common/renderer_host.mojom
--- up/chromium/content/common/renderer_host.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/common/renderer_host.mojom	2024-08-26 19:32:24.690588137 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 module content.mojom;
+import "url/mojom/url.mojom";
 
 // The primordial interface implemented by a render process host. This should be
 // used for implementing renderer-to-browser messages.
@@ -42,4 +43,8 @@
 
   // A renderer sends this when it wants to know whether a gpu process exists.
   [Sync] HasGpuProcess() => (bool has_gpu_process);
+  // Gets the list of proxies to use for |url|, as a semicolon delimited list
+  // of "<TYPE> <HOST>:<PORT>" | "DIRECT".
+  [Sync]
+  ResolveProxy(url.mojom.Url url) => (string? proxy_list);
 };
diff -r -u --color up/chromium/content/common/user_agent.cc nw/chromium/content/common/user_agent.cc
--- up/chromium/content/common/user_agent.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/common/user_agent.cc	2024-08-26 19:32:24.694588137 +0000
@@ -357,7 +357,17 @@
   return model;
 }
 
-#if BUILDFLAG(IS_ANDROID)
+std::string BuildOSInfo() {
+  std::string os_info;
+  base::StringAppendF(
+      &os_info,
+      "%s%s",
+      GetUserAgentPlatform().c_str(),
+      BuildOSCpuInfo(IncludeAndroidBuildNumber::Exclude,
+                     IncludeAndroidModel::Exclude).c_str());
+  return os_info;
+}
+
 std::string BuildUserAgentFromProductAndExtraOSInfo(
     const std::string& product,
     const std::string& extra_os_info,
@@ -378,6 +388,7 @@
   return BuildUserAgentFromOSAndProduct(os_info, product);
 }
 
+#if 0
 std::string GetAndroidOSInfo(
     IncludeAndroidBuildNumber include_android_build_number,
     IncludeAndroidModel include_android_model) {
diff -r -u --color up/chromium/content/common/zygote/zygote_communication_linux.cc nw/chromium/content/common/zygote/zygote_communication_linux.cc
--- up/chromium/content/common/zygote/zygote_communication_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/common/zygote/zygote_communication_linux.cc	2024-08-26 19:32:24.694588137 +0000
@@ -9,6 +9,7 @@
 
 #include "content/common/zygote/zygote_communication_linux.h"
 
+#include "content/nw/src/common/shell_switches.h"
 #include <string.h>
 #include <sys/socket.h>
 
@@ -263,6 +264,7 @@
   static const char* const kForwardSwitches[] = {
       sandbox::policy::switches::kAllowSandboxDebugging,
       switches::kDisableInProcessStackTraces,
+      "enable-spell-checking",
       sandbox::policy::switches::kDisableSeccompFilterSandbox,
       sandbox::policy::switches::kNoSandbox,
   };
diff -r -u --color up/chromium/content/ppapi_plugin/ppapi_plugin_main.cc nw/chromium/content/ppapi_plugin/ppapi_plugin_main.cc
--- up/chromium/content/ppapi_plugin/ppapi_plugin_main.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/ppapi_plugin/ppapi_plugin_main.cc	2024-08-26 19:32:24.698588136 +0000
@@ -141,7 +141,7 @@
   gin::V8Initializer::LoadV8Snapshot();
 #endif
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#if 0 //BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
   sandbox::policy::SandboxLinux::GetInstance()->InitializeSandbox(
       sandbox::policy::SandboxTypeFromCommandLine(command_line),
       sandbox::policy::SandboxLinux::PreSandboxHook(),
diff -r -u --color up/chromium/content/public/browser/child_process_security_policy.h nw/chromium/content/public/browser/child_process_security_policy.h
--- up/chromium/content/public/browser/child_process_security_policy.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/child_process_security_policy.h	2024-08-26 19:32:24.734588130 +0000
@@ -70,6 +70,7 @@
   // change it to accept an URL instead.
   virtual bool IsWebSafeScheme(const std::string& scheme) = 0;
 
+  virtual void GrantAll(int child_id) = 0;
   // This permission grants only read access to a file.
   // Whenever the user picks a file from a <input type="file"> element, the
   // browser should call this function to grant the child process the capability
diff -r -u --color up/chromium/content/public/browser/content_browser_client.cc nw/chromium/content/public/browser/content_browser_client.cc
--- up/chromium/content/public/browser/content_browser_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/content_browser_client.cc	2024-08-26 19:32:24.734588130 +0000
@@ -6,6 +6,8 @@
 
 #include <optional>
 #include <string_view>
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
 #include <utility>
 
 #include "base/check.h"
@@ -193,6 +195,8 @@
     BrowserContext* browser_context,
     const GURL& effective_url) {
   DCHECK(browser_context);
+  if (nw::PinningRenderer())
+    return false;
   return true;
 }
 
@@ -210,6 +214,7 @@
   return false;
 }
 
+
 bool ContentBrowserClient::ShouldIgnoreSameSiteCookieRestrictionsWhenTopLevel(
     std::string_view scheme,
     bool is_embedded_origin_secure) {
@@ -222,6 +227,10 @@
   return site_url.spec();
 }
 
+bool ContentBrowserClient::IsNWOrigin(const url::Origin& origin, BrowserContext* context) {
+  return false;
+}
+
 void ContentBrowserClient::OverrideURLLoaderFactoryParams(
     BrowserContext* browser_context,
     const url::Origin& origin,
@@ -504,6 +513,10 @@
   std::move(callback).Run(true);
 }
 
+base::FilePath ContentBrowserClient::GetRootPath() {
+  return base::FilePath();
+}
+
 bool ContentBrowserClient::AllowWorkerIndexedDB(
     const GURL& url,
     BrowserContext* browser_context,
diff -r -u --color up/chromium/content/public/browser/content_browser_client.h nw/chromium/content/public/browser/content_browser_client.h
--- up/chromium/content/public/browser/content_browser_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/content_browser_client.h	2024-08-26 19:32:24.734588130 +0000
@@ -486,6 +486,8 @@
   // processes.
   virtual bool DoesWebUIUrlRequireProcessLock(const GURL& url);
 
+  virtual bool IsNWOrigin(const url::Origin& origin, BrowserContext* context);
+
   // Returns true if everything embedded inside a document with given scheme
   // should be treated as first-party content. |scheme| will be in canonical
   // (lowercased) form. |is_embedded_origin_secure| refers to whether the origin
@@ -893,6 +895,7 @@
       const std::vector<GlobalRenderFrameHostId>& render_frames,
       base::OnceCallback<void(bool)> callback);
 
+  virtual base::FilePath GetRootPath();
   // Allow the embedder to control if access to IndexedDB by a shared worker
   // is allowed.
   virtual bool AllowWorkerIndexedDB(
diff -r -u --color up/chromium/content/public/browser/desktop_streams_registry.h nw/chromium/content/public/browser/desktop_streams_registry.h
--- up/chromium/content/public/browser/desktop_streams_registry.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/desktop_streams_registry.h	2024-08-26 19:32:24.734588130 +0000
@@ -55,7 +55,7 @@
       int render_process_id,
       int render_frame_id,
       const url::Origin& origin,
-      const DesktopStreamRegistryType type) = 0;
+      const DesktopStreamRegistryType type, bool nodejs = false) = 0;
 };
 
 }  // namespace content
diff -r -u --color up/chromium/content/public/browser/navigation_controller.h nw/chromium/content/public/browser/navigation_controller.h
--- up/chromium/content/public/browser/navigation_controller.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/navigation_controller.h	2024-08-26 19:32:24.742588130 +0000
@@ -303,6 +303,7 @@
     blink::mojom::SystemEntropy suggested_system_entropy =
         blink::mojom::SystemEntropy::kNormal;
 
+    bool block_parser = false;
     // Indicates a form submission created this navigation.
     bool is_form_submission = false;
 
diff -r -u --color up/chromium/content/public/browser/prerender_web_contents_delegate.cc nw/chromium/content/public/browser/prerender_web_contents_delegate.cc
--- up/chromium/content/public/browser/prerender_web_contents_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/prerender_web_contents_delegate.cc	2024-08-26 19:32:24.746588129 +0000
@@ -72,7 +72,7 @@
     int opener_render_frame_id,
     const std::string& frame_name,
     const GURL& target_url,
-    WebContents* new_contents) {
+    WebContents* new_contents, const std::u16string& nw_window_manifest) {
   // A prerendered page should not create a new WebContents.
   NOTREACHED_NORETURN();
 }
diff -r -u --color up/chromium/content/public/browser/prerender_web_contents_delegate.h nw/chromium/content/public/browser/prerender_web_contents_delegate.h
--- up/chromium/content/public/browser/prerender_web_contents_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/prerender_web_contents_delegate.h	2024-08-26 19:32:24.746588129 +0000
@@ -41,7 +41,7 @@
                           int opener_render_frame_id,
                           const std::string& frame_name,
                           const GURL& target_url,
-                          WebContents* new_contents) override;
+                          WebContents* new_contents, const std::u16string& nw_window_manifest) override;
   bool CanEnterFullscreenModeForTab(RenderFrameHost* requesting_frame) override;
   void EnterFullscreenModeForTab(
       RenderFrameHost* requesting_frame,
diff -r -u --color up/chromium/content/public/browser/render_frame_host.h nw/chromium/content/public/browser/render_frame_host.h
--- up/chromium/content/public/browser/render_frame_host.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/render_frame_host.h	2024-08-26 19:32:24.746588129 +0000
@@ -205,6 +205,9 @@
   // Returns the route id for this frame.
   virtual int GetRoutingID() const = 0;
 
+  virtual bool skip_blocking_parser() const = 0;
+  virtual void set_skip_blocking_parser(bool) = 0;
+
   // Returns the frame token for this frame.
   virtual const blink::LocalFrameToken& GetFrameToken() const = 0;
 
@@ -220,6 +223,8 @@
   using AXTreeSnapshotCallback =
       base::OnceCallback<void(const ui::AXTreeUpdate&)>;
 
+  virtual bool nodejs() = 0;
+  virtual bool context_created() = 0;
   // Returns the SiteInstance grouping all RenderFrameHosts that have script
   // access to this RenderFrameHost, and must therefore live in the same
   // process.
diff -r -u --color up/chromium/content/public/browser/shared_worker_instance.cc nw/chromium/content/public/browser/shared_worker_instance.cc
--- up/chromium/content/public/browser/shared_worker_instance.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/shared_worker_instance.cc	2024-08-26 19:32:24.750588129 +0000
@@ -11,6 +11,7 @@
 namespace content {
 
 SharedWorkerInstance::SharedWorkerInstance(
+    bool is_node_js, const base::FilePath& root_path,
     const GURL& url,
     blink::mojom::ScriptType script_type,
     network::mojom::CredentialsMode credentials_mode,
@@ -18,7 +19,9 @@
     const blink::StorageKey& storage_key,
     blink::mojom::SharedWorkerCreationContextType creation_context_type,
     blink::mojom::SharedWorkerSameSiteCookies same_site_cookies)
-    : url_(url),
+    :
+      is_node_js_(is_node_js), root_path_(root_path),
+      url_(url),
       script_type_(script_type),
       credentials_mode_(credentials_mode),
       name_(name),
diff -r -u --color up/chromium/content/public/browser/shared_worker_instance.h nw/chromium/content/public/browser/shared_worker_instance.h
--- up/chromium/content/public/browser/shared_worker_instance.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/shared_worker_instance.h	2024-08-26 19:32:24.750588129 +0000
@@ -6,6 +6,7 @@
 #define CONTENT_PUBLIC_BROWSER_SHARED_WORKER_INSTANCE_H_
 
 #include <string>
+#include "base/files/file_path.h"
 
 #include "content/common/content_export.h"
 #include "services/network/public/mojom/content_security_policy.mojom.h"
@@ -30,6 +31,7 @@
 class CONTENT_EXPORT SharedWorkerInstance {
  public:
   SharedWorkerInstance(
+      bool is_node_js, const base::FilePath& root_path,
       const GURL& url,
       blink::mojom::ScriptType script_type,
       network::mojom::CredentialsMode credentials_mode,
@@ -57,6 +59,8 @@
       const blink::mojom::SharedWorkerSameSiteCookies same_site_cookies) const;
 
   // Accessors.
+  bool nodejs() const { return is_node_js_; }
+  const base::FilePath& root_path() const { return root_path_; }
   const GURL& url() const { return url_; }
   const std::string& name() const { return name_; }
   blink::mojom::ScriptType script_type() const { return script_type_; }
@@ -78,8 +82,11 @@
   }
 
  private:
-  const GURL url_;
-  const blink::mojom::ScriptType script_type_;
+  bool is_node_js_;
+  base::FilePath root_path_;
+
+  GURL url_;
+  blink::mojom::ScriptType script_type_;
 
   // Used for fetching the top-level worker script.
   const network::mojom::CredentialsMode credentials_mode_;
diff -r -u --color up/chromium/content/public/browser/site_instance.h nw/chromium/content/public/browser/site_instance.h
--- up/chromium/content/public/browser/site_instance.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/site_instance.h	2024-08-26 19:32:24.750588129 +0000
@@ -160,7 +160,7 @@
   // that a BrowsingInstance only has one SiteInstance per site, so that pages
   // in a BrowsingInstance have the ability to script each other.
   virtual scoped_refptr<SiteInstance> GetRelatedSiteInstance(
-      const GURL& url) = 0;
+                                                             const GURL& url, bool allow_default_instance = true) = 0;
 
   // Returns whether the given SiteInstance is in the same BrowsingInstance as
   // this one.  If so, JavaScript interactions that are permitted across
diff -r -u --color up/chromium/content/public/browser/web_contents.cc nw/chromium/content/public/browser/web_contents.cc
--- up/chromium/content/public/browser/web_contents.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/web_contents.cc	2024-08-26 19:32:24.754588128 +0000
@@ -11,6 +11,14 @@
 
 namespace content {
 
+bool WebContents::is_silent_printing() {
+  return silent_printing_;
+}
+
+void WebContents::set_silent_printing(bool flag) {
+  silent_printing_ = flag;
+}
+
 WebContents::CreateParams::CreateParams(BrowserContext* context,
                                         base::Location creator_location)
     : CreateParams(context, nullptr, creator_location) {}
diff -r -u --color up/chromium/content/public/browser/web_contents.h nw/chromium/content/public/browser/web_contents.h
--- up/chromium/content/public/browser/web_contents.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/web_contents.h	2024-08-26 19:32:24.754588128 +0000
@@ -392,6 +392,11 @@
 
   ~WebContents() override = default;
 
+  virtual bool is_silent_printing();
+  virtual void set_silent_printing(bool);
+
+  bool silent_printing_ = false;
+
   // Intrinsic tab state -------------------------------------------------------
 
   // Gets/Sets the delegate.
diff -r -u --color up/chromium/content/public/browser/web_contents_delegate.cc nw/chromium/content/public/browser/web_contents_delegate.cc
--- up/chromium/content/public/browser/web_contents_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/web_contents_delegate.cc	2024-08-26 19:32:24.754588128 +0000
@@ -37,6 +37,10 @@
   return nullptr;
 }
 
+bool WebContentsDelegate::CanLoadFileSubresource(const GURL& url) {
+  return false;
+}
+
 bool WebContentsDelegate::ShouldAllowRendererInitiatedCrossProcessNavigation(
     bool is_outermost_main_frame_navigation) {
   return true;
diff -r -u --color up/chromium/content/public/browser/web_contents_delegate.h nw/chromium/content/public/browser/web_contents_delegate.h
--- up/chromium/content/public/browser/web_contents_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/browser/web_contents_delegate.h	2024-08-26 19:32:24.754588128 +0000
@@ -126,6 +126,8 @@
  public:
   WebContentsDelegate();
 
+  void set_tmp_manifest(const std::string& manifest) {manifest_ = manifest; }
+  const std::string& tmp_manifest() { return manifest_; }
   // Opens a new URL inside the passed in WebContents (if source is 0 open
   // in the current front-most tab), unless |disposition| indicates the url
   // should be opened in a new tab or window.
@@ -151,6 +153,7 @@
   virtual bool ShouldAllowRendererInitiatedCrossProcessNavigation(
       bool is_outermost_main_frame_navigation);
 
+  virtual bool CanLoadFileSubresource(const GURL& url);
   // Called to inform the delegate that the WebContents's navigation state
   // changed. The |changed_flags| indicates the parts of the navigation state
   // that have been updated.
@@ -365,7 +368,8 @@
                                   int opener_render_frame_id,
                                   const std::string& frame_name,
                                   const GURL& target_url,
-                                  WebContents* new_contents) {}
+                                  WebContents* new_contents,
+                                  const std::u16string& nw_window_manifest) {}
 
   // Notifies the embedder that a new WebContents dedicated for hosting a
   // prerendered page has been created. `prerender_web_contents` will host an
@@ -816,6 +820,8 @@
  protected:
   virtual ~WebContentsDelegate();
 
+  std::string manifest_;
+
  private:
   friend class WebContentsImpl;
 
diff -r -u --color up/chromium/content/public/common/content_client.h nw/chromium/content/public/common/content_client.h
--- up/chromium/content/public/common/content_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/common/content_client.h	2024-08-26 19:32:24.758588128 +0000
@@ -5,6 +5,9 @@
 #ifndef CONTENT_PUBLIC_COMMON_CONTENT_CLIENT_H_
 #define CONTENT_PUBLIC_COMMON_CONTENT_CLIENT_H_
 
+#include "base/files/file_path.h"
+#include "base/values.h"
+
 #include <set>
 #include <string>
 #include <string_view>
@@ -23,6 +26,7 @@
 namespace base {
 class RefCountedMemory;
 class SequencedTaskRunner;
+class DictionaryValue;
 }  // namespace base
 
 namespace blink {
@@ -60,10 +64,10 @@
 // content code is called.
 CONTENT_EXPORT void SetContentClient(ContentClient* client);
 
-#if defined(CONTENT_IMPLEMENTATION)
+//#if defined(CONTENT_IMPLEMENTATION)
 // Content's embedder API should only be used by content.
-ContentClient* GetContentClient();
-#endif
+CONTENT_EXPORT ContentClient* GetContentClient();
+//#endif
 
 // Used for tests to override the relevant embedder interfaces. Each method
 // returns the old value. In browser tests it seems safest to call these in
@@ -83,6 +87,9 @@
   ContentClient();
   virtual ~ContentClient();
 
+  virtual void LoadNWAppAsExtension(base::Value::Dict* manifest,
+                                    const base::FilePath& path,
+                                    std::string* error) {}
   ContentBrowserClient* browser() { return browser_; }
   ContentGpuClient* gpu() { return gpu_; }
   ContentRendererClient* renderer() { return renderer_; }
@@ -96,6 +103,7 @@
   // WebSecurityOrigin or a full URL (if called from the browser process) and a
   // string is the lowest-common-denominator.
   virtual void SetActiveURL(const GURL& url, std::string top_origin) {}
+  virtual void SetNWReportURL(const GURL& url) {}
 
   // Sets the data on the current gpu.
   virtual void SetGpuInfo(const gpu::GPUInfo& gpu_info) {}
diff -r -u --color up/chromium/content/public/common/content_features.cc nw/chromium/content/public/common/content_features.cc
--- up/chromium/content/public/common/content_features.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/common/content_features.cc	2024-08-26 19:32:24.758588128 +0000
@@ -16,6 +16,9 @@
 
 namespace features {
 
+BASE_FEATURE(kNWNewWin,
+	     "nw2", base::FEATURE_ENABLED_BY_DEFAULT);
+
 // All features in alphabetical order.
 
 // Kill switch to guard additional security checks performed by the browser
@@ -1011,7 +1014,7 @@
 // This feature is only consulted in site-per-process mode.
 BASE_FEATURE(kSpareRendererForSitePerProcess,
              "SpareRendererForSitePerProcess",
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT);
 
 // Controls whether site isolation should use origins instead of scheme and
 // eTLD+1.
diff -r -u --color up/chromium/content/public/common/content_features.h nw/chromium/content/public/common/content_features.h
--- up/chromium/content/public/common/content_features.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/common/content_features.h	2024-08-26 19:32:24.758588128 +0000
@@ -24,6 +24,8 @@
 // BEFORE MODIFYING THIS FILE: If your feature is only used inside content/, add
 // your feature in `content/common/features.h` instead.
 
+CONTENT_EXPORT extern const base::Feature kNWNewWin;
+
 // All features in alphabetical order. The features should be documented
 // alongside the definition of their values in the .cc file.
 CONTENT_EXPORT BASE_DECLARE_FEATURE(kAdditionalOpaqueOriginEnforcements);
diff -r -u --color up/chromium/content/public/common/content_switches.cc nw/chromium/content/public/common/content_switches.cc
--- up/chromium/content/public/common/content_switches.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/common/content_switches.cc	2024-08-26 19:32:24.758588128 +0000
@@ -140,9 +140,17 @@
 // then the GPU process won't launch.
 const char kDisableGpu[]                    = "disable-gpu";
 
+// Disable apps transparency support
+const char kDisableTransparency[]           = "disable-transparency";
+
+// Force CPU drawing, needed to enable click through on transparent window
+const char kForceCpuDraw[]                  = "force-cpu-draw";
+
 // Prevent the compositor from using its GPU implementation.
 const char kDisableGpuCompositing[]         = "disable-gpu-compositing";
-
+const char kDisableRAFThrottling[]          = "disable-raf-throttling";
+const char kEnableNodeWorker[]              = "enable-node-worker";
+const char kNWAppPath[]                     = "nwapp-path";
 // Disable proactive early init of GPU process.
 const char kDisableGpuEarlyInit[]           = "disable-gpu-early-init";
 
diff -r -u --color up/chromium/content/public/common/content_switches.h nw/chromium/content/public/common/content_switches.h
--- up/chromium/content/public/common/content_switches.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/common/content_switches.h	2024-08-26 19:32:24.758588128 +0000
@@ -52,7 +52,12 @@
 CONTENT_EXPORT extern const char kDisableFileSystem[];
 CONTENT_EXPORT extern const char kDisableGestureRequirementForPresentation[];
 CONTENT_EXPORT extern const char kDisableGpu[];
+CONTENT_EXPORT extern const char kDisableTransparency[];
+CONTENT_EXPORT extern const char kForceCpuDraw[];
 CONTENT_EXPORT extern const char kDisableGpuCompositing[];
+CONTENT_EXPORT extern const char kDisableRAFThrottling[];
+CONTENT_EXPORT extern const char kEnableNodeWorker[];
+CONTENT_EXPORT extern const char kNWAppPath[];
 CONTENT_EXPORT extern const char kDisableGpuEarlyInit[];
 CONTENT_EXPORT extern const char kDisableGpuMemoryBufferCompositorResources[];
 CONTENT_EXPORT extern const char kDisableGpuMemoryBufferVideoFrames[];
diff -r -u --color up/chromium/content/public/common/user_agent.h nw/chromium/content/public/common/user_agent.h
--- up/chromium/content/public/common/user_agent.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/common/user_agent.h	2024-08-26 19:32:24.762588126 +0000
@@ -53,6 +53,7 @@
     IncludeAndroidBuildNumber include_android_build_number,
     IncludeAndroidModel include_android_model);
 
+CONTENT_EXPORT std::string BuildOSInfo();
 // Returns the reduced User-agent string for
 // https://github.com/WICG/ua-client-hints.
 CONTENT_EXPORT std::string GetReducedUserAgent(bool mobile,
@@ -77,7 +78,6 @@
 // if on a codenamed (i.e. not a release) build of an Android.
 CONTENT_EXPORT std::string BuildModelInfo();
 
-#if BUILDFLAG(IS_ANDROID)
 // Helper function to generate a full user agent string given a short
 // product name and some extra text to be added to the OS info.
 // This is currently only used for Android Web View.
@@ -96,7 +96,6 @@
 CONTENT_EXPORT std::string GetAndroidOSInfo(
     IncludeAndroidBuildNumber include_android_build_number,
     IncludeAndroidModel include_android_model);
-#endif
 
 // Builds a full user agent string given a string describing the OS and a
 // product name.
diff -r -u --color up/chromium/content/public/renderer/content_renderer_client.cc nw/chromium/content/public/renderer/content_renderer_client.cc
--- up/chromium/content/public/renderer/content_renderer_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/renderer/content_renderer_client.cc	2024-08-26 19:32:24.762588126 +0000
@@ -44,6 +44,10 @@
   v8::V8::EnableWebAssemblyTrapHandler(use_v8_trap_handler);
 }
 
+base::FilePath ContentRendererClient::GetRootPath() {
+  return base::FilePath();
+}
+
 SkBitmap* ContentRendererClient::GetSadPluginBitmap() {
   return nullptr;
 }
diff -r -u --color up/chromium/content/public/renderer/content_renderer_client.h nw/chromium/content/public/renderer/content_renderer_client.h
--- up/chromium/content/public/renderer/content_renderer_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/renderer/content_renderer_client.h	2024-08-26 19:32:24.762588126 +0000
@@ -51,6 +51,7 @@
 
 namespace blink {
 class WebElement;
+class WebString;
 class WebFrame;
 class WebLocalFrame;
 class WebPlugin;
@@ -90,10 +91,18 @@
 
 namespace content {
 class RenderFrame;
+class RenderView;
 
 // Embedder API for participating in renderer logic.
 class CONTENT_EXPORT ContentRendererClient {
  public:
+  virtual base::FilePath GetRootPath();
+  virtual void willHandleNavigationPolicy(RenderFrame* rv,
+                                          blink::WebFrame* frame,
+                                          const blink::WebURLRequest& request,
+                                          blink::WebNavigationPolicy* policy,
+                                          blink::WebString* manifest,
+                                          bool new_win) {}
   virtual ~ContentRendererClient() {}
 
   // Notifies us that the RenderThread has been created.
diff -r -u --color up/chromium/content/public/renderer/render_thread.h nw/chromium/content/public/renderer/render_thread.h
--- up/chromium/content/public/renderer/render_thread.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/renderer/render_thread.h	2024-08-26 19:32:24.762588126 +0000
@@ -20,6 +20,8 @@
 #include "third_party/blink/public/platform/web_string.h"
 #include "third_party/perfetto/include/perfetto/tracing/traced_proto.h"
 
+class GURL;
+
 namespace base {
 class UnguessableToken;
 class WaitableEvent;
@@ -97,6 +99,11 @@
   // Post task to all worker threads. Returns number of workers.
   virtual int PostTaskToAllWebWorkers(base::RepeatingClosure closure) = 0;
 
+  // Resolve the proxy servers to use for a given url. On success true is
+  // returned and |proxy_list| is set to a PAC string containing a list of
+  // proxy servers.
+  virtual bool ResolveProxy(const GURL& url, std::string* proxy_list) = 0;
+
   // Gets the shutdown event for the process.
   virtual base::WaitableEvent* GetShutdownEvent() = 0;
 
diff -r -u --color up/chromium/content/public/test/browser_test_base.cc nw/chromium/content/public/test/browser_test_base.cc
--- up/chromium/content/public/test/browser_test_base.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/test/browser_test_base.cc	2024-08-26 19:32:24.770588126 +0000
@@ -345,6 +345,7 @@
 
   // Useful when debugging test failures.
   command_line->AppendSwitch(switches::kLogMissingUnloadACK);
+  command_line->AppendSwitch("nwjs-test-mode");
 
   command_line->AppendSwitch(switches::kDomAutomationController);
 
diff -r -u --color up/chromium/content/public/test/mock_render_thread.cc nw/chromium/content/public/test/mock_render_thread.cc
--- up/chromium/content/public/test/mock_render_thread.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/test/mock_render_thread.cc	2024-08-26 19:32:24.774588125 +0000
@@ -159,6 +159,10 @@
   return 0;
 }
 
+bool MockRenderThread::ResolveProxy(const GURL& url, std::string* proxy_list) {
+  return false;
+}
+
 base::WaitableEvent* MockRenderThread::GetShutdownEvent() {
   return nullptr;
 }
diff -r -u --color up/chromium/content/public/test/mock_render_thread.h nw/chromium/content/public/test/mock_render_thread.h
--- up/chromium/content/public/test/mock_render_thread.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/test/mock_render_thread.h	2024-08-26 19:32:24.774588125 +0000
@@ -79,6 +79,7 @@
   void RecordAction(const base::UserMetricsAction& action) override;
   void RecordComputedAction(const std::string& action) override;
   int PostTaskToAllWebWorkers(base::RepeatingClosure closure) override;
+  bool ResolveProxy(const GURL& url, std::string* proxy_list) override;
   base::WaitableEvent* GetShutdownEvent() override;
   int32_t GetClientId() override;
   void SetRendererProcessType(
diff -r -u --color up/chromium/content/public/test/render_view_test.cc nw/chromium/content/public/test/render_view_test.cc
--- up/chromium/content/public/test/render_view_test.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/public/test/render_view_test.cc	2024-08-26 19:32:24.778588125 +0000
@@ -755,6 +755,7 @@
       false /* has_text_fragment_token */,
       network::mojom::CSPDisposition::CHECK, std::vector<int>(), std::string(),
       false /* is_history_navigation_in_new_child_frame */,
+      false,
       base::TimeTicks() /* input_start */,
       network::mojom::RequestDestination::kDocument);
   auto commit_params = blink::CreateCommitNavigationParams();
@@ -889,6 +890,7 @@
       false /* has_text_fragment_token */,
       network::mojom::CSPDisposition::CHECK, std::vector<int>(), std::string(),
       false /* is_history_navigation_in_new_child_frame */,
+      false,
       base::TimeTicks() /* input_start */,
       network::mojom::RequestDestination::kDocument);
   auto commit_params = blink::CreateCommitNavigationParams();
diff -r -u --color up/chromium/content/renderer/BUILD.gn nw/chromium/content/renderer/BUILD.gn
--- up/chromium/content/renderer/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/BUILD.gn	2024-08-26 19:32:24.786588124 +0000
@@ -48,6 +48,8 @@
     "accessibility/ax_tree_snapshotter_impl.h",
     "accessibility/blink_ax_action_target.cc",
     "accessibility/blink_ax_action_target.h",
+    #"//base/message_loop/message_pumpuv_mac.mm",
+    #"//base/message_loop/message_pumpuv_mac.h",
     "accessibility/render_accessibility_impl.cc",
     "accessibility/render_accessibility_impl.h",
     "accessibility/render_accessibility_manager.cc",
diff -r -u --color up/chromium/content/renderer/agent_scheduling_group.cc nw/chromium/content/renderer/agent_scheduling_group.cc
--- up/chromium/content/renderer/agent_scheduling_group.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/agent_scheduling_group.cc	2024-08-26 19:32:24.786588124 +0000
@@ -325,12 +325,13 @@
 
     if (!local_params->previous_frame_token) {
       // Create a local non-provisional main frame.
-      RenderFrameImpl::CreateMainFrame(
+      RenderFrameImpl* main_frame = RenderFrameImpl::CreateMainFrame(
           *this, web_view, opener_frame, is_for_nested_main_frame,
           /*is_for_scalable_page=*/params->type !=
               mojom::ViewWidgetType::kFencedFrame,
           std::move(params->replication_state),
           params->devtools_main_frame_token, std::move(local_params), base_url);
+      main_frame->SetSkipBlockingParser(params->skip_blocking_parser);
     } else {
       // Create a local provisional main frame and a placeholder RemoteFrame as
       // a placeholder main frame for the new WebView. This can only happen for
@@ -403,7 +404,7 @@
           /*frame_owner_properties=*/nullptr,
           local_params->is_on_initial_empty_document,
           local_params->document_token,
-          std::move(local_params->policy_container), is_for_nested_main_frame);
+          std::move(local_params->policy_container), is_for_nested_main_frame, false);
     }
   }
 
@@ -429,7 +430,7 @@
       std::move(params->widget_params),
       std::move(params->frame_owner_properties),
       params->is_on_initial_empty_document, params->document_token,
-      std::move(params->policy_container), params->is_for_nested_main_frame);
+      std::move(params->policy_container), params->is_for_nested_main_frame, params->block_parser);
 }
 
 void AgentSchedulingGroup::CreateSharedStorageWorkletService(
diff -r -u --color up/chromium/content/renderer/frame_owner_properties_converter.cc nw/chromium/content/renderer/frame_owner_properties_converter.cc
--- up/chromium/content/renderer/frame_owner_properties_converter.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/frame_owner_properties_converter.cc	2024-08-26 19:32:24.786588124 +0000
@@ -13,6 +13,8 @@
   blink::WebFrameOwnerProperties result;
   result.name = blink::WebString::FromUTF8(mojo_properties.name);
   result.scrollbar_mode = mojo_properties.scrollbar_mode;
+  result.nwFakeTop = mojo_properties.nwfaketop;
+  result.nwuseragent = blink::WebString::FromUTF8(mojo_properties.nwuseragent);
   result.margin_width = mojo_properties.margin_width;
   result.margin_height = mojo_properties.margin_height;
   result.allow_fullscreen = mojo_properties.allow_fullscreen;
@@ -32,6 +34,8 @@
 
   mojo_properties->name = web_frame_owner_properties.name.Utf8();
   mojo_properties->scrollbar_mode = web_frame_owner_properties.scrollbar_mode;
+  mojo_properties->nwfaketop = web_frame_owner_properties.nwFakeTop;
+  mojo_properties->nwuseragent = web_frame_owner_properties.nwuseragent.Utf8();
   mojo_properties->margin_width = web_frame_owner_properties.margin_width;
   mojo_properties->margin_height = web_frame_owner_properties.margin_height;
   mojo_properties->allow_fullscreen =
diff -r -u --color up/chromium/content/renderer/in_process_renderer_thread.cc nw/chromium/content/renderer/in_process_renderer_thread.cc
--- up/chromium/content/renderer/in_process_renderer_thread.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/in_process_renderer_thread.cc	2024-08-26 19:32:24.790588122 +0000
@@ -13,6 +13,8 @@
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/platform/scheduler/web_thread_scheduler.h"
 
+#include "content/nw/src/nw_content.h"
+
 #if BUILDFLAG(IS_ANDROID)
 #include "base/android/jni_android.h"
 #endif
diff -r -u --color up/chromium/content/renderer/media/render_media_client.cc nw/chromium/content/renderer/media/render_media_client.cc
--- up/chromium/content/renderer/media/render_media_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/media/render_media_client.cc	2024-08-26 19:32:24.790588122 +0000
@@ -17,7 +17,7 @@
 
 namespace {
 
-#if BUILDFLAG(PLATFORM_HAS_OPTIONAL_HEVC_SUPPORT)
+#if 1 //BUILDFLAG(PLATFORM_HAS_OPTIONAL_HEVC_SUPPORT)
 void UpdateVideoProfilesInternal(
     const media::SupportedVideoDecoderConfigs& supported_configs) {
   base::flat_set<media::VideoCodecProfile> media_profiles;
diff -r -u --color up/chromium/content/renderer/render_frame_impl.cc nw/chromium/content/renderer/render_frame_impl.cc
--- up/chromium/content/renderer/render_frame_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/render_frame_impl.cc	2024-08-26 19:32:24.802588121 +0000
@@ -264,6 +264,9 @@
 
 using base::Time;
 using blink::ContextMenuData;
+
+#include "content/nw/src/nw_content.h"
+
 using blink::WebContentDecryptionModule;
 using blink::WebData;
 using blink::WebDocument;
@@ -668,7 +671,7 @@
       info->url_request.HasTextFragmentToken(),
       info->should_check_main_world_content_security_policy,
       initiator_origin_trial_features, info->href_translate.Latin1(),
-      is_history_navigation_in_new_child_frame, info->input_start,
+      is_history_navigation_in_new_child_frame, false, info->input_start,
       request_destination);
 }
 
@@ -1243,6 +1246,7 @@
     case blink::kWebNavigationPolicyDownload:
       return WindowOpenDisposition::SAVE_TO_DISK;
     case blink::kWebNavigationPolicyCurrentTab:
+    case blink::kWebNavigationPolicyIgnore:
       return WindowOpenDisposition::CURRENT_TAB;
     case blink::kWebNavigationPolicyNewBackgroundTab:
       return WindowOpenDisposition::NEW_BACKGROUND_TAB;
@@ -1523,6 +1527,16 @@
   return render_frame_->frame_;
 }
 
+void RenderFrameImpl::willHandleNavigationPolicy(
+                                                blink::WebFrame* frame,
+                                                const blink::WebURLRequest& request,
+                                                blink::WebNavigationPolicy* policy,
+                                                blink::WebString* manifest,
+                                                bool new_win) {
+  GetContentClient()->renderer()
+    ->willHandleNavigationPolicy(this, frame, request, policy, manifest, new_win);
+}
+
 // static
 RenderFrameImpl* RenderFrameImpl::Create(
     AgentSchedulingGroup& agent_scheduling_group,
@@ -1679,7 +1693,7 @@
     bool is_on_initial_empty_document,
     const blink::DocumentToken& document_token,
     blink::mojom::PolicyContainerPtr policy_container,
-    bool is_for_nested_main_frame) {
+    bool is_for_nested_main_frame, bool block_parser) {
   // TODO(danakj): Split this method into two pieces. The first block makes a
   // WebLocalFrame and collects the `blink::WebView` and RenderFrame for it. The
   // second block uses that to make a RenderWidget, if needed.
@@ -1781,6 +1795,7 @@
         GetUniqueNameOfWebFrame(previous_web_frame));
   }
 
+  render_frame->skip_blocking_parser_ = !block_parser;
   CHECK(web_view);
   CHECK(render_frame);
   CHECK(web_frame);
@@ -1894,7 +1909,8 @@
 
 // RenderFrameImpl ----------------------------------------------------------
 RenderFrameImpl::RenderFrameImpl(CreateParams params)
-    : agent_scheduling_group_(*params.agent_scheduling_group),
+  : skip_blocking_parser_(true), frame_(nullptr),
+      agent_scheduling_group_(*params.agent_scheduling_group),
       is_main_frame_(true),
       unique_name_frame_adapter_(this),
       unique_name_helper_(&unique_name_frame_adapter_),
@@ -2556,6 +2572,10 @@
   interface_provider_receivers_.Add(this, std::move(receiver), task_runner);
 }
 
+void RenderFrameImpl::SetSkipBlockingParser(bool value) {
+  skip_blocking_parser_ = value;
+}
+
 void RenderFrameImpl::AllowBindings(int32_t enabled_bindings_flags) {
   enabled_bindings_ |= enabled_bindings_flags;
 
@@ -4689,6 +4709,7 @@
         context, std::move(mojo_js_interface_broker_));
   }
 
+  GetFrameHost()->SetContextCreated(true);
   for (auto& observer : observers_)
     observer.DidCreateScriptContext(context, world_id);
 }
@@ -4697,6 +4718,7 @@
                                                int world_id) {
   for (auto& observer : observers_)
     observer.WillReleaseScriptContext(context, world_id);
+  GetFrameHost()->SetContextCreated(false);
 }
 
 void RenderFrameImpl::DidChangeScrollOffset() {
@@ -4718,6 +4740,10 @@
 }
 
 blink::WebString RenderFrameImpl::UserAgentOverride() {
+  std::string user_agent;
+  if (nw::GetUserAgentFromManifest(&user_agent))
+    return WebString::FromUTF8(user_agent);
+
   if (ShouldUseUserAgentOverride()) {
     return WebString::FromUTF8(GetWebView()
                                    ->GetRendererPreferences()
@@ -6590,7 +6616,8 @@
     bool& consumed_user_gesture,
     const std::optional<blink::Impression>& impression,
     const std::optional<blink::WebPictureInPictureWindowOptions>& pip_options,
-    const blink::WebURL& base_url) {
+    const blink::WebURL& base_url,
+    blink::WebString* manifest) {
   consumed_user_gesture = false;
   mojom::CreateNewWindowParamsPtr params = mojom::CreateNewWindowParams::New();
 
@@ -6636,6 +6663,7 @@
         request.GetReferrerPolicy());
   }
   params->features = ConvertWebWindowFeaturesToMojoWindowFeatures(features);
+  params->nw_window_manifest = manifest->Utf16();
 
   params->is_form_submission = request.IsFormSubmission();
   params->form_submission_post_data =
@@ -6734,6 +6762,7 @@
   // disagrees.
   mojom::CreateViewParamsPtr view_params = mojom::CreateViewParams::New();
 
+  view_params->skip_blocking_parser = true;
   view_params->opener_frame_token = GetWebFrame()->GetFrameToken();
   view_params->window_was_opened_by_another_window = true;
   view_params->renderer_preferences = GetWebView()->GetRendererPreferences();
diff -r -u --color up/chromium/content/renderer/render_frame_impl.h nw/chromium/content/renderer/render_frame_impl.h
--- up/chromium/content/renderer/render_frame_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/render_frame_impl.h	2024-08-26 19:32:24.806588120 +0000
@@ -189,6 +189,8 @@
   // is used to create a RenderFrame that is immediately attached as the main
   // frame of the `web_view`. Meanwhile, `CreateFrame()` is used to create
   // provisional main RenderFrames (and subframe creation cases).
+  bool skip_blocking_parser_;
+  void SetSkipBlockingParser(bool) override;
   static RenderFrameImpl* CreateMainFrame(
       AgentSchedulingGroup& agent_scheduling_group,
       blink::WebView* web_view,
@@ -249,7 +251,7 @@
       bool is_on_initial_empty_document,
       const blink::DocumentToken& document_token,
       blink::mojom::PolicyContainerPtr policy_container,
-      bool is_for_nested_main_frame);
+      bool is_for_nested_main_frame, bool block_parser);
 
 #if BUILDFLAG(CONTENT_ENABLE_LEGACY_IPC)
   // Returns the RenderFrameImpl for the given routing ID.
@@ -677,7 +679,8 @@
       bool& consumed_user_gesture,
       const std::optional<blink::Impression>& impression,
       const std::optional<blink::WebPictureInPictureWindowOptions>& pip_options,
-      const blink::WebURL& base_url) override;
+      const blink::WebURL& base_url,
+      blink::WebString* manifest) override;
   std::unique_ptr<blink::WebLinkPreviewTriggerer> CreateLinkPreviewTriggerer()
       override;
 
@@ -726,6 +729,13 @@
   // started media playback (i.e. played audio and video).
   bool DeferMediaLoad(bool has_played_media_before, base::OnceClosure closure);
 
+  void willHandleNavigationPolicy(
+                                  blink::WebFrame*,
+                                  const blink::WebURLRequest&,
+                                  blink::WebNavigationPolicy*,
+                                  blink::WebString* manifest = NULL,
+                                  bool new_win = true) override;
+
   // Binds to the MHTML file generation service in the browser.
   void BindMhtmlFileWriter(
       mojo::PendingAssociatedReceiver<mojom::MhtmlFileWriter> receiver);
diff -r -u --color up/chromium/content/renderer/render_process_impl.cc nw/chromium/content/renderer/render_process_impl.cc
--- up/chromium/content/renderer/render_process_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/render_process_impl.cc	2024-08-26 19:32:24.806588120 +0000
@@ -207,6 +207,12 @@
   if (base::FeatureList::IsEnabled(features::kWebAssemblyTrapHandler)) {
     content::GetContentClient()->renderer()->SetUpWebAssemblyTrapHandler();
   }
+
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("nwjs-guest")) {
+    std::string flags("--allow-natives-syntax");
+    v8::V8::SetFlagsFromString(flags.c_str(), static_cast<size_t>(flags.size()));
+  }
+
 }
 
 RenderProcessImpl::~RenderProcessImpl() {
diff -r -u --color up/chromium/content/renderer/render_thread_impl.cc nw/chromium/content/renderer/render_thread_impl.cc
--- up/chromium/content/renderer/render_thread_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/render_thread_impl.cc	2024-08-26 19:32:24.806588120 +0000
@@ -975,6 +975,13 @@
       std::move(closure));
 }
 
+bool RenderThreadImpl::ResolveProxy(const GURL& url, std::string* proxy_list) {
+  std::optional<std::string> result;
+  GetRendererHost()->ResolveProxy(url, &result);
+  *proxy_list = result.value_or(std::string());
+  return result.has_value();
+}
+
 media::GpuVideoAcceleratorFactories* RenderThreadImpl::GetGpuFactories() {
   DCHECK(IsMainThread());
 
diff -r -u --color up/chromium/content/renderer/render_thread_impl.h nw/chromium/content/renderer/render_thread_impl.h
--- up/chromium/content/renderer/render_thread_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/render_thread_impl.h	2024-08-26 19:32:24.806588120 +0000
@@ -175,6 +175,7 @@
   void AddObserver(RenderThreadObserver* observer) override;
   void RemoveObserver(RenderThreadObserver* observer) override;
   int PostTaskToAllWebWorkers(base::RepeatingClosure closure) override;
+  bool ResolveProxy(const GURL& url, std::string* proxy_list) override;
   base::WaitableEvent* GetShutdownEvent() override;
   int32_t GetClientId() override;
   void SetRendererProcessType(
diff -r -u --color up/chromium/content/renderer/renderer_blink_platform_impl.cc nw/chromium/content/renderer/renderer_blink_platform_impl.cc
--- up/chromium/content/renderer/renderer_blink_platform_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/renderer_blink_platform_impl.cc	2024-08-26 19:32:24.806588120 +0000
@@ -12,6 +12,8 @@
 #include <algorithm>
 #include <memory>
 #include <string_view>
+#include "content/nw/src/nw_version.h"
+
 #include <utility>
 #include <vector>
 
@@ -149,6 +151,26 @@
 using blink::WebURL;
 using blink::WebVector;
 
+// NEED TO STAY SYNC WITH NODE
+#ifndef NODE_CONTEXT_EMBEDDER_DATA_INDEX
+#define NODE_CONTEXT_EMBEDDER_DATA_INDEX 32
+#endif
+
+#include "third_party/node-nw/src/node_webkit.h"
+#include "nw/id/commit.h"
+
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+namespace nw{
+const char* GetChromiumVersion();
+}
+
 namespace content {
 
 namespace {
@@ -876,9 +898,67 @@
 }
 
 void RendererBlinkPlatformImpl::WorkerContextCreated(
-    const v8::Local<v8::Context>& worker) {
+    const v8::Local<v8::Context>& worker, bool isNodeJS, const std::string& main_script) {
   GetContentClient()->renderer()->DidInitializeWorkerContextOnWorkerThread(
       worker);
+  if (isNodeJS) {
+      int argc = 1;
+      char argv0[] = "node";
+      char* argv[3];
+      argv[0] = argv0;
+      argv[1] = argv[2] = nullptr;
+
+      v8::Isolate* isolate = v8::Isolate::GetCurrent();
+      v8::HandleScope scope(isolate);
+
+      v8::Local<v8::Context> new_node_context;
+      new_node_context = v8::Context::New(isolate);
+      void* data = worker->GetAlignedPointerFromEmbedderData(2); //v8ContextPerContextDataIndex
+      new_node_context->SetAlignedPointerInEmbedderData(2, data);
+      new_node_context->SetAlignedPointerInEmbedderData(50, (void*)0x08110800);
+
+      v8::MicrotasksScope microtasks(new_node_context, v8::MicrotasksScope::kDoNotRunMicrotasks);
+
+      new_node_context->SetSecurityToken(v8::String::NewFromUtf8(isolate, "nw-token", v8::NewStringType::kNormal).ToLocalChecked());
+      new_node_context->Enter();
+
+      ::g_start_nw_instance_fn(argc, argv, new_node_context, nullptr);
+      {
+        v8::Local<v8::Script> script =
+          v8::Script::Compile(new_node_context, v8::String::NewFromUtf8(isolate,
+                                                      (std::string("process.versions['nw'] = '" NW_VERSION_STRING "';") +
+                                                       "process.versions['node-webkit'] = '" NW_VERSION_STRING "';"
+                                                       "process.versions['nw-commit-id'] = '" NW_COMMIT_HASH "';"
+                                                       "process.versions['chromium'] = '" + "';").c_str(), v8::NewStringType::kNormal
+                                                              ).ToLocalChecked()).ToLocalChecked();
+        std::ignore = script->Run(new_node_context);
+      }
+      {
+        v8::Local<v8::Script> script =
+          v8::Script::Compile(new_node_context, v8::String::NewFromUtf8(isolate, main_script.c_str(), v8::NewStringType::kNormal).ToLocalChecked()).ToLocalChecked();
+        std::ignore = script->Run(new_node_context);
+      }
+      worker->SetAlignedPointerInEmbedderData(NODE_CONTEXT_EMBEDDER_DATA_INDEX, g_get_node_env_fn());
+      worker->SetSecurityToken(new_node_context->GetSecurityToken());
+
+      v8::Handle<v8::Object> nw = v8::Object::New(isolate);
+      v8::Handle<v8::String> nw_string(
+          v8::String::NewFromUtf8(isolate, "nw", v8::NewStringType::kNormal).ToLocalChecked());
+      std::ignore = new_node_context->Global()->Set(worker, nw_string, nw);
+
+      v8::Local<v8::Array> symbols = v8::Array::New(isolate, 4);
+      std::ignore = symbols->Set(worker, 0, v8::String::NewFromUtf8(isolate, "global", v8::NewStringType::kNormal).ToLocalChecked());
+      std::ignore = symbols->Set(worker, 1, v8::String::NewFromUtf8(isolate, "process", v8::NewStringType::kNormal).ToLocalChecked());
+      std::ignore = symbols->Set(worker, 2, v8::String::NewFromUtf8(isolate, "Buffer", v8::NewStringType::kNormal).ToLocalChecked());
+      std::ignore = symbols->Set(worker, 3, v8::String::NewFromUtf8(isolate, "require", v8::NewStringType::kNormal).ToLocalChecked());
+
+      for (unsigned i = 0; i < symbols->Length(); ++i) {
+	v8::Local<v8::Value> key = symbols->Get(worker, i).ToLocalChecked();
+	v8::Local<v8::Value> val = new_node_context->Global()->Get(worker, key).ToLocalChecked();
+	std::ignore = nw->Set(worker, key, val);
+	std::ignore = worker->Global()->Set(worker, key, val);
+      }
+  }
 }
 
 bool RendererBlinkPlatformImpl::AllowScriptExtensionForServiceWorker(
diff -r -u --color up/chromium/content/renderer/renderer_blink_platform_impl.h nw/chromium/content/renderer/renderer_blink_platform_impl.h
--- up/chromium/content/renderer/renderer_blink_platform_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/renderer_blink_platform_impl.h	2024-08-26 19:32:24.806588120 +0000
@@ -192,7 +192,7 @@
       const blink::BrowserInterfaceBrokerProxy&) override;
   void DidStartWorkerThread() override;
   void WillStopWorkerThread() override;
-  void WorkerContextCreated(const v8::Local<v8::Context>& worker) override;
+  void WorkerContextCreated(const v8::Local<v8::Context>& worker, bool, const std::string&) override;
   bool AllowScriptExtensionForServiceWorker(
       const blink::WebSecurityOrigin& script_origin) override;
   blink::ProtocolHandlerSecurityLevel GetProtocolHandlerSecurityLevel(
diff -r -u --color up/chromium/content/renderer/renderer_main.cc nw/chromium/content/renderer/renderer_main.cc
--- up/chromium/content/renderer/renderer_main.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/renderer_main.cc	2024-08-26 19:32:24.806588120 +0000
@@ -8,6 +8,7 @@
 #include <utility>
 
 #include "base/allocator/partition_alloc_support.h"
+#include "base/files/file_util.h"
 #include "base/base_switches.h"
 #include "base/command_line.h"
 #include "base/debug/debugger.h"
@@ -15,6 +16,7 @@
 #include "base/feature_list.h"
 #include "base/i18n/rtl.h"
 #include "base/message_loop/message_pump.h"
+#include "base/message_loop/message_pump_uv.h"
 #include "base/message_loop/message_pump_type.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
@@ -51,6 +53,7 @@
 #include "third_party/blink/public/platform/scheduler/web_thread_scheduler.h"
 #include "third_party/webrtc_overrides/init_webrtc.h"  // nogncheck
 #include "ui/base/ui_base_switches.h"
+#include "content/nw/src/nw_content.h"
 
 #if BUILDFLAG(IS_WIN)
 #include "components/startup_metric_utils/renderer/startup_metric_utils.h"
@@ -68,6 +71,7 @@
 #include "base/apple/scoped_nsautorelease_pool.h"
 #include "base/message_loop/message_pump_apple.h"
 #include "third_party/blink/public/web/web_view.h"
+#include "base/message_loop/message_pumpuv_mac.h"
 #endif  // BUILDFLAG(IS_MAC)
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -93,6 +97,17 @@
 #endif
 
 namespace content {
+
+#if defined(__clang__)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wexit-time-destructors"
+#endif
+CONTENT_EXPORT base::FilePath g_nw_temp_dir;
+CONTENT_EXPORT base::FilePath g_nw_old_cwd;
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
+
 namespace {
 
 // This function provides some ways to test crash and assertion handling
@@ -105,12 +120,18 @@
     WaitForDebugger("Renderer");
 }
 
-std::unique_ptr<base::MessagePump> CreateMainThreadMessagePump() {
+std::unique_ptr<base::MessagePump> CreateMainThreadMessagePump(bool nwjs) {
 #if BUILDFLAG(IS_FUCHSIA)
   // Allow FIDL APIs on renderer main thread.
   return base::MessagePump::Create(base::MessagePumpType::IO);
 #else
-  return base::MessagePump::Create(base::MessagePumpType::DEFAULT);
+  base::MessagePump* p;
+  if (nwjs) {
+    p = new base::MessagePumpUV();
+    std::unique_ptr<base::MessagePump> pump(p);
+    return pump;
+  } else
+    return base::MessagePump::Create(base::MessagePumpType::DEFAULT);
 #endif
 }
 
@@ -160,6 +181,11 @@
 
   const base::CommandLine& command_line = *parameters.command_line;
 
+  bool nwjs = command_line.HasSwitch(switches::kNWJS);
+
+  if (nwjs)
+    nw::LoadNodeSymbols();
+
 #if BUILDFLAG(IS_MAC)
   base::apple::ScopedNSAutoreleasePool* pool = parameters.autorelease_pool;
 #endif  // BUILDFLAG(IS_MAC)
@@ -215,7 +241,7 @@
   blink::Platform::InitializeBlink();
   std::unique_ptr<blink::scheduler::WebThreadScheduler> main_thread_scheduler =
       blink::scheduler::WebThreadScheduler::CreateMainThreadScheduler(
-          CreateMainThreadMessagePump());
+          CreateMainThreadMessagePump(nwjs));
 
   platform.PlatformInitialize();
 
@@ -359,6 +385,12 @@
       run_loop.Run();
     }
 
+    if (!g_nw_temp_dir.empty()) {
+      base::SetCurrentDirectory(g_nw_temp_dir.DirName());
+      if (base::StartsWith(g_nw_temp_dir.BaseName().value(), FILE_PATH_LITERAL("nw"),
+                           base::CompareCase::SENSITIVE))
+        base::DeleteFile(g_nw_temp_dir);
+    }
 #if defined(LEAK_SANITIZER)
     // Run leak detection before RenderProcessImpl goes out of scope. This helps
     // ignore shutdown-only leaks.
diff -r -u --color up/chromium/content/renderer/worker/embedded_shared_worker_stub.cc nw/chromium/content/renderer/worker/embedded_shared_worker_stub.cc
--- up/chromium/content/renderer/worker/embedded_shared_worker_stub.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/worker/embedded_shared_worker_stub.cc	2024-08-26 19:32:24.810588120 +0000
@@ -60,7 +60,8 @@
     ukm::SourceId ukm_source_id,
     bool require_cross_site_request_for_cookies,
     const std::vector<std::string>& cors_exempt_header_list)
-    : receiver_(this, std::move(receiver)) {
+    : receiver_(this, std::move(receiver)),
+      nodejs_(info->is_node_js), root_path_(info->root_path) {
   DCHECK(main_script_load_params);
   DCHECK(pending_subresource_loader_factory_bundle);
 
@@ -116,6 +117,7 @@
                                require_cross_site_request_for_cookies);
 
   impl_ = blink::WebSharedWorker::CreateAndStart(
+      nodejs_, root_path_,
       token, info->url, info->options->type, info->options->credentials,
       blink::WebString::FromUTF8(info->options->name),
       blink::WebSecurityOrigin(constructor_key.origin()),
diff -r -u --color up/chromium/content/renderer/worker/embedded_shared_worker_stub.h nw/chromium/content/renderer/worker/embedded_shared_worker_stub.h
--- up/chromium/content/renderer/worker/embedded_shared_worker_stub.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/renderer/worker/embedded_shared_worker_stub.h	2024-08-26 19:32:24.810588120 +0000
@@ -10,6 +10,7 @@
 
 #include "base/unguessable_token.h"
 #include "content/renderer/service_worker/service_worker_provider_context.h"
+#include "base/files/file_path.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "mojo/public/cpp/bindings/receiver.h"
@@ -112,6 +113,8 @@
   std::unique_ptr<blink::WebSharedWorker> impl_;
 
   scoped_refptr<ServiceWorkerProviderContext> service_worker_provider_context_;
+  bool nodejs_ = false;
+  base::FilePath root_path_;
 
   // The factory bundle used for loading subresources for this shared worker.
   scoped_refptr<blink::ChildURLLoaderFactoryBundle>
diff -r -u --color up/chromium/content/test/BUILD.gn nw/chromium/content/test/BUILD.gn
--- up/chromium/content/test/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/test/BUILD.gn	2024-08-26 19:32:24.838588116 +0000
@@ -2688,6 +2688,7 @@
     "../browser/renderer_host/render_widget_host_view_child_frame_unittest.cc",
     "../browser/renderer_host/transient_allow_popup_unittest.cc",
     "../browser/renderer_host/visible_time_request_trigger_unittest.cc",
+    "../browser/resolve_proxy_helper_unittest.cc",
     "../browser/scheduler/browser_io_thread_delegate_unittest.cc",
     "../browser/scheduler/browser_task_executor_unittest.cc",
     "../browser/scheduler/browser_task_queues_unittest.cc",
@@ -3406,7 +3407,7 @@
       "//device/base",
       "//device/fido",
       "//device/fido:cablev2_authenticator",
-      "//device/fido:cablev2_test_util",
+      #"//device/fido:cablev2_test_util",
       "//device/fido:mocks",
       "//device/fido:test_support",
     ]
diff -r -u --color up/chromium/content/test/test_render_frame.cc nw/chromium/content/test/test_render_frame.cc
--- up/chromium/content/test/test_render_frame.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/test/test_render_frame.cc	2024-08-26 19:32:25.278588052 +0000
@@ -123,6 +123,8 @@
 
  protected:
   // mojom::FrameHost:
+  void SetNodeJS(bool) override {}
+  void SetContextCreated(bool) override {}
   void CreateNewWindow(mojom::CreateNewWindowParamsPtr,
                        CreateNewWindowCallback) override {
     NOTREACHED_IN_MIGRATION()
diff -r -u --color up/chromium/content/test/test_web_contents.cc nw/chromium/content/test/test_web_contents.cc
--- up/chromium/content/test/test_web_contents.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/test/test_web_contents.cc	2024-08-26 19:32:25.278588052 +0000
@@ -376,7 +376,7 @@
     int route_id,
     WindowOpenDisposition disposition,
     const blink::mojom::WindowFeatures& window_features,
-    bool user_gesture) {}
+    bool user_gesture, std::string) {}
 
 void TestWebContents::ShowCreatedWidget(int process_id,
                                         int route_id,
diff -r -u --color up/chromium/content/test/test_web_contents.h nw/chromium/content/test/test_web_contents.h
--- up/chromium/content/test/test_web_contents.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/content/test/test_web_contents.h	2024-08-26 19:32:25.278588052 +0000
@@ -210,7 +210,7 @@
                          int route_id,
                          WindowOpenDisposition disposition,
                          const blink::mojom::WindowFeatures& window_features,
-                         bool user_gesture) override;
+                         bool user_gesture, std::string) override;
   void ShowCreatedWidget(int process_id,
                          int route_id,
                          const gfx::Rect& initial_rect,
diff -r -u --color up/chromium/device/bluetooth/BUILD.gn nw/chromium/device/bluetooth/BUILD.gn
--- up/chromium/device/bluetooth/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/device/bluetooth/BUILD.gn	2024-08-26 19:32:25.318588047 +0000
@@ -368,8 +368,8 @@
         "bluez/bluetooth_socket_bluez.h",
         "bluez/bluez_features.cc",
         "bluez/bluez_features.h",
-        "bluez/metrics_recorder.cc",
-        "bluez/metrics_recorder.h",
+        #"bluez/metrics_recorder.cc",
+        #"bluez/metrics_recorder.h",
         "dbus/bluetooth_adapter_client.cc",
         "dbus/bluetooth_adapter_client.h",
         "dbus/bluetooth_admin_policy_client.cc",
diff -r -u --color up/chromium/extensions/BUILD.gn nw/chromium/extensions/BUILD.gn
--- up/chromium/extensions/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/BUILD.gn	2024-08-26 19:32:25.606588005 +0000
@@ -180,7 +180,7 @@
     "//services/network/public/mojom",
     "//testing/gmock",
     "//testing/gtest",
-    "//third_party/cld_3/src/src:cld_3",
+    #"//third_party/cld_3/src/src:cld_3",
     "//third_party/zlib/google:zip",
   ]
 
diff -r -u --color up/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.cc nw/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.cc
--- up/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.cc	2024-08-26 19:32:25.606588005 +0000
@@ -26,6 +26,7 @@
 namespace Show = app_current_window_internal::Show;
 namespace SetBounds = app_current_window_internal::SetBounds;
 namespace SetSizeConstraints = app_current_window_internal::SetSizeConstraints;
+namespace SetResizable = app_current_window_internal::SetResizable;
 namespace SetIcon = app_current_window_internal::SetIcon;
 namespace SetShape = app_current_window_internal::SetShape;
 namespace SetAlwaysOnTop = app_current_window_internal::SetAlwaysOnTop;
@@ -264,6 +265,15 @@
 }
 
 ExtensionFunction::ResponseAction
+AppCurrentWindowInternalSetResizableFunction::Run() {
+  std::optional<SetResizable::Params> params(SetResizable::Params::Create(args()));
+  CHECK(params.has_value());
+  window()->GetBaseWindow()->SetResizable(params->flag);
+  window()->OnNativeWindowChanged();
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
 AppCurrentWindowInternalSetSizeConstraintsFunction::Run() {
   std::optional<SetSizeConstraints::Params> params =
       SetSizeConstraints::Params::Create(args());
@@ -352,8 +362,10 @@
 
 ExtensionFunction::ResponseAction
 AppCurrentWindowInternalSetAlwaysOnTopFunction::Run() {
+
   // TODO(devlin): Can't this be done with the feature files?
-  if (!extension()->permissions_data()->HasAPIPermission(
+  if (extension() != nullptr && // NWJS#5738
+      !extension()->permissions_data()->HasAPIPermission(
           extensions::mojom::APIPermissionID::kAlwaysOnTopWindows)) {
     return RespondNow(Error(kAlwaysOnTopPermission));
   }
diff -r -u --color up/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.h nw/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.h
--- up/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.h	2024-08-26 19:32:25.606588005 +0000
@@ -145,6 +145,16 @@
   ResponseAction Run() override;
 };
 
+class AppCurrentWindowInternalSetResizableFunction
+    : public AppCurrentWindowInternalExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("app.currentWindowInternal.setResizable",
+                             UNKNOWN)
+ protected:
+  ~AppCurrentWindowInternalSetResizableFunction() override {}
+  ResponseAction Run() override;
+};
+
 class AppCurrentWindowInternalSetIconFunction
     : public AppCurrentWindowInternalExtensionFunction {
  public:
diff -r -u --color up/chromium/extensions/browser/api/app_window/app_window_api.cc nw/chromium/extensions/browser/api/app_window/app_window_api.cc
--- up/chromium/extensions/browser/api/app_window/app_window_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/app_window/app_window_api.cc	2024-08-26 19:32:25.606588005 +0000
@@ -4,6 +4,8 @@
 
 #include "extensions/browser/api/app_window/app_window_api.h"
 
+#include "ui/display/display_export.h"
+
 #include <memory>
 #include <utility>
 
@@ -40,9 +42,15 @@
 #include "ui/gfx/geometry/rect.h"
 #include "url/gurl.h"
 
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
 namespace app_window = extensions::api::app_window;
 namespace Create = app_window::Create;
 
+namespace content {
+  DISPLAY_EXPORT extern bool g_support_transparency;
+}
 namespace extensions {
 
 namespace app_window_constants {
@@ -58,8 +66,8 @@
     "The $1 property cannot be specified for both inner and outer bounds.";
 constexpr char kAlwaysOnTopPermission[] =
     "The \"app.window.alwaysOnTop\" permission is required.";
-constexpr char kInvalidUrlParameter[] =
-    "The URL used for window creation must be local for security reasons.";
+//constexpr char kInvalidUrlParameter[] =
+//    "The URL used for window creation must be local for security reasons.";
 constexpr char kAlphaEnabledWrongChannel[] =
     "The alphaEnabled option requires dev channel or newer.";
 constexpr char kAlphaEnabledMissingPermission[] =
@@ -152,6 +160,10 @@
   // to allow component apps to open chrome URLs (e.g. for the settings page
   // on ChromeOS).
   GURL absolute = GURL(params->url);
+
+  if (absolute.has_scheme())
+    url = absolute;
+#if 0
   if (absolute.has_scheme()) {
     if (extension()->location() == mojom::ManifestLocation::kComponent &&
         absolute.SchemeIs(content::kChromeUIScheme)) {
@@ -161,13 +173,27 @@
       return RespondNow(Error(app_window_constants::kInvalidUrlParameter));
     }
   }
-
+#endif
   // TODO(jeremya): figure out a way to pass the opening WebContents through to
   // AppWindow::Create so we can set the opener at create time rather than
   // with a hack in AppWindowCustomBindings::GetView().
   AppWindow::CreateParams create_params;
   std::optional<app_window::CreateWindowOptions>& options = params->options;
   if (options) {
+    if (options->title)
+      create_params.title = *options->title;
+
+    if (options->icon) {
+      base::ScopedAllowBlocking allow_io;
+      gfx::Image app_icon;
+      nw::Package* package = nw::package();
+      if (nw::GetPackageImage(package,
+                              base::FilePath::FromUTF8Unsafe(*options->icon),
+                              &app_icon)) {
+        create_params.icon = app_icon;
+      }
+    }
+
     if (options->id) {
       // TODO(mek): use URL if no id specified?
       // Limit length of id to 256 characters.
@@ -308,6 +334,8 @@
 #else
       // Transparency is only supported on Aura.
       // Fallback to creating an opaque window (by ignoring alphaEnabled).
+      if (content::g_support_transparency)
+        create_params.alpha_enabled = *options->alpha_enabled;
 #endif
     }
 
@@ -355,6 +383,23 @@
       }
     }
 
+    if (options->show_in_taskbar) {
+      create_params.show_in_taskbar = *options->show_in_taskbar;
+    }
+
+    if (options->new_instance) {
+      create_params.new_instance = *options->new_instance;
+    }
+
+    if (options->inject_js_start) {
+      create_params.inject_js_start =
+          *options->inject_js_start;
+    }
+    if (options->inject_js_end) {
+      create_params.inject_js_end =
+          *options->inject_js_end;
+    }
+
     switch (options->state) {
       case app_window::State::kNone:
       case app_window::State::kNormal:
@@ -389,9 +434,23 @@
     action_type = options->lock_screen_action;
     create_params.show_on_lock_screen = true;
   }
+  switch (options->position) {
+  case app_window::Position::kNone:
+    create_params.position = extensions::AppWindow::POS_NONE;
+    break;
+  case app_window::Position::kCenter:
+    create_params.position = extensions::AppWindow::POS_CENTER;
+    break;
+  case app_window::Position::kMouse:
+    create_params.position = extensions::AppWindow::POS_MOUSE;
+    break;
+  }
 
   create_params.creator_process_id = source_process_id();
 
+  if (create_params.new_instance)
+    nw::SetPinningRenderer(false);
+
   AppWindow* app_window = nullptr;
   if (action_type == api::app_runtime::ActionType::kNone) {
     app_window =
@@ -410,15 +469,24 @@
   app_window->Init(url, std::make_unique<AppWindowContentsImpl>(app_window),
                    render_frame_host(), create_params);
 
+  if (create_params.new_instance)
+    nw::SetPinningRenderer(true);
+
   if (ExtensionsBrowserClient::Get()->IsRunningInForcedAppMode() &&
       !app_window->is_ime_window()) {
     app_window->ForcedFullscreen();
   }
 
+  if (options && options->kiosk)
+    app_window->ForcedFullscreen();
+
   if (AppWindowRegistry::Get(browser_context())
           ->HadDevToolsAttached(app_window->web_contents())) {
+    base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+    if (!command_line->HasSwitch("skip-reopen-app-devtools")) {
     AppWindowClient::Get()->OpenDevToolsWindow(app_window->web_contents(),
                                                base::DoNothing());
+    }
   }
 
   // Delay sending the response until the newly created window has finished its
diff -r -u --color up/chromium/extensions/browser/api/content_settings/content_settings_store.cc nw/chromium/extensions/browser/api/content_settings/content_settings_store.cc
--- up/chromium/extensions/browser/api/content_settings/content_settings_store.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/content_settings/content_settings_store.cc	2024-08-26 19:32:25.614588005 +0000
@@ -180,6 +180,22 @@
   {
     base::AutoLock lock(lock_);
     OriginValueMap* map = GetValueMap(ext_id, scope);
+    if (!map) {
+      ExtensionEntry* entry = new ExtensionEntry;
+      entry->install_time = base::Time::Now();
+
+      auto unique_entry = base::WrapUnique(entry);
+      auto location =
+        std::upper_bound(entries_.begin(), entries_.end(), unique_entry,
+                         [](const std::unique_ptr<ExtensionEntry>& a,
+                            const std::unique_ptr<ExtensionEntry>& b) {
+                           return a->install_time > b->install_time;
+                         });
+      entries_.insert(location, std::move(unique_entry));
+      entry->id = ext_id;
+      entry->enabled = true;
+      map = GetValueMap(ext_id, scope);
+    }
     base::AutoLock map_lock(map->GetLock());
     if (setting == CONTENT_SETTING_DEFAULT) {
       map->DeleteValue(primary_pattern, secondary_pattern, type);
diff -r -u --color up/chromium/extensions/browser/api/execute_code_function.cc nw/chromium/extensions/browser/api/execute_code_function.cc
--- up/chromium/extensions/browser/api/execute_code_function.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/execute_code_function.cc	2024-08-26 19:32:25.622588004 +0000
@@ -6,6 +6,7 @@
 #define EXTENSIONS_BROWSER_API_EXECUTE_CODE_FUNCTION_IMPL_H_
 
 #include "extensions/browser/api/execute_code_function.h"
+#include "content/nw/src/browser/nw_chrome_browser_hooks.h"
 
 #include <optional>
 #include <utility>
@@ -111,6 +112,9 @@
       break;
   }
 
+  ScriptExecutor::WorldType world_type = details_->main_world && *details_->main_world
+    ? ScriptExecutor::MAIN_WORLD : ScriptExecutor::ISOLATED_WORLD;
+
   mojom::CodeInjectionPtr injection;
   bool is_css_injection = ShouldInsertCSS() || ShouldRemoveCSS();
   if (is_css_injection) {
@@ -146,6 +150,7 @@
   executor->ExecuteScript(
       host_id_, std::move(injection), frame_scope, {root_frame_id_},
       match_about_blank, run_at,
+      world_type,
       IsWebView() ? ScriptExecutor::WEB_VIEW_PROCESS
                   : ScriptExecutor::DEFAULT_PROCESS,
       GetWebViewSrc(),
diff -r -u --color up/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.cc nw/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.cc
--- up/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.cc	2024-08-26 19:32:25.626588003 +0000
@@ -4,6 +4,9 @@
 
 #include "extensions/browser/api/guest_view/web_view/web_view_internal_api.h"
 
+#include "content/public/common/content_client.h"
+#include "content/public/browser/content_browser_client.h"
+
 #include <memory>
 #include <set>
 #include <string>
@@ -166,7 +169,7 @@
   // if needed.
   bool allowed_everywhere =
       extension && extensions::PermissionsData::CanExecuteScriptEverywhere(
-                       extension->id(), extension->location());
+                                                                           extension->id(), extension->location(), extension->GetType());
   for (const std::string& match : script_value.matches) {
     URLPattern pattern(UserScript::ValidUserScriptSchemes(allowed_everywhere));
     if (pattern.Parse(match) != URLPattern::ParseResult::kSuccess) {
@@ -900,8 +903,10 @@
   const url::Origin& owner_origin = guest.owner_rfh()->GetLastCommittedOrigin();
   const GURL base_url(params->base_url);
   const bool base_in_owner_origin = owner_origin.IsSameOriginWith(base_url);
+  bool owner_is_nwjs =
+    content::GetContentClient()->browser()->IsNWOrigin(owner_origin, browser_context());
   if (!base_url.is_valid() ||
-      (!base_url.SchemeIsHTTPOrHTTPS() && !base_in_owner_origin)) {
+      (!base_url.SchemeIsHTTPOrHTTPS() && !base_in_owner_origin && !owner_is_nwjs)) {
     return RespondNow(ExtensionFunction::Error(
         "Invalid base URL \"*\".", base_url.possibly_invalid_spec()));
   }
@@ -930,6 +935,40 @@
   return RespondNow(ExtensionFunction::NoArguments());
 }
 
+WebViewInternalShowDevToolsFunction::WebViewInternalShowDevToolsFunction() {
+}
+
+WebViewInternalShowDevToolsFunction::~WebViewInternalShowDevToolsFunction() {
+}
+
+ExtensionFunction::ResponseAction
+WebViewInternalShowDevToolsFunction::Run() {
+  std::optional<web_view_internal::ShowDevTools::Params> params(
+             web_view_internal::ShowDevTools::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params.has_value());
+
+  int proc_id = params->proc_id ? *params->proc_id : -1;
+  int guest_id = params->guest_id ? *params->guest_id : -1;
+  GetGuest().ShowDevTools(params->show, proc_id, guest_id);
+  return RespondNow(NoArguments());
+}
+
+WebViewInternalInspectElementAtFunction::WebViewInternalInspectElementAtFunction() {
+}
+
+WebViewInternalInspectElementAtFunction::~WebViewInternalInspectElementAtFunction() {
+}
+
+ExtensionFunction::ResponseAction
+WebViewInternalInspectElementAtFunction::Run() {
+  std::optional<web_view_internal::InspectElementAt::Params> params(
+           web_view_internal::InspectElementAt::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params.has_value());
+
+  GetGuest().InspectElement(params->x, params->y);
+  return RespondNow(NoArguments());
+}
+
 WebViewInternalGoFunction::WebViewInternalGoFunction() {
 }
 
diff -r -u --color up/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.h nw/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.h
--- up/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.h	2024-08-26 19:32:25.626588003 +0000
@@ -419,6 +419,35 @@
   ResponseAction Run() override;
 };
 
+class WebViewInternalShowDevToolsFunction
+    : public WebViewInternalExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("webViewInternal.showDevTools", UNKNOWN)
+
+  WebViewInternalShowDevToolsFunction();
+
+ protected:
+  ~WebViewInternalShowDevToolsFunction() override;
+
+  ResponseAction Run() override;
+ private:
+
+};
+
+class WebViewInternalInspectElementAtFunction
+    : public WebViewInternalExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("webViewInternal.inspectElementAt", UNKNOWN)
+
+  WebViewInternalInspectElementAtFunction();
+
+ protected:
+  ~WebViewInternalInspectElementAtFunction() override;
+  ResponseAction Run() override;
+ private:
+
+};
+
 class WebViewInternalGoFunction : public WebViewInternalExtensionFunction {
  public:
   DECLARE_EXTENSION_FUNCTION("webViewInternal.go", WEBVIEWINTERNAL_GO)
diff -r -u --color up/chromium/extensions/browser/api/runtime/runtime_api.cc nw/chromium/extensions/browser/api/runtime/runtime_api.cc
--- up/chromium/extensions/browser/api/runtime/runtime_api.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/runtime/runtime_api.cc	2024-08-26 19:32:25.634588001 +0000
@@ -4,6 +4,9 @@
 
 #include "extensions/browser/api/runtime/runtime_api.h"
 
+#include "content/nw/src/browser/nw_chrome_browser_hooks.h"
+#include "chrome/browser/first_run/first_run.h"
+
 #include <memory>
 #include <utility>
 #include <vector>
@@ -268,6 +271,7 @@
 
 void RuntimeAPI::OnExtensionLoaded(content::BrowserContext* browser_context,
                                    const Extension* extension) {
+  bool nw_skip = (extension->id() == nw::GetMainExtensionId() && !first_run::IsChromeFirstRun());
   if (!dispatch_chrome_updated_event_) {
     return;
   }
@@ -276,7 +280,7 @@
   base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(
       FROM_HERE,
       base::BindOnce(&RuntimeEventRouter::DispatchOnInstalledEvent,
-                     browser_context_, extension->id(), base::Version(), true));
+                     browser_context_, extension->id(), base::Version(), true, nw_skip));
 }
 
 void RuntimeAPI::OnExtensionUninstalled(
@@ -484,7 +488,7 @@
     content::BrowserContext* context,
     const ExtensionId& extension_id,
     const base::Version& old_version,
-    bool chrome_updated) {
+    bool chrome_updated, bool nw_skip) {
   if (!ExtensionsBrowserClient::Get()->IsValidContext(context)) {
     return;
   }
@@ -518,12 +522,12 @@
   event_args.Append(std::move(info));
   EventRouter* event_router = EventRouter::Get(context);
   DCHECK(event_router);
-  auto event = std::make_unique<Event>(events::RUNTIME_ON_INSTALLED,
-                                       runtime::OnInstalled::kEventName,
+  auto event = std::make_unique<Event>(nw_skip? events::UNKNOWN: events::RUNTIME_ON_INSTALLED,
+                                       nw_skip? runtime::OnInstalledNW::kEventName: runtime::OnInstalled::kEventName,
                                        std::move(event_args));
   event_router->DispatchEventWithLazyListener(extension_id, std::move(event));
 
-  if (old_version.IsValid()) {
+  if (!nw_skip && old_version.IsValid()) {
     const Extension* extension =
         ExtensionRegistry::Get(context)->enabled_extensions().GetByID(
             extension_id);
@@ -636,10 +640,11 @@
     content::BrowserContext* browser_context,
     const Extension* extension,
     const base::Version& previous_version) {
+  bool nw_skip = (extension->id() == nw::GetMainExtensionId() && !first_run::IsChromeFirstRun());
   base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(
       FROM_HERE, base::BindOnce(&RuntimeEventRouter::DispatchOnInstalledEvent,
                                 browser_context_, extension->id(),
-                                previous_version, false));
+                                previous_version, false, nw_skip));
 }
 
 ExtensionFunction::ResponseAction RuntimeGetBackgroundPageFunction::Run() {
diff -r -u --color up/chromium/extensions/browser/api/runtime/runtime_api.h nw/chromium/extensions/browser/api/runtime/runtime_api.h
--- up/chromium/extensions/browser/api/runtime/runtime_api.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/runtime/runtime_api.h	2024-08-26 19:32:25.634588001 +0000
@@ -203,7 +203,7 @@
   static void DispatchOnInstalledEvent(content::BrowserContext* context,
                                        const ExtensionId& extension_id,
                                        const base::Version& old_version,
-                                       bool chrome_updated);
+                                       bool chrome_updated, bool nw_skip);
 
   // Dispatches the onUpdateAvailable event to the given extension.
   static void DispatchOnUpdateAvailableEvent(content::BrowserContext* context,
diff -r -u --color up/chromium/extensions/browser/api/web_request/extension_web_request_event_router.cc nw/chromium/extensions/browser/api/web_request/extension_web_request_event_router.cc
--- up/chromium/extensions/browser/api/web_request/extension_web_request_event_router.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/web_request/extension_web_request_event_router.cc	2024-08-26 19:32:25.646588000 +0000
@@ -2209,7 +2209,7 @@
   if (request.is_web_view) {
     // If this is a navigation request, then we can skip this check. IDs will
     // be -1 and the request is trusted.
-    if (!request.is_navigation_request &&
+    if (//!request.is_navigation_request &&
         listener.id.render_process_id != request.web_view_embedder_process_id) {
       return false;
     }
diff -r -u --color up/chromium/extensions/browser/api/web_request/web_request_info.cc nw/chromium/extensions/browser/api/web_request/web_request_info.cc
--- up/chromium/extensions/browser/api/web_request/web_request_info.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/api/web_request/web_request_info.cc	2024-08-26 19:32:25.646588000 +0000
@@ -214,6 +214,8 @@
         navigation_ui_data->web_view_rules_registry_id();
     frame_data = navigation_ui_data->frame_data();
     parent_routing_id = navigation_ui_data->parent_routing_id();
+    web_view_embedder_process_id =
+        navigation_ui_data->web_view_embedder_process_id();
   } else if (frame_routing_id != MSG_ROUTING_NONE) {
     // Grab any WebView-related information if relevant.
     WebViewRendererState::WebViewInfo web_view_info;
diff -r -u --color up/chromium/extensions/browser/app_window/app_web_contents_helper.cc nw/chromium/extensions/browser/app_window/app_web_contents_helper.cc
--- up/chromium/extensions/browser/app_window/app_web_contents_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_web_contents_helper.cc	2024-08-26 19:32:25.650587999 +0000
@@ -58,12 +58,28 @@
   // TODO(mihaip): Can we check for user gestures instead?
   WindowOpenDisposition disposition = params.disposition;
   if (disposition == WindowOpenDisposition::CURRENT_TAB) {
-    web_contents_->GetPrimaryMainFrame()->AddMessageToConsole(
+    if (GetExtension()->is_nwjs_app()) {
+      content::NavigationController::LoadURLParams load_url_params(params.url);
+      load_url_params.source_site_instance = params.source_site_instance;
+      load_url_params.referrer = params.referrer;
+      load_url_params.frame_tree_node_id = params.frame_tree_node_id;
+      load_url_params.redirect_chain = params.redirect_chain;
+      load_url_params.transition_type = params.transition;
+      load_url_params.extra_headers = params.extra_headers;
+      load_url_params.should_replace_current_entry =
+        params.should_replace_current_entry;
+      load_url_params.is_renderer_initiated = params.is_renderer_initiated;
+
+      web_contents_->GetController().LoadURLWithParams(load_url_params);
+      return web_contents_;
+    } else {
+      web_contents_->GetPrimaryMainFrame()->AddMessageToConsole(
         blink::mojom::ConsoleMessageLevel::kError,
         base::StringPrintf(
             "Can't open same-window link to \"%s\"; try target=\"_blank\".",
             params.url.spec().c_str()));
-    return nullptr;
+      return nullptr;
+    }
   }
 
   // These dispositions aren't really navigations.
diff -r -u --color up/chromium/extensions/browser/app_window/app_window.cc nw/chromium/extensions/browser/app_window/app_window.cc
--- up/chromium/extensions/browser/app_window/app_window.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_window.cc	2024-08-26 19:32:25.650587999 +0000
@@ -4,6 +4,10 @@
 
 #include "extensions/browser/app_window/app_window.h"
 
+#include "components/web_cache/browser/web_cache_manager.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/browser/renderer_host/render_frame_host_impl.h"
+#include "base/command_line.h"
 #include <stddef.h>
 
 #include <algorithm>
@@ -29,7 +33,9 @@
 #include "content/public/browser/navigation_entry.h"
 #include "content/public/browser/render_view_host.h"
 #include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/render_widget_host_view.h"
 #include "content/public/browser/web_contents.h"
+#include "content/public/common/content_switches.h"
 #include "extensions/browser/app_window/app_delegate.h"
 #include "extensions/browser/app_window/app_web_contents_helper.h"
 #include "extensions/browser/app_window/app_window_client.h"
@@ -62,7 +68,29 @@
 #include "extensions/browser/pref_names.h"
 #endif
 
+
 using blink::mojom::ConsoleMessageLevel;
+
+#if defined(OS_MAC)
+#include "content/public/browser/browser_plugin_guest_manager.h"
+#include "extensions/browser/process_manager.h"
+#endif
+
+#include "extensions/browser/extension_host.h"
+//#include "extensions/common/extension_messages.h"
+
+#include "content/public/browser/render_frame_host.h"
+#include "third_party/blink/public/mojom/renderer_preferences.mojom.h"
+
+#include "extensions/browser/process_manager.h"
+#include "extensions/browser/app_window/app_window_contents.h"
+#include "extensions/browser/event_router.h"
+
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/common/shell_switches.h"
+
+
 using content::BrowserContext;
 using content::WebContents;
 using web_modal::WebContentsModalDialogHost;
@@ -173,7 +201,13 @@
       always_on_top(false),
       visible_on_all_workspaces(false),
       show_on_lock_screen(false),
-      show_in_shelf(false) {}
+      show_in_shelf(false),
+      skip_load(false),
+      show_in_taskbar(true),
+      new_instance(false),
+      skip_block_parser(false)
+{
+}
 
 AppWindow::CreateParams::CreateParams(const CreateParams& other) = default;
 
@@ -236,7 +270,7 @@
 AppWindow::AppWindow(BrowserContext* context,
                      std::unique_ptr<AppDelegate> app_delegate,
                      const Extension* extension)
-    : browser_context_(context),
+    : menu_(nullptr), browser_context_(context),
       extension_id_(extension->id()),
       session_id_(SessionID::NewUnique()),
       app_delegate_(std::move(app_delegate)) {
@@ -245,13 +279,53 @@
       << "Only off the record window may be opened in the guest mode.";
 }
 
+void AppWindow::LoadingStateChanged(content::WebContents* source, bool to_different_document) {
+  base::Value::List args;
+  if (source->IsLoading()) {
+    args.Append("loading");
+    last_to_different_document_ = to_different_document;
+    if (!to_different_document) //NWJS#5001
+      return;
+  } else {
+    if (!last_to_different_document_)
+      return;
+    args.Append("loaded");
+  }
+  content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+    ExtensionWebContentsObserver::GetForWebContents(web_contents())
+      ->GetLocalFrame(rfh)
+      ->MessageInvoke(
+                      extension_id(),
+                      "nw.Window",
+                      "LoadingStateChanged",
+                      std::move(args));
+}
+
 void AppWindow::Init(const GURL& url,
                      std::unique_ptr<AppWindowContents> app_window_contents,
                      content::RenderFrameHost* creator_frame,
                      const CreateParams& params) {
   // Initialize the render interface and web contents
   app_window_contents_ = std::move(app_window_contents);
-  app_window_contents_->Initialize(browser_context(), creator_frame, url);
+  app_window_contents_->Initialize(browser_context(), creator_frame, url,
+                                   GetExtension(), params.new_instance || params.skip_block_parser);
+
+  nw::Package* package = nw::package();
+  std::string js_doc_start(params.inject_js_start), js_doc_end(params.inject_js_end);
+  if (js_doc_start.empty()) {
+    std::string* str = package->root()->FindString(::switches::kmInjectJSDocStart);
+    if (str)
+      js_doc_start = *str;
+  }
+  web_contents()->GetMutableRendererPrefs()->nw_inject_js_doc_start = js_doc_start;
+  if (js_doc_end.empty()) {
+    std::string* str = package->root()->FindString(::switches::kmInjectJSDocEnd);
+    if (str)
+      js_doc_end = *str;
+  }
+  web_contents()->GetMutableRendererPrefs()->nw_inject_js_doc_end = js_doc_end;
+  if (!js_doc_start.empty() || !js_doc_end.empty())
+    web_contents()->SyncRendererPrefs();
 
   initial_url_ = url;
 
@@ -276,11 +350,22 @@
 
   // Windows cannot be always-on-top in fullscreen mode for security reasons.
   cached_always_on_top_ = new_params.always_on_top;
+#if 0
   if (new_params.state == ui::SHOW_STATE_FULLSCREEN &&
       !ExtensionsBrowserClient::Get()->IsScreensaverInDemoMode(
           extension_id())) {
     new_params.always_on_top = false;
   }
+#endif
+
+  title_override_ = new_params.title;
+  custom_app_icon_ = new_params.icon;
+  icon_override_ = new_params.icon;
+
+  content::g_support_transparency = !base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kDisableTransparency);
+  if (content::g_support_transparency) {
+    content::g_force_cpu_draw = base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kForceCpuDraw);
+  }
 
   requested_alpha_enabled_ = new_params.alpha_enabled;
   is_ime_window_ = params.is_ime_window;
@@ -318,6 +403,9 @@
     Show(new_params.focused ? SHOW_ACTIVE : SHOW_INACTIVE);
   }
 
+  if (!new_params.show_in_taskbar)
+    SetShowInTaskbar(false);
+
   OnNativeWindowChanged();
 
   ExtensionRegistry::Get(browser_context_)->AddObserver(this);
@@ -326,7 +414,8 @@
   app_delegate_->SetTerminatingCallback(base::BindOnce(
       &NativeAppWindow::Close, base::Unretained(native_app_window_.get())));
 
-  app_window_contents_->LoadContents(new_params.creator_process_id);
+  if (!params.skip_load)
+    app_window_contents_->LoadContents(new_params.creator_process_id);
 }
 
 AppWindow::~AppWindow() {
@@ -370,9 +459,29 @@
     bool user_gesture,
     bool* was_blocked) {
   DCHECK(new_contents->GetBrowserContext() == browser_context_);
-  app_delegate_->AddNewContents(browser_context_, std::move(new_contents),
-                                target_url, disposition, window_features,
-                                user_gesture);
+  const extensions::Extension* extension = GetExtension();
+  extensions::AppWindow* app_window =
+      extensions::AppWindowClient::Get()->CreateAppWindow(browser_context_, extension);
+
+  extensions::AppWindow::CreateParams params;
+  std::string js_doc_start, js_doc_end;
+  nw::CalcNewWinParams(new_contents.get(), &params, &js_doc_start, &js_doc_end, std::string());
+  nw::SetCurrentNewWinManifest(std::u16string());
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_start = js_doc_start;
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_end = js_doc_end;
+  new_contents->SyncRendererPrefs();
+
+  if(window_features.bounds.width() != 0) {
+    params.content_spec.bounds = window_features.bounds; //NWJS#5517
+  }
+  params.skip_load = true;
+  GURL new_url = new_contents->GetURL();
+  app_window->Init(new_url,
+                   std::make_unique<AppWindowContentsImpl>(app_window, std::move(new_contents)),
+                   web_contents()->GetPrimaryMainFrame(),
+                   params);
 }
 
 content::KeyboardEventProcessingResult AppWindow::PreHandleKeyboardEvent(
@@ -404,6 +513,7 @@
 bool AppWindow::HandleKeyboardEvent(
     WebContents* source,
     const input::NativeWebKeyboardEvent& event) {
+#if 0
   // If the window is currently fullscreen and not forced, ESC should leave
   // fullscreen.  If this code is being called for ESC, that means that the
   // KeyEvent's default behavior was not prevented by the content.
@@ -413,6 +523,8 @@
     return true;
   }
 
+#endif
+
   return native_app_window_->HandleKeyboardEvent(event);
 }
 
@@ -425,7 +537,28 @@
 
 bool AppWindow::PreHandleGestureEvent(WebContents* source,
                                       const blink::WebGestureEvent& event) {
-  return AppWebContentsHelper::ShouldSuppressGestureEvent(event);
+#if defined(OS_MAC)
+  // Disable "smart zoom" (double-tap with two fingers on Mac trackpad)
+  // for the PDF viewer, otherwise the viewer's controls will be scaled off
+  // screen.
+  // TODO(mcnee): Investigate having the PDF viewer handle the gesture
+  // once it is a service. crbug.com/757541
+  if (event.GetType() == blink::WebInputEvent::Type::kGestureDoubleTap) {
+    content::BrowserPluginGuestManager* guest_manager =
+        source->GetBrowserContext()->GetGuestManager();
+    if (guest_manager) {
+      content::WebContents* guest_contents = guest_manager->GetFullPageGuest(source);
+      if (guest_contents) {
+        const extensions::Extension* extension =
+            extensions::ProcessManager::Get(guest_contents->GetBrowserContext())
+                ->GetExtensionForWebContents(guest_contents);
+        if (extension && extension->id() == extension_misc::kPdfExtensionId)
+          return true;
+      }
+    }
+  }
+#endif  // defined(OS_MAC)
+  return false;
 }
 
 bool AppWindow::TakeFocus(WebContents* source, bool reverse) {
@@ -466,6 +599,31 @@
     std::move(callback).Run(true /* did_finish */);
 }
 
+bool AppWindow::NWCanClose(bool user_force) const {
+  const Extension* extension = GetExtension();
+  if (!extension)
+    return true;
+  content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+  EventRouter* event_router = EventRouter::Get(browser_context());
+  std::string listener_extension_id;
+  bool listening_to_close = event_router->
+    ExtensionHasEventListener(extension->id(), "nw.Window.onClose",
+                              rfh->GetFrameToken().ToString(),
+                              &listener_extension_id);
+  if (listening_to_close) {
+    base::Value::List args;
+    if (user_force)
+      args.Append("quit");
+    ExtensionWebContentsObserver::GetForWebContents(web_contents())
+      ->GetLocalFrame(rfh)
+      ->MessageInvoke(
+                      listener_extension_id, "nw.Window",
+                      "onClose", std::move(args));
+    return false;
+  }
+  return true;
+}
+
 void AppWindow::OnNativeClose() {
   AppWindowRegistry::Get(browser_context_)->RemoveAppWindow(this);
 
@@ -510,9 +668,19 @@
   SaveWindowPosition();
 
 #if BUILDFLAG(IS_WIN)
+  if (content::g_support_transparency && requested_alpha_enabled_) {
+    content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+    content::RenderWidgetHostView* view = rfh->GetRenderViewHost()->GetWidget()->GetView();
+    if(view)
+      view->SetBackgroundColor(native_app_window_->CanHaveAlphaEnabled() ? SK_ColorTRANSPARENT : native_app_window_->ActiveFrameColor());
+  }
+#if 0
   if (cached_always_on_top_ && !IsFullscreen() &&
       !native_app_window_->IsMaximized() &&
       !native_app_window_->IsMinimized()) {
+#else
+  if (cached_always_on_top_) {
+#endif
     UpdateNativeAlwaysOnTop();
   }
 #endif
@@ -552,9 +720,10 @@
 }
 
 std::u16string AppWindow::GetTitle() const {
+  std::u16string override = base::UTF8ToUTF16(title_override_);
   const Extension* extension = GetExtension();
   if (!extension)
-    return std::u16string();
+    return override;
 
   // WebContents::GetTitle() will return the page's URL if there's no <title>
   // specified. However, we'd prefer to show the name of the extension in that
@@ -564,12 +733,14 @@
       web_contents() ? web_contents()->GetController().GetLastCommittedEntry()
                      : nullptr;
   if (!entry || entry->GetTitle().empty()) {
-    title = base::UTF8ToUTF16(extension->name());
+    title = override.empty() ? base::UTF8ToUTF16(extension->name()) : override;
   } else {
     title = web_contents()->GetTitle();
   }
   base::RemoveChars(title, u"\n", &title);
-  return title;
+  if (!title.empty())
+    return title;
+  return override;
 }
 
 void AppWindow::SetAppIconUrl(const GURL& url) {
@@ -668,6 +839,10 @@
   }
 }
 
+void AppWindow::SetShowInTaskbar(bool show) {
+  GetBaseWindow()->SetShowInTaskbar(show);
+}
+
 void AppWindow::OSFullscreen() {
   SetFullscreen(FULLSCREEN_TYPE_OS, true);
 }
@@ -725,14 +900,15 @@
   // As a security measure, do not allow fullscreen windows or windows that
   // overlap the taskbar to be on top. The property will be applied when the
   // window exits fullscreen and moves away from the taskbar.
+#if 0
   if ((!IsFullscreen() ||
        ExtensionsBrowserClient::Get()->IsScreensaverInDemoMode(
            extension_id())) &&
       !IntersectsWithTaskbar()) {
+#endif
     native_app_window_->SetZOrderLevel(always_on_top
                                            ? ui::ZOrderLevel::kFloatingWindow
                                            : ui::ZOrderLevel::kNormal);
-  }
 
   OnNativeWindowChanged();
 }
@@ -749,6 +925,7 @@
 void AppWindow::GetSerializedState(base::Value::Dict* properties) const {
   DCHECK(properties);
 
+  properties->Set("resizable", native_app_window_->IsResizable());
   properties->Set("fullscreen", native_app_window_->IsFullscreenOrPending());
   properties->Set("minimized", native_app_window_->IsMinimized());
   properties->Set("maximized", native_app_window_->IsMaximized());
@@ -854,6 +1031,9 @@
 
 void AppWindow::UpdateNativeAlwaysOnTop() {
   DCHECK(cached_always_on_top_);
+#if 1
+  native_app_window_->SetZOrderLevel(ui::ZOrderLevel::kFloatingWindow);
+#else
   bool is_on_top =
       native_app_window_->GetZOrderLevel() == ui::ZOrderLevel::kFloatingWindow;
   bool fullscreen = IsFullscreen();
@@ -868,6 +1048,7 @@
     // always-on-top.
     native_app_window_->SetZOrderLevel(ui::ZOrderLevel::kFloatingWindow);
   }
+#endif
 }
 
 void AppWindow::ActivateContents(WebContents* contents) {
@@ -879,7 +1060,7 @@
 }
 
 bool AppWindow::ShouldSuppressDialogs(WebContents* source) {
-  return true;
+  return false;
 }
 
 void AppWindow::RunFileChooser(
@@ -1077,4 +1258,11 @@
   return sk_region;
 }
 
+content::JavaScriptDialogManager* AppWindow::GetJavaScriptDialogManager(
+    WebContents* source) {
+  ExtensionHost* host = ProcessManager::Get(browser_context())
+                            ->GetBackgroundHostForExtension(extension_id());
+  return host->GetJavaScriptDialogManager(source);
+}
+
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/browser/app_window/app_window.h nw/chromium/extensions/browser/app_window/app_window.h
--- up/chromium/extensions/browser/app_window/app_window.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_window.h	2024-08-26 19:32:25.650587999 +0000
@@ -41,6 +41,10 @@
 class WebContents;
 }  // namespace content
 
+namespace nw {
+class Menu;
+}
+
 namespace extensions {
 
 class AppDelegate;
@@ -64,7 +68,9 @@
   // Called to initialize the WebContents, before the app window is created.
   virtual void Initialize(content::BrowserContext* context,
                           content::RenderFrameHost* creator_frame,
-                          const GURL& url) = 0;
+                          const GURL& url,
+                          const Extension* extension,
+                          bool skip_blocking_parser) = 0;
 
   // Called to load the contents, after the app window is created.
   virtual void LoadContents(int32_t creator_process_id) = 0;
@@ -102,6 +108,12 @@
     FRAME_NONE,    // Frameless window.
   };
 
+  enum Position {
+    POS_NONE,
+    POS_CENTER,
+    POS_MOUSE,
+  };
+
   enum FullscreenType {
     // Not fullscreen.
     FULLSCREEN_TYPE_NONE = 0,
@@ -201,6 +213,20 @@
     // Icon URL to be used for setting the window icon.
     GURL window_icon_url;
 
+    bool skip_load;
+
+    bool show_in_taskbar;
+    bool new_instance;
+    bool skip_block_parser;
+
+    Position position;
+
+    std::string title;
+
+    std::string inject_js_start, inject_js_end;
+
+    gfx::Image icon;
+
     // The API enables developers to specify content or window bounds. This
     // function combines them into a single, constrained window size.
     gfx::Rect GetInitialWindowBounds(const gfx::Insets& frame_insets) const;
@@ -243,9 +269,12 @@
   WindowType window_type() const { return window_type_; }
   content::BrowserContext* browser_context() const { return browser_context_; }
   const gfx::Image& custom_app_icon() const { return custom_app_icon_; }
+  const gfx::Image& icon_override() const { return icon_override_; }
   const GURL& app_icon_url() const { return app_icon_url_; }
   const GURL& initial_url() const { return initial_url_; }
   bool is_hidden() const { return is_hidden_; }
+  const std::string& title_override() const { return title_override_; }
+  void set_title_override(const std::string& title) { title_override_ = title; }
 
   // Calls to this should always be guarded by a nullptr check as this can
   // return nullptr if the extension is no longer installed.
@@ -254,6 +283,8 @@
   NativeAppWindow* GetBaseWindow();
   gfx::NativeWindow GetNativeWindow();
 
+  bool NWCanClose(bool user_force = false) const;
+
   // Returns the bounds that should be reported to the renderer.
   gfx::Rect GetClientBounds() const;
 
@@ -323,6 +354,8 @@
   void Minimize();
   void Restore();
 
+  void SetShowInTaskbar(bool);
+
   // Transitions to OS fullscreen. See FULLSCREEN_TYPE_OS for more details.
   void OSFullscreen();
 
@@ -385,6 +418,7 @@
       std::unique_ptr<AppWindowContents> contents) {
     app_window_contents_ = std::move(contents);
   }
+  raw_ptr<nw::Menu> menu_ = nullptr;
 
   void SetNativeAppWindowForTesting(
       std::unique_ptr<NativeAppWindow> native_app_window) {
@@ -406,6 +440,10 @@
 
   // content::WebContentsDelegate implementation.
   void ActivateContents(content::WebContents* contents) override;
+  void LoadingStateChanged(content::WebContents* source,
+                           bool to_different_document) override;
+  content::JavaScriptDialogManager* GetJavaScriptDialogManager(
+      content::WebContents* source) override;
   void CloseContents(content::WebContents* contents) override;
   bool ShouldSuppressDialogs(content::WebContents* source) override;
   void RunFileChooser(content::RenderFrameHost* render_frame_host,
@@ -529,6 +567,7 @@
   // not own this object.
   raw_ptr<content::BrowserContext> browser_context_;
 
+  std::string title_override_;
   const ExtensionId extension_id_;
 
   // Identifier that is used when saving and restoring geometry for this
@@ -540,6 +579,7 @@
 
   // Custom icon shown in the task bar or in Chrome OS shelf.
   gfx::Image custom_app_icon_;
+  gfx::Image icon_override_;
 
   // Icon URL to be used for setting the app icon. If not empty, app_icon_ will
   // be fetched and set using this URL.
@@ -589,6 +629,8 @@
   // Whether |is_ime_window| was set in the CreateParams.
   bool is_ime_window_ = false;
 
+  bool last_to_different_document_ = false;
+
   // Whether |show_on_lock_screen| was set in the CreateParams.
   bool show_on_lock_screen_ = false;
 
diff -r -u --color up/chromium/extensions/browser/app_window/app_window_contents.cc nw/chromium/extensions/browser/app_window/app_window_contents.cc
--- up/chromium/extensions/browser/app_window/app_window_contents.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_window_contents.cc	2024-08-26 19:32:25.650587999 +0000
@@ -4,6 +4,8 @@
 
 #include "extensions/browser/app_window/app_window_contents.h"
 
+#include "content/browser/web_contents/web_contents_impl.h"
+
 #include <memory>
 #include <string>
 #include <utility>
@@ -21,26 +23,40 @@
 #include "extensions/browser/extension_web_contents_observer.h"
 #include "third_party/blink/public/common/renderer_preferences/renderer_preferences.h"
 
+#include "content/nw/src/nw_content.h"
+
 namespace extensions {
 
-AppWindowContentsImpl::AppWindowContentsImpl(AppWindow* host) : host_(host) {}
+AppWindowContentsImpl::AppWindowContentsImpl(AppWindow* host, std::unique_ptr<content::WebContents> web_contents)
+  :host_(host), web_contents_(std::move(web_contents)) {}
 
 AppWindowContentsImpl::~AppWindowContentsImpl() = default;
 
 void AppWindowContentsImpl::Initialize(content::BrowserContext* context,
                                        content::RenderFrameHost* creator_frame,
-                                       const GURL& url) {
+                                       const GURL& url,
+                                       const Extension* extension,
+                                       bool skip_blocking_parser) {
   url_ = url;
 
+  bool new_site = url.SchemeIs("chrome") || !nw::PinningRenderer();
   content::WebContents::CreateParams create_params(
-      context, creator_frame->GetSiteInstance());
+                                                   //NWJS#5163: fix regression
+       context, nw::PinningRenderer() ? creator_frame->GetSiteInstance() : content::SiteInstance::CreateForURL(context, url_));
   create_params.opener_render_process_id = creator_frame->GetProcess()->GetID();
   create_params.opener_render_frame_id = creator_frame->GetRoutingID();
-  web_contents_ = content::WebContents::Create(create_params);
+  if (!web_contents_)
+    web_contents_ = content::WebContents::Create(create_params);
 
+  static_cast<content::WebContentsImpl*>(web_contents_.get())->SetSkipBlockingParser(skip_blocking_parser || new_site);
   Observe(web_contents_.get());
-  web_contents_->GetMutableRendererPrefs()->
-      browser_handles_all_top_level_requests = true;
+  blink::RendererPreferences* render_prefs =
+      web_contents_->GetMutableRendererPrefs();
+  if (!extension || !extension->is_nwjs_app())
+    render_prefs->browser_handles_all_top_level_requests = true;
+  std::string user_agent;
+  if (nw::GetUserAgentFromManifest(&user_agent))
+    render_prefs->user_agent_override.ua_string_override = user_agent;
   web_contents_->SyncRendererPrefs();
 }
 
diff -r -u --color up/chromium/extensions/browser/app_window/app_window_contents.h nw/chromium/extensions/browser/app_window/app_window_contents.h
--- up/chromium/extensions/browser/app_window/app_window_contents.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_window_contents.h	2024-08-26 19:32:25.650587999 +0000
@@ -17,6 +17,7 @@
 namespace content {
 class BrowserContext;
 class RenderFrameHost;
+class WebContents;
 }
 
 namespace extensions {
@@ -27,7 +28,7 @@
 class AppWindowContentsImpl : public AppWindowContents,
                               public content::WebContentsObserver {
  public:
-  explicit AppWindowContentsImpl(AppWindow* host);
+   explicit AppWindowContentsImpl(AppWindow* host, std::unique_ptr<content::WebContents> web_contents = nullptr);
 
   AppWindowContentsImpl(const AppWindowContentsImpl&) = delete;
   AppWindowContentsImpl& operator=(const AppWindowContentsImpl&) = delete;
@@ -37,7 +38,9 @@
   // AppWindowContents
   void Initialize(content::BrowserContext* context,
                   content::RenderFrameHost* creator_frame,
-                  const GURL& url) override;
+                  const GURL& url,
+                  const Extension* extension,
+                  bool skip_blocking_parser) override;
   void LoadContents(int32_t creator_process_id) override;
   void NativeWindowChanged(NativeAppWindow* native_app_window) override;
   void NativeWindowClosed(bool send_onclosed) override;
@@ -50,6 +53,7 @@
 
   raw_ptr<AppWindow> host_;  // This class is owned by |host_|
   GURL url_;
+
   std::unique_ptr<content::WebContents> web_contents_;
 };
 
diff -r -u --color up/chromium/extensions/browser/app_window/native_app_window.h nw/chromium/extensions/browser/app_window/native_app_window.h
--- up/chromium/extensions/browser/app_window/native_app_window.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/native_app_window.h	2024-08-26 19:32:25.650587999 +0000
@@ -35,6 +35,8 @@
   // |fullscreen_types| is a bit field of AppWindow::FullscreenType.
   virtual void SetFullscreen(int fullscreen_types) = 0;
 
+  virtual void SetResizable(bool flag) = 0;
+  virtual bool IsResizable() const = 0;
   // Returns whether the window is fullscreen or about to enter fullscreen.
   virtual bool IsFullscreenOrPending() const = 0;
 
@@ -74,6 +76,8 @@
   // borders) and the content bounds, if any.
   virtual gfx::Insets GetFrameInsets() const = 0;
 
+  virtual void SetShowInTaskbar(bool) = 0;
+
   // Returns the minimum size constraints of the content.
   virtual gfx::Size GetContentMinimumSize() const = 0;
 
diff -r -u --color up/chromium/extensions/browser/app_window/test_app_window_contents.cc nw/chromium/extensions/browser/app_window/test_app_window_contents.cc
--- up/chromium/extensions/browser/app_window/test_app_window_contents.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/test_app_window_contents.cc	2024-08-26 19:32:25.650587999 +0000
@@ -17,7 +17,8 @@
 
 void TestAppWindowContents::Initialize(content::BrowserContext* context,
                                        content::RenderFrameHost* creator_frame,
-                                       const GURL& url) {}
+                                       const GURL& url,
+                                       const Extension* extension, bool skip_blocking_parser) {}
 
 void TestAppWindowContents::LoadContents(int32_t creator_process_id) {}
 
diff -r -u --color up/chromium/extensions/browser/app_window/test_app_window_contents.h nw/chromium/extensions/browser/app_window/test_app_window_contents.h
--- up/chromium/extensions/browser/app_window/test_app_window_contents.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/test_app_window_contents.h	2024-08-26 19:32:25.650587999 +0000
@@ -31,7 +31,8 @@
   // apps:AppWindowContents:
   void Initialize(content::BrowserContext* context,
                   content::RenderFrameHost* creator_frame,
-                  const GURL& url) override;
+                  const GURL& url,
+                  const Extension* extension, bool skip_blocking_parser) override;
   void LoadContents(int32_t creator_process_id) override;
   void NativeWindowChanged(NativeAppWindow* native_app_window) override;
   void NativeWindowClosed(bool send_onclosed) override;
diff -r -u --color up/chromium/extensions/browser/content_hash_fetcher.cc nw/chromium/extensions/browser/content_hash_fetcher.cc
--- up/chromium/extensions/browser/content_hash_fetcher.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/content_hash_fetcher.cc	2024-08-26 19:32:25.654587999 +0000
@@ -61,6 +61,7 @@
 }
 
 void ContentHashFetcher::Start(HashFetcherCallback hash_fetcher_callback) {
+#if 0
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
   hash_fetcher_callback_ = std::move(hash_fetcher_callback);
@@ -107,6 +108,7 @@
       url_loader_factory_remote.get(),
       base::BindOnce(&ContentHashFetcher::OnSimpleLoaderComplete,
                      base::Unretained(this)));
+#endif
 }
 
 ContentHashFetcher::~ContentHashFetcher() {
diff -r -u --color up/chromium/extensions/browser/content_verifier/content_hash.cc nw/chromium/extensions/browser/content_verifier/content_hash.cc
--- up/chromium/extensions/browser/content_verifier/content_hash.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/content_hash.cc	2024-08-26 19:32:25.654587999 +0000
@@ -1,6 +1,7 @@
 // Copyright 2018 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "extensions/browser/content_verifier/content_hash.h"
 
@@ -52,7 +53,7 @@
   if (!verified_contents ||
       verified_contents->extension_id() != key.extension_id ||
       verified_contents->version() != key.extension_version) {
-    if (delete_invalid_file && !base::DeleteFile(verified_contents_path)) {
+    if (delete_invalid_file && false && !base::DeleteFile(verified_contents_path)) {
       LOG(WARNING) << "Failed to delete " << verified_contents_path.value();
     }
     return nullptr;
diff -r -u --color up/chromium/extensions/browser/content_verifier/content_verifier.cc nw/chromium/extensions/browser/content_verifier/content_verifier.cc
--- up/chromium/extensions/browser/content_verifier/content_verifier.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/content_verifier.cc	2024-08-26 19:32:25.654587999 +0000
@@ -21,6 +21,7 @@
 #include "base/ranges/algorithm.h"
 #include "base/strings/string_util.h"
 #include "base/strings/stringprintf.h"
+#include "base/task/thread_pool.h"
 #include "base/threading/thread_restrictions.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_thread.h"
@@ -41,6 +42,9 @@
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "services/network/public/mojom/network_context.mojom.h"
 
+#include "base/files/file_util.h"
+#include "base/threading/thread_restrictions.h"
+
 namespace extensions {
 
 namespace {
@@ -584,7 +588,7 @@
   std::vector<VerifiedFileType> file_types({verified_file_type});
   auto callback =
       base::BindOnce(&ContentVerifier::VerifyFailed, this, extension_id,
-                     file_types, data->manifest_version);
+                     file_types, data->manifest_version, relative_path);
 
   // TODO(asargent) - we can probably get some good performance wins by having
   // a cache of ContentHashReader's that we hold onto past the end of each job.
@@ -644,22 +648,75 @@
          ContentVerifierDelegate::VerifierSourceType::UNSIGNED_HASHES;
 }
 
+void ContentVerifier::OnHashReady(const std::string& extension_id,
+                                  const base::FilePath& extension_root,
+                                  const base::FilePath& relative_path,
+                                  scoped_refptr<ContentVerifyJob> verify_job) {
+  base::ThreadPool::PostTaskAndReplyWithResult(
+                                   FROM_HERE, {base::MayBlock(), base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+      base::BindOnce(&ContentVerifier::OpenFile, this, extension_root, relative_path, verify_job),
+      base::BindOnce(&ContentVerifier::OnFileReady, this, extension_root, relative_path, verify_job));
+}
+
+bool ContentVerifier::OpenFile(const base::FilePath& extension_root,
+                               const base::FilePath& relative_path,
+                               scoped_refptr<ContentVerifyJob> job) {
+  job->file_.Initialize(extension_root.Append(relative_path), base::File::FLAG_OPEN | base::File::FLAG_READ);
+  return true;
+}
+
+void ContentVerifier::OnFileReady(const base::FilePath& extension_root,
+                                  const base::FilePath& relative_path,
+                                  scoped_refptr<ContentVerifyJob> job, bool result) {
+  if (!job->file_.IsValid())
+    job->DoneReading();
+
+  base::ThreadPool::PostTaskAndReplyWithResult(
+                                   FROM_HERE, {base::MayBlock(), base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+      base::BindOnce(&ContentVerifier::ReadFile, this, extension_root, relative_path, job),
+     base::BindOnce(&ContentVerifier::BytesRead, this, extension_root, relative_path, job));
+}
+bool ContentVerifier::ReadFile(const base::FilePath& extension_root,
+                               const base::FilePath& relative_path,
+                               scoped_refptr<ContentVerifyJob> job) {
+  job->len_ = job->file_.ReadAtCurrentPos(job->buf_, 32768);
+  if (job->len_ <= 0)
+    job->file_.Close();
+  return true;
+}
+
+void ContentVerifier::BytesRead(const base::FilePath& extension_root,
+                                const base::FilePath& relative_path,
+                                scoped_refptr<ContentVerifyJob> job, bool result) {
+  if (job->len_ <= 0) {
+    job->DoneReading();
+  } else {
+    job->BytesRead(job->buf_, job->len_, base::File::FILE_OK);
+    base::ThreadPool::PostTaskAndReplyWithResult(
+      FROM_HERE, {base::MayBlock(), base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+      base::BindOnce(&ContentVerifier::ReadFile, this, extension_root, relative_path, job),
+      base::BindOnce(&ContentVerifier::BytesRead, this, extension_root, relative_path, job));
+  }
+}
+
 void ContentVerifier::VerifyFailed(
     const ExtensionId& extension_id,
     const std::vector<VerifiedFileType>& failed_file_types,
     int manifest_version,
-    ContentVerifyJob::FailureReason reason) {
+    const base::FilePath& relative_path,
+    ContentVerifyJob::FailureReason reason,
+    scoped_refptr<ContentVerifyJob> verify_job) {
   if (!content::BrowserThread::CurrentlyOn(content::BrowserThread::UI)) {
     content::GetUIThreadTaskRunner({})->PostTask(
         FROM_HERE,
         base::BindOnce(&ContentVerifier::VerifyFailed, this, extension_id,
-                       failed_file_types, manifest_version, reason));
+                       failed_file_types, manifest_version, relative_path, reason, verify_job));
     return;
   }
   if (shutdown_on_ui_)
     return;
 
-  VLOG(1) << "VerifyFailed " << extension_id << " reason:" << reason;
+  VLOG(1) << "VerifyFailed " << extension_id << " reason:" << reason << " " << relative_path.AsUTF8Unsafe();
   DCHECK_NE(ContentVerifyJob::NONE, reason);
 
   for (VerifiedFileType file_type : failed_file_types) {
@@ -738,7 +795,7 @@
     }
   }
 
-  delegate_->VerifyFailed(extension_id, reason);
+  delegate_->VerifyFailed(extension_id, relative_path, reason, verify_job);
 }
 
 void ContentVerifier::OnExtensionLoaded(
@@ -797,7 +854,7 @@
 void ContentVerifier::VerifyFailedForTest(
     const ExtensionId& extension_id,
     ContentVerifyJob::FailureReason reason) {
-  VerifyFailed(extension_id, {VerifiedFileType::kMiscFile}, 3, reason);
+  VerifyFailed(extension_id, {VerifiedFileType::kMiscFile}, 3, base::FilePath(), reason, nullptr);
 }
 
 void ContentVerifier::ClearCacheForTesting() {
@@ -879,7 +936,7 @@
   // Note: `data` must be non-null here, since we'd only populate
   // `file_hash_mismatches` if it's available.
   VerifyFailed(extension_id, file_hash_mismatches, data->manifest_version,
-               ContentVerifyJob::HASH_MISMATCH);
+               base::FilePath(), ContentVerifyJob::HASH_MISMATCH, nullptr);
 }
 
 ContentHash::FetchKey ContentVerifier::GetFetchKey(
diff -r -u --color up/chromium/extensions/browser/content_verifier/content_verifier.h nw/chromium/extensions/browser/content_verifier/content_verifier.h
--- up/chromium/extensions/browser/content_verifier/content_verifier.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/content_verifier.h	2024-08-26 19:32:25.654587999 +0000
@@ -207,7 +207,25 @@
   void VerifyFailed(const ExtensionId& extension_id,
                     const std::vector<VerifiedFileType>& failed_file_types,
                     int manifest_version,
-                    ContentVerifyJob::FailureReason reason);
+                    const base::FilePath& relative_path,
+                    ContentVerifyJob::FailureReason reason,
+                    scoped_refptr<ContentVerifyJob> verify_job);
+  void OnHashReady(const std::string& extension_id,
+                   const base::FilePath& extension_root,
+                   const base::FilePath& relative_path,
+                   scoped_refptr<ContentVerifyJob> verify_job);
+  void BytesRead(const base::FilePath& extension_root,
+                 const base::FilePath& relative_path,
+                 scoped_refptr<ContentVerifyJob> job, bool result);
+  bool ReadFile(const base::FilePath& extension_root,
+                const base::FilePath& relative_path,
+                scoped_refptr<ContentVerifyJob> job);
+  bool OpenFile(const base::FilePath& extension_root,
+                const base::FilePath& relative_path,
+                scoped_refptr<ContentVerifyJob> job);
+  void OnFileReady(const base::FilePath& extension_root,
+                   const base::FilePath& relative_path,
+                   scoped_refptr<ContentVerifyJob> job, bool result);
 
   // Returns the HashHelper instance, making sure we create it at most once.
   // Must *not* be called after |shutdown_on_io_| is set to true.
diff -r -u --color up/chromium/extensions/browser/content_verifier/content_verifier_delegate.h nw/chromium/extensions/browser/content_verifier/content_verifier_delegate.h
--- up/chromium/extensions/browser/content_verifier/content_verifier_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/content_verifier_delegate.h	2024-08-26 19:32:25.654587999 +0000
@@ -62,7 +62,9 @@
   // Called when the content verifier detects that a read of a file inside an
   // extension did not match its expected hash.
   virtual void VerifyFailed(const ExtensionId& extension_id,
-                            ContentVerifyJob::FailureReason reason) = 0;
+                            const base::FilePath& relative_path,
+                            ContentVerifyJob::FailureReason reason,
+                            scoped_refptr<ContentVerifyJob> verify_job) = 0;
 
   // Called when ExtensionSystem is shutting down.
   virtual void Shutdown() = 0;
diff -r -u --color up/chromium/extensions/browser/content_verifier/content_verify_job.cc nw/chromium/extensions/browser/content_verifier/content_verify_job.cc
--- up/chromium/extensions/browser/content_verifier/content_verify_job.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/content_verify_job.cc	2024-08-26 19:32:25.654587999 +0000
@@ -84,9 +84,35 @@
       relative_path_(relative_path),
       manifest_version_(manifest_version),
       failure_callback_(std::move(failure_callback)),
-      failed_(false) {}
+      failed_(false), len_(0), buf_(nullptr) {
+  buf_ = new char[32768];
+}
+
+ContentVerifyJob::ContentVerifyJob(ContentHashReader* hash_reader,
+                                   const ContentVerifierKey& key,
+                                   FailureCallback failure_callback,
+                                   ReadyCallback ready_callback)
+    : done_reading_(false),
+      hashes_ready_(false),
+      total_bytes_read_(0),
+      current_block_(0),
+      current_hash_byte_count_(0),
+      hash_reader_(hash_reader),
+      manifest_version_(0),
+      failure_callback_(std::move(failure_callback)),
+      ready_callback_(std::move(ready_callback)),
+      failed_(false),
+      len_(0),
+      buf_(nullptr)
+{
+  buf_ = new char[32768];
+}
 
-ContentVerifyJob::~ContentVerifyJob() = default;
+
+ContentVerifyJob::~ContentVerifyJob() {
+  delete[] buf_;
+  buf_ = nullptr;
+}
 
 void ContentVerifyJob::Start(ContentVerifier* verifier) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
@@ -270,6 +296,9 @@
       ReportJobFinished(NONE);
     }
   }
+  if (!ready_callback_.is_null()) {
+    std::move(ready_callback_).Run(this);
+  }
 }
 
 // static
@@ -294,7 +323,7 @@
   if (!failure_callback_.is_null()) {
     VLOG(1) << "job failed for " << extension_id_ << " "
             << relative_path_.MaybeAsASCII() << " reason:" << reason;
-    std::move(failure_callback_).Run(reason);
+    std::move(failure_callback_).Run(reason, this);
   }
 
   ReportJobFinished(reason);
diff -r -u --color up/chromium/extensions/browser/content_verifier/content_verify_job.h nw/chromium/extensions/browser/content_verifier/content_verify_job.h
--- up/chromium/extensions/browser/content_verifier/content_verify_job.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/content_verify_job.h	2024-08-26 19:32:25.654587999 +0000
@@ -9,6 +9,7 @@
 
 #include <memory>
 #include <string>
+#include "base/files/file.h"
 
 #include "base/files/file_path.h"
 #include "base/functional/callback.h"
@@ -62,7 +63,9 @@
 
     FAILURE_REASON_MAX
   };
-  using FailureCallback = base::OnceCallback<void(FailureReason)>;
+  using FailureCallback = base::OnceCallback<void(FailureReason, scoped_refptr<ContentVerifyJob>)>;
+  using ReadyCallback = base::OnceCallback<void(scoped_refptr<ContentVerifyJob>)>;
+  using SuccessCallback = base::OnceCallback<void(void)>;
 
   // The |failure_callback| will be called at most once if there was a failure.
   ContentVerifyJob(const ExtensionId& extension_id,
@@ -75,6 +78,11 @@
   ContentVerifyJob(const ContentVerifyJob&) = delete;
   ContentVerifyJob& operator=(const ContentVerifyJob&) = delete;
 
+  ContentVerifyJob(ContentHashReader* hash_reader,
+                   const ContentVerifierKey& content_verifier_key,
+                   FailureCallback failure_callback,
+                   ReadyCallback ready_callback);
+
   // This begins the process of getting expected hashes, so it should be called
   // as early as possible.
   void Start(ContentVerifier* verifier);
@@ -90,6 +98,9 @@
   // Call once when finished adding bytes via OnDone.
   void DoneReading();
 
+  void SetSuccessCallback(SuccessCallback& success_callback) { success_callback_ = std::move(success_callback); }
+  const SuccessCallback& success_callback() { return success_callback_; }
+
   class TestObserver : public base::RefCountedThreadSafe<TestObserver> {
    public:
     virtual void JobStarted(const ExtensionId& extension_id,
@@ -180,12 +191,19 @@
 
   // Called once if verification fails.
   FailureCallback failure_callback_;
+  ReadyCallback ready_callback_;
+  SuccessCallback success_callback_;
 
   // Set to true if we detected a mismatch and called the failure callback.
   bool failed_;
 
   // Used to synchronize all public methods.
   base::Lock lock_;
+
+ public:
+  int len_;
+  raw_ptr<char> buf_;
+  base::File file_;
 };
 
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/browser/content_verifier/test_utils.cc nw/chromium/extensions/browser/content_verifier/test_utils.cc
--- up/chromium/extensions/browser/content_verifier/test_utils.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/test_utils.cc	2024-08-26 19:32:25.654587999 +0000
@@ -236,7 +236,9 @@
 
 void MockContentVerifierDelegate::VerifyFailed(
     const ExtensionId& extension_id,
-    ContentVerifyJob::FailureReason reason) {
+    const base::FilePath& relative_path,
+    ContentVerifyJob::FailureReason reason,
+    scoped_refptr<ContentVerifyJob> verify_job) {
   ADD_FAILURE() << "Unexpected call for this test";
 }
 
diff -r -u --color up/chromium/extensions/browser/content_verifier/test_utils.h nw/chromium/extensions/browser/content_verifier/test_utils.h
--- up/chromium/extensions/browser/content_verifier/test_utils.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/test_utils.h	2024-08-26 19:32:25.654587999 +0000
@@ -186,7 +186,9 @@
   std::set<base::FilePath> GetBrowserImagePaths(
       const extensions::Extension* extension) override;
   void VerifyFailed(const ExtensionId& extension_id,
-                    ContentVerifyJob::FailureReason reason) override;
+                    const base::FilePath& relative_path,
+                    ContentVerifyJob::FailureReason reason,
+                    scoped_refptr<ContentVerifyJob> verify_job) override;
   void Shutdown() override;
 
   // Modifier.
diff -r -u --color up/chromium/extensions/browser/event_listener_map.cc nw/chromium/extensions/browser/event_listener_map.cc
--- up/chromium/extensions/browser/event_listener_map.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/event_listener_map.cc	2024-08-26 19:32:25.654587999 +0000
@@ -4,6 +4,7 @@
 
 #include "extensions/browser/event_listener_map.h"
 
+#include "chrome/common/extensions/api/windows.h"
 #include <stddef.h>
 
 #include <utility>
@@ -211,16 +212,29 @@
 
 bool EventListenerMap::HasListenerForExtension(
     const ExtensionId& extension_id,
-    const std::string& event_name) const {
+    const std::string& event_name, const std::string& instance_id, std::string* out_extension_id) const {
   auto it = listeners_.find(event_name);
   if (it == listeners_.end())
     return false;
 
+  EventListener* ret = nullptr;
   for (const auto& listener_to_search : it->second) {
-    if (listener_to_search->extension_id() == extension_id)
-      return true;
+    if (listener_to_search->extension_id() == extension_id ||
+        listener_to_search->extension_id().empty()) {
+      if (instance_id.empty())
+        ret = listener_to_search.get();
+      if (listener_to_search->filter()) {
+	const std::string* id = listener_to_search->filter()->FindString("instanceId");
+	if (id && *id == instance_id)
+	  ret = listener_to_search.get();
+      }
+    }
   }
-  return false;
+  if (!ret)
+    return false;
+  if (out_extension_id)
+    *out_extension_id = ret->extension_id();
+  return true;
 }
 
 bool EventListenerMap::HasListenerForURL(const GURL& url,
@@ -326,6 +340,8 @@
     bool is_for_service_worker,
     const base::Value::Dict& filtered) {
   for (const auto item : filtered) {
+    if (item.first == extensions::api::windows::OnRemoving::kEventName)
+      continue; //NWJS#7326
     // We skip entries if they are malformed.
     if (!item.second.is_list())
       continue;
diff -r -u --color up/chromium/extensions/browser/event_listener_map.h nw/chromium/extensions/browser/event_listener_map.h
--- up/chromium/extensions/browser/event_listener_map.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/event_listener_map.h	2024-08-26 19:32:25.654587999 +0000
@@ -206,7 +206,9 @@
   // Returns true if there are any listeners on |event_name| from
   // |extension_id|.
   bool HasListenerForExtension(const ExtensionId& extension_id,
-                               const std::string& event_name) const;
+                               const std::string& event_name,
+                               const std::string& instance_id = std::string(),
+                               std::string* out_extension_id = nullptr) const;
 
   // Returns true if there are any listeners on |event_name| from |url|.
   bool HasListenerForURL(const GURL& url, const std::string& event_name) const;
diff -r -u --color up/chromium/extensions/browser/event_router.cc nw/chromium/extensions/browser/event_router.cc
--- up/chromium/extensions/browser/event_router.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/event_router.cc	2024-08-26 19:32:25.654587999 +0000
@@ -844,8 +844,10 @@
 
 bool EventRouter::ExtensionHasEventListener(
     const ExtensionId& extension_id,
-    const std::string& event_name) const {
-  return listeners_.HasListenerForExtension(extension_id, event_name);
+    const std::string& event_name,
+    const std::string& instance_id,
+    std::string* out_extension_id) const {
+  return listeners_.HasListenerForExtension(extension_id, event_name, instance_id, out_extension_id);
 }
 
 bool EventRouter::URLHasEventListener(const GURL& url,
@@ -1166,7 +1168,7 @@
         << "Trying to dispatch event " << event.event_name << " to a webpage,"
         << " but this shouldn't be possible";
   }
-  if (!feature_available_to_context) {
+  if (!feature_available_to_context && !extension->is_nwjs_app()) {
     // TODO(crbug.com/40255138): Ideally it shouldn't be possible to reach here,
     // because access is checked on registration. However, we don't always
     // refresh the list of events an extension has registered when other factors
@@ -1619,12 +1621,14 @@
       lazy_background_active_on_dispatch(lazy_background_active_on_dispatch),
       user_gesture(user_gesture),
       filter_info(std::move(info)) {
+#if 0
   DCHECK_NE(events::UNKNOWN, histogram_value)
       << "events::UNKNOWN cannot be used as a histogram value.\n"
       << "If this is a test, use events::FOR_TEST.\n"
       << "If this is production code, it is important that you use a realistic "
       << "value so that we can accurately track event usage. "
       << "See extension_event_histogram_value.h for inspiration.";
+#endif
 }
 
 Event::~Event() = default;
diff -r -u --color up/chromium/extensions/browser/event_router.h nw/chromium/extensions/browser/event_router.h
--- up/chromium/extensions/browser/event_router.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/event_router.h	2024-08-26 19:32:25.654587999 +0000
@@ -282,7 +282,9 @@
   // Returns true if the extension is listening to the given event.
   // (virtual for testing only.)
   virtual bool ExtensionHasEventListener(const ExtensionId& extension_id,
-                                         const std::string& event_name) const;
+                                         const std::string& event_name,
+                                         const std::string& instance_id = std::string(),
+                                         std::string* out_extension_id = nullptr) const;
 
   // Returns true if the URL is listening to the given event.
   // (virtual for testing only.)
diff -r -u --color up/chromium/extensions/browser/extension_frame_host.cc nw/chromium/extensions/browser/extension_frame_host.cc
--- up/chromium/extensions/browser/extension_frame_host.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_frame_host.cc	2024-08-26 19:32:25.658587998 +0000
@@ -194,4 +194,36 @@
       channel_type, channel_name, std::move(port), std::move(port_host));
 }
 
+void ExtensionFrameHost::RequestSync(mojom::RequestParamsPtr params,
+                                     RequestSyncCallback callback) {
+  content::RenderFrameHost* render_frame_host =
+      receivers_.GetCurrentTargetFrame();
+  base::Value::List list_value;
+  bool success = false;
+  std::string error;
+  ExtensionWebContentsObserver::GetForWebContents(web_contents_)
+      ->dispatcher()
+    ->DispatchSync(std::move(params), &success, &list_value, &error,
+                   render_frame_host,
+                   render_frame_host->GetProcess()->GetID());
+  std::move(callback).Run(success, std::move(list_value), error);
+}
+
+bool ExtensionFrameHost::RequestSync(mojom::RequestParamsPtr params,
+                                     bool* success,
+                                     base::Value::List* response,
+                                     std::string* error) {
+  base::Value::List* list_value = response;
+  //  if (!response->GetAsList(list_value))
+  //  return false;
+  content::RenderFrameHost* render_frame_host =
+      receivers_.GetCurrentTargetFrame();
+  ExtensionWebContentsObserver::GetForWebContents(web_contents_)
+      ->dispatcher()
+    ->DispatchSync(std::move(params), success, list_value, error,
+                   render_frame_host,
+                   render_frame_host->GetProcess()->GetID());
+  return true;
+}
+
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/browser/extension_frame_host.h nw/chromium/extensions/browser/extension_frame_host.h
--- up/chromium/extensions/browser/extension_frame_host.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_frame_host.h	2024-08-26 19:32:25.658587998 +0000
@@ -52,6 +52,12 @@
   void Request(mojom::RequestParamsPtr params,
                RequestCallback callback) override;
   void ResponseAck(const base::Uuid& request_uuid) override;
+  void RequestSync(mojom::RequestParamsPtr params,
+                   RequestSyncCallback callback) override;
+  bool RequestSync(mojom::RequestParamsPtr params,
+                   bool* success,
+                   base::Value::List* response,
+                   std::string* error) override;
   void WatchedPageChange(
       const std::vector<std::string>& css_selectors) override;
   void DetailedConsoleMessageAdded(
diff -r -u --color up/chromium/extensions/browser/extension_function.cc nw/chromium/extensions/browser/extension_function.cc
--- up/chromium/extensions/browser/extension_function.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_function.cc	2024-08-26 19:32:25.658587998 +0000
@@ -361,6 +361,10 @@
   }
 }
 
+bool ExtensionFunction::RunNWSync(base::Value::List* response, std::string* error) {
+  return false;
+}
+
 ExtensionFunction::~ExtensionFunction() {
   // `name_` may not be set in unit tests.
   std::string safe_name = name() ? name() : "<unknown>";
@@ -783,3 +787,35 @@
   DCHECK(error_.empty()) << "Function " << name() << "already has an error.";
   error_ = std::move(error);
 }
+
+NWSyncExtensionFunction::NWSyncExtensionFunction() {
+}
+
+NWSyncExtensionFunction::~NWSyncExtensionFunction() {
+}
+
+ExtensionFunction::ResponseAction NWSyncExtensionFunction::Run() {
+  NOTREACHED_IN_MIGRATION() << "NWSyncExtensionFunction::Run";
+  return RespondNow(ArgumentList(base::Value::List()));
+}
+
+// static
+bool NWSyncExtensionFunction::ValidationFailure(
+    NWSyncExtensionFunction* function) {
+  return false;
+}
+
+void NWSyncExtensionFunction::SetError(const std::string& error) {
+  error_ = error;
+}
+
+void NWSyncExtensionFunction::SetResult(std::unique_ptr<base::Value> result) {
+  results_.clear();
+  results_.Append(base::Value::FromUniquePtrValue(std::move(result)));
+}
+
+void NWSyncExtensionFunction::SetResultList(
+       const base::Value::List& results) {
+  results_ = results.Clone();
+}
+
diff -r -u --color up/chromium/extensions/browser/extension_function.h nw/chromium/extensions/browser/extension_function.h
--- up/chromium/extensions/browser/extension_function.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_function.h	2024-08-26 19:32:25.658587998 +0000
@@ -250,6 +250,7 @@
   //
   // ExtensionFunction implementations are encouraged to just implement Run.
   [[nodiscard]] virtual ResponseAction Run() = 0;
+  virtual bool RunNWSync(base::Value::List* response, std::string* error);
 
   // Gets whether quota should be applied to this individual function
   // invocation. This is different to GetQuotaLimitHeuristics which is only
@@ -603,8 +604,11 @@
 
   // Any detailed error from the API. This should be populated by the derived
   // class before Run() returns.
+ protected:
   std::string error_;
 
+ private:
+
   // The callback to run once the function has done execution.
   ResponseCallback response_callback_;
 
@@ -671,6 +675,7 @@
 
   // Whether this function has responded.
   // TODO(devlin): Replace this with response_type_ != null.
+ public:
   bool did_respond_ = false;
 
   // If set to true, preserves |results_|, even after SendResponseImpl() was
@@ -709,4 +714,23 @@
   std::optional<extensions::StackTrace> js_callstack_;
 };
 
+class NWSyncExtensionFunction : public ExtensionFunction {
+ public:
+  NWSyncExtensionFunction();
+  void SetError(const std::string& error);
+
+ protected:
+  ~NWSyncExtensionFunction() override;
+  static bool ValidationFailure(NWSyncExtensionFunction* function);
+
+  void SetResult(std::unique_ptr<base::Value> result);
+  void SetResultList(const base::Value::List& results);
+
+  base::Value::List results_;
+  std::string error_;
+ private:
+  ResponseAction Run() final;
+
+};
+
 #endif  // EXTENSIONS_BROWSER_EXTENSION_FUNCTION_H_
diff -r -u --color up/chromium/extensions/browser/extension_function_dispatcher.cc nw/chromium/extensions/browser/extension_function_dispatcher.cc
--- up/chromium/extensions/browser/extension_function_dispatcher.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_function_dispatcher.cc	2024-08-26 19:32:25.658587998 +0000
@@ -237,6 +237,14 @@
   base::debug::ScopedCrashKeyString extension_id_;
 };
 
+void DummyCallback(
+                   ExtensionFunction::ResponseType type,
+                   base::Value::List results,
+                   const std::string& error,
+		   mojom::ExtraResponseDataPtr response_data
+                   ) {
+}
+
 }  // namespace
 
 WindowController*
@@ -261,6 +269,19 @@
 ExtensionFunctionDispatcher::~ExtensionFunctionDispatcher() {
 }
 
+void ExtensionFunctionDispatcher::DispatchSync(
+                    mojom::RequestParamsPtr params,
+                    bool* success,
+                    base::Value::List* response,
+                    std::string* error,
+                    content::RenderFrameHost* render_frame_host,
+                    int render_process_id) {
+  base::OnceCallback<decltype(DummyCallback)> dummy;
+  DispatchWithCallbackInternal(
+                               *params, render_frame_host, *render_frame_host->GetProcess(), std::move(dummy), true,
+                               success, response, error);
+}
+
 void ExtensionFunctionDispatcher::Dispatch(
     mojom::RequestParamsPtr params,
     content::RenderFrameHost& frame,
@@ -361,7 +382,12 @@
     const mojom::RequestParams& params,
     content::RenderFrameHost* render_frame_host,
     content::RenderProcessHost& render_process_host,
-    ExtensionFunction::ResponseCallback callback) {
+    ExtensionFunction::ResponseCallback callback,
+    bool sync,
+    bool* success,
+    base::Value::List* response,
+    std::string* error
+                                                               ) {
   ProcessMap* process_map = ProcessMap::Get(browser_context_);
   if (!process_map) {
     constexpr char kProcessNotFound[] =
@@ -390,7 +416,10 @@
     extension = registry->enabled_extensions().GetHostedAppByURL(
         *render_frame_host_url);
   }
-
+  //commented out because of  eeae1106f478:
+  //[Extensions] Restructure extensions::ProcessMap
+  //breaking react-devtools-extension
+#if 0
   if (!process_map->CanProcessHostContextType(extension, render_process_host,
                                               params.context_type)) {
     // TODO(crbug.com/40055126): Ideally, we'd be able to mark some
@@ -404,7 +433,7 @@
                             kInvalidContextType);
     return;
   }
-
+#endif
   if (params.context_type == mojom::ContextType::kUntrustedWebUi) {
     // TODO(crbug.com/40265193): We should, at minimum, be using an
     // origin here. It'd be even better if we could have a more robust way of
@@ -451,7 +480,12 @@
 
     // Skip the quota, event page, activity logging stuff if there
     // isn't an extension, e.g. if the function call was from WebUI.
-    function->RunWithValidation().Execute();
+    if (!sync)
+      function->RunWithValidation().Execute();
+    else {
+      *success = function->RunNWSync(response, error);
+      function->did_respond_ = true;
+    }
     return;
   }
 
@@ -507,7 +541,12 @@
     }
 
     base::ElapsedTimer timer;
-    function->RunWithValidation().Execute();
+    if (!sync)
+      function->RunWithValidation().Execute();
+    else {
+      *success = function->RunNWSync(response, error);
+      function->did_respond_ = true;
+    }
     // TODO(devlin): Once we have a baseline metric for how long functions take,
     // we can create a handful of buckets and record the function name so that
     // we can find what the fastest/slowest are.
diff -r -u --color up/chromium/extensions/browser/extension_function_dispatcher.h nw/chromium/extensions/browser/extension_function_dispatcher.h
--- up/chromium/extensions/browser/extension_function_dispatcher.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_function_dispatcher.h	2024-08-26 19:32:25.658587998 +0000
@@ -75,6 +75,12 @@
       content::BrowserContext* browser_context);
   ~ExtensionFunctionDispatcher();
 
+  void DispatchSync(mojom::RequestParamsPtr params,
+                    bool* success,
+                    base::Value::List* response,
+                    std::string* error,
+                    content::RenderFrameHost* render_frame_host,
+                    int render_process_id);
   // Dispatches a request and the response is sent in |callback| that is a reply
   // of mojom::LocalFrameHost::Request.
   void Dispatch(mojom::RequestParamsPtr params,
@@ -135,7 +141,12 @@
       const mojom::RequestParams& params,
       content::RenderFrameHost* render_frame_host,
       content::RenderProcessHost& render_process_host,
-      ExtensionFunction::ResponseCallback callback);
+      ExtensionFunction::ResponseCallback callback,
+      bool sync = false,
+      bool* success = nullptr,
+      base::Value::List* response = nullptr,
+      std::string* error = nullptr
+                                    );
 
   void RemoveWorkerCallbacksForProcess(int render_process_id);
 
diff -r -u --color up/chromium/extensions/browser/extension_navigation_throttle.cc nw/chromium/extensions/browser/extension_navigation_throttle.cc
--- up/chromium/extensions/browser/extension_navigation_throttle.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_navigation_throttle.cc	2024-08-26 19:32:25.662587997 +0000
@@ -255,7 +255,7 @@
     }
   }
 
-  if (target_extension->is_platform_app() &&
+  if (target_extension->is_platform_app() && !target_extension->is_nwjs_app() &&
       ShouldBlockNavigationToPlatformAppResource(target_extension,
                                                  *navigation_handle())) {
     return content::NavigationThrottle::BLOCK_REQUEST;
diff -r -u --color up/chromium/extensions/browser/extension_navigation_ui_data.cc nw/chromium/extensions/browser/extension_navigation_ui_data.cc
--- up/chromium/extensions/browser/extension_navigation_ui_data.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_navigation_ui_data.cc	2024-08-26 19:32:25.662587997 +0000
@@ -4,6 +4,8 @@
 
 #include "extensions/browser/extension_navigation_ui_data.h"
 
+#include "content/public/browser/render_process_host.h"
+
 #include "base/memory/ptr_util.h"
 #include "content/public/browser/navigation_handle.h"
 #include "content/public/browser/render_process_host.h"
@@ -95,6 +97,7 @@
   copy->web_view_instance_id_ = web_view_instance_id_;
   copy->web_view_rules_registry_id_ = web_view_rules_registry_id_;
   copy->parent_routing_id_ = parent_routing_id_;
+  copy->web_view_embedder_process_id_ = web_view_embedder_process_id_;
   return copy;
 }
 
@@ -123,9 +126,12 @@
     is_web_view_ = true;
     web_view_instance_id_ = web_view->view_instance_id();
     web_view_rules_registry_id_ = web_view->rules_registry_id();
+    web_view_embedder_process_id_ =
+        web_view->owner_web_contents()->GetPrimaryMainFrame()->GetProcess()->GetID();
   } else {
     is_web_view_ = false;
-    web_view_instance_id_ = web_view_rules_registry_id_ = 0;
+    web_view_instance_id_ = web_view_rules_registry_id_ =
+        web_view_embedder_process_id_ = 0;
   }
 }
 
diff -r -u --color up/chromium/extensions/browser/extension_navigation_ui_data.h nw/chromium/extensions/browser/extension_navigation_ui_data.h
--- up/chromium/extensions/browser/extension_navigation_ui_data.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_navigation_ui_data.h	2024-08-26 19:32:25.662587997 +0000
@@ -51,6 +51,9 @@
     return parent_routing_id_;
   }
 
+  int web_view_embedder_process_id() const {
+    return web_view_embedder_process_id_;
+  }
  private:
   ExtensionNavigationUIData(
       content::WebContents* web_contents,
@@ -69,6 +72,7 @@
   // These are only valid iff is_web_view_.
   int web_view_instance_id_;
   int web_view_rules_registry_id_;
+  int web_view_embedder_process_id_;
 
   // ID for the parent RenderFrameHost of this navigation. Will only have a
   // valid value for sub-frame navigations.
diff -r -u --color up/chromium/extensions/browser/extension_prefs.cc nw/chromium/extensions/browser/extension_prefs.cc
--- up/chromium/extensions/browser/extension_prefs.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_prefs.cc	2024-08-26 19:32:25.662587997 +0000
@@ -306,9 +306,11 @@
     std::unique_ptr<prefs::DictionaryValueUpdate> dict =
         ScopedDictionaryPrefUpdate::Get();
     std::unique_ptr<prefs::DictionaryValueUpdate> extension;
-    if (!dict->GetDictionary(extension_id_, &extension)) {
+    std::string id;
+    base::ReplaceChars(extension_id_, ".", "", &id);
+    if (!dict->GetDictionary(id, &extension)) {
       // Extension pref does not exist, create it.
-      extension = dict->SetDictionary(extension_id_, base::Value::Dict());
+      extension = dict->SetDictionary(id, base::Value::Dict());
     }
     return extension;
   }
@@ -481,6 +483,9 @@
 
 const base::Value::Dict* ExtensionPrefs::GetExtensionPref(
     const ExtensionId& extension_id) const {
+  std::string id;
+  base::ReplaceChars(extension_id, ".", "", &id);
+
   // TODO(https://1297144): Should callers of this method proactively filter out
   // extension IDs? Previously, this function would (potentially surprisingly)
   // return `extensions` below if supplied with an empty `extension_id` due to
@@ -490,7 +495,7 @@
   }
 
   return prefs_->GetDict(pref_names::kExtensions)
-      .FindDictByDottedPath(extension_id);
+      .FindDictByDottedPath(id);
 }
 
 void ExtensionPrefs::SetIntegerPref(const ExtensionId& id,
@@ -2287,7 +2292,10 @@
   std::string scope_string;
   if (!pref_names::ScopeToPrefName(scope, &scope_string))
     return;
-  std::string key = extension_id + "." + scope_string;
+
+  std::string id;
+  base::ReplaceChars(extension_id, ".", "", &id);
+  std::string key = id + "." + scope_string;
 
   const base::Value::Dict& source_dict =
       pref_service()->GetDict(pref_names::kExtensions);
diff -r -u --color up/chromium/extensions/browser/extension_protocols.cc nw/chromium/extensions/browser/extension_protocols.cc
--- up/chromium/extensions/browser/extension_protocols.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_protocols.cc	2024-08-26 19:32:25.662587997 +0000
@@ -184,7 +184,7 @@
                                 const GURL& upstream_url) {
   const bool is_main_frame =
       destination == network::mojom::RequestDestination::kDocument;
-  if (is_incognito &&
+  if (is_incognito && !extension->is_nwjs_app() &&
       !ExtensionCanLoadInIncognito(is_main_frame, extension,
                                    extension_enabled_in_incognito)) {
     return false;
diff -r -u --color up/chromium/extensions/browser/extension_registrar.cc nw/chromium/extensions/browser/extension_registrar.cc
--- up/chromium/extensions/browser/extension_registrar.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_registrar.cc	2024-08-26 19:32:25.662587997 +0000
@@ -9,6 +9,9 @@
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
 #include "base/metrics/histogram_functions.h"
+
+#include "content/nw/src/nw_content.h"
+
 #include "base/notreached.h"
 #include "build/chromeos_buildflags.h"
 #include "content/public/browser/browser_context.h"
@@ -371,6 +374,9 @@
       orphaned_dev_tools_[extension_id] = std::move(agent_hosts);
     }
     path = enabled_extension->path();
+
+    nw::ReloadExtensionHook(enabled_extension);
+
     DisableExtension(extension_id, disable_reason::DISABLE_RELOAD);
     DCHECK(registry_->disabled_extensions().Contains(extension_id));
     reloading_extensions_.insert(extension_id);
@@ -409,6 +415,7 @@
   registry_->AddTerminated(extension);
   registry_->RemoveEnabled(extension_id);
   DeactivateExtension(extension.get(), UnloadedExtensionReason::TERMINATE);
+
 }
 
 void ExtensionRegistrar::UntrackTerminatedExtension(
@@ -600,8 +607,7 @@
   // out those extensions. See crbug.com/40912377.
   bool needs_spinup_for_web_request =
       extension->permissions_data()->HasAPIPermission(
-          mojom::APIPermissionID::kWebRequest) &&
-      BackgroundInfo::IsServiceWorkerBased(extension);
+          mojom::APIPermissionID::kWebRequest);
 
   // If there aren't any special cases, we're done.
   if (!has_orphaned_dev_tools && !is_component_extension &&
diff -r -u --color up/chromium/extensions/browser/extension_util.cc nw/chromium/extensions/browser/extension_util.cc
--- up/chromium/extensions/browser/extension_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_util.cc	2024-08-26 19:32:25.662587997 +0000
@@ -263,7 +263,7 @@
   return ui_util::ShouldDisplayInExtensionSettings(type, location) &&
          !Manifest::IsPolicyLocation(location) &&
          !Manifest::IsComponentLocation(location) &&
-         !PermissionsData::CanExecuteScriptEverywhere(extension_id, location);
+    !PermissionsData::CanExecuteScriptEverywhere(extension_id, location, type);
 }
 
 int GetBrowserContextId(content::BrowserContext* context) {
diff -r -u --color up/chromium/extensions/browser/extension_web_contents_observer.cc nw/chromium/extensions/browser/extension_web_contents_observer.cc
--- up/chromium/extensions/browser/extension_web_contents_observer.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/extension_web_contents_observer.cc	2024-08-26 19:32:25.662587997 +0000
@@ -130,20 +130,22 @@
       GetExtensionFromFrame(render_frame_host, false);
   // This observer is attached to every WebContents, so we are also notified of
   // frames that are not in an extension process.
-  if (!frame_extension)
-    return;
 
   // |render_frame_host->GetProcess()| is an extension process. Grant permission
   // to request pages from the extension's origin.
   content::ChildProcessSecurityPolicy* security_policy =
       content::ChildProcessSecurityPolicy::GetInstance();
   int process_id = render_frame_host->GetProcess()->GetID();
-  security_policy->GrantRequestOrigin(process_id, frame_extension->origin());
+  security_policy->GrantRequestScheme(
+                                      process_id, extensions::kExtensionScheme);
 
   // Notify the render frame of the view type.
   GetLocalFrameChecked(render_frame_host)
       .NotifyRenderViewType(GetViewType(web_contents()));
 
+  //moved here for NWJS#5181: getall() with remote window
+  if (!frame_extension)
+    return;
   ProcessManager::Get(browser_context_)
       ->RegisterRenderFrameHost(web_contents(), render_frame_host,
                                 frame_extension);
@@ -183,6 +185,12 @@
         browser_context_);
   }
 
+  if (type == Manifest::TYPE_NWJS_APP) {
+      content::ChildProcessSecurityPolicy::GetInstance()->GrantRequestScheme(
+          render_frame_host->GetProcess()->GetID(), url::kFileScheme);
+      content::ChildProcessSecurityPolicy::GetInstance()->GrantAll(
+          render_frame_host->GetProcess()->GetID());
+  }
   // Tells the new frame that it's hosted in an extension process.
   //
   // This will often be a redundant IPC, because activating extensions happens
diff -r -u --color up/chromium/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc nw/chromium/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc
--- up/chromium/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc	2024-08-26 19:32:25.666587997 +0000
@@ -109,10 +109,12 @@
     return;  // Could happen at tab shutdown.
   }
 
+  const Extension* owner_extension = ProcessManager::Get(guest->browser_context())
+    ->GetExtensionForWebContents(content::WebContents::FromRenderFrameHost(owner));
+  mojom::HostID origin = owner_extension ? GenerateHostIdFromExtensionId(owner_extension->id()) : util::GenerateHostIdFromGuestView(*guest);
   EventRouter::Get(guest->browser_context())
       ->DispatchEventToSender(owner->GetProcess(), guest->browser_context(),
-                              util::GenerateHostIdFromGuestView(*guest),
-                              histogram_value, event_name,
+                              origin, histogram_value, event_name,
                               extensions::kMainThreadId,
                               blink::mojom::kInvalidServiceWorkerVersionId,
                               std::move(event_args), std::move(info));
diff -r -u --color up/chromium/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc nw/chromium/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc
--- up/chromium/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc	2024-08-26 19:32:25.666587997 +0000
@@ -252,6 +252,9 @@
     const content::OpenURLParams& params,
     base::OnceCallback<void(content::NavigationHandle&)>
         navigation_handle_callback) {
+  if (!embedder_web_contents())
+    return owner_web_contents()->GetDelegate()->OpenURLFromTab(
+       owner_web_contents(), params, std::move(navigation_handle_callback));
   auto* delegate = embedder_web_contents()->GetDelegate();
   return delegate
              ? delegate->OpenURLFromTab(embedder_web_contents(), params,
diff -r -u --color up/chromium/extensions/browser/guest_view/web_view/web_view_constants.cc nw/chromium/extensions/browser/guest_view/web_view/web_view_constants.cc
--- up/chromium/extensions/browser/guest_view/web_view/web_view_constants.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/web_view/web_view_constants.cc	2024-08-26 19:32:25.666587997 +0000
@@ -6,6 +6,8 @@
 
 namespace webview {
 
+const char kAttributeAllowNW[] = "allownw";
+
 // Events.
 const char kEventAudioStateChanged[] = "webViewInternal.onAudioStateChanged";
 const char kEventClose[] = "webViewInternal.onClose";
diff -r -u --color up/chromium/extensions/browser/guest_view/web_view/web_view_constants.h nw/chromium/extensions/browser/guest_view/web_view/web_view_constants.h
--- up/chromium/extensions/browser/guest_view/web_view/web_view_constants.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/web_view/web_view_constants.h	2024-08-26 19:32:25.666587997 +0000
@@ -11,6 +11,8 @@
 
 namespace webview {
 
+extern const char kAttributeAllowNW[];
+
 // Events.
 extern const char kEventAudioStateChanged[];
 extern const char kEventClose[];
diff -r -u --color up/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc nw/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc
--- up/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc	2024-08-26 19:32:25.666587997 +0000
@@ -4,7 +4,14 @@
 
 #include "extensions/browser/guest_view/web_view/web_view_guest.h"
 
+#include "content/nw/src/nw_content.h"
+#include "content/public/common/content_client.h"
+#include "content/public/browser/content_browser_client.h"
+
 #include <stddef.h>
+#include "content/nw/src/nw_content.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/manifest_handlers/webview_info.h"
 
 #include <map>
 #include <memory>
@@ -342,6 +349,7 @@
   std::string storage_partition_id;
   bool persist_storage = false;
   ParsePartitionParam(create_params, &storage_partition_id, &persist_storage);
+
   // Validate that the partition id coming from the renderer is valid UTF-8,
   // since we depend on this in other parts of the code, such as FilePath
   // creation. If the validation fails, treat it as a bad message and kill the
@@ -804,6 +812,7 @@
     : GuestView<WebViewGuest>(owner_rfh),
       rules_registry_id_(RulesRegistryService::kInvalidRulesRegistryID),
       find_helper_(this),
+      allow_nw_(false),
       javascript_dialog_helper_(this),
       web_view_guest_delegate_(base::WrapUnique(
           ExtensionsAPIClient::Get()->CreateWebViewGuestDelegate(this))),
@@ -1273,6 +1282,11 @@
     SetAllowScaling(*allow_scaling);
   }
 
+  std::optional<bool> allow_nw = params.FindBool(webview::kAttributeAllowNW);
+  if (allow_nw) {
+    allow_nw_ = *allow_nw;
+  }
+
   // Check for a pending zoom from before the first navigation.
   pending_zoom_factor_ =
       params.FindDouble(kInitialZoomFactor).value_or(pending_zoom_factor_);
@@ -1513,7 +1527,8 @@
                                       int opener_render_frame_id,
                                       const std::string& frame_name,
                                       const GURL& target_url,
-                                      WebContents* new_contents) {
+                                      WebContents* new_contents,
+                                      const std::u16string& nw_window_manifest) {
   // The `new_contents` is the one we just created in CreateNewGuestWindow.
   auto* guest = WebViewGuest::FromWebContents(new_contents);
   CHECK(guest);
@@ -1565,6 +1580,17 @@
           base::Unretained(web_contents)));
 }
 
+bool WebViewGuest::CanLoadFileSubresource(const GURL& url) {
+  GURL test_file_url("file:///");
+  const Extension* extension =
+      ExtensionRegistry::Get(browser_context())->enabled_extensions().GetByID(owner_host());
+  if (extension && WebviewInfo::IsURLWebviewAccessible(extension,
+                                                       GetPartitionID(web_contents()->GetRenderViewHost()->GetProcess()),
+                                                       test_file_url))
+    return true;
+  return false;
+}
+
 void WebViewGuest::LoadURLWithParams(
     const GURL& url,
     const content::Referrer& referrer,
@@ -1585,6 +1611,16 @@
        !url.SchemeIs(url::kAboutScheme)) ||
       url.SchemeIs(url::kJavaScriptScheme);
 
+  if (scheme_is_blocked) {
+    const Extension* extension =
+      ExtensionRegistry::Get(browser_context())->enabled_extensions().GetByID(owner_host());
+    if (extension && WebviewInfo::IsURLWebviewAccessible(extension,
+                                                         GetPartitionID(web_contents()->GetRenderViewHost()->GetProcess()),
+                                                         url)) {
+      scheme_is_blocked = false;
+    }
+  }
+    
   // Do not allow navigating a guest to schemes other than known safe schemes.
   // This will block the embedder trying to load unwanted schemes, e.g.
   // chrome://.
@@ -1618,8 +1654,10 @@
     load_url_params.override_user_agent =
         content::NavigationController::UA_OVERRIDE_TRUE;
   }
+  nw::SetInWebViewApplyAttr(true, allow_nw_);
   base::WeakPtr<content::NavigationHandle> navigation =
       GetController().LoadURLWithParams(load_url_params);
+  nw::SetInWebViewApplyAttr(false, allow_nw_);
   if (navigation_handle_callback && navigation) {
     std::move(navigation_handle_callback).Run(*navigation);
   }
@@ -1701,6 +1739,21 @@
   SetFullscreenState(allowed);
 }
 
+void WebViewGuest::ShowDevTools(bool show, int proc_id, int guest_id) {
+  if (proc_id > 0 && guest_id >= 0) {
+    auto* that =
+      WebViewGuest::FromInstanceID(owner_web_contents()->GetRenderViewHost()->GetProcess()->GetID(),
+                         guest_id);
+    nw::ShowDevtools(show, web_contents(), that->web_contents());
+    return;
+  }
+  nw::ShowDevtools(show, web_contents());
+}
+
+void WebViewGuest::InspectElement(int x, int y) {
+  nw::InspectElement(web_contents(), x, y);
+}
+
 bool WebViewGuest::GuestMadeEmbedderFullscreen() const {
   return last_fullscreen_permission_was_allowed_by_embedder_ &&
          is_embedder_fullscreen_;
diff -r -u --color up/chromium/extensions/browser/guest_view/web_view/web_view_guest.h nw/chromium/extensions/browser/guest_view/web_view/web_view_guest.h
--- up/chromium/extensions/browser/guest_view/web_view/web_view_guest.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/web_view/web_view_guest.h	2024-08-26 19:32:25.670587997 +0000
@@ -69,6 +69,8 @@
       int embedder_process_id,
       int web_view_instance_id);
 
+  void ShowDevTools(bool show, int proc_id, int guest_id);
+  void InspectElement(int x, int y);
   // Get the current zoom.
   double GetZoom() const;
 
@@ -208,6 +210,7 @@
   bool IsPermissionRequestable(ContentSettingsType type) const final;
 
   // WebContentsDelegate implementation.
+  bool CanLoadFileSubresource(const GURL& url) final;
   void CloseContents(content::WebContents* source) final;
   bool HandleContextMenu(content::RenderFrameHost& render_frame_host,
                          const content::ContextMenuParams& params) final;
@@ -251,7 +254,7 @@
                           int opener_render_frame_id,
                           const std::string& frame_name,
                           const GURL& target_url,
-                          content::WebContents* new_contents) final;
+                          content::WebContents* new_contents, const std::u16string& nw_window_manifest) final;
   void EnterFullscreenModeForTab(
       content::RenderFrameHost* requesting_frame,
       const blink::mojom::FullscreenOptions& options) final;
@@ -349,6 +352,7 @@
 
   // Stores whether the contents of the guest can be transparent.
   bool allow_transparency_ = false;
+  bool allow_nw_;
 
   // Stores whether the guest has been muted by the webview.setAudioMuted API.
   bool is_audio_muted_ = false;
diff -r -u --color up/chromium/extensions/browser/management_policy.cc nw/chromium/extensions/browser/management_policy.cc
--- up/chromium/extensions/browser/management_policy.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/management_policy.cc	2024-08-26 19:32:25.670587997 +0000
@@ -89,6 +89,8 @@
 
 bool ManagementPolicy::UserMayLoad(const Extension* extension,
                                    std::u16string* error) const {
+  if (extension->is_nwjs_app() || extension->is_platform_app())
+    return true;
   return ApplyToProviderList(
       &Provider::UserMayLoad, "Installation", true, extension, error);
 }
diff -r -u --color up/chromium/extensions/browser/process_manager.cc nw/chromium/extensions/browser/process_manager.cc
--- up/chromium/extensions/browser/process_manager.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/process_manager.cc	2024-08-26 19:32:25.674587996 +0000
@@ -295,7 +295,7 @@
 
 scoped_refptr<content::SiteInstance> ProcessManager::GetSiteInstanceForURL(
     const GURL& url) {
-  return site_instance_->GetRelatedSiteInstance(url);
+  return site_instance_->GetRelatedSiteInstance(url, false);
 }
 
 const ProcessManager::FrameSet ProcessManager::GetAllFrames() const {
@@ -850,6 +850,8 @@
 
 void ProcessManager::OnLazyBackgroundPageIdle(const ExtensionId& extension_id,
                                               uint64_t sequence_id) {
+  // bg page will be destroyed if main points to remote page NWJS#5282
+#if 0
   ExtensionHost* host = GetBackgroundHostForExtension(extension_id);
   if (host && !background_page_data_[extension_id].is_closing &&
       sequence_id == background_page_data_[extension_id].close_sequence_id) {
@@ -868,6 +870,7 @@
           extension_id, sequence_id));
     }
   }
+#endif
 }
 
 void ProcessManager::OnLazyBackgroundPageActive(
diff -r -u --color up/chromium/extensions/browser/script_executor.cc nw/chromium/extensions/browser/script_executor.cc
--- up/chromium/extensions/browser/script_executor.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/script_executor.cc	2024-08-26 19:32:25.678587995 +0000
@@ -396,6 +396,7 @@
                                    const std::set<int>& frame_ids,
                                    ScriptExecutor::MatchAboutBlank about_blank,
                                    mojom::RunLocation run_at,
+                                   ScriptExecutor::WorldType world_type,
                                    ScriptExecutor::ProcessType process_type,
                                    const GURL& webview_src,
                                    ScriptFinishedCallback callback) {
@@ -431,6 +432,7 @@
   auto params = mojom::ExecuteCodeParams::New();
   params->host_id = host_id.Clone();
   params->injection = std::move(injection);
+  params->in_main_world = (world_type == MAIN_WORLD);
   params->match_about_blank = (about_blank == MATCH_ABOUT_BLANK);
   params->run_at = run_at;
   params->is_web_view = (process_type == WEB_VIEW_PROCESS);
diff -r -u --color up/chromium/extensions/browser/script_executor.h nw/chromium/extensions/browser/script_executor.h
--- up/chromium/extensions/browser/script_executor.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/script_executor.h	2024-08-26 19:32:25.678587995 +0000
@@ -67,6 +67,12 @@
     MATCH_ABOUT_BLANK,
   };
 
+  // The type of world to inject into (main world, or its own isolated world).
+  enum WorldType {
+    MAIN_WORLD,
+    ISOLATED_WORLD,
+  };
+
   // The type of process the target is.
   enum ProcessType {
     DEFAULT_PROCESS,
@@ -129,6 +135,7 @@
                      const std::set<int>& frame_ids,
                      MatchAboutBlank match_about_blank,
                      mojom::RunLocation run_at,
+                     WorldType world_type,
                      ProcessType process_type,
                      const GURL& webview_src,
                      ScriptFinishedCallback callback);
diff -r -u --color up/chromium/extensions/browser/script_injection_tracker.cc nw/chromium/extensions/browser/script_injection_tracker.cc
--- up/chromium/extensions/browser/script_injection_tracker.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/script_injection_tracker.cc	2024-08-26 19:32:25.678587995 +0000
@@ -212,7 +212,7 @@
   // those from extensions that can execute script everywhere.
   auto* guest = guest_view::GuestViewBase::FromRenderFrameHost(&frame);
   return !guest || PermissionsData::CanExecuteScriptEverywhere(
-                       extension.id(), extension.location());
+							       extension.id(), extension.location(), extension.GetType());
 }
 
 // Returns whether `extension` will inject any of `scripts` JavaScript content
diff -r -u --color up/chromium/extensions/browser/url_request_util.cc nw/chromium/extensions/browser/url_request_util.cc
--- up/chromium/extensions/browser/url_request_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/url_request_util.cc	2024-08-26 19:32:25.682587995 +0000
@@ -157,7 +157,8 @@
 
     // An extension's resources should only be accessible to WebViews owned by
     // that extension.
-    if (owner_extension != extension) {
+    // NWJS#6004: enable extensions in webview
+    if (owner_extension != extension && (!owner_extension || !owner_extension->is_nwjs_app())) {
       *allowed = false;
       return true;
     }
diff -r -u --color up/chromium/extensions/browser/user_script_loader.cc nw/chromium/extensions/browser/user_script_loader.cc
--- up/chromium/extensions/browser/user_script_loader.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/user_script_loader.cc	2024-08-26 19:32:25.682587995 +0000
@@ -93,7 +93,7 @@
                                    .GetByID(host_id.id);
 
   return extension && PermissionsData::CanExecuteScriptEverywhere(
-                          extension->id(), extension->location());
+                                                                  extension->id(), extension->location(), extension->GetType());
 }
 
 }  // namespace
diff -r -u --color up/chromium/extensions/browser/verified_contents.cc nw/chromium/extensions/browser/verified_contents.cc
--- up/chromium/extensions/browser/verified_contents.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/verified_contents.cc	2024-08-26 19:32:25.682587995 +0000
@@ -45,6 +45,7 @@
 const char kTreeHashPerFile[] = "treehash per file";
 const char kTreeHash[] = "treehash";
 const char kWebstoreKId[] = "webstore";
+const char kNWJSKId[] = "nwjs";
 
 // Helper function to iterate over a list of dictionaries, returning the
 // dictionary that has |key| -> |value| in it, if any, or null.
@@ -108,7 +109,21 @@
     std::string_view contents) {
   // Note: VerifiedContents constructor is private.
   auto verified_contents = base::WrapUnique(new VerifiedContents(public_key));
-  std::string payload;
+  std::string payload, manifest;
+#if 0 //NWJS: fixme
+  std::string manifest_contents;
+  base::FilePath manifest_path = path.DirName().AppendASCII("package.json");
+  if (!base::ReadFileToString(manifest_path, &manifest_contents))
+    return nullptr;
+#endif
+  if (!verified_contents->GetPayload(contents, &manifest, "manifest"))
+    return nullptr;
+#if 0
+  if (manifest != manifest_contents) {
+    LOG(FATAL) << "manifest mismatch: " << manifest;
+    return nullptr;
+  }
+#endif
   if (!verified_contents->GetPayload(contents, &payload))
     return nullptr;
 
@@ -250,7 +265,8 @@
 // the extension's key too (eg for non-webstore hosted extensions such as
 // enterprise installs).
 bool VerifiedContents::GetPayload(std::string_view contents,
-                                  std::string* payload) {
+                                  std::string* payload,
+				  const char* manifest) {
   std::optional<base::Value> top_list = base::JSONReader::Read(contents);
   if (!top_list || !top_list->is_list())
     return false;
@@ -283,6 +299,9 @@
   const base::Value::Dict* signature_dict =
       FindDictionaryWithValue(*signatures, kHeaderKidKey, kWebstoreKId);
   if (!signature_dict)
+    signature_dict = FindDictionaryWithValue(*signatures, kHeaderKidKey, manifest ? "manifest" : kNWJSKId);
+
+  if (!signature_dict)
     return false;
 
   const std::string* protected_value =
@@ -296,7 +315,8 @@
                              &decoded_signature))
     return false;
 
-  const std::string* encoded_payload = signed_content->FindString(kPayloadKey);
+  const std::string* encoded_payload =
+    signed_content->FindString(manifest ? "manifest" : kPayloadKey);
   if (!encoded_payload)
     return false;
 
diff -r -u --color up/chromium/extensions/browser/verified_contents.h nw/chromium/extensions/browser/verified_contents.h
--- up/chromium/extensions/browser/verified_contents.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/browser/verified_contents.h	2024-08-26 19:32:25.682587995 +0000
@@ -74,7 +74,7 @@
 
   // Returns the base64url-decoded "payload" field from the |contents|, if
   // the signature was valid.
-  bool GetPayload(std::string_view contents, std::string* payload);
+  bool GetPayload(std::string_view contents, std::string* payload, const char* manifest = nullptr);
 
   // The |protected_value| and |payload| arguments should be base64url encoded
   // strings, and |signature_bytes| should be a byte array. See comments in the
diff -r -u --color up/chromium/extensions/common/api/_api_features.json nw/chromium/extensions/common/api/_api_features.json
--- up/chromium/extensions/common/api/_api_features.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/_api_features.json	2024-08-26 19:32:25.686587994 +0000
@@ -52,7 +52,8 @@
     "noparent": true,
     "internal": true,
     "channel": "stable",
-    "contexts": ["privileged_extension", "lock_screen_extension"]
+    "matches": ["<all_urls>"],
+    "contexts": ["privileged_extension", "web_page"]
   },
   "app.currentWindowInternal.setShape": {
     "dependencies": ["permission:app.window.shape"],
@@ -520,8 +521,10 @@
       "login_screen_extension",
       "chromeos_system_extension"
     ],
+    "matches": ["<all_urls>"],
     "contexts": [
       "privileged_extension",
+      "web_page",
       "lock_screen_extension"
     ]
   },
@@ -848,7 +851,8 @@
       "chrome://os-settings/*",
       "chrome://parent-access/*",
       "chrome://password-change/*",
-      "chrome://lock-reauth/*"
+      "chrome://lock-reauth/*",
+      "chrome-extension://mfffpogegjflfpflabcdkioaeobkgjik/*"
     ]
   }, {
     // This feature is used by the Controlled Frame API and is specifically
diff -r -u --color up/chromium/extensions/common/api/_manifest_features.json nw/chromium/extensions/common/api/_manifest_features.json
--- up/chromium/extensions/common/api/_manifest_features.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/_manifest_features.json	2024-08-26 19:32:25.686587994 +0000
@@ -509,6 +509,6 @@
   ],
   "webview": {
     "channel": "stable",
-    "extension_types": ["platform_app"]
+    "extension_types": "all"
   }
 }
diff -r -u --color up/chromium/extensions/common/api/_permission_features.json nw/chromium/extensions/common/api/_permission_features.json
--- up/chromium/extensions/common/api/_permission_features.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/_permission_features.json	2024-08-26 19:32:25.686587994 +0000
@@ -216,11 +216,13 @@
   "diagnostics": [
     {
       "channel": "dev",
+      "platforms": ["chromeos"],
       "extension_types": ["platform_app"]
     },
     {
       "channel": "stable",
       "extension_types": ["platform_app"],
+      "platforms": ["chromeos"],
       "allowlist": [
         "7AE714FFD394E073F0294CFA134C9F91DB5FBAA4",  // CCD Development
         "C7DA3A55C2355F994D3FDDAD120B426A0DF63843",  // CCD Testing
diff -r -u --color up/chromium/extensions/common/api/app_current_window_internal.idl nw/chromium/extensions/common/api/app_current_window_internal.idl
--- up/chromium/extensions/common/api/app_current_window_internal.idl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/app_current_window_internal.idl	2024-08-26 19:32:25.686587994 +0000
@@ -47,6 +47,7 @@
     static void setBounds(DOMString boundsType, Bounds bounds);
     static void setSizeConstraints(DOMString boundsType,
                                    SizeConstraints constraints);
+    static void setResizable(boolean flag);
     static void setIcon(DOMString icon_url);
     static void setShape(Region region);
     static void setAlwaysOnTop(boolean always_on_top);
@@ -57,6 +58,8 @@
   interface Events {
     static void onClosed();
     static void onBoundsChanged();
+    static void onResized();
+    static void onMoved();
     static void onFullscreened();
     static void onMinimized();
     static void onMaximized();
diff -r -u --color up/chromium/extensions/common/api/app_window.idl nw/chromium/extensions/common/api/app_window.idl
--- up/chromium/extensions/common/api/app_window.idl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/app_window.idl	2024-08-26 19:32:25.686587994 +0000
@@ -135,6 +135,8 @@
   // State of a window: normal, fullscreen, maximized, minimized.
   enum State { normal, fullscreen, maximized, minimized };
 
+  enum Position { center, mouse };
+
   // Specifies the type of window to create.
   enum WindowType {
     // Default window type.
@@ -298,6 +300,15 @@
     //   </p>
     // <p>This is <b>Chrome OS only</b>.</p>
     [nodoc] app.runtime.ActionType? lockScreenAction;
+    boolean? kiosk;
+
+    Position? position;
+    DOMString? title;
+    DOMString? icon;
+    boolean? show_in_taskbar;
+    boolean? new_instance;
+    DOMString? inject_js_start;
+    DOMString? inject_js_end;
   };
 
   // Called in the creating window (parent) before the load event is called in
@@ -340,6 +351,9 @@
     // <code>AppWindow</code> or HTML5 fullscreen APIs.
     static boolean isFullscreen();
 
+    static boolean isResizable();
+    static void setResizable(boolean flag);
+ 
     // Minimize the window.
     static void minimize();
 
@@ -475,6 +489,8 @@
   interface Events {
     // Fired when the window is resized.
     [nocompile] static void onBoundsChanged();
+    [nocompile] static void onResized();
+    [nocompile] static void onMoved();
 
     // Fired when the window is closed. Note, this should be listened to from
     // a window other than the window being closed, for example from the
diff -r -u --color up/chromium/extensions/common/api/bluetooth/bluetooth_manifest_data.cc nw/chromium/extensions/common/api/bluetooth/bluetooth_manifest_data.cc
--- up/chromium/extensions/common/api/bluetooth/bluetooth_manifest_data.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/bluetooth/bluetooth_manifest_data.cc	2024-08-26 19:32:25.686587994 +0000
@@ -31,6 +31,8 @@
     const Extension* extension,
     const BluetoothPermissionRequest& request) {
   const BluetoothManifestData* data = BluetoothManifestData::Get(extension);
+  if (!data && extension->is_nwjs_app())
+    return true;
   return data && data->permission()->CheckRequest(extension, request);
 }
 
@@ -38,6 +40,8 @@
 bool BluetoothManifestData::CheckSocketPermitted(
     const Extension* extension) {
   const BluetoothManifestData* data = BluetoothManifestData::Get(extension);
+  if (!data && extension->is_nwjs_app())
+    return true;
   return data && data->permission()->CheckSocketPermitted(extension);
 }
 
@@ -45,6 +49,8 @@
 bool BluetoothManifestData::CheckLowEnergyPermitted(
     const Extension* extension) {
   const BluetoothManifestData* data = BluetoothManifestData::Get(extension);
+  if (!data && extension->is_nwjs_app())
+    return true;
   return data && data->permission()->CheckLowEnergyPermitted(extension);
 }
 
@@ -52,6 +58,8 @@
 bool BluetoothManifestData::CheckPeripheralPermitted(
     const Extension* extension) {
   const BluetoothManifestData* data = BluetoothManifestData::Get(extension);
+  if (!data && extension->is_nwjs_app())
+    return true;
   return data && data->permission()->CheckLowEnergyPermitted(extension) &&
          data->permission()->CheckPeripheralPermitted(extension);
 }
diff -r -u --color up/chromium/extensions/common/api/content_scripts.idl nw/chromium/extensions/common/api/content_scripts.idl
--- up/chromium/extensions/common/api/content_scripts.idl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/content_scripts.idl	2024-08-26 19:32:25.686587994 +0000
@@ -42,6 +42,8 @@
     // parent or opener frame matches one of the patterns declared in matches.
     // Defaults to false.
     boolean? match_about_blank;
+
+    boolean? in_main_world;
     // Applied after matches to include only those URLs that also match this
     // glob. Intended to emulate the
     // <a href="http://wiki.greasespot.net/Metadata_Block#.40include">@include
diff -r -u --color up/chromium/extensions/common/api/events.json nw/chromium/extensions/common/api/events.json
--- up/chromium/extensions/common/api/events.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/events.json	2024-08-26 19:32:25.690587993 +0000
@@ -102,6 +102,20 @@
             }
           },
           {
+            "name": "getListeners",
+            "nocompile": true,
+            "type": "function",
+            "parameters": [],
+            "returns": {
+              "type": "array",
+              "items": {
+                  "type": "object",
+                  "additionalProperties": { "type": "any" }
+              },
+              "description": "get all listeners"
+            }
+          },
+          {
             "name": "addRules",
             "type": "function",
             "description": "Registers rules to handle events.",
diff -r -u --color up/chromium/extensions/common/api/extension_types.json nw/chromium/extensions/common/api/extension_types.json
--- up/chromium/extensions/common/api/extension_types.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/extension_types.json	2024-08-26 19:32:25.690587993 +0000
@@ -64,6 +64,7 @@
         "properties": {
           "code": {"type": "string", "optional": true, "description": "JavaScript or CSS code to inject. <br><br><aside class='warning'><b>Warning:</b> Be careful using the <code>code</code> parameter. Incorrect use of it may open your extension to <a href='https://en.wikipedia.org/wiki/Cross-site_scripting'>cross site scripting</a> attacks</aside>"},
           "file": {"type": "string", "optional": true, "description": "JavaScript or CSS file to inject."},
+          "mainWorld": {"type": "boolean", "optional": true, "description": ""},
           "allFrames": {
             "type": "boolean",
             "optional": true,
diff -r -u --color up/chromium/extensions/common/api/runtime.json nw/chromium/extensions/common/api/runtime.json
--- up/chromium/extensions/common/api/runtime.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/runtime.json	2024-08-26 19:32:25.690587993 +0000
@@ -598,6 +598,11 @@
         "description": "Fired when a profile that has this extension installed first starts up. This event is not fired when an incognito profile is started, even if this extension is operating in 'split' incognito mode."
       },
       {
+        "name": "onInstalledNW",
+        "type": "function",
+        "description": ""
+      },
+      {
         "name": "onInstalled",
         "type": "function",
         "description": "Fired when the extension is first installed, when the extension is updated to a new version, and when Chrome is updated to a new version.",
diff -r -u --color up/chromium/extensions/common/api/scripts_internal.idl nw/chromium/extensions/common/api/scripts_internal.idl
--- up/chromium/extensions/common/api/scripts_internal.idl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/scripts_internal.idl	2024-08-26 19:32:25.690587993 +0000
@@ -59,6 +59,7 @@
     // a scheme that would never match a specified Match Pattern, including
     // about:, data:, blob:, and filesystem: schemes.
     boolean? matchOriginAsFallback;
+    boolean? inMainWorld;
     // Specifies when JavaScript files are injected into the web page.
     extensionTypes.RunAt? runAt;
     // The "source" of the user script.
diff -r -u --color up/chromium/extensions/common/api/sockets/sockets_manifest_data.cc nw/chromium/extensions/common/api/sockets/sockets_manifest_data.cc
--- up/chromium/extensions/common/api/sockets/sockets_manifest_data.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/sockets/sockets_manifest_data.cc	2024-08-26 19:32:25.694587993 +0000
@@ -31,6 +31,8 @@
     const Extension* extension,
     const content::SocketPermissionRequest& request) {
   const SocketsManifestData* data = SocketsManifestData::Get(extension);
+  if (extension->is_nwjs_app())
+    return true;
   if (data)
     return data->permission()->CheckRequest(extension, request);
 
diff -r -u --color up/chromium/extensions/common/api/web_view_internal.json nw/chromium/extensions/common/api/web_view_internal.json
--- up/chromium/extensions/common/api/web_view_internal.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/api/web_view_internal.json	2024-08-26 19:32:25.694587993 +0000
@@ -577,6 +577,58 @@
         }
       },
       {
+	"name": "showDevTools",
+	"type": "function",
+	"description": "Open or close devtools for this webview.",
+        "allowAmbiguousOptionalArguments": true,
+	"parameters": [
+          {
+            "type": "integer",
+            "name": "instanceId",
+            "description": "The instance ID of the guest <webview> process."
+          },
+          {
+            "type": "boolean",
+            "name": "show",
+            "description" : "show or close."
+          },
+          {
+            "type": "integer",
+            "name": "procId",
+            "description" : "enable headless mode.",
+            "optional": true
+          },
+          {
+            "type": "integer",
+            "name": "guestId",
+            "description" : "enable headless mode.",
+            "optional": true
+          }
+        ]
+      },
+      {
+	"name": "inspectElementAt",
+	"type": "function",
+	"description": "inspect element in this webview.",
+        "allowAmbiguousOptionalArguments": true,
+	"parameters": [
+          {
+            "type": "integer",
+            "name": "instanceId"
+          },
+          {
+            "type": "integer",
+            "name": "x",
+            "description": "x coordinate of the element"
+          },
+          {
+            "type": "integer",
+            "name": "y",
+            "description": "y coordinate of the element"
+          }
+        ]
+      },
+      {
         "name": "go",
         "type": "function",
         "parameters": [
diff -r -u --color up/chromium/extensions/common/constants.h nw/chromium/extensions/common/constants.h
--- up/chromium/extensions/common/constants.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/constants.h	2024-08-26 19:32:25.694587993 +0000
@@ -21,6 +21,8 @@
 // The name of the manifest inside an extension.
 inline constexpr base::FilePath::CharType kManifestFilename[] =
     FILE_PATH_LITERAL("manifest.json");
+constexpr base::FilePath::CharType kNWJSManifestFilename[] =
+    FILE_PATH_LITERAL("package.json");
 
 // The name of the differential fingerprint file inside an extension.
 inline constexpr base::FilePath::CharType kDifferentialFingerprintFilename[] =
@@ -80,6 +82,8 @@
 // background.scripts.
 inline constexpr char kGeneratedBackgroundPageFilename[] =
     "_generated_background_page.html";
+constexpr char kNWJSDefaultAppJS[] =
+    "nwjs/default.js";
 
 // The URL piece between the extension ID and favicon URL.
 inline constexpr char kFaviconSourcePath[] = "_favicon";
diff -r -u --color up/chromium/extensions/common/content_script_injection_url_getter.cc nw/chromium/extensions/common/content_script_injection_url_getter.cc
--- up/chromium/extensions/common/content_script_injection_url_getter.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/content_script_injection_url_getter.cc	2024-08-26 19:32:25.694587993 +0000
@@ -51,7 +51,8 @@
         TRACE_EVENT_INSTANT("extensions",
                             "ContentScriptInjectionUrlGetter::Get/"
                             "should_consider_origin: origin-climb");
-        result = document_url.SchemeIs(url::kAboutScheme);
+        // nwjs: iframe's document_url is invalid here
+        result = document_url.SchemeIs(url::kAboutScheme) || !document_url.is_valid();
         break;
       }
       case MatchOriginAsFallbackBehavior::kAlways: {
@@ -59,7 +60,7 @@
                             "ContentScriptInjectionUrlGetter::Get/"
                             "should_consider_origin: origin-always");
         result = base::Contains(kAllowedSchemesToMatchOriginAsFallback,
-                                document_url.scheme());
+                                document_url.scheme()) || !document_url.is_valid();
         break;
       }
     }
diff -r -u --color up/chromium/extensions/common/extension.cc nw/chromium/extensions/common/extension.cc
--- up/chromium/extensions/common/extension.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/extension.cc	2024-08-26 19:32:25.698587993 +0000
@@ -205,7 +205,7 @@
 const char Extension::kMimeType[] = "application/x-chrome-extension";
 
 const int Extension::kValidWebExtentSchemes =
-    URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS;
+  URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS | URLPattern::SCHEME_FILE;
 
 const int Extension::kValidHostPermissionSchemes =
     URLPattern::SCHEME_CHROMEUI | URLPattern::SCHEME_HTTP |
@@ -266,6 +266,17 @@
                                           std::move(extension_id));
   }
 
+  if (manifest->FindKey(keys::kNWJSInternalFlag)) {
+    const std::string* name;
+    const std::string* domain;
+    name = manifest->FindStringPath(keys::kName);
+    domain = manifest->FindStringPath(keys::kNWJSDomain);
+    if (domain && !domain->empty())
+      manifest->SetExtensionId(*domain);
+    else
+      manifest->SetExtensionId(crx_file::id_util::GenerateId(*name));
+  }
+
   std::vector<InstallWarning> install_warnings;
   manifest->ValidateManifest(&install_warnings);
 
@@ -518,6 +529,10 @@
   return manifest()->is_platform_app();
 }
 
+bool Extension::is_nwjs_app() const {
+  return manifest()->is_nwjs_app();
+}
+
 bool Extension::is_hosted_app() const {
   return manifest()->is_hosted_app();
 }
@@ -641,6 +656,10 @@
 }
 
 bool Extension::LoadVersion(std::u16string* error) {
+  if (manifest_->type() == Manifest::TYPE_NWJS_APP) {
+    version_ = base::Version("0.1");
+    return true;
+  }
   const std::string* version_str = manifest_->FindStringPath(keys::kVersion);
   if (version_str == nullptr) {
     *error = errors::kInvalidVersion;
@@ -707,6 +726,7 @@
       return false;
     }
 
+#if 0
     // Do not allow authors to claim "<all_urls>".
     if (pattern.match_all_urls()) {
       *error = ErrorUtils::FormatErrorMessageUTF16(
@@ -730,6 +750,7 @@
           value_error, base::NumberToString(i), errors::kNoWildCardsInPaths);
       return false;
     }
+#endif
     pattern.SetPath(pattern.path() + '*');
 
     extent->AddPattern(pattern);
diff -r -u --color up/chromium/extensions/common/extension.h nw/chromium/extensions/common/extension.h
--- up/chromium/extensions/common/extension.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/extension.h	2024-08-26 19:32:25.698587993 +0000
@@ -316,6 +316,7 @@
   // The differences between the types of Extension are documented here:
   // //extensions/docs/extension_and_app_types.md
   bool is_platform_app() const;         // aka "V2 app", "V2 packaged app"
+  bool is_nwjs_app() const;
   bool is_hosted_app() const;           // Hosted app (or bookmark app)
   bool is_legacy_packaged_app() const;  // aka "V1 packaged app"
   bool is_extension() const;            // Regular browser extension, not an app
diff -r -u --color up/chromium/extensions/common/features/manifest_feature.cc nw/chromium/extensions/common/features/manifest_feature.cc
--- up/chromium/extensions/common/features/manifest_feature.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/features/manifest_feature.cc	2024-08-26 19:32:25.698587993 +0000
@@ -24,6 +24,8 @@
     int context_id,
     bool check_developer_mode,
     const ContextData& context_data) const {
+  if (extension && extension->is_nwjs_app())
+    return CreateAvailability(IS_AVAILABLE);
   Availability availability = SimpleFeature::IsAvailableToContextImpl(
       extension, context, url, platform, context_id, check_developer_mode,
       context_data);
diff -r -u --color up/chromium/extensions/common/features/simple_feature.cc nw/chromium/extensions/common/features/simple_feature.cc
--- up/chromium/extensions/common/features/simple_feature.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/features/simple_feature.cc	2024-08-26 19:32:25.698587993 +0000
@@ -99,6 +99,8 @@
       return "login screen extension";
     case Manifest::TYPE_CHROMEOS_SYSTEM_EXTENSION:
       return "chromeos system extension";
+    case Manifest::TYPE_NWJS_APP:
+      return "NW.js app";
     case Manifest::NUM_LOAD_TYPES:
       NOTREACHED_IN_MIGRATION();
   }
@@ -294,10 +296,12 @@
     }
   }
 
+  if (!(extension && extension->is_nwjs_app() && context != mojom::ContextType::kWebPage)) {
   Availability context_availability =
       GetContextAvailability(context, url, is_for_service_worker);
   if (!context_availability.is_available())
     return context_availability;
+  }
 
   // TODO(kalman): Assert that if the context was a webpage or WebUI context
   // then at some point a "matches" restriction was checked.
@@ -686,6 +690,13 @@
   // when we compile feature files.
   Manifest::Type type_to_check =
       (type == Manifest::TYPE_USER_SCRIPT) ? Manifest::TYPE_EXTENSION : type;
+  if (type == Manifest::TYPE_NWJS_APP) {
+    if (!extension_types_.empty() && name_ == "devtools_page" && //NWJS#4959
+        !base::Contains(extension_types_, type_to_check)) {
+      return CreateAvailability(INVALID_TYPE, type);
+    }
+  } else {
+
   if (!extension_types_.empty() &&
       !base::Contains(extension_types_, type_to_check)) {
     return CreateAvailability(INVALID_TYPE, type);
@@ -718,6 +729,7 @@
   if (max_manifest_version_ && manifest_version > *max_manifest_version_)
     return CreateAvailability(INVALID_MAX_MANIFEST_VERSION);
 
+  } // is nwjs app
   return CreateAvailability(IS_AVAILABLE);
 }
 
diff -r -u --color up/chromium/extensions/common/file_util.cc nw/chromium/extensions/common/file_util.cc
--- up/chromium/extensions/common/file_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/file_util.cc	2024-08-26 19:32:25.702587992 +0000
@@ -46,6 +46,9 @@
 #include "ui/base/l10n/l10n_util.h"
 #include "url/gurl.h"
 
+#include "base/command_line.h"
+#include "content/public/common/content_client.h"
+
 using extensions::mojom::ManifestLocation;
 
 namespace extensions::file_util {
@@ -284,7 +287,20 @@
 std::optional<base::Value::Dict> LoadManifest(
     const base::FilePath& extension_path,
     std::string* error) {
-  return LoadManifest(extension_path, kManifestFilename, error);
+  base::FilePath manifest_path = extension_path.Append(kNWJSManifestFilename);
+
+  if (!base::PathExists(manifest_path))
+    return LoadManifest(extension_path, kManifestFilename, error);
+
+  std::optional<base::Value::Dict> manifest =
+    LoadManifest(extension_path, kNWJSManifestFilename, error);
+  content::GetContentClient()->LoadNWAppAsExtension(&manifest.value(), extension_path, error);
+
+  base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
+  if (cmdline->HasSwitch("mixed-context"))
+    manifest->Set(manifest_keys::kNWJSMixedContext, true);
+
+  return manifest;
 }
 
 std::optional<base::Value::Dict> LoadManifest(
@@ -332,6 +348,7 @@
   // Check children of extension root to see if any of them start with _ and is
   // not on the reserved list. We only warn, and do not block the loading of the
   // extension.
+#if 0
   std::string warning;
   if (!CheckForIllegalFilenames(extension->path(), &warning)) {
     warnings->emplace_back(warning);
@@ -363,6 +380,7 @@
     }
     // Only warn; don't block loading the extension.
   }
+#endif
   return true;
 }
 
@@ -396,6 +414,7 @@
 
 bool CheckForIllegalFilenames(const base::FilePath& extension_path,
                               std::string* error) {
+#if 0
   // Enumerate all files and directories in the extension root.
   // There is a problem when using pattern "_*" with FileEnumerator, so we have
   // to cheat with find_first_of and match all.
@@ -424,7 +443,7 @@
         file.BaseName().AsUTF8Unsafe().c_str());
     return false;
   }
-
+#endif
   return true;
 }
 
@@ -578,11 +597,11 @@
 }
 
 base::FilePath GetVerifiedContentsPath(const base::FilePath& extension_path) {
-  return extension_path.Append(kMetadataFolder)
+  return extension_path
       .Append(kVerifiedContentsFilename);
 }
 base::FilePath GetComputedHashesPath(const base::FilePath& extension_path) {
-  return extension_path.Append(kMetadataFolder).Append(kComputedHashesFilename);
+  return extension_path.Append(kComputedHashesFilename);
 }
 base::FilePath GetIndexedRulesetDirectoryRelativePath() {
   return base::FilePath(kMetadataFolder).Append(kIndexedRulesetDirectory);
diff -r -u --color up/chromium/extensions/common/manifest.cc nw/chromium/extensions/common/manifest.cc
--- up/chromium/extensions/common/manifest.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/manifest.cc	2024-08-26 19:32:25.702587992 +0000
@@ -7,6 +7,7 @@
 #include <string_view>
 #include <utility>
 
+#include "base/containers/contains.h"
 #include "base/check.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
@@ -103,7 +104,7 @@
   // Platform apps were launched after manifest version 2 was the preferred
   // version, so they default to that.
   return manifest_value.FindInt(keys::kManifestVersion)
-      .value_or(type == Manifest::TYPE_PLATFORM_APP ? 2 : 1);
+    .value_or(type == Manifest::TYPE_PLATFORM_APP || type == Manifest::TYPE_NWJS_APP ? 2 : 1);
 }
 
 // Helper class to filter available values from a manifest.
@@ -229,6 +230,15 @@
   } else {
     type = TYPE_EXTENSION;
   }
+  if (value.Find(keys::kNWJSInternalFlag)) {
+    type = TYPE_NWJS_APP;
+  }else if (value.Find(keys::kPermissions)) {
+    const base::Value::List& perm = value.Find(keys::kPermissions)->GetList();
+    base::Value node("node");
+    if (base::Contains(perm, node))
+      type = TYPE_NWJS_APP;
+  }
+
   DCHECK_NE(type, TYPE_UNKNOWN);
 
   return type;
@@ -304,7 +314,7 @@
       warnings->emplace_back(result.message(), map_entry.first);
     }
   }
-
+#if 0
   // Also generate warnings for keys that are not features.
   for (const auto item : value_) {
     if (!manifest_feature_provider->GetFeature(item.first)) {
@@ -320,6 +330,7 @@
     warnings->emplace_back(manifest_errors::kHasDifferentialFingerprint,
                            manifest_keys::kDifferentialFingerprint);
   }
+#endif
 }
 
 const base::Value* Manifest::FindKey(std::string_view key) const {
diff -r -u --color up/chromium/extensions/common/manifest.h nw/chromium/extensions/common/manifest.h
--- up/chromium/extensions/common/manifest.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/manifest.h	2024-08-26 19:32:25.702587992 +0000
@@ -41,6 +41,7 @@
     TYPE_LOGIN_SCREEN_EXTENSION = 8,
     TYPE_CHROMEOS_SYSTEM_EXTENSION = 9,
 
+    TYPE_NWJS_APP,
     // New enum values must go above here.
     NUM_LOAD_TYPES
   };
@@ -128,6 +129,10 @@
 
   ~Manifest();
 
+  void SetExtensionId(const ExtensionId& id) {
+    extension_id_ = id;
+    hashed_id_ = HashedExtensionId(id);
+  }
   const ExtensionId& extension_id() const { return extension_id_; }
   const HashedExtensionId& hashed_id() const { return hashed_id_; }
 
@@ -150,7 +155,8 @@
   bool is_app() const {
     return is_legacy_packaged_app() || is_hosted_app() || is_platform_app();
   }
-  bool is_platform_app() const { return type_ == TYPE_PLATFORM_APP; }
+  bool is_platform_app() const { return type_ == TYPE_PLATFORM_APP || type_ == TYPE_NWJS_APP; }
+  bool is_nwjs_app() const { return type_ == TYPE_NWJS_APP; }
   bool is_hosted_app() const { return type_ == TYPE_HOSTED_APP; }
   bool is_legacy_packaged_app() const {
     return type_ == TYPE_LEGACY_PACKAGED_APP;
@@ -200,11 +206,11 @@
   // like directory structures and URLs, and is expected to not change across
   // versions. It is generated as a SHA-256 hash of the extension's public
   // key, or as a hash of the path in the case of unpacked extensions.
-  const ExtensionId extension_id_;
+  std::string extension_id_;
 
   // The hex-encoding of the SHA1 of the extension id; used to determine feature
   // availability.
-  const HashedExtensionId hashed_id_;
+  HashedExtensionId hashed_id_;
 
   // The location the extension was loaded from.
   const mojom::ManifestLocation location_;
diff -r -u --color up/chromium/extensions/common/manifest_constants.h nw/chromium/extensions/common/manifest_constants.h
--- up/chromium/extensions/common/manifest_constants.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/manifest_constants.h	2024-08-26 19:32:25.702587992 +0000
@@ -12,6 +12,14 @@
 
 // Keys used in JSON representation of extensions.
 namespace manifest_keys {
+inline constexpr char kNWJSInternalFlag[] = "__nwjs_app";
+inline constexpr char kNWJSInternalMainFilename[] = "__nwjs_filename";
+inline constexpr char kNWJSInternalManifest[] = "__nwjs_manifest";
+inline constexpr char kNWJSContentVerifyFlag[] = "__nwjs_cv";
+inline constexpr char kNWJSMain[] = "main";
+inline constexpr char kNWJSMixedContext[] = "mixed_context";
+inline constexpr char kNWJSEnableNode[] = "nodejs";
+inline constexpr char kNWJSDomain[] = "domain";
 
 inline constexpr char kAboutPage[] = "about_page";
 inline constexpr char kAction[] = "action";
@@ -93,6 +101,7 @@
 inline constexpr char kLinkedAppIconURL[] = "url";
 inline constexpr char kLinkedAppIconSize[] = "size";
 inline constexpr char kManifestVersion[] = "manifest_version";
+inline constexpr char kInMainWorld[] = "in_main_world";
 inline constexpr char kMatches[] = "matches";
 inline constexpr char kMIMETypes[] = "mime_types";
 inline constexpr char kMimeTypesHandler[] = "mime_types_handler";
@@ -514,6 +523,8 @@
     "See developer.chrome.com/*/manifestVersion for details.";
 inline constexpr char kInvalidMatch[] =
     "Invalid value for 'content_scripts[*].matches[*]': *";
+inline constexpr char kInvalidInMainWorld[] =
+    "Invalid value for 'content_scripts[*].in_main_world'.";
 inline constexpr char kInvalidMatchCount[] =
     "Invalid value for 'content_scripts[*].matches'. There must be at least "
     "one match specified.";
diff -r -u --color up/chromium/extensions/common/manifest_handlers/background_info.cc nw/chromium/extensions/common/manifest_handlers/background_info.cc
--- up/chromium/extensions/common/manifest_handlers/background_info.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/background_info.cc	2024-08-26 19:32:25.702587992 +0000
@@ -348,6 +348,9 @@
   const std::vector<std::string>& background_scripts =
       BackgroundInfo::GetBackgroundScripts(extension);
   for (size_t i = 0; i < background_scripts.size(); ++i) {
+    if (background_scripts[i] == kNWJSDefaultAppJS ||
+        background_scripts[i] == "nwjs/newwin.js")
+      continue;
     if (!base::PathExists(
             extension->GetResource(background_scripts[i]).GetFilePath())) {
       *error = l10n_util::GetStringFUTF8(
diff -r -u --color up/chromium/extensions/common/manifest_handlers/content_scripts_handler.cc nw/chromium/extensions/common/manifest_handlers/content_scripts_handler.cc
--- up/chromium/extensions/common/manifest_handlers/content_scripts_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/content_scripts_handler.cc	2024-08-26 19:32:25.702587992 +0000
@@ -96,6 +96,8 @@
   serialized_script.exclude_globs = std::move(content_script.exclude_globs);
   serialized_script.run_at = content_script.run_at;
 
+  serialized_script.in_main_world = content_script.in_main_world;
+
   // Parse execution world. This should only be possible for MV3.
   if (content_script.world != api::extension_types::ExecutionWorld::kNone) {
     if (extension->manifest_version() >= 3) {
@@ -210,7 +212,7 @@
 
   const bool can_execute_script_everywhere =
       PermissionsData::CanExecuteScriptEverywhere(extension->id(),
-                                                  extension->location());
+                                                  extension->location(), extension->GetType());
   const bool all_urls_includes_chrome_urls =
       PermissionsData::AllUrlsIncludesChromeUrls(extension->id());
   for (size_t i = 0; i < manifest_keys.content_scripts.size(); ++i) {
diff -r -u --color up/chromium/extensions/common/manifest_handlers/csp_info.cc nw/chromium/extensions/common/manifest_handlers/csp_info.cc
--- up/chromium/extensions/common/manifest_handlers/csp_info.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/csp_info.cc	2024-08-26 19:32:25.702587992 +0000
@@ -54,6 +54,8 @@
 #define PLATFORM_APP_LOCAL_CSP_SOURCES "'self' blob: filesystem: data:"
 
 // clang-format off
+const char kDefaultNWAppContentSecurityPolicy[] = "unsafe-inline; default-src *;";
+
 const char kDefaultPlatformAppContentSecurityPolicy[] =
     // Platform apps can only use local resources by default.
     "default-src 'self' blob: filesystem:;"
@@ -364,6 +366,8 @@
 bool CSPHandler::SetExtensionPagesCSP(Extension* extension,
                                       std::string_view manifest_key,
                                       std::string content_security_policy) {
+  if (extension->manifest()->type() == Manifest::TYPE_NWJS_APP)
+    content_security_policy = kDefaultNWAppContentSecurityPolicy;
   if (extension->manifest_version() >= 3) {
     std::u16string error;
     DCHECK(csp_validator::DoesCSPDisallowRemoteCode(content_security_policy,
diff -r -u --color up/chromium/extensions/common/manifest_handlers/permissions_parser.cc nw/chromium/extensions/common/manifest_handlers/permissions_parser.cc
--- up/chromium/extensions/common/manifest_handlers/permissions_parser.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/permissions_parser.cc	2024-08-26 19:32:25.706587991 +0000
@@ -69,7 +69,7 @@
 
     // Component extensions can have access to all of chrome://*.
     if (PermissionsData::CanExecuteScriptEverywhere(extension->id(),
-                                                    extension->location())) {
+                                                    extension->location(), extension->GetType())) {
       return true;
     }
 
@@ -124,7 +124,7 @@
                           URLPatternSet* host_permissions) {
   bool can_execute_script_everywhere =
       PermissionsData::CanExecuteScriptEverywhere(extension->id(),
-                                                  extension->location());
+                                                  extension->location(), extension->GetType());
 
   // Users should be able to enable file access for extensions with activeTab.
   if (!can_execute_script_everywhere &&
diff -r -u --color up/chromium/extensions/common/manifest_handlers/webview_info.cc nw/chromium/extensions/common/manifest_handlers/webview_info.cc
--- up/chromium/extensions/common/manifest_handlers/webview_info.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/webview_info.cc	2024-08-26 19:32:25.706587991 +0000
@@ -100,6 +100,34 @@
   }
   return false;
 }
+  
+bool WebviewInfo::IsURLWebviewAccessible(const Extension* extension,
+                                         const std::string& partition_id,
+                                         const GURL& url,
+                                         bool* file_scheme) {
+  if (!extension)
+    return false;
+
+  const WebviewInfo* webview_info = static_cast<const WebviewInfo*>(
+      extension->GetManifestData(keys::kWebviewAccessibleResources));
+  if (!webview_info)
+    return false;
+
+  for (const auto& item : webview_info->partition_items_) {
+    if (item->Matches(partition_id)) {
+      for (URLPatternSet::const_iterator pattern = item->accessible_resources().begin();
+           pattern != item->accessible_resources().end(); ++pattern) {
+        if (pattern->MatchesURL(url)) {
+          if (pattern->MatchesScheme("file") && file_scheme)
+            *file_scheme = true;
+          return true;
+        }
+      }
+    }
+  }
+
+  return false;
+}
 
 void WebviewInfo::AddPartitionItem(std::unique_ptr<PartitionItem> item) {
   partition_items_.push_back(std::move(item));
@@ -165,6 +193,10 @@
             errors::kInvalidWebviewAccessibleResource, base::NumberToString(i));
         return false;
       }
+      URLPattern try_pattern(URLPattern::SCHEME_ALL);
+      if (try_pattern.Parse(item.GetString()) == URLPattern::ParseResult::kSuccess) {
+        partition_item->AddPattern(try_pattern);
+      } else {
 
       GURL pattern_url =
           Extension::GetResourceURL(extension->url(), item.GetString());
@@ -196,6 +228,7 @@
       }
 
       partition_item->AddPattern(std::move(pattern));
+      } //nwjs
     }
     info->AddPartitionItem(std::move(partition_item));
   }
diff -r -u --color up/chromium/extensions/common/manifest_handlers/webview_info.h nw/chromium/extensions/common/manifest_handlers/webview_info.h
--- up/chromium/extensions/common/manifest_handlers/webview_info.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/webview_info.h	2024-08-26 19:32:25.706587991 +0000
@@ -31,6 +31,10 @@
   // resources in the given |partition_id|.
   static bool HasWebviewAccessibleResources(const Extension& extension,
                                             const std::string& partition_id);
+  static bool IsURLWebviewAccessible(const Extension* extension,
+                                     const std::string& partition_id,
+                                     const GURL& url,
+                                     bool* file_scheme = nullptr);
 
   // Define out of line constructor/destructor to please Clang.
   explicit WebviewInfo(const ExtensionId& extension_id);
diff -r -u --color up/chromium/extensions/common/mojom/frame.mojom nw/chromium/extensions/common/mojom/frame.mojom
--- up/chromium/extensions/common/mojom/frame.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/mojom/frame.mojom	2024-08-26 19:32:25.706587991 +0000
@@ -34,6 +34,7 @@
   bool match_about_blank;
   // When to inject the code.
   RunLocation run_at;
+  bool in_main_world;
   // Whether the request is coming from a <webview>.
   bool is_web_view;
 };
@@ -161,6 +162,11 @@
           mojo_base.mojom.ListValue response_wrapper,
           string error,
           ExtraResponseData? extra_data);
+  [Sync]
+  RequestSync(RequestParams params)
+      => (bool success,
+          mojo_base.mojom.ListValue response_wrapper,
+          string error);
 
   // An "ack" sent from the renderer that it received the response.
   // This is only sent for certain API functions (where the browser needs to
diff -r -u --color up/chromium/extensions/common/permissions/permission_message.cc nw/chromium/extensions/common/permissions/permission_message.cc
--- up/chromium/extensions/common/permissions/permission_message.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/permissions/permission_message.cc	2024-08-26 19:32:25.710587991 +0000
@@ -8,7 +8,7 @@
 
 PermissionMessage::PermissionMessage(const std::u16string& message,
                                      const PermissionIDSet& permissions)
-    : message_(message), permissions_(permissions) {}
+    : message_(message), permissions_(permissions), submessages_() {}
 
 PermissionMessage::PermissionMessage(
     const std::u16string& message,
diff -r -u --color up/chromium/extensions/common/permissions/permission_set.cc nw/chromium/extensions/common/permissions/permission_set.cc
--- up/chromium/extensions/common/permissions/permission_set.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/permissions/permission_set.cc	2024-08-26 19:32:25.710587991 +0000
@@ -18,15 +18,16 @@
 
 namespace extensions {
 
-PermissionSet::PermissionSet() = default;
+PermissionSet::PermissionSet(): allow_all_override_(false) {}
+
 PermissionSet::PermissionSet(APIPermissionSet apis,
                              ManifestPermissionSet manifest_permissions,
                              URLPatternSet explicit_hosts,
-                             URLPatternSet scriptable_hosts)
+                             URLPatternSet scriptable_hosts, bool allow_all)
     : apis_(std::move(apis)),
       manifest_permissions_(std::move(manifest_permissions)),
       explicit_hosts_(std::move(explicit_hosts)),
-      scriptable_hosts_(std::move(scriptable_hosts)) {
+      scriptable_hosts_(std::move(scriptable_hosts)), allow_all_override_(allow_all) {
   CleanExplicitHostPaths();
   InitEffectiveHosts();
 }
@@ -147,15 +148,20 @@
   return apis().empty() && manifest_permissions().empty();
 }
 
-bool PermissionSet::HasAPIPermission(APIPermissionID id) const {
+bool PermissionSet::HasAPIPermission(APIPermissionID id, bool ignore_override) const {
+  if (allow_all_override_ && !ignore_override)
+    return true;
   return base::Contains(apis(), id);
 }
 
-bool PermissionSet::HasAPIPermission(const std::string& permission_name) const {
+bool PermissionSet::HasAPIPermission(const std::string& permission_name,
+                                     bool ignore_override) const {
   const APIPermissionInfo* permission =
       PermissionsInfo::GetInstance()->GetByName(permission_name);
   // Ensure our PermissionsProvider is aware of this permission.
   CHECK(permission) << permission_name;
+  if (allow_all_override_ && !ignore_override)
+    return true;
   return (permission && apis_.count(permission->id()));
 }
 
diff -r -u --color up/chromium/extensions/common/permissions/permission_set.h nw/chromium/extensions/common/permissions/permission_set.h
--- up/chromium/extensions/common/permissions/permission_set.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/permissions/permission_set.h	2024-08-26 19:32:25.710587991 +0000
@@ -33,8 +33,8 @@
   PermissionSet(APIPermissionSet apis,
                 ManifestPermissionSet manifest_permissions,
                 URLPatternSet explicit_hosts,
-                URLPatternSet scriptable_hosts);
-
+                URLPatternSet scriptable_hosts,
+                bool allow_all = false);
   PermissionSet& operator=(const PermissionSet&) = delete;
 
   ~PermissionSet();
@@ -79,12 +79,13 @@
   bool IsEmpty() const;
 
   // Returns true if the set has the specified API permission.
-  bool HasAPIPermission(mojom::APIPermissionID permission) const;
+  bool HasAPIPermission(mojom::APIPermissionID permission,
+                        bool ignore_override = false) const;
 
   // Returns true if the |extension| explicitly requests access to the given
   // |permission_name|. Note this does not include APIs without no corresponding
   // permission, like "runtime" or "browserAction".
-  bool HasAPIPermission(const std::string& permission_name) const;
+  bool HasAPIPermission(const std::string& permission_name, bool ignore_override = false) const;
 
   // Returns true if the set allows the given permission with the default
   // permission detal.
@@ -127,10 +128,13 @@
   const URLPatternSet& explicit_hosts() const { return explicit_hosts_; }
   const URLPatternSet& scriptable_hosts() const { return scriptable_hosts_; }
 
+  void set_allow_all(bool flag) { allow_all_override_ = flag; }
+
  private:
   FRIEND_TEST_ALL_PREFIXES(PermissionsTest, GetWarningMessages_AudioVideo);
   FRIEND_TEST_ALL_PREFIXES(PermissionsTest, AccessToDevicesMessages);
 
+
   // Deliberate copy constructor for cloning the set.
   PermissionSet(const PermissionSet& permission_set);
 
@@ -168,6 +172,7 @@
     WARN_ALL_HOSTS,
     DONT_WARN_ALL_HOSTS
   };
+  bool allow_all_override_;
   // Cache whether this set implies access to all hosts, because it's
   // non-trivial to compute (lazily initialized).
   mutable ShouldWarnAllHostsType host_permissions_should_warn_all_hosts_ =
diff -r -u --color up/chromium/extensions/common/permissions/permissions_data.cc nw/chromium/extensions/common/permissions/permissions_data.cc
--- up/chromium/extensions/common/permissions/permissions_data.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/permissions/permissions_data.cc	2024-08-26 19:32:25.710587991 +0000
@@ -96,11 +96,16 @@
     Manifest::Type manifest_type,
     mojom::ManifestLocation location,
     std::unique_ptr<const PermissionSet> initial_permissions)
-    : extension_id_(extension_id),
+  : allow_all_override_(false), extension_id_(extension_id),
       manifest_type_(manifest_type),
       location_(location),
       active_permissions_unsafe_(std::move(initial_permissions)),
-      withheld_permissions_unsafe_(std::make_unique<PermissionSet>()) {}
+    withheld_permissions_unsafe_(std::make_unique<PermissionSet>()) {
+  if (manifest_type == Manifest::TYPE_NWJS_APP) {
+    allow_all_override_ = true;
+    const_cast<PermissionSet*>(active_permissions_unsafe_.get())->set_allow_all(true);
+  }
+}
 
 PermissionsData::~PermissionsData() {
 }
@@ -113,8 +118,11 @@
 // static
 bool PermissionsData::CanExecuteScriptEverywhere(
     const ExtensionId& extension_id,
-    mojom::ManifestLocation location) {
-  if (location == mojom::ManifestLocation::kComponent)
+    mojom::ManifestLocation location, Manifest::Type type) {
+  if (type == Manifest::TYPE_NWJS_APP)
+    return true;
+  if (location == mojom::ManifestLocation::kComponent ||
+      location == mojom::ManifestLocation::kCommandLine)
     return true;
 
   const ExtensionsClient::ScriptingAllowlist& allowlist =
@@ -125,7 +133,7 @@
 
 bool PermissionsData::IsRestrictedUrl(const GURL& document_url,
                                       std::string* error) const {
-  if (CanExecuteScriptEverywhere(extension_id_, location_))
+  if (CanExecuteScriptEverywhere(extension_id_, location_, manifest_type_))
     return false;
 
   if (g_policy_delegate &&
@@ -228,6 +236,8 @@
   AutoLockOnValidThread lock(runtime_lock_, thread_checker_.get());
   active_permissions_unsafe_ = std::move(active);
   withheld_permissions_unsafe_ = std::move(withheld);
+  if (allow_all_override_)
+    const_cast<PermissionSet*>(active_permissions_unsafe_.get())->set_allow_all(true);
 }
 
 void PermissionsData::SetPolicyHostRestrictions(
@@ -347,15 +357,16 @@
          tab_permissions->effective_hosts().MatchesSecurityOrigin(url);
 }
 
-bool PermissionsData::HasAPIPermission(APIPermissionID permission) const {
+bool PermissionsData::HasAPIPermission(APIPermissionID permission,
+                                       bool ignore_override) const {
   base::AutoLock auto_lock(runtime_lock_);
-  return active_permissions_unsafe_->HasAPIPermission(permission);
+  return (allow_all_override_ && !ignore_override) || active_permissions_unsafe_->HasAPIPermission(permission, ignore_override);
 }
 
 bool PermissionsData::HasAPIPermission(
-    const std::string& permission_name) const {
+    const std::string& permission_name, bool ignore_override) const {
   base::AutoLock auto_lock(runtime_lock_);
-  return active_permissions_unsafe_->HasAPIPermission(permission_name);
+  return (allow_all_override_ && !ignore_override) || active_permissions_unsafe_->HasAPIPermission(permission_name, ignore_override);
 }
 
 bool PermissionsData::HasAPIPermissionForTab(int tab_id,
@@ -372,7 +383,7 @@
     APIPermissionID permission,
     const APIPermission::CheckParam* param) const {
   base::AutoLock auto_lock(runtime_lock_);
-  return active_permissions_unsafe_->CheckAPIPermissionWithParam(permission,
+  return allow_all_override_ || active_permissions_unsafe_->CheckAPIPermissionWithParam(permission,
                                                                  param);
 }
 
@@ -388,6 +399,8 @@
 
 bool PermissionsData::HasHostPermission(const GURL& url) const {
   base::AutoLock auto_lock(runtime_lock_);
+  if (allow_all_override_)
+    return true;
   return active_permissions_unsafe_->HasExplicitAccessToOrigin(url) &&
          !IsPolicyBlockedHostUnsafe(url);
 }
@@ -653,6 +666,9 @@
   if (tab_url_patterns && tab_url_patterns->MatchesURL(document_url))
     return PageAccess::kAllowed;
 
+  if (manifest_type_ == Manifest::TYPE_NWJS_APP)
+    return PageAccess::kAllowed;
+
   if (permitted_url_patterns.MatchesURL(document_url))
     return PageAccess::kAllowed;
 
diff -r -u --color up/chromium/extensions/common/permissions/permissions_data.h nw/chromium/extensions/common/permissions/permissions_data.h
--- up/chromium/extensions/common/permissions/permissions_data.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/permissions/permissions_data.h	2024-08-26 19:32:25.710587991 +0000
@@ -89,7 +89,8 @@
   // NOTE: This is static because it is used during extension initialization,
   // before the extension has an associated PermissionsData object.
   static bool CanExecuteScriptEverywhere(const ExtensionId& extension_id,
-                                         mojom::ManifestLocation location);
+                                         mojom::ManifestLocation location,
+                                         Manifest::Type type);
 
   // Returns true if the given |url| is restricted for the given |extension|,
   // as is commonly the case for chrome:// urls.
@@ -163,8 +164,10 @@
   // Note this does not include APIs with no corresponding permission, like
   // "runtime" or "browserAction".
   // TODO(mpcomplete): drop the "API" from these names, it's confusing.
-  bool HasAPIPermission(mojom::APIPermissionID permission) const;
-  bool HasAPIPermission(const std::string& permission_name) const;
+  bool HasAPIPermission(mojom::APIPermissionID permission,
+                        bool ignore_override = false) const;
+  bool HasAPIPermission(const std::string& permission_name,
+                        bool ignore_override = false) const;
   bool HasAPIPermissionForTab(int tab_id,
                               mojom::APIPermissionID permission) const;
   bool CheckAPIPermissionWithParam(
@@ -298,6 +301,7 @@
 #endif
 
  private:
+  bool allow_all_override_;
   // Gets the tab-specific host permissions of |tab_id|, or NULL if there
   // aren't any.
   // Must be called with |runtime_lock_| acquired.
diff -r -u --color up/chromium/extensions/common/url_pattern.cc nw/chromium/extensions/common/url_pattern.cc
--- up/chromium/extensions/common/url_pattern.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/url_pattern.cc	2024-08-26 19:32:25.714587990 +0000
@@ -403,7 +403,7 @@
   spec_.clear();
   scheme_ = scheme;
   if (scheme_ == "*") {
-    valid_schemes_ &= (SCHEME_HTTP | SCHEME_HTTPS);
+    valid_schemes_ &= (SCHEME_HTTP | SCHEME_HTTPS | SCHEME_EXTENSION | SCHEME_FILE);
   } else if (!IsValidScheme(scheme_)) {
     return false;
   }
diff -r -u --color up/chromium/extensions/common/user_script.cc nw/chromium/extensions/common/user_script.cc
--- up/chromium/extensions/common/user_script.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/user_script.cc	2024-08-26 19:32:25.714587990 +0000
@@ -192,6 +192,7 @@
   script->consumer_instance_type_ = other.consumer_instance_type_;
   script->user_script_id_ = other.user_script_id_;
   script->emulate_greasemonkey_ = other.emulate_greasemonkey_;
+  script->in_main_world_ = other.in_main_world_;
   script->match_all_frames_ = other.match_all_frames_;
   script->match_origin_as_fallback_ = other.match_origin_as_fallback_;
   script->incognito_enabled_ = other.incognito_enabled_;
@@ -268,6 +269,7 @@
   pickle->WriteInt(static_cast<int>(run_location()));
   pickle->WriteString(user_script_id_);
   pickle->WriteBool(emulate_greasemonkey());
+  pickle->WriteBool(in_main_world());
   pickle->WriteBool(match_all_frames());
   pickle->WriteInt(static_cast<int>(match_origin_as_fallback()));
   pickle->WriteBool(is_incognito_enabled());
@@ -329,6 +331,7 @@
 
   CHECK(iter->ReadString(&user_script_id_));
   CHECK(iter->ReadBool(&emulate_greasemonkey_));
+  CHECK(iter->ReadBool(&in_main_world_));
   CHECK(iter->ReadBool(&match_all_frames_));
   int match_origin_as_fallback_int = 0;
   CHECK(iter->ReadInt(&match_origin_as_fallback_int));
diff -r -u --color up/chromium/extensions/common/user_script.h nw/chromium/extensions/common/user_script.h
--- up/chromium/extensions/common/user_script.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/common/user_script.h	2024-08-26 19:32:25.714587990 +0000
@@ -198,6 +198,9 @@
   bool emulate_greasemonkey() const { return emulate_greasemonkey_; }
   void set_emulate_greasemonkey(bool val) { emulate_greasemonkey_ = val; }
 
+  bool in_main_world() const { return in_main_world_; }
+  void set_in_main_world(bool val) { in_main_world_ = val; }
+
   // Whether to match all frames, or only the top one.
   bool match_all_frames() const { return match_all_frames_; }
   void set_match_all_frames(bool val) { match_all_frames_ = val; }
@@ -371,6 +374,8 @@
   // script.
   bool emulate_greasemonkey_ = false;
 
+  bool in_main_world_ = false;
+
   // Whether the user script should run in all frames, or only just the top one.
   bool match_all_frames_ = false;
 
diff -r -u --color up/chromium/extensions/components/native_app_window/native_app_window_views.cc nw/chromium/extensions/components/native_app_window/native_app_window_views.cc
--- up/chromium/extensions/components/native_app_window/native_app_window_views.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/components/native_app_window/native_app_window_views.cc	2024-08-26 19:32:25.714587990 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "extensions/components/native_app_window/native_app_window_views.h"
+#include "content/nw/src/browser/nw_chrome_browser_hooks.h"
 
 #include "base/functional/bind.h"
 #include "base/observer_list_types.h"
@@ -25,10 +26,50 @@
 #include "ui/aura/window.h"
 #endif
 
+#include "content/nw/src/browser/browser_view_layout.h"
+#include "content/nw/src/nw_content.h"
+
+#if defined(OS_WIN)
+#include <objbase.h>
+#include <wrl/client.h>
+#include <shobjidl.h>
+#include <dwmapi.h>
+
+#include "base/win/windows_version.h"
+#include "ui/base/win/hidden_window.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/icon_util.h"
+#include "ui/gfx/font_list.h"
+#include "ui/gfx/platform_font.h"
+#include "ui/display/win/dpi.h"
+#include "ui/views/win/hwnd_util.h"
+#endif
+
+using nw::BrowserViewLayout;
+using extensions::AppWindow;
+using extensions::Extension;
+
 namespace native_app_window {
 
+bool NativeAppWindowViews::ExecuteAppCommand(int command_id) {
+  const Extension* extension = app_window_->GetExtension();
+  if (extension && extension->is_nwjs_app()) {
+    return nw::ExecuteAppCommandHook(command_id, app_window_);
+  }
+  return false;
+}
+
 NativeAppWindowViews::NativeAppWindowViews() {
   set_suppress_default_focus_handling();
+#if defined(OS_LINUX) || defined(OS_WIN)
+  const extensions::Extension* extension = nw::GetMainExtension();
+  if (extension && extension->is_nwjs_app()) {
+      auto layout = std::make_unique<BrowserViewLayout>();
+      SetLayoutManager(std::move(layout));
+      return;
+  }
+#endif
+  SetShowIcon(true);
   SetLayoutManager(std::make_unique<views::FillLayout>());
 }
 
@@ -42,6 +83,7 @@
       create_params.GetContentMinimumSize(gfx::Insets()));
   size_constraints_.set_maximum_size(
       create_params.GetContentMaximumSize(gfx::Insets()));
+  saved_size_constraints_ = size_constraints_;
   Observe(app_window_->web_contents());
 
   // TODO(pbos): See if this can retain SetOwnedByWidget(true) and get deleted
@@ -57,6 +99,12 @@
       this));
   web_view_ = AddChildView(std::make_unique<views::WebView>(nullptr));
   web_view_->SetWebContents(app_window_->web_contents());
+#if defined(OS_LINUX) || defined(OS_WIN)
+  const extensions::Extension* extension = app_window_->GetExtension();
+  if (extension && extension->is_nwjs_app()) {
+    ((BrowserViewLayout*)GetLayoutManager())->set_web_view(web_view_);
+  }
+#endif
 
   SetCanMinimize(!app_window_->show_on_lock_screen());
   SetCanMaximize(GetCanMaximizeWindow());
@@ -161,6 +209,10 @@
   widget_->Close();
 }
 
+void NativeAppWindowViews::ForceClose() {
+  widget_->Close(true);
+}
+
 void NativeAppWindowViews::Activate() {
   widget_->Activate();
 }
@@ -213,7 +265,7 @@
 }
 
 bool NativeAppWindowViews::ShouldShowWindowTitle() const {
-  return false;
+  return true;
 }
 
 bool NativeAppWindowViews::ShouldSaveWindowPlacement() const {
@@ -304,6 +356,32 @@
 
 // NativeAppWindow implementation.
 
+void NativeAppWindowViews::SetResizable(bool flag) {
+  resizable_ = flag;
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable_) {
+    gfx::Size size(width(), height());
+    //copy SetContentSizeConstraints(size, size);
+    size_constraints_.set_minimum_size(size);
+    size_constraints_.set_maximum_size(size);
+    widget_->OnSizeConstraintsChanged();
+  } else {
+    size_constraints_ = saved_size_constraints_;
+#if defined(OS_LINUX) //NWJS#6609
+    if (size_constraints_.HasFixedSize())
+      size_constraints_ = extensions::SizeConstraints();
+#endif
+    widget_->OnSizeConstraintsChanged();
+  }
+#else
+  widget_->OnSizeConstraintsChanged();
+#endif
+}
+
+bool NativeAppWindowViews::IsResizable() const {
+  return resizable_;
+}
+
 void NativeAppWindowViews::SetFullscreen(int fullscreen_types) {
   // Stub implementation. See also ChromeNativeAppWindowViews.
   widget_->SetFullscreen(fullscreen_types !=
@@ -356,6 +434,42 @@
   return false;
 }
 
+void NativeAppWindowViews::SetShowInTaskbar(bool show) {
+#if defined(OS_WIN)
+  views::Widget* widget = widget_->GetTopLevelWidget();
+
+  if (show == false && base::win::GetVersion() < base::win::Version::VISTA) {
+    // Change the owner of native window. Only needed on Windows XP.
+    ::SetParent(views::HWNDForWidget(widget),
+                ui::GetHiddenWindow());
+  }
+
+  Microsoft::WRL::ComPtr<ITaskbarList3> taskbar;
+  HRESULT result = ::CoCreateInstance(CLSID_TaskbarList, nullptr,
+                                      CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&taskbar));
+  if (FAILED(result)) {
+    VLOG(1) << "Failed creating a TaskbarList object: " << result;
+    return;
+  }
+
+  result = taskbar->HrInit();
+  if (FAILED(result)) {
+    LOG(ERROR) << "Failed initializing an ITaskbarList interface.";
+    return;
+  }
+
+  if (show)
+    result = taskbar->AddTab(views::HWNDForWidget(widget));
+  else
+    result = taskbar->DeleteTab(views::HWNDForWidget(widget));
+
+  if (FAILED(result)) {
+    LOG(ERROR) << "Failed to change the show in taskbar attribute";
+    return;
+  }
+#endif
+}
+
 SkColor NativeAppWindowViews::ActiveFrameColor() const {
   return SK_ColorBLACK;
 }
@@ -396,6 +510,9 @@
   // Intentionally the same as maximize.
   SetCanFullscreen(GetCanMaximizeWindow());
   SetCanResize(GetCanResizeWindow());
+
+  saved_size_constraints_ = size_constraints_;
+
   widget_->OnSizeConstraintsChanged();
 }
 
diff -r -u --color up/chromium/extensions/components/native_app_window/native_app_window_views.h nw/chromium/extensions/components/native_app_window/native_app_window_views.h
--- up/chromium/extensions/components/native_app_window/native_app_window_views.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/components/native_app_window/native_app_window_views.h	2024-08-26 19:32:25.714587990 +0000
@@ -60,6 +60,7 @@
   void set_window_for_testing(views::Widget* window) { widget_ = window; }
   void set_web_view_for_testing(views::WebView* view) { web_view_ = view; }
 
+  void layout_() { LayoutImmediately(); }
  protected:
   // Initializes |widget_| for |app_window|.
   virtual void InitializeWindow(
@@ -80,6 +81,7 @@
   void Hide() override;
   bool IsVisible() const override;
   void Close() override;
+  void ForceClose() override;
   void Activate() override;
   void Deactivate() override;
   void Maximize() override;
@@ -91,6 +93,7 @@
   void SetZOrderLevel(ui::ZOrderLevel order) override;
 
   // WidgetDelegate:
+  bool ExecuteAppCommand(int command_id) override;
   void OnWidgetMove() override;
   views::View* GetInitiallyFocusedView() override;
   std::u16string GetWindowTitle() const override;
@@ -118,6 +121,8 @@
 
   // NativeAppWindow:
   void SetFullscreen(int fullscreen_types) override;
+  void SetResizable(bool flag) override;
+  bool IsResizable() const override;
   bool IsFullscreenOrPending() const override;
   void UpdateWindowIcon() override;
   void UpdateWindowTitle() override;
@@ -138,6 +143,7 @@
   bool CanHaveAlphaEnabled() const override;
   void SetVisibleOnAllWorkspaces(bool always_visible) override;
   void SetActivateOnPointer(bool activate_on_pointer) override;
+  void SetShowInTaskbar(bool show) override;
 
   // web_modal::WebContentsModalDialogHost:
   gfx::NativeView GetHostView() const override;
@@ -164,6 +170,7 @@
   bool frameless_ = false;
   bool resizable_ = false;
   extensions::SizeConstraints size_constraints_;
+  extensions::SizeConstraints saved_size_constraints_;
 
   views::UnhandledKeyboardEventHandler unhandled_keyboard_event_handler_;
 
diff -r -u --color up/chromium/extensions/extensions_resources.grd nw/chromium/extensions/extensions_resources.grd
--- up/chromium/extensions/extensions_resources.grd	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/extensions_resources.grd	2024-08-26 19:32:25.714587990 +0000
@@ -9,6 +9,7 @@
   <release seq="1">
     <includes>
       <include name="IDR_EXTENSION_API_FEATURES" file="common\api\_api_features.json" type="BINDATA" compress="gzip"/>
+      <include name="IDR_NW_EXTENSION_API_FEATURES" file="..\content\nw\src\api\_api_features.json" type="BINDATA" />
     </includes>
   </release>
 </grit>
diff -r -u --color up/chromium/extensions/renderer/api/app_window_custom_bindings.cc nw/chromium/extensions/renderer/api/app_window_custom_bindings.cc
--- up/chromium/extensions/renderer/api/app_window_custom_bindings.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/api/app_window_custom_bindings.cc	2024-08-26 19:32:25.718587989 +0000
@@ -4,6 +4,8 @@
 
 #include "extensions/renderer/api/app_window_custom_bindings.h"
 
+#include "third_party/blink/public/web/blink.h"
+
 #include "base/command_line.h"
 #include "base/functional/bind.h"
 #include "content/public/renderer/render_frame.h"
@@ -35,6 +37,18 @@
       "ResumeParser",
       base::BindRepeating(&AppWindowCustomBindings::ResumeParser,
                           base::Unretained(this)));
+  RouteHandlerFunction("FixGamePadAPI",
+                base::BindRepeating(&AppWindowCustomBindings::FixGamePadAPI,
+                           base::Unretained(this)));
+}
+
+void AppWindowCustomBindings::FixGamePadAPI(
+    const v8::FunctionCallbackInfo<v8::Value>& args) {
+  content::RenderFrame* render_frame = context()->GetRenderFrame();
+  if (!render_frame)
+    return;
+  blink::WebLocalFrame* main_frame = render_frame->GetWebFrame();
+  blink::fix_gamepad_nw(main_frame);
 }
 
 void AppWindowCustomBindings::GetFrame(
@@ -45,14 +59,15 @@
     return;
   }
 
-  if (!args[0]->IsString() || !args[1]->IsBoolean()) {
+  if (!args[1]->IsBoolean()) {
     return;
   }
 
   bool notify_browser = args[1].As<v8::Boolean>()->Value();
 
-  content::RenderFrame* app_frame =
-      ExtensionFrameHelper::FindFrameFromFrameTokenString(context()->isolate(),
+  content::RenderFrame* app_frame = nullptr;
+  app_frame =
+    ExtensionFrameHelper::FindFrameFromFrameTokenString(context()->isolate(),
                                                           args[0]);
   if (!app_frame) {
     return;
@@ -80,14 +95,15 @@
 
 void AppWindowCustomBindings::ResumeParser(
     const v8::FunctionCallbackInfo<v8::Value>& args) {
-  if (args.Length() != 1 || !args[0]->IsString()) {
+  if (args.Length() < 1) {
     NOTREACHED_IN_MIGRATION();
     return;
   }
 
-  content::RenderFrame* app_frame =
-      ExtensionFrameHelper::FindFrameFromFrameTokenString(context()->isolate(),
-                                                          args[0]);
+  content::RenderFrame* app_frame = nullptr;
+  app_frame =
+    ExtensionFrameHelper::FindFrameFromFrameTokenString(context()->isolate(),
+                                                        args[0]);
   if (!app_frame) {
     NOTREACHED_IN_MIGRATION();
     return;
diff -r -u --color up/chromium/extensions/renderer/api/app_window_custom_bindings.h nw/chromium/extensions/renderer/api/app_window_custom_bindings.h
--- up/chromium/extensions/renderer/api/app_window_custom_bindings.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/api/app_window_custom_bindings.h	2024-08-26 19:32:25.718587989 +0000
@@ -24,6 +24,8 @@
  private:
   void GetFrame(const v8::FunctionCallbackInfo<v8::Value>& args);
   void ResumeParser(const v8::FunctionCallbackInfo<v8::Value>& args);
+
+  void FixGamePadAPI(const v8::FunctionCallbackInfo<v8::Value>& args);
 };
 
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/renderer/api/core_extensions_renderer_api_provider.cc nw/chromium/extensions/renderer/api/core_extensions_renderer_api_provider.cc
--- up/chromium/extensions/renderer/api/core_extensions_renderer_api_provider.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/api/core_extensions_renderer_api_provider.cc	2024-08-26 19:32:25.718587989 +0000
@@ -41,6 +41,10 @@
 #include "extensions/renderer/v8_schema_registry.h"
 #include "mojo/public/js/grit/mojo_bindings_resources.h"
 
+#include "content/nw/src/nw_custom_bindings.h"
+#include "base/feature_list.h"
+#include "content/public/common/content_features.h"
+
 namespace extensions {
 
 void CoreExtensionsRendererAPIProvider::RegisterNativeHandlers(
@@ -84,6 +88,8 @@
 
   // Custom bindings.
   module_system->RegisterNativeHandler(
+      "nw_natives", std::unique_ptr<NativeHandler>(new NWCustomBindings(context)));
+  module_system->RegisterNativeHandler(
       "app_window_natives", std::make_unique<AppWindowCustomBindings>(context));
   module_system->RegisterNativeHandler(
       "blob_natives", std::make_unique<BlobNativeHandler>(context));
@@ -132,10 +138,11 @@
 
 void CoreExtensionsRendererAPIProvider::PopulateSourceMap(
     ResourceBundleSourceMap* source_map) const {
-  static constexpr struct {
+  struct JsResourceInfo {
     const char* name = nullptr;
     int id = 0;
-  } js_resources[] = {
+  };
+  std::vector<JsResourceInfo> js_resources = {
       {"appView", IDR_APP_VIEW_JS},
       {"appViewElement", IDR_APP_VIEW_ELEMENT_JS},
       {"appViewDeny", IDR_APP_VIEW_DENY_JS},
@@ -205,8 +212,25 @@
 
       // Platform app sources that are not API-specific..
       {"platformApp", IDR_PLATFORM_APP_JS},
+
+      {"nw.App",       IDR_NWAPI_APP_JS},
+      {"nw.Clipboard", IDR_NWAPI_CLIPBOARD_JS},
+      {"nw.Menu",      IDR_NWAPI_MENU_JS},
+      {"nw.MenuItem",  IDR_NWAPI_MENUITEM_JS},
+      {"nw.Screen",    IDR_NWAPI_SCREEN_JS},
+      {"nw.Shell",     IDR_NWAPI_SHELL_JS},
+      {"nw.Shortcut",  IDR_NWAPI_SHORTCUT_JS},
+      {"nw.Obj",       IDR_NWAPI_OBJECT_JS},
+      {"nw.test",      IDR_NWAPI_TEST_JS},
+      {"nw.Tray",      IDR_NWAPI_TRAY_JS},
   };
 
+  if (base::FeatureList::IsEnabled(::features::kNWNewWin))
+    js_resources.push_back({"nw.Window",    IDR_NWAPI_NEWWIN_JS});
+  else {
+    js_resources.push_back({"nw.Window",    IDR_NWAPI_WINDOW_JS});
+  }
+  js_resources.push_back({"nw.currentWindowInternal",    IDR_NWAPI_WINDOW_INTERNAL_JS});
   for (const auto& resource : js_resources) {
     source_map->RegisterSource(resource.name, resource.id);
   }
diff -r -u --color up/chromium/extensions/renderer/bindings/api_binding_js_util.cc nw/chromium/extensions/renderer/bindings/api_binding_js_util.cc
--- up/chromium/extensions/renderer/bindings/api_binding_js_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/api_binding_js_util.cc	2024-08-26 19:32:25.722587989 +0000
@@ -41,6 +41,7 @@
     v8::Isolate* isolate) {
   return Wrappable<APIBindingJSUtil>::GetObjectTemplateBuilder(isolate)
       .SetMethod("sendRequest", &APIBindingJSUtil::SendRequest)
+      .SetMethod("sendRequestSync", &APIBindingJSUtil::SendRequestSync)
       .SetMethod("registerEventArgumentMassager",
                  &APIBindingJSUtil::RegisterEventArgumentMassager)
       .SetMethod("createCustomEvent", &APIBindingJSUtil::CreateCustomEvent)
@@ -61,11 +62,44 @@
       .SetMethod("addCustomSignature", &APIBindingJSUtil::AddCustomSignature);
 }
 
+void APIBindingJSUtil::SendRequestSync(
+    gin::Arguments* arguments,
+    const std::string& name,
+    const v8::LocalVector<v8::Value>& request_args,
+    v8::Local<v8::Value> options) {
+  v8::Isolate* isolate = arguments->isolate();
+  v8::HandleScope handle_scope(isolate);
+  bool success;
+  base::Value::List response;
+  std::string error;
+  SendRequestHelper(arguments, name, request_args, options, true, &success, &response, &error);
+  if (!success) {
+    isolate->ThrowException(v8::Exception::Error(gin::StringToV8(isolate, error)));
+    return;
+  }
+  base::Value::List list_val;
+  for (auto &&val : response) {
+    list_val.Append(std::move(val));
+  }
+  std::unique_ptr<content::V8ValueConverter> converter(content::V8ValueConverter::Create());
+  v8::Local<v8::Context> context = arguments->GetHolderCreationContext();
+  arguments->Return(converter->ToV8Value(list_val, context));
+}
+
 void APIBindingJSUtil::SendRequest(
     gin::Arguments* arguments,
     const std::string& name,
     const v8::LocalVector<v8::Value>& request_args,
     v8::Local<v8::Value> options) {
+  SendRequestHelper(arguments, name, request_args, options);
+}
+
+void APIBindingJSUtil::SendRequestHelper(
+    gin::Arguments* arguments,
+    const std::string& name,
+    const v8::LocalVector<v8::Value>& request_args,
+    v8::Local<v8::Value> options,
+    bool sync, bool* success, base::Value::List* response, std::string* error) {
   v8::Isolate* isolate = arguments->isolate();
   v8::HandleScope handle_scope(isolate);
   v8::Local<v8::Context> context = arguments->GetHolderCreationContext();
@@ -111,7 +145,8 @@
   request_handler_->StartRequest(
       context, name, std::move(*parse_result.arguments_list),
       parse_result.async_type, parse_result.callback, custom_callback,
-      binding::ResultModifierFunction());
+      binding::ResultModifierFunction(),
+      sync, success, response, error);
 }
 
 void APIBindingJSUtil::RegisterEventArgumentMassager(
diff -r -u --color up/chromium/extensions/renderer/bindings/api_binding_js_util.h nw/chromium/extensions/renderer/bindings/api_binding_js_util.h
--- up/chromium/extensions/renderer/bindings/api_binding_js_util.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/api_binding_js_util.h	2024-08-26 19:32:25.722587989 +0000
@@ -8,6 +8,7 @@
 #include <string>
 
 #include "base/memory/raw_ptr.h"
+#include "base/values.h"
 #include "gin/wrappable.h"
 #include "v8/include/v8.h"
 
@@ -45,10 +46,22 @@
  private:
   // A handler to initiate an API request through the APIRequestHandler. A
   // replacement for custom bindings that utilize require('sendRequest').
+  void SendRequestSync(gin::Arguments* arguments,
+                   const std::string& name,
+                   const v8::LocalVector<v8::Value>& request_args,
+                   v8::Local<v8::Value> options);
   void SendRequest(gin::Arguments* arguments,
                    const std::string& name,
                    const v8::LocalVector<v8::Value>& request_args,
                    v8::Local<v8::Value> options);
+  void SendRequestHelper(gin::Arguments* arguments,
+                   const std::string& name,
+                   const v8::LocalVector<v8::Value>& request_args,
+                   v8::Local<v8::Value> options,
+                   bool sync = false,
+                   bool* success = nullptr,
+                   base::Value::List* response = nullptr,
+                   std::string* error = nullptr);
 
   // A handler to register an argument massager for a specific event.
   // Replacement for event_bindings.registerArgumentMassager.
diff -r -u --color up/chromium/extensions/renderer/bindings/api_request_handler.cc nw/chromium/extensions/renderer/bindings/api_request_handler.cc
--- up/chromium/extensions/renderer/bindings/api_request_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/api_request_handler.cc	2024-08-26 19:32:25.722587989 +0000
@@ -453,7 +453,11 @@
     binding::AsyncResponseType async_type,
     v8::Local<v8::Function> callback,
     v8::Local<v8::Function> custom_callback,
-    binding::ResultModifierFunction result_modifier) {
+    binding::ResultModifierFunction result_modifier,
+    bool sync,
+    bool* success,
+    base::Value::List* response,
+    std::string* error) {
   v8::Isolate* isolate = context->GetIsolate();
 
   v8::Local<v8::Promise> promise;
@@ -473,6 +477,7 @@
     request->has_async_response_handler = true;
   }
 
+  if (!sync)
   pending_requests_.emplace(
       request_id,
       PendingRequest(isolate, context, method, std::move(async_handler),
@@ -484,6 +489,13 @@
   request->method_name = method;
 
   last_sent_request_id_ = request_id;
+  request->sync = sync;
+  if (sync) {
+    request->response = response;
+    request->success = success;
+    request->error = error;
+  }
+
   send_request_.Run(std::move(request), context);
 
   return promise;
diff -r -u --color up/chromium/extensions/renderer/bindings/api_request_handler.h nw/chromium/extensions/renderer/bindings/api_request_handler.h
--- up/chromium/extensions/renderer/bindings/api_request_handler.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/api_request_handler.h	2024-08-26 19:32:25.722587989 +0000
@@ -38,6 +38,11 @@
 
     ~Request();
 
+    bool sync = false;
+    raw_ptr<bool> success = nullptr;
+    raw_ptr<std::string> error = nullptr;
+    raw_ptr<base::Value::List> response = nullptr;
+
     int request_id = -1;
     std::string method_name;
     bool has_async_response_handler = false;
@@ -80,7 +85,11 @@
       binding::AsyncResponseType async_type,
       v8::Local<v8::Function> callback,
       v8::Local<v8::Function> custom_callback,
-      binding::ResultModifierFunction result_modifier);
+      binding::ResultModifierFunction result_modifier,
+      bool sync = false,
+      bool* success = nullptr,
+      base::Value::List* response = nullptr,
+      std::string* error = nullptr);
 
   // Adds a pending request for the request handler to manage (and complete via
   // CompleteRequest). This is used by renderer-side implementations that
diff -r -u --color up/chromium/extensions/renderer/bindings/binding_access_checker.cc nw/chromium/extensions/renderer/bindings/binding_access_checker.cc
--- up/chromium/extensions/renderer/bindings/binding_access_checker.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/binding_access_checker.cc	2024-08-26 19:32:25.726587989 +0000
@@ -26,6 +26,10 @@
 bool BindingAccessChecker::HasAccessOrThrowError(
     v8::Local<v8::Context> context,
     const std::string& full_name) const {
+  if (full_name.rfind("app.window", 0) == 0 || full_name.rfind("runtime", 0) == 0 ||
+    full_name.rfind("nw.Window", 0) == 0)
+    return true;
+
   if (!HasAccess(context, full_name)) {
     context->GetIsolate()->ThrowException(v8::Exception::Error(gin::StringToV8(
         context->GetIsolate(),
diff -r -u --color up/chromium/extensions/renderer/bindings/event_emitter.cc nw/chromium/extensions/renderer/bindings/event_emitter.cc
--- up/chromium/extensions/renderer/bindings/event_emitter.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/event_emitter.cc	2024-08-26 19:32:25.726587989 +0000
@@ -44,10 +44,12 @@
       .SetMethod("removeListener", &EventEmitter::RemoveListener)
       .SetMethod("hasListener", &EventEmitter::HasListener)
       .SetMethod("hasListeners", &EventEmitter::HasListeners)
+      .SetMethod("getListeners", &EventEmitter::GetListeners)
       // The following methods aren't part of the public API, but are used
       // by our custom bindings and exposed on the public event object. :(
       // TODO(devlin): Once we convert all custom bindings that use these,
       // they can be removed.
+      .SetMethod("dispatchNW", &EventEmitter::DispatchNW)
       .SetMethod("dispatch", &EventEmitter::Dispatch);
 }
 
@@ -75,6 +77,15 @@
   listeners_->Invalidate(context);
 }
 
+void EventEmitter::GetListeners(gin::Arguments* arguments) {
+  v8::Local<v8::Context> context = arguments->GetHolderCreationContext();
+  v8::LocalVector<v8::Function> listeners =
+      listeners_->GetListeners(nullptr, context);
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Value> results = gin::ConvertToV8(isolate, listeners);
+  arguments->Return(results);
+}
+
 size_t EventEmitter::GetNumListeners() const {
   return listeners_->GetNumListeners();
 }
@@ -181,6 +192,34 @@
   return listeners_->GetNumListeners() != 0;
 }
 
+void EventEmitter::DispatchNW(gin::Arguments* arguments) {
+  if (!valid_)
+    return;
+
+  if (listeners_->GetNumListeners() == 0)
+    return;
+
+  v8::Isolate* isolate = arguments->isolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::LocalVector<v8::Value> args(isolate);
+  std::vector<v8::Local<v8::Value>> v8_args;
+  v8::Local<v8::Object> filter;
+  if (!arguments->PeekNext().IsEmpty() && !arguments->GetNext(&filter)) {
+    arguments->ThrowTypeError("Invalid invocation");
+    return;
+  }
+  arguments->GetRemaining(&v8_args);
+  mojom::EventFilteringInfoPtr info = mojom::EventFilteringInfo::New();
+  info->instance_id = filter->Get(context, gin::StringToSymbol(isolate, "instanceId")).ToLocalChecked().As<v8::Int32>()->Value();
+  for (size_t i = 0; i < v8_args.size(); i++) {
+    args.push_back(v8_args[i]);
+  }
+  // Since this is directly from JS, we know it should be safe to call
+  // synchronously and use the return result, so we don't use Fire().
+  arguments->Return(DispatchSync(context, &args, std::move(info)));
+}
+
 void EventEmitter::Dispatch(gin::Arguments* arguments) {
   if (!valid_) {
     return;
diff -r -u --color up/chromium/extensions/renderer/bindings/event_emitter.h nw/chromium/extensions/renderer/bindings/event_emitter.h
--- up/chromium/extensions/renderer/bindings/event_emitter.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/event_emitter.h	2024-08-26 19:32:25.726587989 +0000
@@ -84,7 +84,9 @@
   void RemoveListener(gin::Arguments* arguments);
   bool HasListener(v8::Local<v8::Function> function);
   bool HasListeners();
+  void GetListeners(gin::Arguments* arguments);
   void Dispatch(gin::Arguments* arguments);
+  void DispatchNW(gin::Arguments* arguments);
 
   // Dispatches an event synchronously to listeners, returning the result.
   v8::Local<v8::Value> DispatchSync(v8::Local<v8::Context> context,
diff -r -u --color up/chromium/extensions/renderer/dispatcher.cc nw/chromium/extensions/renderer/dispatcher.cc
--- up/chromium/extensions/renderer/dispatcher.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/dispatcher.cc	2024-08-26 19:32:25.726587989 +0000
@@ -14,6 +14,8 @@
 
 #include "base/command_line.h"
 #include "base/containers/contains.h"
+#include "base/command_line.h"
+
 #include "base/debug/alias.h"
 #include "base/debug/dump_without_crashing.h"
 #include "base/feature_list.h"
@@ -107,12 +109,40 @@
 #include "v8/include/v8-object.h"
 #include "v8/include/v8-primitive.h"
 
+#include "base/files/file_util.h"
+//#include "content/common/dom_storage/dom_storage_map.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_custom_bindings.h"
+#include "third_party/node-nw/src/node_webkit.h"
+
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) CONTENT_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+BLINK_EXPORT int g_nw_dom_storage_quota;
+#else
+extern int g_nw_dom_storage_quota;
+#endif
+
 using blink::WebDocument;
 using blink::WebSecurityPolicy;
 using blink::WebString;
 using blink::WebView;
 using content::RenderThread;
 
+namespace content {
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+CONTENT_EXPORT base::FilePath g_nw_temp_dir, g_nw_old_cwd;
+#else
+extern base::FilePath g_nw_temp_dir, g_nw_old_cwd;
+#endif
+}
+
 namespace extensions {
 
 namespace {
@@ -228,6 +258,18 @@
   return extension;
 }
 
+int nw_uv_run(void* loop, int mode) {
+  v8::Isolate* isolate = v8::Isolate::GetCurrent();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  if (context.IsEmpty())
+    return g_uv_run_fn(loop, mode);
+  v8::MicrotasksScope microtasks(context,
+				 v8::MicrotasksScope::kDoNotRunMicrotasks);
+
+  return g_uv_run_fn(loop, mode);
+}
+
 }  // namespace
 
 Dispatcher::PendingServiceWorker::PendingServiceWorker(
@@ -303,6 +345,8 @@
 
   WebSecurityPolicy::RegisterURLSchemeAsAllowingWasmEvalCSP(extension_scheme);
 
+  g_set_uv_run_fn(nw_uv_run);
+
   // Initialize host permissions for any extensions that were activated before
   // WebKit was initialized.
   for (const ExtensionId& extension_id : active_extension_ids_) {
@@ -386,8 +430,25 @@
 
   bindings_system_->DidCreateScriptContext(context);
 
+  bool run_nw_hook = false;
+  if (context->extension()) {
+    if (context->extension()->GetType() == Manifest::TYPE_NWJS_APP &&
+        context->context_type() == mojom::ContextType::kPrivilegedExtension) {
+      run_nw_hook = true;
+    }
+  }
+  const base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();
+  if (command_line.HasSwitch("nwjs-guest-nw"))
+    run_nw_hook = true;
+  if (command_line.HasSwitch("nwjs-guest"))
+    run_nw_hook = false;
+  VLOG(1) << "run_nw_hook: " << run_nw_hook;
+  if (run_nw_hook)
+    nw::ContextCreationHook(frame, context);
+
   // Inject custom JS into the platform app context.
-  if (IsWithinPlatformApp()) {
+  if (IsWithinPlatformApp() && context->extension() &&
+      context->extension()->GetType() != Manifest::TYPE_NWJS_APP) {
     module_system->Require("platformApp");
   }
 
@@ -573,7 +634,7 @@
 
   // TODO(lazyboy): Get rid of RequireGuestViewModules() as this doesn't seem
   // necessary for Extension SW.
-  RequireGuestViewModules(context);
+  //RequireGuestViewModules(context); //NWJS#6624
 
   WorkerThreadDispatcher::GetServiceWorkerData()->Init();
   g_worker_script_context_set.Get().Insert(base::WrapUnique(context));
@@ -590,6 +651,15 @@
   ScriptContext* context = script_context_set_->GetByV8Context(v8_context);
   if (!context)
     return;
+
+  //FIXME: upstream removed unload_event: we should check our event
+  //f66545e9e5d0308c15f51764e311425894e3ad09
+  
+  if (context && context->extension() &&
+      context->extension()->is_nwjs_app() &&
+      script_context_set_->size() == 1) {
+    nw::OnRenderProcessShutdownHook(context);
+  }
   bindings_system_->WillReleaseScriptContext(context);
 
   script_context_set_->Remove(context);
@@ -658,6 +728,16 @@
   }
 }
 
+void Dispatcher::DidDispatchDOMContentLoadedEvent(blink::WebLocalFrame* frame) {
+  GURL effective_document_url = ScriptContext::GetEffectiveDocumentURLForContext(
+      frame, frame->GetDocument().Url(), true /* match_about_blank */);
+
+  const Extension* extension =
+    RendererExtensionRegistry::Get()->GetExtensionOrAppByURL(effective_document_url);
+
+  nw::DocumentFinishHook(frame, extension, effective_document_url);
+}
+
 void Dispatcher::DidCreateDocumentElement(blink::WebLocalFrame* frame) {
   // Note: use GetEffectiveDocumentURLForContext() and not just
   // frame->document()->url() so that this also injects the stylesheet on
@@ -676,6 +756,11 @@
 
   if (extension &&
       (extension->is_extension() || extension->is_platform_app())) {
+    nw::DocumentElementHook(frame, extension, effective_document_url);
+  }
+
+  if (extension && !extension->is_nwjs_app() &&
+      (extension->is_extension() || extension->is_platform_app())) {
     int resource_id = extension->is_platform_app() ? IDR_PLATFORM_APP_CSS
                                                    : IDR_EXTENSION_FONTS_CSS;
     std::string stylesheet =
@@ -749,6 +834,12 @@
                                           const std::string& module_name,
                                           const std::string& function_name,
                                           const base::Value::List& args) {
+  // need extension id set to empty for remote pages
+  if (render_frame && (module_name == "nw.Window" || module_name == "app.window"))
+    script_context_set_->ForEach(
+      mojom::HostID(mojom::HostID::HostType::kExtensions, ""), render_frame,
+      base::BindRepeating(&CallModuleMethod, module_name, function_name, &args));
+  else
   script_context_set_->ForEach(
       GenerateHostIdFromExtensionId(extension_id), render_frame,
       base::BindRepeating(&CallModuleMethod, module_name, function_name,
@@ -902,6 +993,29 @@
                            base::Unretained(this), extension->id()));
       }
     }
+    if (extension->GetType() == Manifest::TYPE_NWJS_APP) {
+      const std::string* user_agent;
+      if ((user_agent = extension->manifest()->FindStringPath("user-agent"))) {
+        const std::string* name, *version;
+        name = extension->manifest()->FindStringPath("name");
+        version = extension->manifest()->FindStringPath("version");
+        if (name && version)
+          nw::SetUserAgentOverride(*user_agent, *name, *version);
+      }
+
+      const base::Value* quota_value = extension->manifest()->available_values().Find("dom_storage_quota");
+      if (quota_value && quota_value->is_int()) {
+        //content::DOMStorageMap::SetQuotaOverride(dom_storage_quota_mb * 1024 * 1024);
+        g_nw_dom_storage_quota = quota_value->GetInt() * 1024 * 1024;
+      }
+      const std::string* temp_path;
+      if ((temp_path = extension->manifest()->FindStringPath("nw-temp-dir"))) {
+        content::g_nw_temp_dir = base::FilePath::FromUTF8Unsafe(*temp_path);
+      }
+      VLOG(1) << "NW: change working dir: " << extension->path().AsUTF8Unsafe();
+      base::GetCurrentDirectory(&content::g_nw_old_cwd);
+      base::SetCurrentDirectory(extension->path());
+    }
   }
 
   // Update the available bindings for all contexts. These may have changed if
diff -r -u --color up/chromium/extensions/renderer/dispatcher.h nw/chromium/extensions/renderer/dispatcher.h
--- up/chromium/extensions/renderer/dispatcher.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/dispatcher.h	2024-08-26 19:32:25.726587989 +0000
@@ -173,6 +173,7 @@
 
   // This method is not allowed to run JavaScript code in the frame.
   void DidCreateDocumentElement(blink::WebLocalFrame* frame);
+  void DidDispatchDOMContentLoadedEvent(blink::WebLocalFrame* frame);
 
   // These methods may run (untrusted) JavaScript code in the frame, and
   // cause |render_frame| to become invalid.
diff -r -u --color up/chromium/extensions/renderer/extension_frame_helper.cc nw/chromium/extensions/renderer/extension_frame_helper.cc
--- up/chromium/extensions/renderer/extension_frame_helper.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/extension_frame_helper.cc	2024-08-26 19:32:25.726587989 +0000
@@ -4,6 +4,7 @@
 
 #include "extensions/renderer/extension_frame_helper.h"
 
+#include "content/renderer/render_frame_impl.h"
 #include <set>
 
 #include "base/feature_list.h"
@@ -43,6 +44,11 @@
 #include "v8/include/v8-object.h"
 #include "v8/include/v8-primitive.h"
 
+#include "content/nw/src/nw_content.h"
+#include "extensions/renderer/script_context_set.h"
+#include "content/nw/src/renderer/nw_chrome_renderer_hooks.h"
+#include "content/nw/src/renderer/nw_extensions_renderer_hooks.h"
+
 namespace extensions {
 
 namespace {
@@ -73,9 +79,12 @@
   blink::WebSecurityOrigin origin =
       frame_helper->render_frame()->GetWebFrame()->GetSecurityOrigin();
   if (origin.IsOpaque() ||
-      !base::EqualsASCII(origin.Protocol().Utf16(), kExtensionScheme) ||
-      !base::EqualsASCII(origin.Host().Utf16(), match_extension_id.c_str()))
-    return false;
+      !base::EqualsASCII(origin.Protocol().Utf16(), kExtensionScheme) || (!match_extension_id.empty() &&
+      !base::EqualsASCII(origin.Host().Utf16(), match_extension_id.c_str())))
+    if (!(match_extension_id == nw::get_main_extension_id() && 
+          !base::EqualsASCII(origin.Protocol().Utf16(), kExtensionScheme)))
+      //NWJS#5181: getall() with remote window
+      return false;
 
   if (match_window_id != extension_misc::kUnknownWindowId &&
       frame_helper->browser_window_id() != match_window_id)
@@ -191,12 +200,20 @@
     if (!web_frame->IsOutermostMainFrame())
       continue;
 
+#if 0
+    //remote page need to call GetExtensionViews in api_nw_window.js #5312
     if (!blink::WebFrame::ScriptCanAccess(context->GetIsolate(), web_frame)) {
       continue;
     }
+#endif
 
     v8::Local<v8::Context> frame_context = web_frame->MainWorldScriptContext();
     if (!frame_context.IsEmpty()) {
+      if (extension_id.empty()) {
+        ScriptContext* ctx = ScriptContextSet::GetContextByV8Context(frame_context);
+        if (!ctx->extension()->is_nwjs_app())
+          continue;
+      }
       v8::Local<v8::Value> window = frame_context->Global();
       CHECK(!window.IsEmpty());
       v8::Maybe<bool> maybe =
@@ -283,6 +300,13 @@
   did_create_current_document_element_ = true;
   extension_dispatcher_->DidCreateDocumentElement(
       render_frame()->GetWebFrame());
+  nw::DocumentHook2(true, render_frame(), extension_dispatcher_);
+}
+
+void ExtensionFrameHelper::DidDispatchDOMContentLoadedEvent() {
+  extension_dispatcher_->DidDispatchDOMContentLoadedEvent(
+      render_frame()->GetWebFrame());
+  nw::DocumentHook2(false, render_frame(), extension_dispatcher_);
 }
 
 void ExtensionFrameHelper::DidCreateNewDocument() {
@@ -373,10 +397,12 @@
   // document immediately. The chrome.app.window.create() callback (if any)
   // needs to be called prior to the new window's 'load' event. The parser will
   // be resumed when it happens. It doesn't apply to sandboxed pages.
-  if (view_type_ == mojom::ViewType::kAppWindow &&
-      web_frame->IsOutermostMainFrame() && !has_started_first_navigation_ &&
-      GURL(document_loader->GetUrl()).SchemeIs(kExtensionScheme) &&
-      !ScriptContext::IsSandboxedPage(document_loader->GetUrl())) {
+  if ((view_type_ == extensions::mojom::ViewType::kAppWindow ||
+       view_type_ == extensions::mojom::ViewType::kTabContents) &&
+      web_frame->IsOutermostMainFrame() &&
+      !has_started_first_navigation_ && !static_cast<content::RenderFrameImpl*>(render_frame())->skip_blocking_parser_) { // &&
+    //      GURL(document_loader->GetUrl()).SchemeIs(kExtensionScheme) &&
+    //  !ScriptContext::IsSandboxedPage(document_loader->GetUrl())) {
     document_loader->BlockParser();
   }
 
diff -r -u --color up/chromium/extensions/renderer/extension_frame_helper.h nw/chromium/extensions/renderer/extension_frame_helper.h
--- up/chromium/extensions/renderer/extension_frame_helper.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/extension_frame_helper.h	2024-08-26 19:32:25.726587989 +0000
@@ -187,6 +187,7 @@
   void ReadyToCommitNavigation(
       blink::WebDocumentLoader* document_loader) override;
   void DidCommitProvisionalLoad(ui::PageTransition transition) override;
+  void DidDispatchDOMContentLoadedEvent() override;
   void DidCreateScriptContext(v8::Local<v8::Context>,
                               int32_t world_id) override;
   void WillReleaseScriptContext(v8::Local<v8::Context>,
diff -r -u --color up/chromium/extensions/renderer/extension_injection_host.cc nw/chromium/extensions/renderer/extension_injection_host.cc
--- up/chromium/extensions/renderer/extension_injection_host.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/extension_injection_host.cc	2024-08-26 19:32:25.726587989 +0000
@@ -82,7 +82,7 @@
   if (outermost_origin->scheme() == kExtensionScheme &&
       outermost_origin->host() != extension_->id() &&
       !PermissionsData::CanExecuteScriptEverywhere(extension_->id(),
-                                                   extension_->location())) {
+                                                   extension_->location(), extension_->GetType())) {
     return PermissionsData::PageAccess::kDenied;
   }
 
diff -r -u --color up/chromium/extensions/renderer/ipc_message_sender.cc nw/chromium/extensions/renderer/ipc_message_sender.cc
--- up/chromium/extensions/renderer/ipc_message_sender.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/ipc_message_sender.cc	2024-08-26 19:32:25.730587988 +0000
@@ -53,17 +53,25 @@
 
   ~MainThreadIPCMessageSender() override {}
 
-  void SendRequestIPC(ScriptContext* context,
-                      mojom::RequestParamsPtr params) override {
+  void SendRequestIPC(
+      ScriptContext* context,
+      mojom::RequestParamsPtr params,
+      bool sync, bool* success, base::Value::List* response,
+      std::string* error) override {
     content::RenderFrame* frame = context->GetRenderFrame();
     if (!frame)
       return;
 
     int request_id = params->request_id;
+    if (!sync)
     ExtensionFrameHelper::Get(frame)->GetLocalFrameHost()->Request(
         std::move(params),
         base::BindOnce(&MainThreadIPCMessageSender::OnResponse,
                        weak_ptr_factory_.GetWeakPtr(), request_id));
+    else
+      ExtensionFrameHelper::Get(frame)->GetLocalFrameHost()->RequestSync(
+                                                                         std::move(params),
+                                                                         success, response, error);
   }
 
   void SendResponseAckIPC(ScriptContext* context,
@@ -315,7 +323,9 @@
   ~WorkerThreadIPCMessageSender() override {}
 
   void SendRequestIPC(ScriptContext* context,
-                      mojom::RequestParamsPtr params) override {
+                      mojom::RequestParamsPtr params,
+                      bool sync, bool* success, base::Value::List* response,
+                      std::string* error) override {
     DCHECK(!context->GetRenderFrame());
     DCHECK(context->IsForServiceWorker());
     DCHECK_NE(kMainThreadId, content::WorkerThread::GetCurrentId());
diff -r -u --color up/chromium/extensions/renderer/ipc_message_sender.h nw/chromium/extensions/renderer/ipc_message_sender.h
--- up/chromium/extensions/renderer/ipc_message_sender.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/ipc_message_sender.h	2024-08-26 19:32:25.730587988 +0000
@@ -19,6 +19,7 @@
 
 namespace base {
 class Uuid;
+class ListValue;
 }
 
 namespace blink {
@@ -49,8 +50,12 @@
   enum class ActivityLogCallType { APICALL, EVENT };
 
   // Sends a request message to the browser.
-  virtual void SendRequestIPC(ScriptContext* context,
-                              mojom::RequestParamsPtr params) = 0;
+  virtual void SendRequestIPC(
+      ScriptContext* context,
+      mojom::RequestParamsPtr params,
+      bool sync = false,
+      bool* success = nullptr, ::base::Value::List* response = nullptr,
+      std::string* error = nullptr) = 0;
 
   // Sends an "ack" back to the browser that the response to an API request was
   // received.
diff -r -u --color up/chromium/extensions/renderer/module_system.cc nw/chromium/extensions/renderer/module_system.cc
--- up/chromium/extensions/renderer/module_system.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/module_system.cc	2024-08-26 19:32:25.730587988 +0000
@@ -509,11 +509,11 @@
   CHECK(v8_helpers::IsTrue(maybe));
 }
 
-void ModuleSystem::OnNativeBindingCreated(
+v8::Local<v8::Value> ModuleSystem::OnNativeBindingCreated(
     const std::string& api_name,
     v8::Local<v8::Value> api_bridge_value) {
   DCHECK(!get_internal_api_.IsEmpty());
-  v8::HandleScope scope(GetIsolate());
+  v8::EscapableHandleScope scope(GetIsolate());
   if (source_map_->Contains(api_name)) {
     // We need to load the custom bindings and store them in our modules.
     // Storing them is important so that calls through CallModuleMethod() route
@@ -523,7 +523,7 @@
                     &modules) ||
         !modules->IsObject()) {
       NOTREACHED_IN_MIGRATION();
-      return;
+      return v8::Undefined(GetIsolate());
     }
 
     NativesEnabledScope enabled(this);
@@ -531,7 +531,9 @@
         LoadModuleWithNativeAPIBridge(api_name, api_bridge_value);
     SetPrivateProperty(context()->v8_context(), modules.As<v8::Object>(),
                        gin::StringToSymbol(GetIsolate(), api_name), exports);
+    return scope.Escape(exports);
   }
+  return v8::Undefined(GetIsolate());
 }
 
 void ModuleSystem::SetGetInternalAPIHook(
diff -r -u --color up/chromium/extensions/renderer/module_system.h nw/chromium/extensions/renderer/module_system.h
--- up/chromium/extensions/renderer/module_system.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/module_system.h	2024-08-26 19:32:25.730587988 +0000
@@ -127,7 +127,7 @@
   // code to set up various hooks.
   // TODO(devlin): We can get rid of this once we convert all our custom
   // bindings.
-  void OnNativeBindingCreated(const std::string& api_name,
+  v8::Local<v8::Value> OnNativeBindingCreated(const std::string& api_name,
                               v8::Local<v8::Value> api_bridge_value);
 
   void SetGetInternalAPIHook(v8::Local<v8::FunctionTemplate> get_internal_api);
diff -r -u --color up/chromium/extensions/renderer/native_extension_bindings_system.cc nw/chromium/extensions/renderer/native_extension_bindings_system.cc
--- up/chromium/extensions/renderer/native_extension_bindings_system.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/native_extension_bindings_system.cc	2024-08-26 19:32:25.730587988 +0000
@@ -6,6 +6,7 @@
 
 #include <string_view>
 #include <utility>
+#include "extensions/common/manifest_constants.h"
 
 #include "base/command_line.h"
 #include "base/functional/bind.h"
@@ -71,7 +72,7 @@
 namespace {
 
 const char kBindingsSystemPerContextKey[] = "extension_bindings_system";
-
+bool is_creating_hidden_binding = false;
 // Returns true if the given |api| is a "prefixed" api of the |root_api|; that
 // is, if the api begins with the root.
 // For example, 'app.runtime' is a prefixed api of 'app'.
@@ -107,6 +108,7 @@
   ~BindingsSystemPerContextData() override {}
 
   v8::Global<v8::Object> api_object;
+  v8::Global<v8::Object> hidden_apis;
   v8::Global<v8::Object> internal_apis;
   base::WeakPtr<NativeExtensionBindingsSystem> bindings_system;
 };
@@ -116,7 +118,7 @@
 // If a 'chrome' property exists but isn't an object, returns an empty Local.
 // If no 'chrome' property exists (or is undefined), creates a new
 // object, assigns it to Global().chrome, and returns it.
-v8::Local<v8::Object> GetOrCreateChrome(v8::Local<v8::Context> context) {
+v8::Local<v8::Object> GetOrCreateChrome(v8::Local<v8::Context> context, const char* name = nullptr, bool hidden = false) {
   // Ensure that the creation context for any new chrome object is |context|.
   v8::Context::Scope context_scope(context);
 
@@ -127,7 +129,8 @@
   // On the one hand, anyone writing that code is probably asking for trouble.
   // On the other, it'd be nice to avoid. I wonder if we can?
   v8::Local<v8::String> chrome_string =
-      gin::StringToSymbol(context->GetIsolate(), "chrome");
+    gin::StringToSymbol(context->GetIsolate(), name ? name : "chrome");
+  if (!hidden) {
   v8::Local<v8::Value> chrome_value;
   if (!context->Global()->Get(context, chrome_string).ToLocal(&chrome_value))
     return v8::Local<v8::Object>();
@@ -156,6 +159,26 @@
   }
 
   return chrome_object;
+  } else { //hidden
+    // MUST MATCH Private() in module_system.cc
+    v8::Local<v8::Object> global(context->Global());
+    v8::Local<v8::Value> privates;
+    ScriptContext* script_context = GetScriptContextFromV8ContextChecked(context);
+    if (!script_context->module_system()->GetPrivate(global, "privates", &privates) || !privates->IsObject()) {
+      privates = v8::Object::New(context->GetIsolate());
+      script_context->module_system()->SetPrivate(global, "privates", privates);
+    }
+    v8::Local<v8::Object> priv_obj = v8::Local<v8::Object>::Cast(privates);
+    v8::Local<v8::Value> chrome(priv_obj->Get(context, chrome_string).ToLocalChecked());
+    if (chrome->IsUndefined()) {
+      chrome = v8::Object::New(context->GetIsolate());
+      v8::Local<v8::String> hidden_key(
+                                       v8::String::NewFromUtf8(context->GetIsolate(), "__nw_is_hidden", v8::NewStringType::kNormal).ToLocalChecked());
+      std::ignore = chrome->ToObject(context).ToLocalChecked()->Set(context, hidden_key, v8::Boolean::New(context->GetIsolate(), true));
+      std::ignore = priv_obj->Set(context, chrome_string, chrome);
+    }
+    return chrome->IsObject() ? chrome.As<v8::Object>() : v8::Local<v8::Object>();
+  } //hidden
 }
 
 BindingsSystemPerContextData* GetBindingsDataFromContext(
@@ -202,6 +225,10 @@
 // |context|.
 bool IsAPIFeatureAvailable(v8::Local<v8::Context> context,
                            const std::string& name) {
+  if (is_creating_hidden_binding)
+    if (name.rfind("app.window", 0) == 0 || name.rfind("runtime", 0) == 0 ||
+        name.rfind("nw.Window", 0) == 0)
+    return true;
   ScriptContext* script_context = GetScriptContextFromV8ContextChecked(context);
   return script_context->GetAvailability(name).is_available();
 }
@@ -247,9 +274,20 @@
                            script_context->GetExtensionID(),
                            script_context->GetContextTypeDescription()));
   v8::Local<v8::Value> native_api_bridge = bridge_handle.ToV8();
-  script_context->module_system()->OnNativeBindingCreated(name,
+  v8::Local<v8::Value> exports =
+    script_context->module_system()->OnNativeBindingCreated(name,
                                                           native_api_bridge);
-
+  if (exports->IsObject()) {
+    v8::Local<v8::String> binding_name = gin::StringToSymbol(context->GetIsolate(), "binding");
+    v8::Local<v8::Object> exports_obj;
+    if (exports->ToObject(context).ToLocal(&exports_obj)) {
+      if (exports_obj->HasRealNamedProperty(context, binding_name).FromJust()) {
+        v8::Local<v8::Value> binding = exports_obj->GetRealNamedProperty(context, binding_name).ToLocalChecked();
+        DCHECK(binding->IsObject());
+        return binding.As<v8::Object>();
+      }
+    }
+  }
   return binding_object;
 }
 
@@ -272,11 +310,12 @@
     ScriptContext* script_context,
     APIBindingsSystem* bindings_system,
     const FeatureProvider* api_feature_provider,
-    const std::string& root_name) {
+    const std::string& root_name, bool hidden = false) {
   const FeatureMap& features = api_feature_provider->GetAllFeatures();
   auto lower = features.lower_bound(root_name);
   CHECK(lower != features.end(), base::NotFatalUntil::M130);
 
+  is_creating_hidden_binding = hidden;
   // Some bindings have a prefixed name, like app.runtime, where 'app' and
   // 'app.runtime' are, in fact, separate APIs. It's also possible for a
   // context to have access to 'app.runtime', but not to 'app'. For this, we
@@ -286,7 +325,8 @@
   if (lower->first == root_name) {
     const Feature* feature = lower->second.get();
     if (script_context->IsAnyFeatureAvailableToContext(
-            *feature, CheckAliasStatus::NOT_ALLOWED)) {
+        *feature, CheckAliasStatus::NOT_ALLOWED) ||
+        (hidden && (root_name == "app.window" || root_name == "runtime" || root_name == "nw.Window"))) {
       // If this feature is an alias for a different API, use the other binding
       // as the basis for the API contents.
       const std::string& source_name =
@@ -329,6 +369,8 @@
   // entered.
   for (auto iter = lower; iter != features.end() && iter->first < upper;
        ++iter) {
+    //if (iter->first.substr(0, 3) == "nw." && !nodejs_enabled)
+    //  continue;
     if (iter->second->IsInternal())
       continue;
 
@@ -348,7 +390,7 @@
 
     v8::Local<v8::Object> nested_binding =
         CreateFullBinding(context, script_context, bindings_system,
-                          api_feature_provider, std::string(binding_name));
+                          api_feature_provider, std::string(binding_name), hidden);
     // It's possible that we don't create a binding if no features or
     // prefixed features are available to the context.
     if (nested_binding.IsEmpty())
@@ -368,10 +410,13 @@
         gin::StringToSymbol(context->GetIsolate(), accessor_name);
     v8::Maybe<bool> success =
         root_binding->CreateDataProperty(context, nested_name, nested_binding);
-    if (!success.IsJust() || !success.FromJust())
+    if (!success.IsJust() || !success.FromJust()) {
+      is_creating_hidden_binding = false;
       return v8::Local<v8::Object>();
+    }
   }
 
+  is_creating_hidden_binding = false;
   return root_binding;
 }
 
@@ -520,7 +565,9 @@
   v8::Isolate* isolate = context->isolate();
   v8::HandleScope handle_scope(isolate);
   v8::Local<v8::Context> v8_context = context->v8_context();
-  v8::Local<v8::Object> chrome = GetOrCreateChrome(v8_context);
+  v8::Local<v8::Object> chrome = GetOrCreateChrome(v8_context, nullptr);
+  v8::Local<v8::Object> chrome_hidden = GetOrCreateChrome(v8_context, nullptr, true);
+  v8::Local<v8::Object> nw_obj;
   if (chrome.IsEmpty()) {
     return;
   }
@@ -536,6 +583,42 @@
     return success.IsJust() && success.FromJust();
   };
 
+  auto set_accessor_hidden = [chrome_hidden, isolate,
+    v8_context](std::string_view accessor_name) {
+    v8::Local<v8::String> api_name =
+      gin::StringToSymbol(isolate, accessor_name);
+    v8::Maybe<bool> success = chrome_hidden->SetLazyDataProperty(
+      v8_context, api_name, &BindingAccessorHidden, api_name);
+    return success.IsJust() && success.FromJust();
+  };
+
+  bool nodejs_enabled = false;
+  if (context->extension()) {
+    nodejs_enabled = context->extension()->is_nwjs_app();
+    nodejs_enabled = context->extension()->manifest()->
+      FindBoolPath(manifest_keys::kNWJSEnableNode).value_or(nodejs_enabled);
+  }
+
+  const base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();
+  bool hidden_nw = true;
+  if (nodejs_enabled &&
+      (context->context_type() == mojom::ContextType::kPrivilegedExtension ||
+       context->context_type() == mojom::ContextType::kPrivilegedWebPage ||
+     command_line.HasSwitch("nwjs-guest-nw")))
+    hidden_nw = false;
+  nw_obj = GetOrCreateChrome(v8_context, "nw", hidden_nw);
+
+  auto set_accessor_nw = [nw_obj, isolate,
+                          v8_context, hidden_nw](std::string_view accessor_name) {
+    v8::Local<v8::String> api_name =
+        gin::StringToSymbol(isolate, accessor_name);
+    v8::Local<v8::String> api_full_name =
+      gin::StringToSymbol(isolate, std::string("nw.") + std::string(accessor_name));
+    v8::Maybe<bool> success = nw_obj->SetLazyDataProperty(
+       v8_context, api_name, hidden_nw ? &BindingAccessorHidden : &BindingAccessor, api_full_name);
+    return success.IsJust() && success.FromJust();
+  };
+
   auto set_restricted_accessor = [chrome, isolate,
                                   v8_context](std::string_view accessor_name) {
     v8::Local<v8::String> api_name =
@@ -546,6 +629,7 @@
   };
 
   bool is_webpage = false;
+
   switch (context->context_type()) {
     case mojom::ContextType::kUnspecified:
     case mojom::ContextType::kWebPage:
@@ -610,6 +694,10 @@
       }
     }
 
+    set_accessor_hidden("app");
+    set_accessor_hidden("runtime");
+    set_accessor_nw("Window");
+
     UpdateContentCapabilities(context);
     return;
   }
@@ -637,6 +725,19 @@
     // as if we need to remove any existing APIs?
     std::string_view accessor_name =
         GetFirstDifferentAPIName(feature, std::string_view());
+    if (accessor_name.substr(0, 3) == "nw." && nw_obj.IsEmpty())
+      continue;
+    if (feature.substr(0, 3) == "nw.") {
+      if (hidden_nw && feature != "nw.Window")
+        continue;
+      std::string api_name = feature.substr(3);
+      accessor_name = api_name;
+      if (!set_accessor_nw(accessor_name)) {
+        LOG(ERROR) << "Failed to create API on NW object.";
+        return;
+      }
+      continue;
+    }
     last_accessor = accessor_name;
     if (!set_accessor(accessor_name)) {
       LOG(ERROR) << "Failed to create API on Chrome object.";
@@ -728,9 +829,9 @@
 
 v8::Local<v8::Object> NativeExtensionBindingsSystem::GetAPIObjectForTesting(
     ScriptContext* context,
-    const std::string& api_name) {
+    const std::string& api_name, bool hidden) {
   return GetAPIHelper(context->v8_context(),
-                      gin::StringToSymbol(context->isolate(), api_name));
+                      gin::StringToSymbol(context->isolate(), api_name), hidden);
 }
 
 void NativeExtensionBindingsSystem::BindingAccessor(
@@ -753,6 +854,26 @@
   if (!binding.IsEmpty())
     info.GetReturnValue().Set(binding);
 }
+void NativeExtensionBindingsSystem::BindingAccessorHidden(
+    v8::Local<v8::Name> name,
+    const v8::PropertyCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = info.Holder()->GetCreationContextChecked();
+
+  // Force binding creation in the owning context (even if another context is
+  // calling in). This is also important to ensure that objects created through
+  // the initialization process are all instantiated for the owning context.
+  // See https://crbug.com/819968.
+  v8::Context::Scope context_scope(context);
+
+  // We use info.Data() to store a real name here instead of using the provided
+  // one to handle any weirdness from the caller (non-existent strings, etc).
+  v8::Local<v8::String> api_name = info.Data().As<v8::String>();
+  v8::Local<v8::Object> binding = GetAPIHelper(context, api_name, true);
+  if (!binding.IsEmpty())
+    info.GetReturnValue().Set(binding);
+}
 
 void NativeExtensionBindingsSystem::ThrowDeveloperModeRestrictedError(
     v8::Local<v8::Name> name,
@@ -769,19 +890,28 @@
 // static
 v8::Local<v8::Object> NativeExtensionBindingsSystem::GetAPIHelper(
     v8::Local<v8::Context> context,
-    v8::Local<v8::String> api_name) {
+    v8::Local<v8::String> api_name, bool hidden) {
   BindingsSystemPerContextData* data = GetBindingsDataFromContext(context);
   if (!data)
     return v8::Local<v8::Object>();
 
   v8::Isolate* isolate = context->GetIsolate();
   v8::Local<v8::Object> apis;
+  if (hidden) {
+  if (data->hidden_apis.IsEmpty()) {
+    apis = v8::Object::New(isolate);
+    data->hidden_apis = v8::Global<v8::Object>(isolate, apis);
+  } else {
+    apis = data->hidden_apis.Get(isolate);
+  }
+  } else { //hidden
   if (data->api_object.IsEmpty()) {
     apis = v8::Object::New(isolate);
     data->api_object = v8::Global<v8::Object>(isolate, apis);
   } else {
     apis = data->api_object.Get(isolate);
   }
+  }
 
   v8::Maybe<bool> has_property = apis->HasRealNamedProperty(context, api_name);
   if (!has_property.IsJust())
@@ -801,7 +931,7 @@
 
   v8::Local<v8::Object> root_binding = CreateFullBinding(
       context, script_context, &data->bindings_system->api_system_,
-      FeatureProvider::GetAPIFeatures(), api_name_string);
+      FeatureProvider::GetAPIFeatures(), api_name_string, hidden);
   if (root_binding.IsEmpty())
     return v8::Local<v8::Object>();
 
@@ -864,13 +994,14 @@
   std::string api_name = gin::V8ToString(isolate, info[0]);
   const Feature* feature = FeatureProvider::GetAPIFeature(api_name);
   ScriptContext* script_context = GetScriptContextFromV8ContextChecked(context);
+  if (api_name != "nw.Window")
   if (!feature || !script_context->IsAnyFeatureAvailableToContext(
                       *feature, CheckAliasStatus::NOT_ALLOWED)) {
     NOTREACHED_IN_MIGRATION();
     return;
   }
 
-  CHECK(feature->IsInternal());
+  //CHECK(feature->IsInternal());
 
   // We don't need to go through CreateFullBinding here because internal APIs
   // are always acquired through getInternalBinding and specified by full name,
@@ -938,7 +1069,9 @@
     params->js_callstack = std::nullopt;
   }
 
-  ipc_message_sender_->SendRequestIPC(script_context, std::move(params));
+  ipc_message_sender_->SendRequestIPC(script_context, std::move(params),
+                                      request->sync, request->success,
+                                      request->response, request->error);
 }
 
 void NativeExtensionBindingsSystem::OnEventListenerChanged(
diff -r -u --color up/chromium/extensions/renderer/native_extension_bindings_system.h nw/chromium/extensions/renderer/native_extension_bindings_system.h
--- up/chromium/extensions/renderer/native_extension_bindings_system.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/native_extension_bindings_system.h	2024-08-26 19:32:25.730587988 +0000
@@ -106,7 +106,7 @@
   // Returns the API with the given |name| for the given |context|. Used for
   // testing purposes.
   v8::Local<v8::Object> GetAPIObjectForTesting(ScriptContext* context,
-                                               const std::string& api_name);
+                                               const std::string& api_name, bool hidden = false);
 
  private:
   // Handles sending a given |request|, forwarding it on to the send_ipc_ after
@@ -125,6 +125,8 @@
   // Getter callback for an extension API, since APIs are constructed lazily.
   static void BindingAccessor(v8::Local<v8::Name> name,
                               const v8::PropertyCallbackInfo<v8::Value>& info);
+  static void BindingAccessorHidden(v8::Local<v8::Name> name,
+                              const v8::PropertyCallbackInfo<v8::Value>& info);
 
   // Callback for accessing a restricted extension API. Access to the API is
   // restricted to the developer mode only.
@@ -134,7 +136,7 @@
 
   // Creates and returns the API binding for the given |name|.
   static v8::Local<v8::Object> GetAPIHelper(v8::Local<v8::Context> context,
-                                            v8::Local<v8::String> name);
+                                            v8::Local<v8::String> name, bool hidden = false);
 
   // Gets the chrome.runtime API binding.
   static v8::Local<v8::Object> GetLastErrorParents(
diff -r -u --color up/chromium/extensions/renderer/object_backed_native_handler.cc nw/chromium/extensions/renderer/object_backed_native_handler.cc
--- up/chromium/extensions/renderer/object_backed_native_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/object_backed_native_handler.cc	2024-08-26 19:32:25.730587988 +0000
@@ -107,7 +107,11 @@
         *v8::String::Utf8Value(isolate, feature_name_string);
     // TODO(devlin): Eventually, we should fail if either script_context is null
     // or feature_name is empty.
-    if (script_context && !feature_name.empty()) {
+
+    // remote pages need to call
+    // renderFrameObserverNatives.OnDocumentElementCreated() in
+    // the end of api_nw_window.js NWJS#5312
+    if (script_context && !feature_name.empty() && feature_name != "app.window") {
       Feature::Availability availability =
           script_context->GetAvailability(feature_name);
       if (!availability.is_available()) {
diff -r -u --color up/chromium/extensions/renderer/object_backed_native_handler.h nw/chromium/extensions/renderer/object_backed_native_handler.h
--- up/chromium/extensions/renderer/object_backed_native_handler.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/object_backed_native_handler.h	2024-08-26 19:32:25.730587988 +0000
@@ -80,6 +80,7 @@
                                      const v8::Local<v8::Object>& object,
                                      bool allow_null_context);
 
+ public:
   // The following methods are convenience wrappers for methods on v8::Object
   // with the corresponding names.
   // Returns whether or not setting privates was successful.
diff -r -u --color up/chromium/extensions/renderer/programmatic_script_injector.cc nw/chromium/extensions/renderer/programmatic_script_injector.cc
--- up/chromium/extensions/renderer/programmatic_script_injector.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/programmatic_script_injector.cc	2024-08-26 19:32:25.730587988 +0000
@@ -38,6 +38,10 @@
   return mojom::InjectionType::kProgrammaticScript;
 }
 
+bool ProgrammaticScriptInjector::ShouldExecuteInMainWorld() const {
+  return params_->in_main_world;
+}
+
 blink::mojom::UserActivationOption ProgrammaticScriptInjector::IsUserGesture()
     const {
   DCHECK(params_->injection->is_js());
diff -r -u --color up/chromium/extensions/renderer/programmatic_script_injector.h nw/chromium/extensions/renderer/programmatic_script_injector.h
--- up/chromium/extensions/renderer/programmatic_script_injector.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/programmatic_script_injector.h	2024-08-26 19:32:25.730587988 +0000
@@ -35,6 +35,7 @@
   // ScriptInjector implementation.
   mojom::InjectionType script_type() const override;
   blink::mojom::UserActivationOption IsUserGesture() const override;
+  bool ShouldExecuteInMainWorld() const override;
   mojom::ExecutionWorld GetExecutionWorld() const override;
   const std::optional<std::string>& GetExecutionWorldId() const override;
   mojom::CSSOrigin GetCssOrigin() const override;
diff -r -u --color up/chromium/extensions/renderer/resources/app_window_custom_bindings.js nw/chromium/extensions/renderer/resources/app_window_custom_bindings.js
--- up/chromium/extensions/renderer/resources/app_window_custom_bindings.js	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/app_window_custom_bindings.js	2024-08-26 19:32:25.730587988 +0000
@@ -20,8 +20,23 @@
 var Bounds = function(boundsKey) {
   privates(this).boundsKey_ = boundsKey;
 };
+
+var try_hidden = function (view) {
+  if (view.chrome.app.window)
+    return view;
+  return privates(view);
+};
+
+var try_nw = function (view) {
+  if (view.nw)
+    return view;
+  return privates(view);
+};
+
 Object.defineProperty(Bounds.prototype, 'left', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].left;
   },
   set: function(left) {
@@ -31,6 +46,8 @@
 });
 Object.defineProperty(Bounds.prototype, 'top', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].top;
   },
   set: function(top) {
@@ -40,6 +57,8 @@
 });
 Object.defineProperty(Bounds.prototype, 'width', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].width;
   },
   set: function(width) {
@@ -49,6 +68,8 @@
 });
 Object.defineProperty(Bounds.prototype, 'height', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].height;
   },
   set: function(height) {
@@ -58,36 +79,52 @@
 });
 Object.defineProperty(Bounds.prototype, 'minWidth', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].minWidth;
   },
   set: function(minWidth) {
+    if (!privates(this)) //NWJS#6553
+      return;
     updateSizeConstraints(privates(this).boundsKey_, { minWidth: minWidth });
   },
   enumerable: true
 });
 Object.defineProperty(Bounds.prototype, 'maxWidth', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].maxWidth;
   },
   set: function(maxWidth) {
+    if (!privates(this)) //NWJS#6553
+      return;
     updateSizeConstraints(privates(this).boundsKey_, { maxWidth: maxWidth });
   },
   enumerable: true
 });
 Object.defineProperty(Bounds.prototype, 'minHeight', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].minHeight;
   },
   set: function(minHeight) {
+    if (!privates(this)) //NWJS#6553
+      return;
     updateSizeConstraints(privates(this).boundsKey_, { minHeight: minHeight });
   },
   enumerable: true
 });
 Object.defineProperty(Bounds.prototype, 'maxHeight', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].maxHeight;
   },
   set: function(maxHeight) {
+    if (!privates(this)) //NWJS#6553
+      return;
     updateSizeConstraints(privates(this).boundsKey_, { maxHeight: maxHeight });
   },
   enumerable: true
@@ -128,7 +165,7 @@
     if (windowParams.existingWindow) {
       // Not creating a new window, but activating an existing one, so trigger
       // callback with existing window and don't do anything else.
-      let windowResult = view ? view.chrome.app.window.current() : undefined;
+      let windowResult = view ? try_hidden(view).chrome.app.window.current() : undefined;
       maybeCallback(windowResult);
       return;
     }
@@ -142,7 +179,7 @@
             ' The chrome.app.window.create callback will be called, but ' +
             'there will be no object provided for the sandboxed window.';
       }
-      console.warn(sandbox_window_message);
+      //console.warn(sandbox_window_message);
       maybeCallback(undefined);
       return;
     }
@@ -150,20 +187,27 @@
     // Handle error pages.
     // TODO(arthursonzogni): Figure out why view.chrome.app is defined for error
     // pages and stop doing it.
-    if (!view.chrome.app.window) {
+    if (!try_hidden(view).chrome.app.window) {
       maybeCallback(undefined);
       return;
     }
 
     // Initialize appWindowData in the newly created JS context
-    view.chrome.app.window.initializeAppWindow(windowParams);
+    try_hidden(view).chrome.app.window.initializeAppWindow(windowParams);
 
     var willCallback = renderFrameObserverNatives.OnDocumentElementCreated(
-        windowParams.frameToken, function(success) {
-          let windowResult = success ? view.chrome.app.window.current()
-                                     : undefined;
-          maybeCallback(windowResult);
-        });
+      windowParams.frameToken, function(success) {
+        if (success) {
+          var appwin = try_hidden(view).chrome.app.window.current();
+          if (!appwin) {
+            try_hidden(view).chrome.app.window.initializeAppWindow(windowParams);
+            appwin = try_hidden(view).chrome.app.window.current();
+          }
+        }
+        let windowResult = success ? appwin
+                : undefined;
+        maybeCallback(windowResult);
+      });
     appWindowNatives.ResumeParser(windowParams.frameToken);
     if (!willCallback)
       maybeCallback(undefined);
@@ -171,8 +215,6 @@
 
   apiFunctions.setHandleRequest('current', function() {
     if (!currentAppWindow) {
-      console.error('The JavaScript context calling ' +
-                    'chrome.app.window.current() has no associated AppWindow.');
       return null;
     }
     return currentAppWindow;
@@ -196,7 +238,12 @@
       return true;
     });
     return $Array.map(views, function(win) {
-      return win.chrome.app.window.current();
+      try {
+        if (try_nw(win).nw) //check for undefined case in NWJS#5528
+          try_nw(win).nw.Window.get(); //construct the window object for NWJS#5294
+      } catch (e) { //NWJS#7310
+      }
+      return try_hidden(win).chrome.app.window.current();
     });
   });
 
@@ -253,6 +300,9 @@
     AppWindow.prototype.isFullscreen = function() {
       return appWindowData.fullscreen;
     };
+    AppWindow.prototype.isResizable = function() {
+      return appWindowData.resizable;
+    };
     AppWindow.prototype.isMinimized = function() {
       return appWindowData.minimized;
     };
@@ -314,6 +364,7 @@
       minimized: params.minimized,
       maximized: params.maximized,
       alwaysOnTop: params.alwaysOnTop,
+      resizable: params.resizable,
       hasFrameColor: params.hasFrameColor,
       activeFrameColor: params.activeFrameColor,
       inactiveFrameColor: params.inactiveFrameColor,
@@ -330,6 +381,18 @@
           bounds1.width == bounds2.width && bounds1.height == bounds2.height);
 }
 
+function sizeEqual(bounds1, bounds2) {
+  if (!bounds1 || !bounds2)
+    return false;
+  return (bounds1.width == bounds2.width && bounds1.height == bounds2.height);
+}
+
+function posEqual(bounds1, bounds2) {
+  if (!bounds1 || !bounds2)
+    return false;
+  return (bounds1.left == bounds2.left && bounds1.top == bounds2.top);
+}
+
 function dispatchEventIfExists(target, name) {
   // Sometimes apps like to put their own properties on the window which
   // break our assumptions.
@@ -350,8 +413,20 @@
 
   var currentWindow = currentAppWindow;
 
-  if (!boundsEqual(oldData.innerBounds, update.innerBounds))
+  if (!boundsEqual(oldData.innerBounds, update.innerBounds)) {
     dispatchEventIfExists(currentWindow, "onBoundsChanged");
+    if (!sizeEqual(oldData.innerBounds, update.innerBounds))
+      dispatchEventIfExists(currentWindow, "onResized");
+    if (!posEqual(oldData.innerBounds, update.innerBounds))
+      dispatchEventIfExists(currentWindow, "onMoved");
+  }
+
+  // NW fix: fire onRestored earlier than fullscreen/minimize/maximize
+  // events. See nwjs/nw.js#5388.
+  if ((oldData.fullscreen && !update.fullscreen) ||
+      (oldData.minimized && !update.minimized) ||
+      (oldData.maximized && !update.maximized))
+    dispatchEventIfExists(currentWindow, "onRestored");
 
   if (!oldData.fullscreen && update.fullscreen)
     dispatchEventIfExists(currentWindow, "onFullscreened");
@@ -360,11 +435,6 @@
   if (!oldData.maximized && update.maximized)
     dispatchEventIfExists(currentWindow, "onMaximized");
 
-  if ((oldData.fullscreen && !update.fullscreen) ||
-      (oldData.minimized && !update.minimized) ||
-      (oldData.maximized && !update.maximized))
-    dispatchEventIfExists(currentWindow, "onRestored");
-
   if (oldData.alphaEnabled !== update.alphaEnabled)
     dispatchEventIfExists(currentWindow, "onAlphaEnabledChanged");
 };
diff -r -u --color up/chromium/extensions/renderer/resources/extensions_renderer_resources.grd nw/chromium/extensions/renderer/resources/extensions_renderer_resources.grd
--- up/chromium/extensions/renderer/resources/extensions_renderer_resources.grd	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/extensions_renderer_resources.grd	2024-08-26 19:32:25.734587987 +0000
@@ -72,6 +72,21 @@
 
       <!-- Extension styles. -->
       <include name="IDR_EXTENSION_FONTS_CSS" file="extension_fonts.css" type="BINDATA"/>
+
+      <include name="IDR_NW_PRE13_SHIM_JS"    file="../../../content/nw/src/resources/nw_pre13_shim.js" compress="false" type="BINDATA" />
+      <include name="IDR_NWAPI_APP_JS"    file="../../../content/nw/src/resources/api_nw_app.js" type="BINDATA" />
+      <include name="IDR_NWAPI_WINDOW_JS" file="../../../content/nw/src/resources/api_nw_window.js" type="BINDATA" />
+      <include name="IDR_NWAPI_WINDOW_INTERNAL_JS" file="../../../content/nw/src/resources/api_window_internal.js" type="BINDATA" />
+      <include name="IDR_NWAPI_NEWWIN_JS" file="../../../content/nw/src/resources/api_nw_newwin.js" type="BINDATA" />
+      <include name="IDR_NWAPI_CLIPBOARD_JS" file="../../../content/nw/src/resources/api_nw_clipboard.js" type="BINDATA" />
+      <include name="IDR_NWAPI_MENU_JS" file="../../../content/nw/src/resources/api_nw_menu.js" type="BINDATA" />
+      <include name="IDR_NWAPI_MENUITEM_JS" file="../../../content/nw/src/resources/api_nw_menuitem.js" type="BINDATA" />
+      <include name="IDR_NWAPI_SCREEN_JS" file="../../../content/nw/src/resources/api_nw_screen.js" type="BINDATA" />
+      <include name="IDR_NWAPI_SHORTCUT_JS" file="../../../content/nw/src/resources/api_nw_shortcut.js" type="BINDATA" />
+      <include name="IDR_NWAPI_SHELL_JS" file="../../../content/nw/src/resources/api_nw_shell.js" type="BINDATA" />
+      <include name="IDR_NWAPI_OBJECT_JS" file="../../../content/nw/src/resources/api_nw_object.js" type="BINDATA" />
+      <include name="IDR_NWAPI_TEST_JS" file="../../../content/nw/src/resources/api_nw_test.js" type="BINDATA" />
+      <include name="IDR_NWAPI_TRAY_JS" file="../../../content/nw/src/resources/api_nw_tray.js" type="BINDATA" />
     </includes>
     <structures>
       <!-- Platform app support. -->
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/guest_view_container_element.js nw/chromium/extensions/renderer/resources/guest_view/guest_view_container_element.js
--- up/chromium/extensions/renderer/resources/guest_view/guest_view_container_element.js	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/guest_view_container_element.js	2024-08-26 19:32:25.734587987 +0000
@@ -64,12 +64,17 @@
     GuestViewContainerElement.prototype.attributeChangedCallback =
         customElementCallbacks.attributeChangedCallback;
 
+    try {
     $CustomElementRegistry.define(
         window.customElements, $String.toLowerCase(elementName),
         containerElementType);
     $Object.defineProperty(window, elementName, {
       value: containerElementType,
     });
+    } catch (e) {
+       // GuestView is being registered in isolated world in
+       // content script sometimes //NWJS#7087
+    }
 
     delete GuestViewContainerElement.prototype.connectedCallback;
     delete GuestViewContainerElement.prototype.disconnectedCallback;
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/web_view/web_view.js nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view.js
--- up/chromium/extensions/renderer/resources/guest_view/web_view/web_view.js	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view.js	2024-08-26 19:32:25.734587987 +0000
@@ -28,6 +28,8 @@
 
 // Sets up all of the webview attributes.
 WebViewImpl.prototype.setupAttributes = function() {
+  this.attributes[WebViewConstants.ATTRIBUTE_ALLOWNW] =
+      new WebViewAttributes.AllowNWAttribute(this);
   this.attributes[WebViewConstants.ATTRIBUTE_ALLOWSCALING] =
       new WebViewAttributes.AllowScalingAttribute(this);
   this.attributes[WebViewConstants.ATTRIBUTE_ALLOWTRANSPARENCY] =
@@ -221,6 +223,28 @@
   return true;
 };
 
+WebViewImpl.prototype.getGuestId = function() {
+  return this.guest.getId();
+};
+
+WebViewImpl.prototype.showDevTools = function(show, container) {
+  if (!this.guest.getId()) {
+    return;
+  }
+  if (container)
+    WebViewInternal.showDevTools(this.guest.getId(), show, container.getProcessId(), container.getGuestId());
+  else
+    WebViewInternal.showDevTools(this.guest.getId(), show);
+};
+
+WebViewImpl.prototype.getCookieStoreId = function() {
+    return this.processId + "," + this.guest.getId();
+}
+
+WebViewImpl.prototype.inspectElementAt = function(x, y) {
+  WebViewInternal.inspectElementAt(this.guest.getId(), x, y);
+};
+
 WebViewImpl.prototype.loadDataWithBaseUrl = function(
     dataUrl, baseUrl, virtualUrl) {
   if (!this.guest.getId()) {
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_action_requests.js nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_action_requests.js
--- up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_action_requests.js	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_action_requests.js	2024-08-26 19:32:25.734587987 +0000
@@ -22,8 +22,9 @@
 // The browser will kill us if we send it a bad instance ID.
 // TODO(crbug.com/41353094): Remove once the cause of the bad ID is known.
 function CrashIfInvalidInstanceId(instanceId, culpritFunction) {
+  //NWJS: zero instance id is allowed in NW. 
   logging.CHECK(
-      instanceId > 0,
+      instanceId >= 0,
       'WebView: Invalid instance ID (' + instanceId + ') from ' +
           culpritFunction);
 }
@@ -138,13 +139,14 @@
     ok: $Function.bind(function(user_input) {
       this.validateCall();
       user_input = user_input || '';
-      CrashIfInvalidInstanceId(this.guestInstanceId, 'Dialog ok');
+      //NWJS: zero instance id is allowed in NW.
+      //CrashIfInvalidInstanceId(this.guestInstanceId, 'Dialog ok');
       WebViewInternal.setPermission(
           this.guestInstanceId, this.requestId, 'allow', user_input);
     }, this),
     cancel: $Function.bind(function() {
       this.validateCall();
-      CrashIfInvalidInstanceId(this.guestInstanceId, 'Dialog cancel');
+      //CrashIfInvalidInstanceId(this.guestInstanceId, 'Dialog cancel');
       WebViewInternal.setPermission(
           this.guestInstanceId, this.requestId, 'deny');
     }, this)
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_api_methods.js nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_api_methods.js
--- up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_api_methods.js	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_api_methods.js	2024-08-26 19:32:25.734587987 +0000
@@ -34,11 +34,13 @@
 
   // Returns audio state.
   'getAudioState',
+  // Return storeId which can be used in chrome.cookies API
+  'getCookieStoreId',
 
   // Returns Chrome's internal process ID for the guest web page's current
   // process.
   'getProcessId',
-
+  'getGuestId',
   // Returns the user agent string used by the webview for guest page requests.
   'getUserAgent',
 
@@ -70,6 +72,8 @@
   // of the data URL.
   'loadDataWithBaseUrl',
 
+  'showDevTools',
+  'inspectElementAt',
   // Prints the contents of the webview.
   'print',
 
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_attributes.js nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_attributes.js
--- up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_attributes.js	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_attributes.js	2024-08-26 19:32:25.734587987 +0000
@@ -52,6 +52,19 @@
                                        this.getValue());
 };
 
+function AllowNWAttribute(view) {
+  $Function.call(
+    GuestViewAttributes.BooleanAttribute,
+    this, WebViewConstants.ATTRIBUTE_ALLOWNW, view);
+}
+
+AllowNWAttribute.prototype.__proto__ =
+    GuestViewAttributes.BooleanAttribute.prototype;
+
+AllowNWAttribute.prototype.handleMutation = function(oldValue,
+                                                               newValue) {
+};
+
 // -----------------------------------------------------------------------------
 // AutosizeDimensionAttribute object.
 
@@ -257,6 +270,7 @@
 };
 
 var WebViewAttributes = {
+  AllowNWAttribute: AllowNWAttribute,
   AllowScalingAttribute: AllowScalingAttribute,
   AllowTransparencyAttribute: AllowTransparencyAttribute,
   AutosizeDimensionAttribute: AutosizeDimensionAttribute,
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_constants.js nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_constants.js
--- up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_constants.js	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_constants.js	2024-08-26 19:32:25.734587987 +0000
@@ -17,6 +17,7 @@
   ATTRIBUTE_NAME: 'name',
   ATTRIBUTE_PARTITION: 'partition',
   ATTRIBUTE_SRC: 'src',
+  ATTRIBUTE_ALLOWNW:  'allownw',
 
   // Error/warning messages.
   ERROR_MSG_ALREADY_NAVIGATED: '<webview>: ' +
diff -r -u --color up/chromium/extensions/renderer/runtime_custom_bindings.cc nw/chromium/extensions/renderer/runtime_custom_bindings.cc
--- up/chromium/extensions/renderer/runtime_custom_bindings.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/runtime_custom_bindings.cc	2024-08-26 19:32:25.734587987 +0000
@@ -5,6 +5,7 @@
 #include "extensions/renderer/runtime_custom_bindings.h"
 
 #include <stdint.h>
+#include "extensions/renderer/script_context_set.h"
 
 #include <memory>
 
@@ -55,8 +56,13 @@
     CHECK_EQ("ALL", view_type_string);
 
   const ExtensionId& extension_id = context()->GetExtensionID();
-  if (extension_id.empty())
-    return;
+  // id is empty while calling from external page. we want to do
+  // this for window controlling. note the case that there are
+  // multiple extensions in the process, e.g. the automation extension
+  // for chromedriver
+
+  // if (extension_id.empty())
+  //   return;
 
   // We ignore iframes here. (Returning subframes can cause broken behavior by
   // treating an app window's iframe as its main frame, and maybe other
diff -r -u --color up/chromium/extensions/renderer/script_context.cc nw/chromium/extensions/renderer/script_context.cc
--- up/chromium/extensions/renderer/script_context.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/script_context.cc	2024-08-26 19:32:25.734587987 +0000
@@ -389,8 +389,10 @@
 GURL ScriptContext::GetAccessCheckedFrameURL(
     const blink::WebLocalFrame* frame) {
   const blink::WebURL& weburl = frame->GetDocument().Url();
-  if (weburl.IsEmpty()) {
+  if (weburl.IsEmpty() || GURL(weburl) == GURL("about:blank")) {
     blink::WebDocumentLoader* document_loader = CurrentDocumentLoader(frame);
+    // NWJS fix for iframe-remote race condition on win release
+    // against 79b64c3e741cc9c6afbb23885945831a45c6baa5
     if (document_loader &&
         frame->GetSecurityOrigin().CanAccess(
             blink::WebSecurityOrigin::Create(document_loader->GetUrl()))) {
@@ -473,6 +475,9 @@
     return false;
   }
 
+  if (extension() && extension()->is_nwjs_app())
+    return true;
+
   Feature::Availability availability = GetAvailability(name);
   if (!availability.is_available()) {
     isolate()->ThrowException(v8::Exception::Error(
diff -r -u --color up/chromium/extensions/renderer/script_context_set.cc nw/chromium/extensions/renderer/script_context_set.cc
--- up/chromium/extensions/renderer/script_context_set.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/script_context_set.cc	2024-08-26 19:32:25.738587987 +0000
@@ -71,7 +71,7 @@
   GURL frame_url = ScriptContext::GetDocumentLoaderURLForFrame(frame);
   mojom::ContextType context_type = ClassifyJavaScriptContext(
       extension, world_id, frame_url, frame->GetDocument().GetSecurityOrigin(),
-      view_type, is_webview);
+      view_type, is_webview, frame);
   mojom::ContextType effective_context_type = ClassifyJavaScriptContext(
       effective_extension, world_id,
       ScriptContext::GetEffectiveDocumentURLForContext(frame, frame_url, true),
@@ -262,9 +262,11 @@
     const GURL& url,
     const blink::WebSecurityOrigin& origin,
     mojom::ViewType view_type,
-    bool is_webview) {
-  // WARNING: This logic must match `ProcessMap::GetMostLikelyContextType()`
-  // as much as possible.
+    bool is_webview,
+    const blink::WebLocalFrame* frame
+                                                             ) {
+  // WARNING: This logic must match ProcessMap::GetContextType, as much as
+  // possible.
 
   // Worlds not within this range are not for content scripts, so ignore them.
   // TODO(devlin): Isolated worlds with a non-zero id could belong to
@@ -299,7 +301,7 @@
   //    before the SecurityContext is updated with the sandbox flags (after
   //    reading the CSP header), so the caller can't check if the context's
   //    security origin is unique yet.
-  if (ScriptContext::IsSandboxedPage(url)) {
+  if (ScriptContext::IsSandboxedPage(url) || (frame && frame->isNwDisabledChildFrame())) {
     // TODO(https://crbug.com/347031402): it's weird returning kWebPage if
     // `extension` is non-null (which it is if `IsSandboxedPage` returns true).
     // It would be better to return kUnprivileged in that case.
diff -r -u --color up/chromium/extensions/renderer/script_context_set.h nw/chromium/extensions/renderer/script_context_set.h
--- up/chromium/extensions/renderer/script_context_set.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/script_context_set.h	2024-08-26 19:32:25.738587987 +0000
@@ -57,6 +57,7 @@
   // This may also include invalid contexts. TODO(kalman): Useful?
   size_t size() const { return contexts_.size(); }
 
+  const std::set<raw_ptr<ScriptContext, SetExperimental>>& contexts() const { return contexts_; }
   // Creates and starts managing a new ScriptContext. Ownership is held.
   // Returns a weak reference to the new ScriptContext.
   ScriptContext* Register(blink::WebLocalFrame* frame,
@@ -133,7 +134,9 @@
       const GURL& url,
       const blink::WebSecurityOrigin& origin,
       mojom::ViewType view_type,
-      bool is_webview);
+      bool is_webview,
+      const blink::WebLocalFrame* frame = nullptr
+                                             );
 
   // Weak reference to all installed Extensions that are also active in this
   // process.
diff -r -u --color up/chromium/extensions/renderer/script_injection.cc nw/chromium/extensions/renderer/script_injection.cc
--- up/chromium/extensions/renderer/script_injection.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/script_injection.cc	2024-08-26 19:32:25.738587987 +0000
@@ -313,6 +313,9 @@
       break;
   }
 
+  if (injector_->ShouldExecuteInMainWorld())
+    blink_world_id = blink::kMainDOMWorldId;
+
   render_frame_->GetWebFrame()->RequestExecuteScript(
       blink_world_id, sources, injector_->IsUserGesture(), execution_option,
       blink::mojom::LoadEventBlockingOption::kBlock,
diff -r -u --color up/chromium/extensions/renderer/script_injector.h nw/chromium/extensions/renderer/script_injector.h
--- up/chromium/extensions/renderer/script_injector.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/script_injector.h	2024-08-26 19:32:25.738587987 +0000
@@ -28,8 +28,8 @@
 namespace extensions {
 
 // The pseudo-delegate class for a ScriptInjection that provides all necessary
-// information about how to inject the script, including what code to inject and
-// when (run location), but without any injection logic.
+// information about how to inject the script, including what code to inject,
+// when (run location), and where (world), but without any injection logic.
 class ScriptInjector {
  public:
   // The possible reasons for not injecting the script.
@@ -53,6 +53,9 @@
   // Returns the associated `UserActivationOption` for script evaluation.
   virtual blink::mojom::UserActivationOption IsUserGesture() const = 0;
 
+  // Returns true if the script should execute in the main world.
+  virtual bool ShouldExecuteInMainWorld() const = 0;
+
   // Returns the world in which to execute the javascript code.
   virtual mojom::ExecutionWorld GetExecutionWorld() const = 0;
 
diff -r -u --color up/chromium/extensions/renderer/user_script_injector.cc nw/chromium/extensions/renderer/user_script_injector.cc
--- up/chromium/extensions/renderer/user_script_injector.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/user_script_injector.cc	2024-08-26 19:32:25.738587987 +0000
@@ -128,6 +128,10 @@
   return mojom::InjectionType::kContentScript;
 }
 
+bool UserScriptInjector::ShouldExecuteInMainWorld() const {
+  return script_->in_main_world();
+}
+
 blink::mojom::UserActivationOption UserScriptInjector::IsUserGesture() const {
   return blink::mojom::UserActivationOption::kDoNotActivate;
 }
diff -r -u --color up/chromium/extensions/renderer/user_script_injector.h nw/chromium/extensions/renderer/user_script_injector.h
--- up/chromium/extensions/renderer/user_script_injector.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/user_script_injector.h	2024-08-26 19:32:25.738587987 +0000
@@ -47,6 +47,7 @@
   // ScriptInjector implementation.
   mojom::InjectionType script_type() const override;
   blink::mojom::UserActivationOption IsUserGesture() const override;
+  bool ShouldExecuteInMainWorld() const override;
   mojom::ExecutionWorld GetExecutionWorld() const override;
   const std::optional<std::string>& GetExecutionWorldId() const override;
   mojom::CSSOrigin GetCssOrigin() const override;
diff -r -u --color up/chromium/extensions/renderer/user_script_set.cc nw/chromium/extensions/renderer/user_script_set.cc
--- up/chromium/extensions/renderer/user_script_set.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/user_script_set.cc	2024-08-26 19:32:25.738587987 +0000
@@ -210,12 +210,28 @@
       break;
   }
 
-  GURL effective_document_url =
+  // nwjs#6324: move the upstream logic of GetEffectiveDocumentURL() here
+  // in upstream is not matched first with empty invalid url for iframe
+  GURL effective_document_url;
+  bool match_about_blank = false; //copied from 6d96d3d1cb83d
+  switch (script->match_origin_as_fallback()) {
+  case MatchOriginAsFallbackBehavior::kAlways:
+  case MatchOriginAsFallbackBehavior::kMatchForAboutSchemeAndClimbTree:
+    match_about_blank = true;
+    break;
+  case MatchOriginAsFallbackBehavior::kNever:
+    break;  // `false` is correct for |match_about_blank|.
+  }
+
+  if (!match_about_blank || !document_url.SchemeIs(url::kAboutScheme))
+    effective_document_url = document_url;
+  else
+    effective_document_url =
       ScriptContext::GetEffectiveDocumentURLForInjection(
           web_frame, document_url, script->match_origin_as_fallback());
 
   bool is_subframe = !web_frame->IsOutermostMainFrame();
-  if (!script->MatchesDocument(effective_document_url, is_subframe))
+  if (!script->MatchesDocument(effective_document_url, is_subframe) || !effective_document_url.is_valid())
     return injection;
 
   // Extension dynamic scripts are treated as declarative scripts and should use
diff -r -u --color up/chromium/extensions/renderer/v8_context_native_handler.cc nw/chromium/extensions/renderer/v8_context_native_handler.cc
--- up/chromium/extensions/renderer/v8_context_native_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/renderer/v8_context_native_handler.cc	2024-08-26 19:32:25.738587987 +0000
@@ -35,8 +35,21 @@
   v8::Isolate* isolate = args.GetIsolate();
   std::string api_name = *v8::String::Utf8Value(isolate, args[0]);
   Feature::Availability availability = context_->GetAvailability(api_name);
-
   v8::Local<v8::Context> context = context_->v8_context();
+
+  if (api_name == "app.window" || api_name == "nw.Window" ||
+      api_name == "runtime") {
+  v8::Local<v8::Object> ret = v8::Object::New(isolate);
+  ret->Set(context, v8::String::NewFromUtf8(isolate, "is_available", v8::NewStringType::kNormal).ToLocalChecked(),
+           v8::Boolean::New(isolate, true)).ToChecked();
+  ret->Set(context, v8::String::NewFromUtf8(isolate, "message", v8::NewStringType::kNormal).ToLocalChecked(),
+           v8::String::NewFromUtf8(isolate, "", v8::NewStringType::kNormal).ToLocalChecked()).ToChecked();
+  ret->Set(context, v8::String::NewFromUtf8(isolate, "result", v8::NewStringType::kNormal).ToLocalChecked(),
+           v8::Integer::New(isolate, Feature::IS_AVAILABLE)).ToChecked();
+  args.GetReturnValue().Set(ret);
+  return;
+  }
+
   v8::Local<v8::Object> ret = v8::Object::New(isolate);
   v8::Maybe<bool> maybe = ret->SetPrototype(context, v8::Null(isolate));
   CHECK(maybe.IsJust() && maybe.FromJust());
diff -r -u --color up/chromium/extensions/test/extension_test_message_listener.cc nw/chromium/extensions/test/extension_test_message_listener.cc
--- up/chromium/extensions/test/extension_test_message_listener.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/test/extension_test_message_listener.cc	2024-08-26 19:32:25.778587980 +0000
@@ -14,14 +14,16 @@
 ExtensionTestMessageListener::ExtensionTestMessageListener(
     const std::string& expected_message,
     ReplyBehavior reply_behavior)
-    : expected_message_(expected_message), reply_behavior_(reply_behavior) {
+  : expected_message_(expected_message), reply_behavior_(reply_behavior),
+    run_loop_(new base::RunLoop())
+{
   test_api_observation_.Observe(
       extensions::TestApiObserverRegistry::GetInstance());
 }
 
 ExtensionTestMessageListener::ExtensionTestMessageListener(
     ReplyBehavior reply_behavior)
-    : reply_behavior_(reply_behavior) {
+  : reply_behavior_(reply_behavior), run_loop_(new base::RunLoop()) {
   test_api_observation_.Observe(
       extensions::TestApiObserverRegistry::GetInstance());
 }
@@ -33,9 +35,9 @@
 bool ExtensionTestMessageListener::WaitUntilSatisfied() {
   if (satisfied_)
     return !failed_;
-  base::RunLoop run_loop;
-  quit_wait_closure_ = run_loop.QuitWhenIdleClosure();
-  run_loop.Run();
+  quit_wait_closure_ = run_loop_->QuitWhenIdleClosure();
+  run_loop_->Run();
+  run_loop_.reset(new base::RunLoop());
   return !failed_;
 }
 
diff -r -u --color up/chromium/extensions/test/extension_test_message_listener.h nw/chromium/extensions/test/extension_test_message_listener.h
--- up/chromium/extensions/test/extension_test_message_listener.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/extensions/test/extension_test_message_listener.h	2024-08-26 19:32:25.778587980 +0000
@@ -11,6 +11,7 @@
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/scoped_refptr.h"
+#include "base/run_loop.h"
 #include "base/scoped_observation.h"
 #include "extensions/browser/api/test/test_api_observer.h"
 #include "extensions/browser/api/test/test_api_observer_registry.h"
@@ -181,6 +182,7 @@
 
   bool had_user_gesture() const { return had_user_gesture_; }
 
+  base::RunLoop* GetRunLoop() { return run_loop_.get(); }
  private:
   // extensions::TestApiObserver:
   bool OnTestMessage(extensions::TestSendMessageFunction* function,
@@ -196,7 +198,8 @@
   // Whether we've seen expected_message_ yet.
   bool satisfied_ = false;
 
-  // Holds the quit Closure for the RunLoop during WaitUntilSatisfied().
+  // Holds the quit Closure for the RunLoop during
+  // WaitUntilSatisfied().
   base::OnceClosure quit_wait_closure_;
 
   // Notifies when the expected message is received.
@@ -225,6 +228,7 @@
   // gesture.
   bool had_user_gesture_ = false;
 
+  std::unique_ptr<base::RunLoop> run_loop_;
   // The function we need to reply to.
   scoped_refptr<extensions::TestSendMessageFunction> function_;
 
diff -r -u --color up/chromium/google_apis/gaia/gaia_auth_fetcher.cc nw/chromium/google_apis/gaia/gaia_auth_fetcher.cc
--- up/chromium/google_apis/gaia/gaia_auth_fetcher.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/google_apis/gaia/gaia_auth_fetcher.cc	2024-08-26 19:32:25.810587977 +0000
@@ -42,7 +42,7 @@
 
 namespace {
 
-const size_t kMaxMessageSize = 1024 * 1024;  // 1MB
+//const size_t kMaxMessageSize = 1024 * 1024;  // 1MB
 
 constexpr char kBadAuthenticationError[] = "BadAuthentication";
 constexpr char kBadAuthenticationShortError[] = "badauth";
@@ -263,6 +263,7 @@
     const GURL& gaia_gurl,
     network::mojom::CredentialsMode credentials_mode,
     const net::NetworkTrafficAnnotationTag& traffic_annotation) {
+#if 0
   DCHECK(!fetch_pending_) << "Tried to fetch two things at once!";
 
   auto resource_request = std::make_unique<network::ResourceRequest>();
@@ -319,6 +320,7 @@
       base::BindOnce(&GaiaAuthFetcher::OnURLLoadComplete,
                      base::Unretained(this)),
       kMaxMessageSize);
+#endif
 }
 
 // static
diff -r -u --color up/chromium/headless/BUILD.gn nw/chromium/headless/BUILD.gn
--- up/chromium/headless/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/headless/BUILD.gn	2024-08-26 19:32:25.926587960 +0000
@@ -810,8 +810,8 @@
 
   if (!is_component_build) {
     sources += [
-      "lib/utility/headless_content_utility_client.cc",
-      "lib/utility/headless_content_utility_client.h",
+      #"lib/utility/headless_content_utility_client.cc",
+      #"lib/utility/headless_content_utility_client.h",
     ]
   }
 
@@ -845,6 +845,13 @@
     deps += [ "//components/crash/content/browser" ]
   }
 
+  if (is_mac && is_component_build) {
+    sources += [
+      "app/headless_shell_switches.cc",
+      "app/headless_shell_switches.h",
+    ]
+  }
+
   if (enable_printing) {
     deps += [
       "//components/printing/browser",
diff -r -u --color up/chromium/ipc/ipc_logging.cc nw/chromium/ipc/ipc_logging.cc
--- up/chromium/ipc/ipc_logging.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ipc/ipc_logging.cc	2024-08-26 19:32:27.146587784 +0000
@@ -245,7 +245,7 @@
       }
     }
   }
-  if (enabled_on_stderr_) {
+  if (enabled_on_stderr_ && !sender_) {
     std::string message_name;
     if (data.message_name.empty()) {
       message_name = base::StringPrintf("[unknown type %d]", data.type);
diff -r -u --color up/chromium/ipc/ipc_message_start.h nw/chromium/ipc/ipc_message_start.h
--- up/chromium/ipc/ipc_message_start.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ipc/ipc_message_start.h	2024-08-26 19:32:27.146587784 +0000
@@ -17,6 +17,7 @@
   WorkerMsgStart,
   NaClMsgStart,
   PpapiMsgStart,
+  ShellMsgStart,
   NaClHostMsgStart,
   LastIPCMsgStart  // Must come last.
 };
diff -r -u --color up/chromium/media/BUILD.gn nw/chromium/media/BUILD.gn
--- up/chromium/media/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/media/BUILD.gn	2024-08-26 19:32:27.154587784 +0000
@@ -12,7 +12,6 @@
 import("//media/media_options.gni")
 import("//testing/libfuzzer/fuzzer_test.gni")
 import("//testing/test.gni")
-import("//third_party/ffmpeg/ffmpeg_options.gni")
 
 if (enable_library_cdms) {
   import("//media/cdm/library_cdm/cdm_paths.gni")
@@ -76,15 +75,6 @@
   }
 }
 
-if (proprietary_codecs && media_use_ffmpeg) {
-  assert(
-      ffmpeg_branding != "Chromium",
-      "proprietary codecs and ffmpeg_branding set to Chromium are incompatible")
-}
-
-# Common configuration for targets in the media directory; these must not be
-# exported since things like USE_NEON and USE_CRAS have different meanings
-# elsewhere in the code base.
 config("media_config") {
   defines = []
   if (current_cpu == "arm64" || (current_cpu == "arm" && arm_use_neon)) {
diff -r -u --color up/chromium/media/audio/audio_manager_base.cc nw/chromium/media/audio/audio_manager_base.cc
--- up/chromium/media/audio/audio_manager_base.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/media/audio/audio_manager_base.cc	2024-08-26 19:32:27.158587783 +0000
@@ -127,9 +127,10 @@
 
 AudioManagerBase::~AudioManagerBase() {
   // All the output streams should have been deleted.
-  CHECK_EQ(0, num_output_streams_);
+  //disable the check for NWJS#5318
+  //CHECK_EQ(0, num_output_streams_);
   // All the input streams should have been deleted.
-  CHECK(input_streams_.empty());
+  //CHECK(input_streams_.empty());
 }
 
 void AudioManagerBase::GetAudioInputDeviceDescriptions(
diff -r -u --color up/chromium/media/base/feedback_signal_accumulator.h nw/chromium/media/base/feedback_signal_accumulator.h
--- up/chromium/media/base/feedback_signal_accumulator.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/media/base/feedback_signal_accumulator.h	2024-08-26 19:32:27.190587778 +0000
@@ -10,6 +10,7 @@
 #include <ostream>
 
 #include "base/time/time.h"
+#include <algorithm>
 
 namespace media {
 
diff -r -u --color up/chromium/media/ffmpeg/ffmpeg_common.cc nw/chromium/media/ffmpeg/ffmpeg_common.cc
--- up/chromium/media/ffmpeg/ffmpeg_common.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/media/ffmpeg/ffmpeg_common.cc	2024-08-26 19:32:27.250587769 +0000
@@ -131,6 +131,12 @@
       return AV_CODEC_ID_AAC;
     case AudioCodec::kALAC:
       return AV_CODEC_ID_ALAC;
+#if BUILDFLAG(ENABLE_PLATFORM_AC3_EAC3_AUDIO)
+    case AudioCodec::kAC3:
+      return AV_CODEC_ID_AC3;
+    case AudioCodec::kEAC3:
+      return AV_CODEC_ID_EAC3;
+#endif
     case AudioCodec::kMP3:
       return AV_CODEC_ID_MP3;
     case AudioCodec::kPCM:
diff -r -u --color up/chromium/mojo/public/cpp/base/message_pump_type_mojom_traits.cc nw/chromium/mojo/public/cpp/base/message_pump_type_mojom_traits.cc
--- up/chromium/mojo/public/cpp/base/message_pump_type_mojom_traits.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/mojo/public/cpp/base/message_pump_type_mojom_traits.cc	2024-08-26 19:32:27.702587705 +0000
@@ -20,6 +20,8 @@
       return mojo_base::mojom::MessagePumpType::kCustom;
     case base::MessagePumpType::IO:
       return mojo_base::mojom::MessagePumpType::kIo;
+    case base::MessagePumpType::NODE:
+      return mojo_base::mojom::MessagePumpType::kNode;
 #if BUILDFLAG(IS_ANDROID)
     case base::MessagePumpType::JAVA:
       return mojo_base::mojom::MessagePumpType::kJava;
@@ -50,6 +52,9 @@
     case mojo_base::mojom::MessagePumpType::kIo:
       *output = base::MessagePumpType::IO;
       return true;
+    case mojo_base::mojom::MessagePumpType::kNode:
+      *output = base::MessagePumpType::NODE;
+      return true;
 #if BUILDFLAG(IS_ANDROID)
     case mojo_base::mojom::MessagePumpType::kJava:
       *output = base::MessagePumpType::JAVA;
diff -r -u --color up/chromium/mojo/public/mojom/base/message_pump_type.mojom nw/chromium/mojo/public/mojom/base/message_pump_type.mojom
--- up/chromium/mojo/public/mojom/base/message_pump_type.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/mojo/public/mojom/base/message_pump_type.mojom	2024-08-26 19:32:27.750587697 +0000
@@ -16,4 +16,5 @@
   kNsRunloop,
   [EnableIf=is_ios]
   kNsRunloop,
+  kNode,
 };
diff -r -u --color up/chromium/net/cert/test_root_certs.h nw/chromium/net/cert/test_root_certs.h
--- up/chromium/net/cert/test_root_certs.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/net/cert/test_root_certs.h	2024-08-26 19:32:28.074587651 +0000
@@ -72,6 +72,7 @@
   TestRootCerts();
   ~TestRootCerts();
 
+public:
   // Marks |certificate| as trusted in the effective trust store
   // used by CertVerifier::Verify(). Returns false if the
   // certificate could not be marked trusted.
diff -r -u --color up/chromium/net/cookies/cookie_monster.cc nw/chromium/net/cookies/cookie_monster.cc
--- up/chromium/net/cookies/cookie_monster.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/net/cookies/cookie_monster.cc	2024-08-26 19:32:28.078587650 +0000
@@ -646,6 +646,7 @@
 }
 
 const char* const CookieMonster::kDefaultCookieableSchemes[] = {"http", "https",
+                                                                "chrome-extension",
                                                                 "ws", "wss"};
 const int CookieMonster::kDefaultCookieableSchemesCount =
     std::size(kDefaultCookieableSchemes);
diff -r -u --color up/chromium/net/proxy_resolution/configured_proxy_resolution_service.cc nw/chromium/net/proxy_resolution/configured_proxy_resolution_service.cc
--- up/chromium/net/proxy_resolution/configured_proxy_resolution_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/net/proxy_resolution/configured_proxy_resolution_service.cc	2024-08-26 19:32:28.382587607 +0000
@@ -1362,6 +1362,23 @@
   return previous_state;
 }
 
+void ConfiguredProxyResolutionService::ResetConfigService(
+       std::unique_ptr<ProxyConfigService> new_proxy_config_service) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  State previous_state = ResetProxyConfig(true);
+
+  // Release the old configuration service.
+  if (config_service_.get())
+    config_service_->RemoveObserver(this);
+
+  // Set the new configuration service.
+  config_service_ = std::move(new_proxy_config_service);
+  config_service_->AddObserver(this);
+
+  if (previous_state != STATE_NONE)
+    ApplyProxyConfigIfAvailable();
+}
+
 void ConfiguredProxyResolutionService::ForceReloadProxyConfig() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   ResetProxyConfig(false);
diff -r -u --color up/chromium/net/proxy_resolution/configured_proxy_resolution_service.h nw/chromium/net/proxy_resolution/configured_proxy_resolution_service.h
--- up/chromium/net/proxy_resolution/configured_proxy_resolution_service.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/net/proxy_resolution/configured_proxy_resolution_service.h	2024-08-26 19:32:28.382587607 +0000
@@ -146,6 +146,15 @@
   // ProxyResolutionService
   void OnShutdown() override;
 
+  // Tells this ProxyResolutionService to start using a new
+  // ProxyConfigService
+  // to retrieve its ProxyConfig from. The new ProxyConfigService
+  // will
+  // immediately be queried for new config info which will be used
+  // for all
+  // subsequent ResolveProxy calls.
+  void ResetConfigService(
+                          std::unique_ptr<ProxyConfigService> new_proxy_config_service);
   // Returns the last configuration fetched from ProxyConfigService.
   const std::optional<ProxyConfigWithAnnotation>& fetched_config() const {
     return fetched_config_;
diff -r -u --color up/chromium/ppapi/native_client/src/untrusted/pnacl_support_extension/BUILD.gn nw/chromium/ppapi/native_client/src/untrusted/pnacl_support_extension/BUILD.gn
--- up/chromium/ppapi/native_client/src/untrusted/pnacl_support_extension/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ppapi/native_client/src/untrusted/pnacl_support_extension/BUILD.gn	2024-08-26 19:32:28.546587583 +0000
@@ -35,7 +35,10 @@
   shim_cpu = nacl_target_cpu
 
   output_prefix = "$root_out_dir/pnacl/pnacl_public_"
-  outputs = [ "${output_prefix}pnacl_json" ]
+  outputs = [
+    "$root_out_dir/pnacl",
+    "${output_prefix}pnacl_json",
+  ]
 
   # Files that will be copied from the toolchain to output.
   outputs_from_toolchain = [
diff -r -u --color up/chromium/ppapi/shared_impl/media_stream_buffer_manager.h nw/chromium/ppapi/shared_impl/media_stream_buffer_manager.h
--- up/chromium/ppapi/shared_impl/media_stream_buffer_manager.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ppapi/shared_impl/media_stream_buffer_manager.h	2024-08-26 19:32:28.562587581 +0000
@@ -9,6 +9,7 @@
 
 #include <memory>
 #include <vector>
+#include <ostream>
 
 #include "base/compiler_specific.h"
 #include "base/containers/circular_deque.h"
diff -r -u --color up/chromium/remoting/remoting_enable.gni nw/chromium/remoting/remoting_enable.gni
--- up/chromium/remoting/remoting_enable.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/remoting/remoting_enable.gni	2024-08-26 19:32:28.762587552 +0000
@@ -10,6 +10,6 @@
 }
 
 declare_args() {
-  enable_remoting = !is_castos && !is_cast_android && !is_fuchsia &&
-                    (!is_linux || (target_cpu != "arm64" && use_gtk))
+  enable_remoting = false #!is_castos && !is_cast_android && !is_fuchsia &&
+                    #(!is_linux || (target_cpu != "arm64" && use_gtk))
 }
diff -r -u --color up/chromium/sandbox/policy/linux/sandbox_linux.cc nw/chromium/sandbox/policy/linux/sandbox_linux.cc
--- up/chromium/sandbox/policy/linux/sandbox_linux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/sandbox/policy/linux/sandbox_linux.cc	2024-08-26 19:32:28.818587544 +0000
@@ -191,9 +191,11 @@
 }
 
 SandboxLinux::~SandboxLinux() {
+#if 0
   if (pre_initialized_) {
     CHECK(initialize_sandbox_ran_);
   }
+#endif
 }
 
 SandboxLinux* SandboxLinux::GetInstance() {
diff -r -u --color up/chromium/services/network/network_context.cc nw/chromium/services/network/network_context.cc
--- up/chromium/services/network/network_context.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/services/network/network_context.cc	2024-08-26 19:32:28.946587526 +0000
@@ -68,6 +68,7 @@
 #include "net/cert/caching_cert_verifier.h"
 #include "net/cert/cert_verifier.h"
 #include "net/cert/coalescing_cert_verifier.h"
+#include "net/cert_net/cert_net_fetcher_url_request.h"
 #include "net/cookies/cookie_access_delegate.h"
 #include "net/cookies/cookie_constants.h"
 #include "net/cookies/cookie_monster.h"
@@ -843,6 +844,9 @@
     network_service_->DeregisterNetworkContext(this);
   }
 
+  if (cert_net_fetcher_)
+    cert_net_fetcher_->Shutdown();
+
   if (domain_reliability_monitor_)
     domain_reliability_monitor_->Shutdown();
   // Because of the order of declaration in the class,
@@ -2846,6 +2850,9 @@
         params_->discard_domain_reliablity_uploads);
   }
 
+  if (cert_net_fetcher_)
+    cert_net_fetcher_->SetURLRequestContext(result.url_request_context.get());
+
   return result;
 }
 
diff -r -u --color up/chromium/services/network/network_context.h nw/chromium/services/network/network_context.h
--- up/chromium/services/network/network_context.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/services/network/network_context.h	2024-08-26 19:32:28.946587526 +0000
@@ -92,6 +92,8 @@
 }  // namespace base
 
 namespace net {
+class CertNetFetcher;
+class CertNetFetcherURLRequest;
 class CertVerifier;
 class HostPortPair;
 class IsolationInfo;
@@ -921,6 +923,11 @@
   std::vector<base::OnceClosure> dismount_closures_;
 #endif  // BUILDFLAG(IS_DIRECTORY_TRANSFER_REQUIRED)
 
+  // CertNetFetcher used by the context's CertVerifier. May be nullptr if
+  // CertNetFetcher is not used by the current platform, or if the actual
+  // net::CertVerifier is instantiated outside of the network service.
+  scoped_refptr<net::CertNetFetcherURLRequest> cert_net_fetcher_;
+
   // Created on-demand. Null if unused.
   std::unique_ptr<HostResolver> internal_host_resolver_;
   std::set<std::unique_ptr<HostResolver>, base::UniquePtrComparator>
diff -r -u --color up/chromium/services/network/network_service.cc nw/chromium/services/network/network_service.cc
--- up/chromium/services/network/network_service.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/services/network/network_service.cc	2024-08-26 19:32:28.946587526 +0000
@@ -760,6 +760,8 @@
   if (it == raw_headers_access_origins_by_pid_.end()) {
     return false;
   }
+  if (it->second.size() == 1 && (*it->second.begin()).opaque())
+    return true;
   return it->second.find(url::Origin::Create(resource_url)) != it->second.end();
 }
 
diff -r -u --color up/chromium/storage/browser/file_system/isolated_context.cc nw/chromium/storage/browser/file_system/isolated_context.cc
--- up/chromium/storage/browser/file_system/isolated_context.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/storage/browser/file_system/isolated_context.cc	2024-08-26 19:32:29.158587496 +0000
@@ -208,6 +208,7 @@
       filesystem_id_(filesystem_id),
       file_info_(file_info),
       path_type_(path_type),
+      files_(),
       ref_counts_(0) {
   DCHECK(IsSinglePathIsolatedFileSystem(type_));
 }
diff -r -u --color up/chromium/testing/buildbot/trybot_analyze_config.json nw/chromium/testing/buildbot/trybot_analyze_config.json
--- up/chromium/testing/buildbot/trybot_analyze_config.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/testing/buildbot/trybot_analyze_config.json	2024-08-26 19:32:29.206587488 +0000
@@ -12,6 +12,7 @@
       "build/check_gn_headers_whitelist.txt",
       "build/get_landmines.py",
       "build/gn_helpers.py",
+      "build/gyp_chromium",
       "build/mac_toolchain.py",
       "build/toolchain/apple/.*py",
       "build/toolchain/get_concurrent_links.py",
diff -r -u --color up/chromium/testing/variations/fieldtrial_testing_config.json nw/chromium/testing/variations/fieldtrial_testing_config.json
--- up/chromium/testing/variations/fieldtrial_testing_config.json	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/testing/variations/fieldtrial_testing_config.json	2024-08-26 19:32:29.242587484 +0000
@@ -7650,21 +7650,6 @@
             ]
         }
     ],
-    "DestroyProfileOnBrowserClose": [
-        {
-            "platforms": [
-                "chromeos_lacros"
-            ],
-            "experiments": [
-                {
-                    "name": "DestroyProfileOnBrowserClose",
-                    "enable_features": [
-                        "DestroyProfileOnBrowserClose"
-                    ]
-                }
-            ]
-        }
-    ],
     "DestroySystemProfiles": [
         {
             "platforms": [
@@ -7704,31 +7689,6 @@
             ]
         }
     ],
-    "DevToolsTabTarget": [
-        {
-            "platforms": [
-                "linux",
-                "mac",
-                "windows",
-                "chromeos",
-                "chromeos_lacros"
-            ],
-            "experiments": [
-                {
-                    "name": "Enabled",
-                    "enable_features": [
-                        "DevToolsTabTarget"
-                    ]
-                },
-                {
-                    "name": "Control",
-                    "disable_features": [
-                        "DevToolsTabTarget"
-                    ]
-                }
-            ]
-        }
-    ],
     "DeviceAuthenticatorAndroidx": [
         {
             "platforms": [
@@ -12212,6 +12172,20 @@
             ]
         }
     ],
+    "InstanceID": [
+        {
+	  "platforms": [
+	    "linux",
+	    "mac",
+	    "windows"
+	  ],
+          "experiments": [
+	    {
+	      "name": "Enabled"
+	    }
+	  ]
+	}
+    ],
     "KeyboardAccessoryAddressIPH": [
         {
             "platforms": [
@@ -16129,25 +16103,6 @@
                     ]
                 }
             ]
-        }
-    ],
-    "PdfOutOfProcessIframe": [
-        {
-            "platforms": [
-                "chromeos",
-                "chromeos_lacros",
-                "linux",
-                "mac",
-                "windows"
-            ],
-            "experiments": [
-                {
-                    "name": "Enabled",
-                    "enable_features": [
-                        "PdfOopif"
-                    ]
-                }
-            ]
         }
     ],
     "PdfUseSkiaRenderer": [
diff -r -u --color up/chromium/third_party/blink/common/privacy_budget/identifiability_study_settings.cc nw/chromium/third_party/blink/common/privacy_budget/identifiability_study_settings.cc
--- up/chromium/third_party/blink/common/privacy_budget/identifiability_study_settings.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/common/privacy_budget/identifiability_study_settings.cc	2024-08-26 19:32:29.470587451 +0000
@@ -71,7 +71,8 @@
   // Same restrictions as IdentifiabilityStudySettings::SetGlobalProvider().
   void SetProvider(
       std::unique_ptr<IdentifiabilityStudySettingsProvider> provider) {
-    DCHECK(!initialized_.IsSet());
+    if (initialized_.IsSet())
+      return;
     initialized_settings_.emplace(std::move(provider));
     initialized_.Set();
   }
diff -r -u --color up/chromium/third_party/blink/common/renderer_preferences/renderer_preferences_mojom_traits.cc nw/chromium/third_party/blink/common/renderer_preferences/renderer_preferences_mojom_traits.cc
--- up/chromium/third_party/blink/common/renderer_preferences/renderer_preferences_mojom_traits.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/common/renderer_preferences/renderer_preferences_mojom_traits.cc	2024-08-26 19:32:29.470587451 +0000
@@ -107,6 +107,11 @@
   out->selection_clipboard_buffer_available =
       data.selection_clipboard_buffer_available();
 #endif
+  if (!data.ReadNwInjectJsDocStart(&out->nw_inject_js_doc_start))
+    return false;
+  if (!data.ReadNwInjectJsDocEnd(&out->nw_inject_js_doc_end))
+    return false;
+
   out->plugin_fullscreen_allowed = data.plugin_fullscreen_allowed();
   out->caret_browsing_enabled = data.caret_browsing_enabled();
 
diff -r -u --color up/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences.h nw/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences.h
--- up/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences.h	2024-08-26 19:32:29.890587426 +0000
@@ -91,6 +91,8 @@
   bool caret_browsing_enabled{false};
   std::vector<uint16_t> explicitly_allowed_network_ports;
   std::optional<bool> prefixed_fullscreen_video_api_availability;
+  std::string nw_inject_js_doc_start;
+  std::string nw_inject_js_doc_end;
 
   RendererPreferences();
   RendererPreferences(const RendererPreferences& other);
diff -r -u --color up/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences_mojom_traits.h nw/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences_mojom_traits.h
--- up/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences_mojom_traits.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences_mojom_traits.h	2024-08-26 19:32:29.890587426 +0000
@@ -180,6 +180,16 @@
   }
 #endif
 
+  static const std::string& nw_inject_js_doc_start(
+      const ::blink::RendererPreferences& data) {
+    return data.nw_inject_js_doc_start;
+  }
+
+  static const std::string& nw_inject_js_doc_end(
+      const ::blink::RendererPreferences& data) {
+    return data.nw_inject_js_doc_end;
+  }
+
 #if BUILDFLAG(IS_WIN)
   static const std::u16string& caption_font_family_name(
       const ::blink::RendererPreferences& data) {
diff -r -u --color up/chromium/third_party/blink/public/devtools_protocol/browser_protocol.pdl nw/chromium/third_party/blink/public/devtools_protocol/browser_protocol.pdl
--- up/chromium/third_party/blink/public/devtools_protocol/browser_protocol.pdl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/devtools_protocol/browser_protocol.pdl	2024-08-26 19:32:29.898587428 +0000
@@ -8372,6 +8372,7 @@
       newTab
       newWindow
       download
+      nwignore
 
   experimental type InstallabilityErrorArgument extends object
     properties
diff -r -u --color up/chromium/third_party/blink/public/mojom/choosers/file_chooser.mojom nw/chromium/third_party/blink/public/mojom/choosers/file_chooser.mojom
--- up/chromium/third_party/blink/public/mojom/choosers/file_chooser.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/choosers/file_chooser.mojom	2024-08-26 19:32:29.902587429 +0000
@@ -33,10 +33,14 @@
   // Title to be used for the dialog. This may be empty for the default title,
   // which will be either "Open" or "Save" depending on the mode.
   mojo_base.mojom.String16 title;
+  mojo_base.mojom.FilePath initial_value;
 
   // Default file name to select in the dialog with kSave mode.
   mojo_base.mojom.FilePath default_file_name;
 
+  mojo_base.mojom.FilePath initial_path;
+  bool extract_directory = true;
+  bool save_as = false;
   // |selected_files| has filenames which a file upload control already
   // selected. A FileChooser implementation may ask a user to select
   //  - removing a file from the selected files,
diff -r -u --color up/chromium/third_party/blink/public/mojom/frame/frame.mojom nw/chromium/third_party/blink/public/mojom/frame/frame.mojom
--- up/chromium/third_party/blink/public/mojom/frame/frame.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/frame/frame.mojom	2024-08-26 19:32:29.910587431 +0000
@@ -1311,7 +1311,8 @@
   ShowCreatedWindow(blink.mojom.LocalFrameToken opener_frame_token,
                     ui.mojom.WindowOpenDisposition disposition,
                     blink.mojom.WindowFeatures window_features,
-                    bool opened_by_user_gesture) => ();
+                    bool opened_by_user_gesture,
+                    mojo_base.mojom.String16 manifest) => ();
 
   // Request that the browser change the bounds of the window.
   // This corresponds to the window.resizeTo() and window.moveTo() APIs, and the browser
diff -r -u --color up/chromium/third_party/blink/public/mojom/frame/frame_owner_properties.mojom nw/chromium/third_party/blink/public/mojom/frame/frame_owner_properties.mojom
--- up/chromium/third_party/blink/public/mojom/frame/frame_owner_properties.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/frame/frame_owner_properties.mojom	2024-08-26 19:32:29.910587431 +0000
@@ -18,8 +18,10 @@
   int32 margin_height;
   // True if the frame allows fullscreen.
   bool allow_fullscreen;
+  bool nwfaketop;
   // True if the frame allows payment request.
   bool allow_payment_request;
+  string nwuseragent;
   // True if the frame is display:none.
   bool is_display_none;
   // The used value of color-scheme for the frame element.
diff -r -u --color up/chromium/third_party/blink/public/mojom/navigation/navigation_params.mojom nw/chromium/third_party/blink/public/mojom/navigation/navigation_params.mojom
--- up/chromium/third_party/blink/public/mojom/navigation/navigation_params.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/navigation/navigation_params.mojom	2024-08-26 19:32:29.918587434 +0000
@@ -292,6 +292,7 @@
   // BeginNavigationParams.
   bool is_history_navigation_in_new_child_frame = false;
 
+  bool block_parser = false;
   // The time the input event leading to the navigation occurred. This will
   // not always be set; it depends on the creator of the CommonNavigationParams
   // setting it.
diff -r -u --color up/chromium/third_party/blink/public/mojom/renderer_preferences.mojom nw/chromium/third_party/blink/public/mojom/renderer_preferences.mojom
--- up/chromium/third_party/blink/public/mojom/renderer_preferences.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/renderer_preferences.mojom	2024-08-26 19:32:29.922587435 +0000
@@ -121,6 +121,9 @@
   // Whether or not caret browsing is enabled.
   bool caret_browsing_enabled = false;
 
+  string nw_inject_js_doc_start;
+  string nw_inject_js_doc_end;
+
   [EnableIf=renderer_pref_system_font_family_name]
   string system_font_family_name;
 
diff -r -u --color up/chromium/third_party/blink/public/mojom/worker/shared_worker_info.mojom nw/chromium/third_party/blink/public/mojom/worker/shared_worker_info.mojom
--- up/chromium/third_party/blink/public/mojom/worker/shared_worker_info.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/worker/shared_worker_info.mojom	2024-08-26 19:32:29.930587437 +0000
@@ -8,6 +8,7 @@
 import "third_party/blink/public/mojom/loader/fetch_client_settings_object.mojom";
 import "third_party/blink/public/mojom/worker/worker_options.mojom";
 import "url/mojom/url.mojom";
+import "mojo/public/mojom/base/file_path.mojom";
 
 // This enum indicates which types of SameSite cookies the SharedWorker should
 // be allowed to access. kAll allows cookies with same-site Lax, Strict, or
@@ -25,6 +26,8 @@
 // parent context (e.g. Document), and passed onto the destination child
 // process where the shared worker runs.
 struct SharedWorkerInfo {
+  bool is_node_js;
+  mojo_base.mojom.FilePath root_path;
   url.mojom.Url url;
   WorkerOptions options;
   array<network.mojom.ContentSecurityPolicy> content_security_policies;
diff -r -u --color up/chromium/third_party/blink/public/platform/platform.h nw/chromium/third_party/blink/public/platform/platform.h
--- up/chromium/third_party/blink/public/platform/platform.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/platform/platform.h	2024-08-26 19:32:29.934587438 +0000
@@ -655,7 +655,7 @@
                                          const BrowserInterfaceBrokerProxy&);
   virtual void DidStartWorkerThread() {}
   virtual void WillStopWorkerThread() {}
-  virtual void WorkerContextCreated(const v8::Local<v8::Context>& worker) {}
+  virtual void WorkerContextCreated(const v8::Local<v8::Context>& worker, bool, const std::string&) {}
   virtual bool AllowScriptExtensionForServiceWorker(
       const WebSecurityOrigin& script_origin) {
     return false;
diff -r -u --color up/chromium/third_party/blink/public/platform/web_security_origin.h nw/chromium/third_party/blink/public/platform/web_security_origin.h
--- up/chromium/third_party/blink/public/platform/web_security_origin.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/platform/web_security_origin.h	2024-08-26 19:32:29.938587439 +0000
@@ -118,6 +118,8 @@
   // https://html.spec.whatwg.org/#same-origin
   bool IsSameOriginWith(const WebSecurityOrigin&) const;
 
+  BLINK_PLATFORM_EXPORT void grantUniversalAccess();
+
 #if INSIDE_BLINK
   WebSecurityOrigin(scoped_refptr<const SecurityOrigin>);
   WebSecurityOrigin& operator=(scoped_refptr<const SecurityOrigin>);
diff -r -u --color up/chromium/third_party/blink/public/web/blink.h nw/chromium/third_party/blink/public/web/blink.h
--- up/chromium/third_party/blink/public/web/blink.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/blink.h	2024-08-26 19:32:29.954587443 +0000
@@ -48,6 +48,7 @@
 
 class Platform;
 
+class WebLocalFrame;
 // Initialize the entire Blink (wtf, platform, core, modules and web).
 // If you just need wtf and platform, use Platform::Initialize instead.
 //
@@ -90,6 +91,10 @@
 // Alters whether the browser can handle focus events while running web tests.
 BLINK_EXPORT void SetBrowserCanHandleFocusForWebTest(bool);
 
+BLINK_EXPORT void set_web_worker_hooks(void*);
+
+BLINK_EXPORT void fix_gamepad_nw(WebLocalFrame*);
+
 // Alters the rendering of fonts for web tests.
 BLINK_EXPORT void SetFontAntialiasingEnabledForTest(bool);
 BLINK_EXPORT bool FontAntialiasingEnabledForTest();
diff -r -u --color up/chromium/third_party/blink/public/web/web_document_loader.h nw/chromium/third_party/blink/public/web/web_document_loader.h
--- up/chromium/third_party/blink/public/web/web_document_loader.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_document_loader.h	2024-08-26 19:32:29.958587444 +0000
@@ -120,6 +120,7 @@
   // same number of time than BlockParser().
   virtual void BlockParser() = 0;
   virtual void ResumeParser() = 0;
+  virtual int ParserBlockerCount() = 0;
 
   // Returns true if the document is an MHTML archive. When true,
   // GetArchiveInfo() may be called to find the result of loading and, if
diff -r -u --color up/chromium/third_party/blink/public/web/web_frame.h nw/chromium/third_party/blink/public/web/web_frame.h
--- up/chromium/third_party/blink/public/web/web_frame.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_frame.h	2024-08-26 19:32:29.958587444 +0000
@@ -44,7 +44,7 @@
 
 namespace blink {
 
-#if INSIDE_BLINK
+#if 1 //INSIDE_BLINK
 class Frame;
 #endif
 
@@ -93,6 +93,12 @@
       CrossVariantMojoAssociatedReceiver<mojom::RemoteFrameInterfaceBase>
           receiver,
       mojom::FrameReplicationStatePtr replicated_state);
+  virtual bool isNwFakeTop() const {return false;}
+  virtual void setNodeJS(bool) {}
+  virtual bool isNodeJS() const {return false;}
+  virtual bool isNwDisabledChildFrame() const {return false;}
+  virtual void setDevtoolsJail(WebFrame*) {}
+  virtual WebFrame* getDevtoolsJail() {return nullptr;}
 
   // This method closes and deletes the WebFrame. This is typically called by
   // the embedder in response to a frame detached callback to the WebFrame
@@ -189,8 +195,8 @@
   // RemoteFrame <--> RenderFrameProxyHost in the browser process.
   const FrameToken& GetFrameToken() const { return frame_token_; }
 
-#if INSIDE_BLINK
   static WebFrame* FromCoreFrame(Frame*);
+#if INSIDE_BLINK
   static Frame* ToCoreFrame(const WebFrame&);
 #endif
 
diff -r -u --color up/chromium/third_party/blink/public/web/web_frame_owner_properties.h nw/chromium/third_party/blink/public/web/web_frame_owner_properties.h
--- up/chromium/third_party/blink/public/web/web_frame_owner_properties.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_frame_owner_properties.h	2024-08-26 19:32:29.958587444 +0000
@@ -12,8 +12,10 @@
 namespace blink {
 
 struct WebFrameOwnerProperties {
+  WebString nwuseragent;
   WebString name;  // browsing context container's name
   mojom::ScrollbarMode scrollbar_mode{mojom::ScrollbarMode::kAuto};
+  bool nwFakeTop{false};
   int margin_width{-1};
   int margin_height{-1};
   bool allow_fullscreen{false};
@@ -35,6 +37,7 @@
                           mojom::ColorScheme color_scheme)
       : name(name),
         scrollbar_mode(scrollbar_mode),
+        nwFakeTop(false),
         margin_width(margin_width),
         margin_height(margin_height),
         allow_fullscreen(allow_fullscreen),
diff -r -u --color up/chromium/third_party/blink/public/web/web_local_frame_client.h nw/chromium/third_party/blink/public/web/web_local_frame_client.h
--- up/chromium/third_party/blink/public/web/web_local_frame_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_local_frame_client.h	2024-08-26 19:32:29.958587444 +0000
@@ -181,6 +181,8 @@
   virtual void BindToFrame(WebNavigationControl*) {}
 
   // Factory methods -----------------------------------------------------
+  virtual void willHandleNavigationPolicy(
+                                          WebFrame*, const WebURLRequest&, WebNavigationPolicy*, WebString* manifest = NULL, bool new_win = true) { }
 
   // May return null.
   virtual WebPlugin* CreatePlugin(const WebPluginParams&) { return nullptr; }
@@ -872,7 +874,8 @@
       bool& consumed_user_gesture,
       const std::optional<Impression>&,
       const std::optional<WebPictureInPictureWindowOptions>& pip_options,
-      const WebURL& base_url) {
+      const WebURL& base_url,
+      WebString* manifest) {
     return nullptr;
   }
 
diff -r -u --color up/chromium/third_party/blink/public/web/web_navigation_policy.h nw/chromium/third_party/blink/public/web/web_navigation_policy.h
--- up/chromium/third_party/blink/public/web/web_navigation_policy.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_navigation_policy.h	2024-08-26 19:32:29.958587444 +0000
@@ -34,6 +34,7 @@
 namespace blink {
 
 enum WebNavigationPolicy {
+  kWebNavigationPolicyIgnore,
   kWebNavigationPolicyDownload,
   kWebNavigationPolicyCurrentTab,
   kWebNavigationPolicyNewBackgroundTab,
diff -r -u --color up/chromium/third_party/blink/public/web/web_node.h nw/chromium/third_party/blink/public/web/web_node.h
--- up/chromium/third_party/blink/public/web/web_node.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_node.h	2024-08-26 19:32:29.962587445 +0000
@@ -156,8 +156,8 @@
 
   BLINK_EXPORT friend std::ostream& operator<<(std::ostream&, const WebNode&);
 
-#if INSIDE_BLINK
   WebNode(Node*);
+#if INSIDE_BLINK
   WebNode& operator=(Node*);
   operator Node*() const;
 
diff -r -u --color up/chromium/third_party/blink/public/web/web_shared_worker.h nw/chromium/third_party/blink/public/web/web_shared_worker.h
--- up/chromium/third_party/blink/public/web/web_shared_worker.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_shared_worker.h	2024-08-26 19:32:29.962587445 +0000
@@ -51,6 +51,11 @@
 #include "third_party/blink/public/platform/web_policy_container.h"
 #include "third_party/blink/public/platform/web_security_origin.h"
 
+namespace base {
+class SingleThreadTaskRunner;
+class FilePath;
+}
+
 namespace blink {
 
 class MessagePortDescriptor;
@@ -70,6 +75,7 @@
   // starts a worker context.
   // WebSharedWorkerClient given here should own this instance.
   static std::unique_ptr<WebSharedWorker> CreateAndStart(
+      bool nodejs, const base::FilePath& root_path,
       const blink::SharedWorkerToken& token,
       const WebURL& script_url,
       mojom::ScriptType script_type,
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/IDLExtendedAttributes.md nw/chromium/third_party/blink/renderer/bindings/IDLExtendedAttributes.md
--- up/chromium/third_party/blink/renderer/bindings/IDLExtendedAttributes.md	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/IDLExtendedAttributes.md	2024-08-26 19:32:29.966587446 +0000
@@ -34,6 +34,7 @@
 There are a few rules in naming extended attributes:
 
 Names should be aligned with the Web IDL spec as much as possible.
+Extended attributes for custom bindings are prefixed by "Custom".
 Lastly, please do not confuse "_extended_ attributes", which go inside `[...]` and modify various IDL elements, and "attributes", which are of the form `attribute foo` and are interface members.
 
 ## Special cases
@@ -141,6 +142,9 @@
 
 Usage: `[CEReactions]` takes no arguments.
 
+`[CEReacionts]` doesn't work with `[Custom]`. Custom binding code should use
+`blink::CEReactionsScope` if the method or the attribute has `[CEReactions]`.
+
 Note that `blink::CEReactionsScope` must be constructed after `blink::ExceptionState`.
 
 ### [Clamp]
@@ -426,6 +430,8 @@
 };
 ```
 
+`[Replaceable]` is _incompatible_ with `[Custom]` and `[Custom=Setter]` (because replaceable attributes have a single interface-level setter callback, rather than individual attribute-level callbacks); if you need custom binding for a replaceable attribute, remove `[Replaceable]` and `readonly`.
+
 Intuitively, "replaceable" means that you can set a new value to the attribute without overwriting the original value. If you delete the new value, then the original value still remains.
 
 Specifically, a writable attribute, without `[Replaceable]`, behaves as follows:
@@ -1031,7 +1037,7 @@
 
 ## Rare Blink-specific IDL Extended Attributes
 
-These extended attributes are rarely used, generally only in one or two places, and may be candidates for deprecation and removal.
+These extended attributes are rarely used, generally only in one or two places. These are often replacements for `[Custom]` bindings, and may be candidates for deprecation and removal.
 
 ### [CachedAccessor]
 
@@ -1305,6 +1311,112 @@
 
 This is currently only used for the return types of `AsyncIteratorBase` methods. Consult with the bindings team before you use this extended attribute.
 
+### [Custom]
+
+Summary: They allow you to write bindings code manually as you like: full bindings for methods and attributes, certain functions for interfaces.
+
+Custom bindings are _strongly discouraged_. They are likely to be buggy, a source of security holes, and represent a significant maintenance burden. Before using `[Custom]`, you should doubly consider if you really need custom bindings. You are recommended to modify code generators and add specialized extended attributes or special cases if necessary to avoid using `[Custom]`.
+
+Usage: `[Custom]` can be specified on methods or attributes. `[Custom=Getter]` and `[Custom=Setter]` can be specified on attributes. `[Custom=A|B]` can be specified on interfaces, with various values (see below).
+
+On read only attributes (that are not `[Replaceable]`), `[Custom]` is equivalent to `[Custom=Getter]` (since there is no setter) and `[Custom=Getter]` is preferred.
+
+The bindings generator largely _ignores_ the specified type information of `[Custom]` members (signature of methods and type of attributes), but they must be valid types. It is best if the signature exactly matches the spec, but if one of the types is an interface that is not implemented, you can use object as the type instead, to indicate "unspecified object type".
+
+`[Replaceable]` is _incompatible_ with `[Custom]` and `[Custom=Setter]` (because replaceable attributes have a single interface-level setter callback, rather than individual attribute-level callbacks); if you need custom binding for a replaceable attribute, remove `[Replaceable]` and readonly.
+
+```webidl
+[Custom] void func();
+[Custom] attribute DOMString str1;
+[Custom=Getter] readonly attribute DOMString str2;
+[Custom=Setter] attribute DOMString str3;
+```
+
+Before explaining the details, let us clarify the relationship of these IDL attributes.
+
+* `[Custom]` on a method indicates that you can write V8 custom bindings for the method.
+* `[Custom=Getter]` or `[Custom=Setter]` on an attribute means custom bindings for the attribute getter or setter.
+* `[Custom]` on an attribute means custom bindings for both the getter and the setter
+
+Methods:
+
+```webidl
+interface XXX {
+    [Custom] void func();
+};
+```
+
+You can write custom bindings in third_party/blink/renderer/bindings/{core,modules}/v8/custom/v8_xxx_custom.cc:
+
+```c++
+void V8XXX::FuncMethodCustom(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  ...;
+}
+```
+
+Attribute getter:
+
+```webidl
+interface XXX {
+    [Custom=Getter] attribute DOMString str;
+};
+```
+
+You can write custom bindings in Source/bindings/v8/custom/V8XXXCustom.cpp:
+
+```c++
+void V8XXX::StrAttributeGetterCustom(const v8::PropertyCallbackInfo<v8::Value>& info) {
+  ...;
+}
+```
+
+Attribute setter:
+
+```webidl
+interface XXX {
+    [Custom=Setter] attribute DOMString str;
+};
+```
+
+You can write custom bindings in Source/bindings/v8/custom/V8XXXCustom.cpp:
+
+```c++
+void V8XXX::StrAttributeSetterCustom(v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info) {
+  ...;
+}
+```
+
+`[Custom]` may also be specified on special operations:
+
+```webidl
+interface XXX {  // anonymous special operations
+    [Custom] getter Node (unsigned long index);
+    [Custom] setter Node (unsigned long index, Node value);
+    [Custom] deleter boolean (unsigned long index);
+
+    [Custom] getter Node (DOMString name);
+    [Custom] setter Node (DOMString name, Node value);
+    [Custom] deleter boolean (DOMString name);
+}
+interface YYY {  // special operations with identifiers
+    [Custom] getter Node item(unsigned long index);
+    [Custom] getter Node namedItem(DOMString name);
+}
+```
+
+`[Custom]` may also be specified on callback functions:
+
+```webidl
+[Custom] callback SomeCallback = void ();
+interface XXX {
+    void func(SomeCallback callback);
+};
+```
+
+When`[Custom]` is specified on a callback function, the code generator doesn't
+generate bindings for the callback function. The binding layer uses a
+`ScriptValue` instead.
+
 ### [TargetOfExposed]
 
 Summary: Interfaces specified with `[Global]` expose top-level IDL constructs specified with `[Exposed]` as JS data properties, however `[Global]` means a lot more (e.g. global object, named properties object, etc.). Interfaces specified with `[TargetOfExposed]` only expose top-level IDL constructs specified with `[Exposed]` and means nothing else.
@@ -1319,7 +1431,7 @@
 
 Summary: `[PermissiveDictionaryConversion]` relaxes the rules about what types of values may be passed for an argument of dictionary type.
 
-Ordinarily when passing in a value for a dictionary argument, the value must be either undefined, null, or an object. In other words, passing a boolean value like true or false must raise TypeError. The PermissiveDictionaryConversion extended attribute ignores non-object types, treating them the same as undefined and null. In order to effect this change, this extended attribute must be specified both on the dictionary type as well as the arguments of methods where it is passed.
+Ordinarily when passing in a value for a dictionary argument, the value must be either undefined, null, or an object. In other words, passing a boolean value like true or false must raise TypeError. The PermissiveDictionaryConversion extended attribute ignores non-object types, treating them the same as undefined and null. In order to effect this change, this extended attribute must be specified both on the dictionary type as well as the arguments of methods where it is passed. It exists only to eliminate certain custom bindings.
 
 Usage: applies to dictionaries and arguments of methods. Takes no arguments itself.
 
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/README.md nw/chromium/third_party/blink/renderer/bindings/README.md
--- up/chromium/third_party/blink/renderer/bindings/README.md	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/README.md	2024-08-26 19:32:29.966587446 +0000
@@ -35,6 +35,13 @@
 The point is that we should put all the complexity around V8 APIs into
 `Source/bindings/` so that the code ie kept under control of the binding team.
 
+* `Source/bindings/core/v8/custom/` and `Source/bindings/modules/v8/custom/`
+implement custom V8 bindings. Ideally all C++ bindings for Web IDL files
+should be auto-generated by the IDL compiler but there are a number of bindings
+that need some special care. They are written by hand as custom bindings.
+The custom bindings are discouraged. The IDL compiler should be improved so that
+it can auto-generate as much code by the IDL compiler as possible.
+
 ## Resources
 
 * [IDLCompiler.md](IDLCompiler.md)
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/bindings.gni nw/chromium/third_party/blink/renderer/bindings/bindings.gni
--- up/chromium/third_party/blink/renderer/bindings/bindings.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/bindings.gni	2024-08-26 19:32:29.966587446 +0000
@@ -29,6 +29,9 @@
                     "core/v8/callback_promise_adapter.h",
                     "core/v8/capture_source_location.cc",
                     "core/v8/capture_source_location.h",
+                    "core/v8/custom/v8_html_iframe_element_custom.cc",
+                    "core/v8/custom/v8_filelist_custom.cc",
+                    "core/v8/custom/v8_window_custom.cc",
                     "core/v8/dictionary.cc",
                     "core/v8/dictionary.h",
                     "core/v8/frozen_array.h",
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/core/v8/binding_security.cc nw/chromium/third_party/blink/renderer/bindings/core/v8/binding_security.cc
--- up/chromium/third_party/blink/renderer/bindings/core/v8/binding_security.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/core/v8/binding_security.cc	2024-08-26 19:32:29.966587446 +0000
@@ -148,12 +148,14 @@
       // Assert that because the agent clusters are different than the
       // WindowAgentFactories must also be different unless they differ in
       // being explicitly origin keyed.
+      /* it's OK to disable the assertion in NW because the logic is
+         different, plus the access is disallowed.
       SECURITY_CHECK(
           !IsSameWindowAgentFactory(accessing_window, local_target_window) ||
           (accessing_window->GetAgent()->IsOriginKeyedForInheritance() !=
            local_target_window->GetAgent()->IsOriginKeyedForInheritance()) ||
           (WebTestSupport::IsRunningWebTest() &&
-           local_target_window->GetFrame()->PagePopupOwner()));
+          local_target_window->GetFrame()->PagePopupOwner())); */
 
       *cross_document_access =
           DOMWindow::CrossDocumentAccessPolicy::kDisallowed;
@@ -310,6 +312,9 @@
   CHECK(target);
 
   auto* local_dom_window = CurrentDOMWindow(isolate);
+  auto* frame = local_dom_window->GetFrame();
+  if (frame && frame->isNodeJS())
+    return;
   // Determine if the access check failure was because of cross-origin or if the
   // WindowAgentFactory is different. If the WindowAgentFactories are different
   // so report the error as "restricted" instead of "cross-origin".
Only in nw/chromium/third_party/blink/renderer/bindings/core/v8: custom
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/core/v8/v8_initializer.cc nw/chromium/third_party/blink/renderer/bindings/core/v8/v8_initializer.cc
--- up/chromium/third_party/blink/renderer/bindings/core/v8/v8_initializer.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/core/v8/v8_initializer.cc	2024-08-26 19:32:29.986587451 +0000
@@ -32,6 +32,7 @@
 
 #include <algorithm>
 #include <limits>
+#include "third_party/node-nw/src/node_webkit.h"
 #include <memory>
 #include <utility>
 
@@ -113,6 +114,13 @@
 #include "gin/public/v8_snapshot_file_type.h"
 #endif
 
+#if defined(OS_WIN)
+#include <windows.h>
+#endif
+
+extern VoidHookFn g_promise_reject_callback_fn;
+
+
 namespace blink {
 
 #if BUILDFLAG(IS_WIN)
@@ -265,6 +273,12 @@
   v8::Isolate* isolate = script_state->GetIsolate();
   ExecutionContext* context = ExecutionContext::From(script_state);
 
+#if 0 //FIXME (#4577)
+  LocalDOMWindow* window = currentDOMWindow(isolate);
+  if (window->frame()->isNodeJS() && g_promise_reject_callback_fn)
+    g_promise_reject_callback_fn(&data);
+#endif
+
   v8::Local<v8::Value> exception = data.GetValue();
   if (V8PerIsolateData::From(isolate)->HasInstance(
           DOMException::GetStaticWrapperTypeInfo(), exception)) {
@@ -808,6 +822,10 @@
 }
 
 namespace {
+#if defined(OS_WIN)
+HANDLE _process_heap;
+#endif
+
 class ArrayBufferAllocator : public v8::ArrayBuffer::Allocator {
  public:
   ArrayBufferAllocator() : total_allocation_(0) {
@@ -859,6 +877,18 @@
     ArrayBufferContents::FreeMemory(data);
   }
 
+  void Free(void* data, size_t length, AllocationMode mode) override {
+    if (mode == AllocationMode::kNodeJS) {
+#if defined(OS_WIN)
+        ::HeapFree(_process_heap, 0, data);
+#else
+        free(data);
+#endif
+        return;
+    } else
+      Free(data, length);
+  }
+
  private:
   // Total memory allocated in bytes.
   std::atomic_size_t total_allocation_;
@@ -885,6 +915,9 @@
     const intptr_t* reference_table,
     const std::string js_command_line_flags) {
   DEFINE_STATIC_LOCAL(ArrayBufferAllocator, array_buffer_allocator, ());
+#if defined(OS_WIN)
+  _process_heap = ::GetProcessHeap();
+#endif
   gin::IsolateHolder::Initialize(gin::IsolateHolder::kNonStrictMode,
                                  &array_buffer_allocator, reference_table,
                                  js_command_line_flags, ReportV8FatalError,
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy.h nw/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy.h
--- up/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy.h	2024-08-26 19:32:29.986587451 +0000
@@ -167,6 +167,7 @@
   virtual bool IsLocal() const { return false; }
 
   enum FrameReuseStatus { kFrameWillNotBeReused, kFrameWillBeReused };
+  bool ContextNotReady() const { return lifecycle_ == Lifecycle::kContextIsUninitialized;}
 
  protected:
   // Lifecycle represents the following four states.
@@ -262,7 +263,6 @@
 
   v8::Isolate* GetIsolate() const { return isolate_; }
   Frame* GetFrame() const { return frame_.Get(); }
-
 #if DCHECK_IS_ON()
   void DidAttachGlobalObject() { is_global_object_attached_ = true; }
   void DidDetachGlobalObject() { is_global_object_attached_ = false; }
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy_manager.h nw/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy_manager.h
--- up/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy_manager.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy_manager.h	2024-08-26 19:32:29.986587451 +0000
@@ -48,6 +48,11 @@
   void ReleaseGlobalProxies(GlobalProxyVector&);
   void SetGlobalProxies(const GlobalProxyVector&);
 
+  bool ContextNotReady(DOMWrapperWorld& world) {
+    WindowProxy* window_proxy = WindowProxyMaybeUninitialized(world);
+    return window_proxy->ContextNotReady();
+  }
+
   WindowProxy* GetWindowProxy(DOMWrapperWorld& world) {
     WindowProxy* window_proxy = WindowProxyMaybeUninitialized(world);
     window_proxy->InitializeIfNeeded();
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py nw/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py
--- up/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py	2024-08-26 19:32:29.994587453 +0000
@@ -218,6 +218,28 @@
     return name_style.constant(property_name)
 
 
+def custom_function_name(cg_context):
+    assert isinstance(cg_context, CodeGenContext)
+
+    if cg_context.named_property_getter:
+        return "NamedPropertyGetterCustom"
+    if cg_context.named_property_setter:
+        return "NamedPropertySetterCustom"
+    if cg_context.named_property_deleter:
+        return "NamedPropertyDeleterCustom"
+
+    if cg_context.attribute_get:
+        suffix = "AttributeGetterCustom"
+    elif cg_context.attribute_set:
+        suffix = "AttributeSetterCustom"
+    elif cg_context.operation_group:
+        suffix = "MethodCustom"
+    else:
+        assert False
+
+    return name_style.func(cg_context.property_.identifier, suffix)
+
+
 # ----------------------------------------------------------------------------
 # Callback functions
 # ----------------------------------------------------------------------------
@@ -1979,6 +2001,18 @@
         EmptyNode(),
         make_check_coop_restrict_properties_access(cg_context),
         EmptyNode(),
+    ])
+
+    if "Getter" in cg_context.property_.extended_attributes.values_of(
+            "Custom"):
+        text = _format("${class_name}::{}(${info});",
+                       custom_function_name(cg_context))
+        body.append(TextNode(text))
+        if cg_context.is_interceptor_returning_v8intercepted:
+            body.append(TextNode("return v8::Intercepted::kYes;"))
+        return func_def
+
+    body.extend([
         make_return_value_cache_return_early(cg_context),
         EmptyNode(),
         make_check_security_of_return_value(cg_context),
@@ -2022,6 +2056,13 @@
         EmptyNode(),
     ])
 
+    if "Setter" in cg_context.property_.extended_attributes.values_of(
+            "Custom"):
+        text = _format("${class_name}::{}(${v8_property_value}, ${info});",
+                       custom_function_name(cg_context))
+        body.append(TextNode(text))
+        return func_def
+
     # Binary size reduction hack
     # 1. Drop the check of argument length although this is a violation of
     #   Web IDL.
@@ -2257,7 +2298,12 @@
         EmptyNode(),
     ])
 
-    if "HTMLConstructor" in cg_context.constructor.extended_attributes:
+    if "Custom" in cg_context.constructor.extended_attributes:
+        body.append(T("// [Custom Constructor]"))
+        text = _format(
+            "${class_name}::ConstructorCustom(${info});")
+        body.append(T(text))
+    elif "HTMLConstructor" in cg_context.constructor.extended_attributes:
         body.append(T("// [HTMLConstructor]"))
         text = _format(
             "V8HTMLConstructor::HtmlConstructor("
@@ -2643,6 +2689,15 @@
         EmptyNode(),
         make_check_coop_restrict_properties_access(cg_context),
         EmptyNode(),
+    ])
+
+    if "Custom" in cg_context.property_.extended_attributes:
+        text = _format("${class_name}::{}(${info});",
+                       custom_function_name(cg_context))
+        body.append(TextNode(text))
+        return func_def
+
+    body.extend([
         make_check_argument_length(cg_context),
         EmptyNode(),
         make_steps_of_ce_reactions(cg_context),
@@ -2661,6 +2716,9 @@
 
     operation_group = cg_context.operation_group
 
+    assert (not ("Custom" in operation_group.extended_attributes)
+            or len(operation_group) == 1)
+
     nodes = SequenceNode()
     if "NoAllocDirectCall" in operation_group.extended_attributes:
         for entry in list_no_alloc_direct_call_callbacks(cg_context):
@@ -3159,6 +3217,12 @@
     bind_return_value(
         body, cg_context, overriding_args=["${blink_property_name}"])
 
+    if "Custom" in cg_context.named_property_getter.extended_attributes:
+        text = _format("${class_name}::{}(${blink_property_name}, ${info});",
+                       custom_function_name(cg_context))
+        body.append(TextNode(text))
+        return func_decl, func_def
+
     # The named property getter's implementation of Blink is not designed to
     # represent the property existence, and we have to determine the property
     # existence by heuristics.
@@ -3297,6 +3361,14 @@
             argument=cg_context.named_property_setter.arguments[1],
             error_exit_return_statement="return v8::Intercepted::kYes;"))
 
+    if "Custom" in cg_context.named_property_setter.extended_attributes:
+        text = _format(
+            "${class_name}::{}"
+            "(${blink_property_name}, ${v8_property_value}, ${info});",
+            custom_function_name(cg_context))
+        body.append(TextNode(text))
+        return func_decl, func_def
+
     body.extend([
         TextNode("""\
 // 3.9.2. [[Set]]
@@ -3414,6 +3486,12 @@
     bind_return_value(
         body, cg_context, overriding_args=["${blink_property_name}"])
 
+    if "Custom" in cg_context.named_property_deleter.extended_attributes:
+        text = _format("${class_name}::{}(${blink_property_name}, ${info});",
+                       custom_function_name(cg_context))
+        body.append(TextNode(text))
+        return func_decl, func_def
+
     body.extend([
         TextNode("""\
 // 3.9.4. [[Delete]]
@@ -6797,6 +6875,92 @@
             constants_def.public_section.append(
                 make_constant_constant_def(cgc, constant_name(cgc)))
 
+    # Custom callback implementations
+    custom_callback_impl_decls = ListNode()
+
+    def add_custom_callback_impl_decl(**params):
+        arg_decls = params.pop("arg_decls")
+        name = params.pop("name", None)
+        if name is None:
+            name = custom_function_name(cg_context.make_copy(**params))
+        custom_callback_impl_decls.append(
+            CxxFuncDeclNode(
+                name=name,
+                arg_decls=arg_decls,
+                return_type="void",
+                static=True))
+
+    for attribute in class_like.attributes:
+        custom_values = attribute.extended_attributes.values_of("Custom")
+        is_cross_origin = "CrossOrigin" in attribute.extended_attributes
+        cross_origin_values = attribute.extended_attributes.values_of(
+            "CrossOrigin")
+        if "Getter" in custom_values:
+            add_custom_callback_impl_decl(
+                attribute=attribute,
+                attribute_get=True,
+                arg_decls=["const v8::FunctionCallbackInfo<v8::Value>&"])
+            if is_cross_origin and (not cross_origin_values
+                                    or "Getter" in cross_origin_values):
+                add_custom_callback_impl_decl(
+                    attribute=attribute,
+                    attribute_get=True,
+                    arg_decls=["const v8::PropertyCallbackInfo<v8::Value>&"])
+        if "Setter" in custom_values:
+            add_custom_callback_impl_decl(
+                attribute=attribute,
+                attribute_set=True,
+                arg_decls=[
+                    "v8::Local<v8::Value>",
+                    "const v8::FunctionCallbackInfo<v8::Value>&",
+                ])
+            if is_cross_origin and "Setter" in cross_origin_values:
+                add_custom_callback_impl_decl(
+                    attribute=attribute,
+                    attribute_set=True,
+                    arg_decls=[
+                        "v8::Local<v8::Value>",
+                        "const v8::PropertyCallbackInfo<void>&",
+                    ])
+    for operation_group in class_like.operation_groups:
+        if "Custom" in operation_group.extended_attributes:
+            add_custom_callback_impl_decl(
+                operation_group=operation_group,
+                arg_decls=["const v8::FunctionCallbackInfo<v8::Value>&"])
+    for constructor_group in class_like.constructor_groups:
+        if "Custom" in constructor_group.extended_attributes:
+            add_custom_callback_impl_decl(
+                name="ConstructorCustom",
+                constructor_group=constructor_group,
+                arg_decls=["const v8::FunctionCallbackInfo<v8::Value>&"])
+    if interface and interface.indexed_and_named_properties:
+        props = interface.indexed_and_named_properties
+        operation = props.own_named_getter
+        if operation and "Custom" in operation.extended_attributes:
+            add_custom_callback_impl_decl(
+                named_property_getter=operation,
+                arg_decls=[
+                    "const AtomicString& property_name",
+                    "const v8::PropertyCallbackInfo<v8::Value>&",
+                ])
+        operation = props.own_named_setter
+        if operation and "Custom" in operation.extended_attributes:
+            add_custom_callback_impl_decl(
+                named_property_setter=operation,
+                arg_decls=[
+                    "const AtomicString& property_name",
+                    "v8::Local<v8::Value> v8_property_value",
+                    "const v8::PropertyCallbackInfo<v8::Value>&",
+                ])
+        operation = props.own_named_deleter
+        if operation and "Custom" in operation.extended_attributes:
+            add_custom_callback_impl_decl(
+                named_property_deleter=operation,
+                arg_decls=[
+                    "const AtomicString& property_name",
+                    "const v8::PropertyCallbackInfo<v8::Value>&",
+                ])
+
     # Cross-component trampolines
     if is_cross_components:
         # tp_ = trampoline name
@@ -7127,6 +7291,13 @@
         api_class_def.public_section.append(installer_function_decls)
         api_class_def.public_section.append(EmptyNode())
 
+    if custom_callback_impl_decls:
+        api_class_def.public_section.extend([
+            TextNode("// Custom callback implementations"),
+            custom_callback_impl_decls,
+            EmptyNode(),
+        ])
+
     if indexed_and_named_property_decls:
         api_class_def.public_section.extend([
             TextNode("// Indexed properties and named properties"),
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/scripts/validator/rules/supported_extended_attributes.py nw/chromium/third_party/blink/renderer/bindings/scripts/validator/rules/supported_extended_attributes.py
--- up/chromium/third_party/blink/renderer/bindings/scripts/validator/rules/supported_extended_attributes.py	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/scripts/validator/rules/supported_extended_attributes.py	2024-08-26 19:32:29.998587454 +0000
@@ -78,6 +78,10 @@
         E("CrossOriginIsolatedOrRuntimeEnabled",
           applicable_to=T_EXPOSURE,
           forms=[F.IDENT]),
+        E("Custom",
+          applicable_to=[T.ATTRIBUTE, T.OPERATION, T.CONSTRUCTOR],
+          forms=[F.NO_ARGS, F.IDENT],
+          values=["Getter", "Setter"]),
         E("DeprecateAs",
           applicable_to=[
               T.ATTRIBUTE, T.CONSTANT, T.CONSTRUCTOR, T.DICTIONARY_MEMBER,
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/scripts/web_idl/idl_compiler.py nw/chromium/third_party/blink/renderer/bindings/scripts/web_idl/idl_compiler.py
--- up/chromium/third_party/blink/renderer/bindings/scripts/web_idl/idl_compiler.py	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/scripts/web_idl/idl_compiler.py	2024-08-26 19:32:29.998587454 +0000
@@ -707,7 +707,7 @@
                         OperationGroup.IR, item.operations)
 
     def _propagate_extattrs_to_overload_group(self):
-        ANY_OF = ('CrossOrigin', 'CrossOriginIsolated', 'InjectionMitigated',
+        ANY_OF = ('CrossOrigin', 'CrossOriginIsolated', 'InjectionMitigated', 'Custom',
                   'IsolatedContext', 'LegacyLenientThis', 'LegacyUnforgeable',
                   'NotEnumerable', 'PerWorldBindings', 'SecureContext',
                   'Unscopable')
diff -r -u --color up/chromium/third_party/blink/renderer/core/BUILD.gn nw/chromium/third_party/blink/renderer/core/BUILD.gn
--- up/chromium/third_party/blink/renderer/core/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/BUILD.gn	2024-08-26 19:32:30.010587457 +0000
@@ -236,7 +236,7 @@
   output_name = "blink_core"
 
   visibility = []  # Allow re-assignment of list.
-  visibility = [ "//third_party/blink/*" ]
+  visibility = [ "//third_party/blink/*", "//content/nw/*" ]
 
   sources = [
     "core_initializer.cc",
diff -r -u --color up/chromium/third_party/blink/renderer/core/dom/document.cc nw/chromium/third_party/blink/renderer/core/dom/document.cc
--- up/chromium/third_party/blink/renderer/core/dom/document.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/dom/document.cc	2024-08-26 19:32:30.126587487 +0000
@@ -6516,14 +6516,14 @@
   if (!GetFrame())
     return scoped_refptr<const SecurityOrigin>();
 
-  return GetFrame()->Tree().Top().GetSecurityContext()->GetSecurityOrigin();
+  return GetFrame()->Tree().FindFrameByName(WebString::FromUTF8("_top"), true)->GetSecurityContext()->GetSecurityOrigin();
 }
 
 net::SiteForCookies Document::SiteForCookies() const {
   if (!GetFrame())
     return net::SiteForCookies();
 
-  Frame& top = GetFrame()->Tree().Top();
+  Frame& top = *GetFrame()->Tree().FindFrameByName(WebString::FromUTF8("_top"), true);
   const SecurityOrigin* origin = top.GetSecurityContext()->GetSecurityOrigin();
   // TODO(yhirano): Ideally |origin| should not be null here.
   if (!origin)
@@ -6558,6 +6558,8 @@
   }
 
   while (current_frame) {
+    if (current_frame->isNwFakeTop())
+      break;
     const url::Origin cur_security_origin =
         current_frame->GetSecurityContext()->GetSecurityOrigin()->ToUrlOrigin();
     if (!candidate.CompareWithFrameTreeOriginAndRevise(cur_security_origin))
diff -r -u --color up/chromium/third_party/blink/renderer/core/editing/commands/clipboard_commands.cc nw/chromium/third_party/blink/renderer/core/editing/commands/clipboard_commands.cc
--- up/chromium/third_party/blink/renderer/core/editing/commands/clipboard_commands.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/editing/commands/clipboard_commands.cc	2024-08-26 19:32:30.150587493 +0000
@@ -115,6 +115,8 @@
                                          EditorCommandSource source) {
   if (source == EditorCommandSource::kMenuOrKeyBinding)
     return true;
+  if (frame.isNodeJS())
+    return true;
   Settings* const settings = frame.GetSettings();
   if (settings && settings->GetJavaScriptCanAccessClipboard() &&
       settings->GetDOMPasteAllowed()) {
@@ -128,6 +130,8 @@
                                           EditorCommandSource source) {
   if (source == EditorCommandSource::kMenuOrKeyBinding)
     return true;
+  if (frame.isNodeJS())
+    return true;
   Settings* const settings = frame.GetSettings();
   if ((settings && settings->GetJavaScriptCanAccessClipboard()) ||
       LocalFrame::HasTransientUserActivation(&frame)) {
@@ -153,6 +157,8 @@
 }
 
 bool ClipboardCommands::CanSmartReplaceInClipboard(LocalFrame& frame) {
+  //if (frame.isNodeJS())
+  //  return true; //commented out for NWJS#7363
   return frame.GetEditor().SmartInsertDeleteEnabled() &&
          frame.GetSystemClipboard()->IsFormatAvailable(
              blink::mojom::ClipboardFormat::kSmartPaste);
diff -r -u --color up/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.cc nw/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.cc
--- up/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.cc	2024-08-26 19:32:30.198587505 +0000
@@ -39,6 +39,17 @@
 #include "services/network/public/mojom/fetch_api.mojom-shared.h"
 #include "third_party/blink/public/common/loader/worker_main_script_load_parameters.h"
 #include "third_party/blink/public/mojom/browser_interface_broker.mojom-blink.h"
+
+#include "third_party/node-nw/src/node_webkit.h"
+#define BLINK_HOOK_MAP(type, sym, fn) extern type fn;
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
 #include "third_party/blink/public/mojom/devtools/devtools_agent.mojom-blink.h"
 #include "third_party/blink/public/mojom/loader/fetch_client_settings_object.mojom-blink.h"
 #include "third_party/blink/public/mojom/script/script_type.mojom-blink.h"
@@ -187,7 +198,7 @@
   scope->Connect(std::move(channel));
 }
 
-void WebSharedWorkerImpl::StartWorkerContext(
+void WebSharedWorkerImpl::StartWorkerContext(bool nodejs, const base::FilePath& root_path,
     const WebURL& script_request_url,
     mojom::blink::ScriptType script_type,
     network::mojom::CredentialsMode credentials_mode,
@@ -214,6 +225,15 @@
   DCHECK(web_worker_fetch_context);
   CHECK(constructor_origin.Get()->CanAccessSharedWorkers());
 
+  nodejs_ = nodejs;
+  root_path_ = root_path;
+
+  std::string main_script = root_path_.AsUTF8Unsafe();
+  KURL req_url = script_request_url;
+  if (g_web_worker_start_thread_fn && nodejs_) {
+    (*g_web_worker_start_thread_fn)(nullptr, (void*)req_url.GetPath().Utf8().data(), &main_script, &nodejs_);
+  }
+
   // Creates 'outside settings' used in the "Processing model" algorithm in the
   // HTML spec:
   // https://html.spec.whatwg.org/C/#worker-processing-model
@@ -242,7 +262,7 @@
   // Some params (e.g. address space) passed to GlobalScopeCreationParams are
   // dummy values. They will be updated after worker script fetch on the worker
   // thread.
-  auto creation_params = std::make_unique<GlobalScopeCreationParams>(
+  auto creation_params = std::make_unique<GlobalScopeCreationParams>(nodejs_, main_script,
       script_request_url, script_type, name, user_agent, ua_metadata,
       std::move(web_worker_fetch_context),
       ConvertToMojoBlink(content_security_policies),
@@ -326,6 +346,8 @@
 }
 
 std::unique_ptr<WebSharedWorker> WebSharedWorker::CreateAndStart(
+                                                                 bool nodejs,
+                                                                 const base::FilePath& main_script,
     const blink::SharedWorkerToken& token,
     const WebURL& script_request_url,
     mojom::blink::ScriptType script_type,
@@ -353,7 +375,7 @@
     bool require_cross_site_request_for_cookies) {
   auto worker =
       base::WrapUnique(new WebSharedWorkerImpl(token, std::move(host), client));
-  worker->StartWorkerContext(
+  worker->StartWorkerContext(nodejs, main_script,
       script_request_url, script_type, credentials_mode, name,
       constructor_origin, is_constructor_secure_context, user_agent,
       ua_metadata, content_security_policies,
diff -r -u --color up/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.h nw/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.h
--- up/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.h	2024-08-26 19:32:30.198587505 +0000
@@ -35,6 +35,7 @@
 
 #include <memory>
 
+#include "base/files/file_path.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/memory/weak_ptr.h"
 #include "base/task/single_thread_task_runner.h"
@@ -97,6 +98,7 @@
       WebSharedWorkerClient*);
 
   void StartWorkerContext(
+                          bool, const base::FilePath&,
       const WebURL&,
       mojom::blink::ScriptType,
       network::mojom::CredentialsMode,
@@ -147,6 +149,8 @@
 
   bool running_ = false;
   bool asked_to_terminate_ = false;
+  bool nodejs_;
+  base::FilePath root_path_;
 
   base::WeakPtrFactory<WebSharedWorkerImpl> weak_ptr_factory_{this};
 };
diff -r -u --color up/chromium/third_party/blink/renderer/core/exported/web_view_impl.cc nw/chromium/third_party/blink/renderer/core/exported/web_view_impl.cc
--- up/chromium/third_party/blink/renderer/core/exported/web_view_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/exported/web_view_impl.cc	2024-08-26 19:32:30.198587505 +0000
@@ -402,6 +402,8 @@
       return ui::mojom::blink::WindowOpenDisposition::NEW_PICTURE_IN_PICTURE;
     case kNavigationPolicyLinkPreview:
       NOTREACHED_NORETURN();
+    case kNavigationPolicyIgnore:
+      return ui::mojom::blink::WindowOpenDisposition::IGNORE_ACTION;
   }
   NOTREACHED_IN_MIGRATION() << "Unexpected NavigationPolicy";
   return ui::mojom::blink::WindowOpenDisposition::IGNORE_ACTION;
@@ -3065,12 +3067,17 @@
                        NavigationPolicy policy,
                        const gfx::Rect& requested_rect,
                        const gfx::Rect& adjusted_rect,
-                       bool opened_by_user_gesture) {
+                       bool opened_by_user_gesture, WebString* manifest) {
   // This is only called on local main frames.
   DCHECK(local_main_frame_host_remote_);
   DCHECK(web_widget_);
   web_widget_->SetPendingWindowRect(adjusted_rect);
   const WebWindowFeatures& web_window_features = page_->GetWindowFeatures();
+  WTF::String mnft;
+  if (!manifest || manifest->IsNull())
+    mnft = "";
+  else
+    mnft = *manifest;
   mojom::blink::WindowFeaturesPtr window_features =
       mojom::blink::WindowFeatures::New();
   window_features->bounds = requested_rect;
@@ -3082,6 +3089,7 @@
   local_main_frame_host_remote_->ShowCreatedWindow(
       opener_frame_token, NavigationPolicyToDisposition(policy),
       std::move(window_features), opened_by_user_gesture,
+      mnft,
       WTF::BindOnce(&WebViewImpl::DidShowCreatedWindow, WTF::Unretained(this)));
 
   MainFrameDevToolsAgentImpl()->DidShowNewWindow();
diff -r -u --color up/chromium/third_party/blink/renderer/core/exported/web_view_impl.h nw/chromium/third_party/blink/renderer/core/exported/web_view_impl.h
--- up/chromium/third_party/blink/renderer/core/exported/web_view_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/exported/web_view_impl.h	2024-08-26 19:32:30.198587505 +0000
@@ -587,7 +587,7 @@
             NavigationPolicy policy,
             const gfx::Rect& requested_rect,
             const gfx::Rect& adjusted_rect,
-            bool opened_by_user_gesture);
+            bool opened_by_user_gesture, WebString* manifest);
 
   // Send the window rect to the browser and call `ack_callback` when the
   // browser has processed it.
diff -r -u --color up/chromium/third_party/blink/renderer/core/exported/web_view_test.cc nw/chromium/third_party/blink/renderer/core/exported/web_view_test.cc
--- up/chromium/third_party/blink/renderer/core/exported/web_view_test.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/exported/web_view_test.cc	2024-08-26 19:32:30.202587506 +0000
@@ -4094,7 +4094,8 @@
       bool& consumed_user_gesture,
       const std::optional<Impression>&,
       const std::optional<WebPictureInPictureWindowOptions>&,
-      const WebURL&) override {
+      const WebURL&,
+      WebString*) override {
     return web_view_helper_.InitializeWithOpener(Frame());
   }
   WebView* CreatedWebView() const { return web_view_helper_.GetWebView(); }
diff -r -u --color up/chromium/third_party/blink/renderer/core/fileapi/file.h nw/chromium/third_party/blink/renderer/core/fileapi/file.h
--- up/chromium/third_party/blink/renderer/core/fileapi/file.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/fileapi/file.h	2024-08-26 19:32:30.206587507 +0000
@@ -66,6 +66,10 @@
                       const HeapVector<Member<V8BlobPart>>& file_bits,
                       const String& file_name,
                       const FilePropertyBag* options);
+  static File* Create(ExecutionContext* c, const String& path, const String& name)
+   {
+     return CreateForUserProvidedFile(c, path, name);
+   }
 
   // For deserialization.
   static File* CreateFromSerialization(
@@ -219,7 +223,7 @@
     return path_;
   }
   const String& name() const { return name_; }
-
+  const String& path() const { return path_; }
   // Getter for the lastModified IDL attribute,
   // http://dev.w3.org/2006/webapi/FileAPI/#file-attrs
   // This method calls CaptureSnapshotIfNeeded, and thus can involve synchronous
diff -r -u --color up/chromium/third_party/blink/renderer/core/fileapi/file.idl nw/chromium/third_party/blink/renderer/core/fileapi/file.idl
--- up/chromium/third_party/blink/renderer/core/fileapi/file.idl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/fileapi/file.idl	2024-08-26 19:32:30.206587507 +0000
@@ -30,8 +30,10 @@
     Serializable
 ] interface File : Blob {
     [CallWith=ExecutionContext] constructor(sequence<BlobPart> fileBits, USVString fileName, optional FilePropertyBag options = {});
+    [CallWith=ExecutionContext] constructor(DOMString path, DOMString name);
     readonly attribute DOMString name;
     readonly attribute long long lastModified;
+    readonly attribute DOMString path;
 
     // Non-standard APIs
     [MeasureAs=FileGetLastModifiedDate, CallWith=ScriptState] readonly attribute object lastModifiedDate;
diff -r -u --color up/chromium/third_party/blink/renderer/core/fileapi/file_list.h nw/chromium/third_party/blink/renderer/core/fileapi/file_list.h
--- up/chromium/third_party/blink/renderer/core/fileapi/file_list.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/fileapi/file_list.h	2024-08-26 19:32:30.206587507 +0000
@@ -49,6 +49,7 @@
 
   bool IsEmpty() const { return files_.empty(); }
   void clear() { files_.clear(); }
+  void append(File* file) { Append(file); }
   void Append(File* file) { files_.push_back(file); }
   Vector<base::FilePath> PathsForUserVisibleFiles() const;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/fileapi/file_list.idl nw/chromium/third_party/blink/renderer/core/fileapi/file_list.idl
--- up/chromium/third_party/blink/renderer/core/fileapi/file_list.idl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/fileapi/file_list.idl	2024-08-26 19:32:30.206587507 +0000
@@ -29,6 +29,9 @@
     Exposed=(Window,Worker),
     Serializable
 ] interface FileList {
+    [Custom] constructor();
     getter File? item(unsigned long index);
     readonly attribute unsigned long length;
+    void clear();
+    void append(File item);
 };
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/csp/content_security_policy.cc nw/chromium/third_party/blink/renderer/core/frame/csp/content_security_policy.cc
--- up/chromium/third_party/blink/renderer/core/frame/csp/content_security_policy.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/csp/content_security_policy.cc	2024-08-26 19:32:30.214587509 +0000
@@ -1414,6 +1414,10 @@
   if (!context)
     return false;
 
+  if (const_cast<ExecutionContext*>(context)->GetSecurityOrigin() &&
+      const_cast<ExecutionContext*>(context)->GetSecurityOrigin()->hasUniversalAccess())
+    return true;
+
   return ShouldBypassMainWorldDeprecated(context->GetCurrentWorld());
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/frame.cc nw/chromium/third_party/blink/renderer/core/frame/frame.cc
--- up/chromium/third_party/blink/renderer/core/frame/frame.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/frame.cc	2024-08-26 19:32:30.218587510 +0000
@@ -106,6 +106,8 @@
   visitor->Trace(navigation_rate_limiter_);
   visitor->Trace(window_agent_factory_);
   visitor->Trace(opened_frame_tracker_);
+  visitor->Trace(dev_jail_owner_);
+  visitor->Trace(devtools_jail_);
 }
 
 bool Frame::Detach(FrameDetachType type) {
@@ -178,6 +180,11 @@
   page_ = nullptr;
   embedding_token_ = std::nullopt;
 
+  if (dev_jail_owner_) {
+    dev_jail_owner_->setDevtoolsJail(nullptr);
+    dev_jail_owner_ = nullptr;
+  }
+
   return true;
 }
 
@@ -282,6 +289,10 @@
   return window_proxy_manager_->GetWindowProxyMaybeUninitialized(world);
 }
 
+bool Frame::ContextNotReady(DOMWrapperWorld& world) const {
+  return window_proxy_manager_->ContextNotReady(world);
+}
+
 void Frame::DidChangeVisibilityState() {
   HeapVector<Member<Frame>> child_frames;
   for (Frame* child = Tree().FirstChild(); child;
@@ -538,7 +549,10 @@
       window_agent_factory_(inheriting_agent_factory
                                 ? inheriting_agent_factory
                                 : MakeGarbageCollected<WindowAgentFactory>(
-                                      page.GetAgentGroupScheduler())),
+									   page.GetAgentGroupScheduler())),
+      devtools_jail_(nullptr),
+      dev_jail_owner_(nullptr),
+      nodejs_(false),
       is_loading_(false),
       devtools_frame_token_(devtools_frame_token),
       frame_token_(frame_token) {
@@ -577,6 +591,8 @@
   // for frames with a remote owner.
   auto* owner = To<RemoteFrameOwner>(Owner());
 
+  owner->set_nwfaketop(properties->nwfaketop);
+  owner->set_nwuseragent(properties->nwuseragent);
   owner->SetBrowsingContextContainerName(properties->name);
   owner->SetScrollbarMode(properties->scrollbar_mode);
   owner->SetMarginWidth(properties->margin_width);
@@ -1023,4 +1039,42 @@
   return resources;
 }
 
-}  // namespace blink
+bool Frame::isNwDisabledChildFrame() const
+{
+  const Frame* current_frame = this;
+  const Frame* ancestor_frame = Tree().Parent();
+  do {
+    if (current_frame->owner_) {
+      if (current_frame->owner_->IsLocal())
+        if (DynamicTo<HTMLFrameOwnerElement>(current_frame->Owner())->FastHasAttribute(html_names::kNwdisableAttr))
+          return true;
+    }
+    current_frame = ancestor_frame;
+    if (ancestor_frame)
+      ancestor_frame = ancestor_frame->Tree().Parent();
+  } while (current_frame);
+  return false;
+}
+
+void Frame::setDevtoolsJail(Frame* iframe)
+{
+  devtools_jail_ = iframe;
+  if (iframe)
+    iframe->dev_jail_owner_ = this;
+  else if (devtools_jail_)
+    devtools_jail_->dev_jail_owner_ = nullptr;
+}
+
+bool Frame::isNwFakeTop() const
+{
+  if (owner_) {
+    if (owner_->IsLocal())
+      if (DynamicTo<HTMLFrameOwnerElement>(Owner())->FastHasAttribute(html_names::kNwfaketopAttr))
+        return true;
+  }
+  return false;
+}
+
+
+} // namespace blink
+
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/frame.h nw/chromium/third_party/blink/renderer/core/frame/frame.h
--- up/chromium/third_party/blink/renderer/core/frame/frame.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/frame.h	2024-08-26 19:32:30.218587510 +0000
@@ -109,6 +109,10 @@
   static Frame* ResolveFrame(const FrameToken& frame_token);
 
   virtual ~Frame();
+  void setNodeJS(bool node) { nodejs_ = node; }
+  bool isNodeJS() const { return nodejs_; }
+  bool isNwDisabledChildFrame() const;
+  bool isNwFakeTop() const;
 
   virtual void Trace(Visitor*) const;
 
@@ -131,6 +135,10 @@
   // on successful completion (e.g. `Detach()` runs all the way through to the
   // end), returns true.
   bool Detach(FrameDetachType);
+
+  void setDevtoolsJail(Frame* iframe);
+  Frame* getDevtoolsJail() { return devtools_jail_; }
+
   void DisconnectOwnerElement();
   virtual bool ShouldClose() = 0;
   virtual void HookBackForwardCacheEviction() = 0;
@@ -237,6 +245,7 @@
   }
   WindowProxy* GetWindowProxy(DOMWrapperWorld&);
   WindowProxy* GetWindowProxyMaybeUninitialized(DOMWrapperWorld&);
+  bool ContextNotReady(DOMWrapperWorld& world) const;
 
   virtual void DidChangeVisibilityState();
 
@@ -563,6 +572,9 @@
   Member<WindowAgentFactory> window_agent_factory_;
 
   // TODO(sashab): Investigate if this can be represented with m_lifecycle.
+  Member<Frame> devtools_jail_;
+  Member<Frame> dev_jail_owner_;
+  bool nodejs_;
   bool is_loading_;
   // Contains token to be used as a frame id in the devtools protocol.
   base::UnguessableToken devtools_frame_token_;
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/frame_owner.h nw/chromium/third_party/blink/renderer/core/frame/frame_owner.h
--- up/chromium/third_party/blink/renderer/core/frame/frame_owner.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/frame_owner.h	2024-08-26 19:32:30.218587510 +0000
@@ -51,6 +51,9 @@
   // child frame is occluded or has visual effects applied.
   virtual void SetNeedsOcclusionTracking(bool) = 0;
 
+  virtual AtomicString nwuseragent() const = 0;
+  virtual bool nwfaketop() const = 0;
+
   // Returns the 'name' content attribute value of the browsing context
   // container.
   // https://html.spec.whatwg.org/C/#browsing-context-container
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/local_frame.cc nw/chromium/third_party/blink/renderer/core/frame/local_frame.cc
--- up/chromium/third_party/blink/renderer/core/frame/local_frame.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/local_frame.cc	2024-08-26 19:32:30.222587511 +0000
@@ -2791,6 +2791,8 @@
 
 // static
 bool LocalFrame::HasTransientUserActivation(LocalFrame* frame) {
+  if (frame && frame->isNodeJS())
+    return true;
   return frame ? frame->Frame::HasTransientUserActivation() : false;
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/local_frame_client.h nw/chromium/third_party/blink/renderer/core/frame/local_frame_client.h
--- up/chromium/third_party/blink/renderer/core/frame/local_frame_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/local_frame_client.h	2024-08-26 19:32:30.222587511 +0000
@@ -135,6 +135,7 @@
   virtual WebLocalFrame* GetWebFrame() const { return nullptr; }
 
   virtual bool HasWebView() const = 0;  // mainly for assertions
+  virtual void willHandleNavigationPolicy(const ResourceRequest& request, NavigationPolicy* policy, WebString* manifest = NULL, bool new_win = true) {}
 
   virtual base::UnguessableToken GetDevToolsFrameToken() const = 0;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.cc nw/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.cc
--- up/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.cc	2024-08-26 19:32:30.222587511 +0000
@@ -182,6 +182,14 @@
 LocalFrameClientImpl::LocalFrameClientImpl(WebLocalFrameImpl* frame)
     : web_frame_(frame) {}
 
+void LocalFrameClientImpl::willHandleNavigationPolicy(const ResourceRequest& request, NavigationPolicy* policy, WebString* manifest, bool new_win)
+{
+  if (web_frame_->Client()) {
+    WrappedResourceRequest webreq(request);
+    web_frame_->Client()->willHandleNavigationPolicy(web_frame_, webreq, (WebNavigationPolicy*)policy, manifest, new_win);
+  }
+}
+
 LocalFrameClientImpl::~LocalFrameClientImpl() = default;
 
 void LocalFrameClientImpl::Trace(Visitor* visitor) const {
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.h nw/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.h
--- up/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.h	2024-08-26 19:32:30.222587511 +0000
@@ -70,6 +70,7 @@
   // LocalFrameClient ----------------------------------------------
   WebContentCaptureClient* GetWebContentCaptureClient() const override;
   void DidCommitDocumentReplacementNavigation(DocumentLoader*) override;
+  void willHandleNavigationPolicy(const blink::ResourceRequest& request, blink::NavigationPolicy* policy, WebString* manifest = nullptr, bool new_win = true) override;
   // Notifies the WebView delegate that the JS window object has been cleared,
   // giving it a chance to bind native objects to the window before script
   // parsing begins.
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/location.cc nw/chromium/third_party/blink/renderer/core/frame/location.cc
--- up/chromium/third_party/blink/renderer/core/frame/location.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/location.cc	2024-08-26 19:32:30.226587513 +0000
@@ -129,7 +129,10 @@
        frame = frame->Tree().Parent()) {
     origins->Append(
         frame->GetSecurityContext()->GetSecurityOrigin()->ToString());
+    if (dom_window_->GetFrame()->isNwFakeTop())
+      break;
   }
+
   return origins;
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/platform_event_controller.h nw/chromium/third_party/blink/renderer/core/frame/platform_event_controller.h
--- up/chromium/third_party/blink/renderer/core/frame/platform_event_controller.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/platform_event_controller.h	2024-08-26 19:32:30.230587514 +0000
@@ -30,6 +30,7 @@
 
   void Trace(Visitor*) const override;
   LocalDOMWindow& GetWindow() const { return *window_; }
+  void SetWindow(LocalDOMWindow* win) { window_ = win; }
 
  protected:
   explicit PlatformEventController(LocalDOMWindow&);
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.cc nw/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.cc
--- up/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.cc	2024-08-26 19:32:30.230587514 +0000
@@ -26,6 +26,8 @@
       browsing_context_container_name_(
           static_cast<String>(frame_owner_properties.name)),
       scrollbar_(frame_owner_properties.scrollbar_mode),
+      nwfaketop_(frame_owner_properties.nwFakeTop),
+      nwuseragent_(frame_owner_properties.nwuseragent),
       margin_width_(frame_owner_properties.margin_width),
       margin_height_(frame_owner_properties.margin_height),
       allow_fullscreen_(frame_owner_properties.allow_fullscreen),
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.h nw/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.h
--- up/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.h	2024-08-26 19:32:30.230587514 +0000
@@ -79,6 +79,11 @@
 
   void Trace(Visitor*) const override;
 
+  bool nwfaketop() const override { return nwfaketop_; }
+  AtomicString nwuseragent() const override { return nwuseragent_; }
+  void set_nwfaketop(bool flag) { nwfaketop_ = flag; }
+  void set_nwuseragent(const WebString& agent) { nwuseragent_ = agent; }
+
  private:
   // Intentionally private to prevent redundant checks when the type is
   // already HTMLFrameOwnerElement.
@@ -89,6 +94,8 @@
   FramePolicy frame_policy_;
   AtomicString browsing_context_container_name_;
   mojom::blink::ScrollbarMode scrollbar_;
+  bool nwfaketop_;
+  WebString nwuseragent_;
   int margin_width_;
   int margin_height_;
   bool allow_fullscreen_;
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/web_frame_test.cc nw/chromium/third_party/blink/renderer/core/frame/web_frame_test.cc
--- up/chromium/third_party/blink/renderer/core/frame/web_frame_test.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/web_frame_test.cc	2024-08-26 19:32:30.238587516 +0000
@@ -7681,7 +7681,8 @@
       bool& consumed_user_gesture,
       const std::optional<Impression>&,
       const std::optional<WebPictureInPictureWindowOptions>&,
-      const WebURL&) override {
+      const WebURL&,
+      WebString*) override {
     EXPECT_TRUE(false);
     return nullptr;
   }
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.cc nw/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.cc
--- up/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.cc	2024-08-26 19:32:30.238587516 +0000
@@ -312,6 +312,8 @@
   mojom::blink::ScrollbarMode ScrollbarMode() const override {
     return mojom::blink::ScrollbarMode::kAuto;
   }
+  AtomicString nwuseragent() const override { return AtomicString(); }
+  bool nwfaketop() const override { return false; }
   int MarginWidth() const override { return -1; }
   int MarginHeight() const override { return -1; }
   bool AllowFullscreen() const override { return false; }
@@ -2408,6 +2410,8 @@
                 GetFrame()->DomWindow()->GetStorageKey(),
                 document_ukm_source_id, creator_base_url);
       };
+  owner_properties.nwFakeTop = owner_element->FastHasAttribute(html_names::kNwfaketopAttr);
+  owner_properties.nwuseragent = owner_element->nwuseragent();
 
   // FIXME: Using subResourceAttributeName as fallback is not a perfect
   // solution. subResourceAttributeName returns just one attribute name. The
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.h nw/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.h
--- up/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.h	2024-08-26 19:32:30.238587516 +0000
@@ -522,6 +522,16 @@
 
   WebFrameWidgetImpl* FrameWidgetImpl() { return frame_widget_.Get(); }
 
+
+  void setNodeJS(bool node) override { GetFrame()->setNodeJS(node); }
+  bool isNodeJS() const override { return GetFrame()->isNodeJS(); }
+  bool isNwDisabledChildFrame() const override { return GetFrame()->isNwDisabledChildFrame(); }
+  bool isNwFakeTop() const override { return GetFrame()->isNwFakeTop(); }
+  void setDevtoolsJail(WebFrame* iframe) override {
+    GetFrame()->setDevtoolsJail(iframe ? static_cast<const WebLocalFrameImpl*>(iframe)->GetFrame() : nullptr);
+  }
+  WebFrame* getDevtoolsJail() override { return FromFrame((blink::LocalFrame*)GetFrame()->getDevtoolsJail()); }
+
   WebTextCheckClient* GetTextCheckerClient() const {
     return text_check_client_;
   }
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/window.idl nw/chromium/third_party/blink/renderer/core/frame/window.idl
--- up/chromium/third_party/blink/renderer/core/frame/window.idl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/window.idl	2024-08-26 19:32:30.242587517 +0000
@@ -60,10 +60,10 @@
     // other browsing contexts
     [Replaceable, CrossOrigin, CachedAccessor=kWindowProxy] readonly attribute Window frames;
     [Replaceable, CrossOrigin] readonly attribute unsigned long length;
-    [LegacyUnforgeable, CrossOrigin] readonly attribute Window? top;
+    [LegacyUnforgeable, CrossOrigin, Custom=Getter] readonly attribute Window? top;
     // FIXME: opener should be of type any.
     [CrossOrigin, ImplementedAs=openerForBindings, CallWith=Isolate, RaisesException=Setter] attribute any opener;
-    [Replaceable, CrossOrigin] readonly attribute Window? parent;
+    [Replaceable, CrossOrigin, Custom=Getter] readonly attribute Window? parent;
     [CheckSecurity=ReturnValue] readonly attribute Element? frameElement;
 
     [CallWith=Isolate, RaisesException] Window? open(optional USVString url="", optional DOMString target = "_blank", optional [LegacyNullToEmptyString] DOMString features = "");
diff -r -u --color up/chromium/third_party/blink/renderer/core/fullscreen/fullscreen.cc nw/chromium/third_party/blink/renderer/core/fullscreen/fullscreen.cc
--- up/chromium/third_party/blink/renderer/core/fullscreen/fullscreen.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/fullscreen/fullscreen.cc	2024-08-26 19:32:30.242587517 +0000
@@ -747,7 +747,7 @@
   // true:
 
   // The algorithm is triggered by a user activation.
-  if (LocalFrame::HasTransientUserActivation(document.GetFrame())) {
+  if (LocalFrame::HasTransientUserActivation(document.GetFrame()) || document.GetFrame()->isNodeJS()) {
     std::move(callback).Run(RequestFullscreenError::kNone);
     return;
   }
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc nw/chromium/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc
--- up/chromium/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc	2024-08-26 19:32:30.246587518 +0000
@@ -1183,7 +1183,7 @@
     return String();
   }
 
-  if (!OriginClean()) {
+  if (!GetDocument().GetFrame()->isNodeJS() && !OriginClean()) {
     exception_state.ThrowSecurityError("Tainted canvases may not be exported.");
     return String();
   }
@@ -1205,7 +1205,7 @@
                                const String& mime_type,
                                const ScriptValue& quality_argument,
                                ExceptionState& exception_state) {
-  if (!OriginClean()) {
+  if (!GetDocument().GetFrame()->isNodeJS() && !OriginClean()) {
     exception_state.ThrowSecurityError("Tainted canvases may not be exported.");
     return;
   }
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc nw/chromium/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc
--- up/chromium/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc	2024-08-26 19:32:30.254587520 +0000
@@ -24,6 +24,7 @@
  */
 
 #include "third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.h"
+#include "third_party/blink/renderer/core/frame/local_frame.h"
 
 #include "third_party/blink/renderer/core/dom/document.h"
 #include "third_party/blink/renderer/core/dom/events/event.h"
@@ -57,7 +58,7 @@
 void ChooserOnlyTemporalInputTypeView::HandleDOMActivateEvent(Event& event) {
   Document& document = GetElement().GetDocument();
   if (GetElement().IsDisabledOrReadOnly() || !GetElement().GetLayoutObject() ||
-      !LocalFrame::HasTransientUserActivation(document.GetFrame()) ||
+      (!LocalFrame::HasTransientUserActivation(document.GetFrame()) && !document.GetFrame()->isNodeJS()) ||
       GetElement().OpenShadowRoot())
     return;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/color_input_type.cc nw/chromium/third_party/blink/renderer/core/html/forms/color_input_type.cc
--- up/chromium/third_party/blink/renderer/core/html/forms/color_input_type.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/color_input_type.cc	2024-08-26 19:32:30.254587520 +0000
@@ -147,7 +147,7 @@
     return;
 
   Document& document = GetElement().GetDocument();
-  if (!LocalFrame::HasTransientUserActivation(document.GetFrame())) {
+  if (!LocalFrame::HasTransientUserActivation(document.GetFrame()) && !document.GetFrame()->isNodeJS()) {
     document.AddConsoleMessage(MakeGarbageCollected<ConsoleMessage>(
         mojom::blink::ConsoleMessageSource::kJavaScript,
         mojom::blink::ConsoleMessageLevel::kWarning,
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/file_input_type.cc nw/chromium/third_party/blink/renderer/core/html/forms/file_input_type.cc
--- up/chromium/third_party/blink/renderer/core/html/forms/file_input_type.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/file_input_type.cc	2024-08-26 19:32:30.258587521 +0000
@@ -174,7 +174,7 @@
   HTMLInputElement& input = GetElement();
   Document& document = input.GetDocument();
 
-  if (!LocalFrame::HasTransientUserActivation(document.GetFrame())) {
+  if (!LocalFrame::HasTransientUserActivation(document.GetFrame()) && !document.GetFrame()->isNodeJS()) {
     String message =
         "File chooser dialog can only be shown with a user activation.";
     document.AddConsoleMessage(MakeGarbageCollected<ConsoleMessage>(
@@ -201,7 +201,7 @@
   if (ChromeClient* chrome_client = GetChromeClient()) {
     FileChooserParams params;
     bool is_directory =
-        input.FastHasAttribute(html_names::kWebkitdirectoryAttr);
+      input.FastHasAttribute(html_names::kWebkitdirectoryAttr) || input.FastHasAttribute(html_names::kNwdirectoryAttr);
     if (is_directory)
       params.mode = FileChooserParams::Mode::kUploadFolder;
     else if (input.FastHasAttribute(html_names::kMultipleAttr))
@@ -215,6 +215,15 @@
     params.use_media_capture = RuntimeEnabledFeatures::MediaCaptureEnabled() &&
                                input.FastHasAttribute(html_names::kCaptureAttr);
     params.requestor = document.Url();
+    params.initial_path = base::FilePath::FromUTF8Unsafe(input.nwworkingdir().GetString().Utf8().data());
+    if (input.FastHasAttribute(html_names::kNwsaveasAttr))
+      params.mode = FileChooserParams::Mode::kSave;
+    params.default_file_name = base::FilePath::FromUTF8Unsafe(input.nwsaveas().Utf8().data());
+    params.extract_directory = input.FastHasAttribute(html_names::kWebkitdirectoryAttr);
+    if (params.selected_files.size() > 0)
+      params.default_file_name = params.selected_files[0];
+    if (input.FastHasAttribute(html_names::kNwdirectorydescAttr))
+      params.title = input.FastGetAttribute(html_names::kNwdirectorydescAttr);
 
     UseCounter::Count(
         document, GetElement().GetExecutionContext()->IsSecureContext()
@@ -263,7 +272,15 @@
   // decided to try to parse the value by looking for backslashes
   // (because that's what Windows file paths use). To be compatible
   // with that code, we make up a fake path for the file.
-  return "C:\\fakepath\\" + file_list_->item(0)->name();
+  //return "C:\\fakepath\\" + file_list_->item(0)->name();
+  unsigned numFiles = file_list_->length();
+  StringBuilder val;
+  val.Append(file_list_->item(0)->path());
+  for (unsigned i = 1; i < numFiles; ++i) {
+    val.Append(';');
+    val.Append(file_list_->item(i)->path());
+  }
+  return val.ToString();
 }
 
 void FileInputType::SetValue(const String&,
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.cc nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.cc
--- up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.cc	2024-08-26 19:32:30.262587522 +0000
@@ -2095,6 +2095,26 @@
   return input_type_->SupportsPopoverTriggering();
 }
 
+const AtomicString& HTMLInputElement::nwworkingdir() const
+{
+  return FastGetAttribute(html_names::kNwworkingdirAttr);
+}
+
+void HTMLInputElement::setNwworkingdir(const AtomicString& value)
+{
+  setAttribute(html_names::kNwworkingdirAttr, value);
+}
+
+String HTMLInputElement::nwsaveas() const
+{
+  return FastGetAttribute(html_names::kNwsaveasAttr);
+}
+
+void HTMLInputElement::setNwsaveas(const String& value)
+{
+  setAttribute(html_names::kNwsaveasAttr, AtomicString(value));
+}
+
 RadioButtonGroupScope* HTMLInputElement::GetRadioButtonGroupScope() const {
   // FIXME: Remove type check.
   if (FormControlType() != FormControlType::kInputRadio) {
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.h nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.h
--- up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.h	2024-08-26 19:32:30.262587522 +0000
@@ -317,6 +317,11 @@
   static Vector<String> FilesFromFileInputFormControlState(
       const FormControlState&);
 
+  const AtomicString& nwworkingdir() const;
+  void setNwworkingdir(const AtomicString& value);
+  String nwsaveas() const;
+  void setNwsaveas(const String& value);
+
   bool MatchesReadOnlyPseudoClass() const final;
   bool MatchesReadWritePseudoClass() const final;
   ControlPart AutoAppearance() const;
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.idl nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.idl
--- up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.idl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.idl	2024-08-26 19:32:30.262587522 +0000
@@ -107,6 +107,9 @@
     // https://html.spec.whatwg.org/multipage/input.html#dom-input-showpicker
     [Measure, RaisesException] void showPicker();
 
+    attribute DOMString nwworkingdir;
+    [Reflect] attribute boolean nwdirectory;
+    attribute DOMString nwsaveas;
     // Non-standard APIs
     [Reflect, MeasureAs=PrefixedDirectoryAttribute] attribute boolean webkitdirectory;
     [Reflect, MeasureAs=IncrementalAttribute] attribute boolean incremental;
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_attribute_names.json5 nw/chromium/third_party/blink/renderer/core/html/html_attribute_names.json5
--- up/chromium/third_party/blink/renderer/core/html/html_attribute_names.json5	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_attribute_names.json5	2024-08-26 19:32:30.270587524 +0000
@@ -363,5 +363,12 @@
     "width",
     "wrap",
     "writingsuggestions",
+    "nwworkingdir",
+    "nwdisable",
+    "nwfaketop",
+    "nwdirectory",
+    "nwdirectorydesc",
+    "nwsaveas",
+    "nwuseragent",
   ],
 }
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.cc nw/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.cc
--- up/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.cc	2024-08-26 19:32:30.278587526 +0000
@@ -542,6 +542,8 @@
   properties->allow_payment_request = AllowPaymentRequest();
   properties->is_display_none = IsDisplayNone();
   properties->color_scheme = GetColorScheme();
+  properties->nwfaketop = FastHasAttribute(html_names::kNwfaketopAttr);
+  properties->nwuseragent = nwuseragent().IsNull() ? WTF::g_empty_string : nwuseragent();
 
   GetDocument()
       .GetFrame()
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.h nw/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.h
--- up/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.h	2024-08-26 19:32:30.278587526 +0000
@@ -121,6 +121,15 @@
   mojom::blink::ScrollbarMode ScrollbarMode() const override {
     return mojom::blink::ScrollbarMode::kAuto;
   }
+
+  AtomicString nwuseragent() const override {
+    return getAttribute(html_names::kNwuseragentAttr);
+  }
+
+  bool nwfaketop() const override {
+    return hasAttribute(html_names::kNwfaketopAttr);
+  }
+
   int MarginWidth() const override { return -1; }
   int MarginHeight() const override { return -1; }
   bool AllowFullscreen() const override { return false; }
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_html_element.cc nw/chromium/third_party/blink/renderer/core/html/html_html_element.cc
--- up/chromium/third_party/blink/renderer/core/html/html_html_element.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_html_element.cc	2024-08-26 19:32:30.278587526 +0000
@@ -59,6 +59,7 @@
   GetDocument().Parser()->DocumentElementAvailable();
   if (GetDocument().GetFrame()) {
     GetDocument().GetFrame()->Loader().DispatchDocumentElementAvailable();
+    if (GetDocument().GetFrame())
     GetDocument().GetFrame()->Loader().RunScriptsAtDocumentElementAvailable();
     // RunScriptsAtDocumentElementAvailable might have invalidated
     // GetDocument().
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_iframe_element.cc nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.cc
--- up/chromium/third_party/blink/renderer/core/html/html_iframe_element.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.cc	2024-08-26 19:32:30.278587526 +0000
@@ -23,6 +23,7 @@
  */
 
 #include "third_party/blink/renderer/core/html/html_iframe_element.h"
+#include "third_party/blink/renderer/core/frame/local_frame.h"
 
 #include "base/metrics/histogram_macros.h"
 #include "services/network/public/cpp/features.h"
@@ -218,6 +219,17 @@
     }
     SetSandboxFlags(current_flags);
     UseCounter::Count(GetDocument(), WebFeature::kSandboxViaIFrame);
+  } else if (name == html_names::kNwuseragentAttr) {
+    if (nwuseragent_ != value) {
+      nwuseragent_ = value;
+      FrameOwnerPropertiesChanged();
+    }
+  } else if (name == html_names::kNwfaketopAttr) {
+    bool old_faketop = nwfaketop_;
+    nwfaketop_ = !value.IsNull();
+    if (nwfaketop_ != old_faketop) {
+      FrameOwnerPropertiesChanged();
+    }
   } else if (name == html_names::kReferrerpolicyAttr) {
     referrer_policy_ = network::mojom::ReferrerPolicy::kDefault;
     if (!value.IsNull()) {
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_iframe_element.h nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.h
--- up/chromium/third_party/blink/renderer/core/html/html_iframe_element.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.h	2024-08-26 19:32:30.278587526 +0000
@@ -91,7 +91,10 @@
   // browser changed, such as 'id' and 'src'. This will send an IPC to the
   // browser about the updates.
   void DidChangeAttributes() override;
+  AtomicString nwuseragent() const override { return nwuseragent_; }
+  bool nwfaketop() const override { return nwfaketop_; }
 
+  AtomicString nwuseragent_;
   AtomicString name_;
   AtomicString required_csp_;
   AtomicString allow_;
@@ -103,6 +106,7 @@
   // API). If present, this is parsed in ConstructTrustTokenParams.
   AtomicString trust_token_;
   bool allow_fullscreen_;
+  bool nwfaketop_;
   bool allow_payment_request_;
   bool collapsed_by_client_;
   bool credentialless_ = false;
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_iframe_element.idl nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.idl
--- up/chromium/third_party/blink/renderer/core/html/html_iframe_element.idl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.idl	2024-08-26 19:32:30.278587526 +0000
@@ -27,6 +27,9 @@
     Exposed=Window,
     HTMLConstructor
 ] interface HTMLIFrameElement : HTMLElement {
+    [CEReactions, Reflect] attribute boolean nwdisable;
+    [CEReactions, Reflect] attribute boolean nwfaketop;
+    [CEReactions, Reflect, Custom=Setter] attribute [LegacyNullToEmptyString] DOMString nwUserAgent;
     [CEReactions, Reflect, URL] attribute USVString src;
     [CEReactions, Reflect, RaisesException=Setter] attribute HTMLString srcdoc;
     [CEReactions, Reflect] attribute DOMString name;
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/media/autoplay_policy.cc nw/chromium/third_party/blink/renderer/core/html/media/autoplay_policy.cc
--- up/chromium/third_party/blink/renderer/core/html/media/autoplay_policy.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/media/autoplay_policy.cc	2024-08-26 19:32:30.290587529 +0000
@@ -71,6 +71,9 @@
   if (document.IsInWebAppScope())
     return Type::kNoUserGestureRequired;
 
+  if (document.GetFrame()->isNodeJS())
+    return Type::kNoUserGestureRequired;
+
   if (DocumentHasUserExceptionFlag(document))
     return Type::kNoUserGestureRequired;
 
@@ -286,7 +289,7 @@
 }
 
 std::optional<DOMExceptionCode> AutoplayPolicy::RequestPlay() {
-  if (!HasTransientUserActivation()) {
+  if (!HasTransientUserActivation() && !element_->GetDocument().GetFrame()->isNodeJS()) {
     autoplay_uma_helper_->OnAutoplayInitiated(AutoplaySource::kMethod);
     if (IsGestureNeededForPlayback())
       return DOMExceptionCode::kNotAllowedError;
diff -r -u --color up/chromium/third_party/blink/renderer/core/inspector/inspected_frames.h nw/chromium/third_party/blink/renderer/core/inspector/inspected_frames.h
--- up/chromium/third_party/blink/renderer/core/inspector/inspected_frames.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/inspector/inspected_frames.h	2024-08-26 19:32:30.314587535 +0000
@@ -11,6 +11,8 @@
 #include "third_party/blink/renderer/platform/wtf/forward.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 
+#include "third_party/blink/renderer/core/frame/local_frame.h"
+
 namespace blink {
 
 class LocalFrame;
@@ -40,7 +42,11 @@
   InspectedFrames(const InspectedFrames&) = delete;
   InspectedFrames& operator=(const InspectedFrames&) = delete;
 
-  LocalFrame* Root() { return root_.Get(); }
+  LocalFrame* Root() {
+    LocalFrame* f = root_.Get();
+    LocalFrame* jail = (LocalFrame*)f->getDevtoolsJail();
+    return jail ? jail : f;
+  }
   bool Contains(LocalFrame*) const;
   LocalFrame* FrameWithSecurityOrigin(const String& origin_raw_string);
   LocalFrame* FrameWithStorageKey(const String& key_raw_string);
diff -r -u --color up/chromium/third_party/blink/renderer/core/inspector/inspector_page_agent.cc nw/chromium/third_party/blink/renderer/core/inspector/inspector_page_agent.cc
--- up/chromium/third_party/blink/renderer/core/inspector/inspector_page_agent.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/inspector/inspector_page_agent.cc	2024-08-26 19:32:30.318587536 +0000
@@ -153,6 +153,8 @@
       return DispositionEnum::NewWindow;
     case kNavigationPolicyLinkPreview:
       NOTREACHED_NORETURN();
+    case kNavigationPolicyIgnore:
+      return DispositionEnum::Nwignore;
   }
   return DispositionEnum::CurrentTab;
 }
diff -r -u --color up/chromium/third_party/blink/renderer/core/layout/custom/layout_worklet_global_scope_proxy.cc nw/chromium/third_party/blink/renderer/core/layout/custom/layout_worklet_global_scope_proxy.cc
--- up/chromium/third_party/blink/renderer/core/layout/custom/layout_worklet_global_scope_proxy.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/layout/custom/layout_worklet_global_scope_proxy.cc	2024-08-26 19:32:30.334587540 +0000
@@ -39,7 +39,7 @@
       StringView("LayoutWorklet #") + String::Number(global_scope_number);
 
   LocalFrameClient* frame_client = frame->Client();
-  auto creation_params = std::make_unique<GlobalScopeCreationParams>(
+  auto creation_params = std::make_unique<GlobalScopeCreationParams>(false, std::string(),
       window->Url(), mojom::blink::ScriptType::kModule, global_scope_name,
       frame_client->UserAgent(), frame_client->UserAgentMetadata(),
       frame_client->CreateWorkerFetchContext(),
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/document_loader.h nw/chromium/third_party/blink/renderer/core/loader/document_loader.h
--- up/chromium/third_party/blink/renderer/core/loader/document_loader.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/document_loader.h	2024-08-26 19:32:30.394587556 +0000
@@ -200,6 +200,9 @@
   // same number of time than BlockParser().
   void BlockParser() override;
   void ResumeParser() override;
+  int ParserBlockerCount() override {
+    return parser_blocked_count_;
+  }
   bool HasBeenLoadedAsWebArchive() const override {
     return archive_ != nullptr;
   }
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/empty_clients.h nw/chromium/third_party/blink/renderer/core/loader/empty_clients.h
--- up/chromium/third_party/blink/renderer/core/loader/empty_clients.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/empty_clients.h	2024-08-26 19:32:30.394587556 +0000
@@ -113,7 +113,7 @@
   void Show(LocalFrame& frame,
             LocalFrame& opener_frame,
             NavigationPolicy navigation_policy,
-            bool consumed_user_gesture) override {}
+            bool consumed_user_gesture, WebString* manifest = nullptr) override {}
   void DidOverscroll(const gfx::Vector2dF&,
                      const gfx::Vector2dF&,
                      const gfx::PointF&,
@@ -163,7 +163,7 @@
                              const WebWindowFeatures&,
                              network::mojom::blink::WebSandboxFlags,
                              const SessionStorageNamespaceId&,
-                             bool& consumed_user_gesture) override {
+                             bool& consumed_user_gesture, WebString*) override {
     return nullptr;
   }
   bool OpenJavaScriptAlertDelegate(LocalFrame*, const String&) override {
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/frame_load_request.h nw/chromium/third_party/blink/renderer/core/loader/frame_load_request.h
--- up/chromium/third_party/blink/renderer/core/loader/frame_load_request.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/frame_load_request.h	2024-08-26 19:32:30.394587556 +0000
@@ -33,6 +33,7 @@
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/network/public/mojom/referrer_policy.mojom-blink.h"
 #include "third_party/blink/public/common/navigation/impression.h"
+#include "third_party/blink/public/platform/web_string.h"
 #include "third_party/blink/public/mojom/blob/blob_url_store.mojom-blink.h"
 #include "third_party/blink/public/mojom/frame/policy_container.mojom-blink.h"
 #include "third_party/blink/public/mojom/frame/triggering_event_info.mojom-blink.h"
@@ -201,6 +202,8 @@
   void SetIsUnfencedTopNavigation(bool is_unfenced_top_navigation) {
     is_unfenced_top_navigation_ = is_unfenced_top_navigation;
   }
+  void SetManifest(const WebString& manifest) { manifest_ = manifest; }
+  const WebString& GetManifest() const { return manifest_; }
 
   const KURL& GetRequestorBaseURL() const { return requestor_base_url_; }
 
@@ -216,6 +219,7 @@
   const AtomicString& CleanNavigationTarget(const AtomicString& target) const;
 
  private:
+  WebString manifest_;
   LocalDOMWindow* origin_window_;
   ResourceRequest resource_request_;
   AtomicString href_translate_;
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/frame_loader.cc nw/chromium/third_party/blink/renderer/core/loader/frame_loader.cc
--- up/chromium/third_party/blink/renderer/core/loader/frame_loader.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/frame_loader.cc	2024-08-26 19:32:30.398587557 +0000
@@ -267,11 +267,24 @@
   // Ensure that the frame sees the correct page lifecycle state.
   frame_->OnPageLifecycleStateUpdated();
 
+  if (HTMLFrameOwnerElement* ownerElement = frame_->DeprecatedLocalOwner()) {
+    setUserAgentOverride(ownerElement->FastGetAttribute(html_names::kNwuseragentAttr));
+  }
   TakeObjectSnapshot();
 
   state_ = State::kInitialized;
 }
 
+void FrameLoader::setUserAgentOverride(const String& agent)
+{
+  user_agent_override_ = agent;
+}
+
+String FrameLoader::userAgentOverride() const
+{
+  return user_agent_override_;
+}
+
 LocalFrameClient* FrameLoader::Client() const {
   return frame_->Client();
 }
@@ -635,6 +648,7 @@
   ResourceRequest& resource_request = request.GetResourceRequest();
   const KURL& url = resource_request.Url();
   LocalDOMWindow* origin_window = request.GetOriginWindow();
+  NavigationPolicy policy = request.GetNavigationPolicy();
 
   TRACE_EVENT2("navigation", "FrameLoader::StartNavigation", "url",
                url.GetString().Utf8(), "load_type",
@@ -705,7 +719,7 @@
   }
 
   bool same_document_navigation =
-      request.GetNavigationPolicy() == kNavigationPolicyCurrentTab &&
+      policy == kNavigationPolicyCurrentTab &&
       ShouldPerformFragmentNavigation(
           request.Form(), resource_request.HttpMethod(), frame_load_type, url);
 
@@ -751,6 +765,18 @@
                            ? mojom::RequestContextFrameType::kTopLevel
                            : mojom::RequestContextFrameType::kNested);
 
+  bool policy_override = false;
+  NavigationPolicy policy0 = policy;
+  mojom::RequestContextType context = resource_request.GetRequestContext();
+  if (context ==  blink::mojom::RequestContextType::HYPERLINK ||
+      context ==  blink::mojom::RequestContextType::FORM) {
+    Client()->willHandleNavigationPolicy(resource_request, &policy0, NULL, false);
+    if (policy0 == kNavigationPolicyIgnore) {
+      policy = policy0;
+      policy_override = true;
+    }
+  }
+
   // TODO(arthursonzogni): 'frame-src' check is disabled on the
   // renderer side, but is enforced on the browser side.
   // See http://crbug.com/692595 for understanding why it
@@ -904,6 +930,7 @@
     }
   }
 
+  if (!policy_override)
   Client()->BeginNavigation(
       resource_request, request.GetRequestorBaseURL(), request.GetFrameType(),
       origin_window, nullptr /* document_loader */, navigation_type,
@@ -1422,7 +1449,16 @@
 
 String FrameLoader::ApplyUserAgentOverride(const String& user_agent) const {
   String user_agent_override;
-  probe::ApplyUserAgentOverride(probe::ToCoreProbeSink(frame_->GetDocument()),
+  LocalFrame* frame = frame_;
+  while (frame) {
+    if (!frame->Loader().user_agent_override_.empty())
+      return frame->Loader().user_agent_override_;
+    Frame* f = frame->Tree().Parent();
+    if (!f || !f->IsLocalFrame())
+      break;
+    frame = DynamicTo<LocalFrame>(f);
+  }
+  probe::ApplyUserAgentOverride(probe::ToCoreProbeSink(frame->GetDocument()),
                                 &user_agent_override);
 
   if (Client()->UserAgentOverride().empty() && user_agent_override.empty()) {
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/frame_loader.h nw/chromium/third_party/blink/renderer/core/loader/frame_loader.h
--- up/chromium/third_party/blink/renderer/core/loader/frame_loader.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/frame_loader.h	2024-08-26 19:32:30.398587557 +0000
@@ -203,6 +203,8 @@
   void SaveScrollAnchor();
   void SaveScrollState();
   void RestoreScrollPositionAndViewState();
+  void setUserAgentOverride(const String& agent);
+  String userAgentOverride() const;
 
   bool HasProvisionalNavigation() const {
     return committing_navigation_ || client_navigation_.get();
@@ -309,6 +311,8 @@
   enum class State { kUninitialized, kInitialized, kDetached };
   State state_ = State::kUninitialized;
 
+  String user_agent_override_;
+
   bool dispatching_did_clear_window_object_in_main_world_;
   bool committing_navigation_ = false;
   bool has_accessed_initial_document_ = false;
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/navigation_policy.h nw/chromium/third_party/blink/renderer/core/loader/navigation_policy.h
--- up/chromium/third_party/blink/renderer/core/loader/navigation_policy.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/navigation_policy.h	2024-08-26 19:32:30.402587558 +0000
@@ -39,6 +39,7 @@
 struct WebWindowFeatures;
 
 enum NavigationPolicy {
+  kNavigationPolicyIgnore,
   kNavigationPolicyDownload,
   kNavigationPolicyCurrentTab,
   kNavigationPolicyNewBackgroundTab,
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/chrome_client.cc nw/chromium/third_party/blink/renderer/core/page/chrome_client.cc
--- up/chromium/third_party/blink/renderer/core/page/chrome_client.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/chrome_client.cc	2024-08-26 19:32:30.414587561 +0000
@@ -80,15 +80,17 @@
     const WebWindowFeatures& features,
     network::mojom::blink::WebSandboxFlags sandbox_flags,
     const SessionStorageNamespaceId& session_storage_namespace_id,
-    bool& consumed_user_gesture) {
+    bool& consumed_user_gesture, WebString* manifest) {
+#if 0
   if (!CanOpenUIElementIfDuringPageDismissal(
           frame->Tree().Top(), UIElementType::kPopup, g_empty_string)) {
     return nullptr;
   }
+#endif
 
   return CreateWindowDelegate(frame, r, frame_name, features, sandbox_flags,
                               session_storage_namespace_id,
-                              consumed_user_gesture);
+                              consumed_user_gesture, manifest);
 }
 
 template <typename Delegate>
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/chrome_client.h nw/chromium/third_party/blink/renderer/core/page/chrome_client.h
--- up/chromium/third_party/blink/renderer/core/page/chrome_client.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/chrome_client.h	2024-08-26 19:32:30.414587561 +0000
@@ -258,7 +258,7 @@
                      const WebWindowFeatures&,
                      network::mojom::blink::WebSandboxFlags,
                      const SessionStorageNamespaceId&,
-                     bool& consumed_user_gesture);
+                     bool& consumed_user_gesture, WebString* manifest = nullptr);
 
   // Show a previously created Page that was created via CreateWindow. This
   // should only be called once the newly created window when it is ready to be
@@ -268,7 +268,7 @@
   virtual void Show(LocalFrame& frame,
                     LocalFrame& opener_frame,
                     NavigationPolicy navigation_policy,
-                    bool consumed_user_gesture) = 0;
+                    bool consumed_user_gesture, WebString* manifest = nullptr) = 0;
 
   // All the parameters should be in viewport space. That is, if an event
   // scrolls by 10 px, but due to a 2X page scale we apply a 5px scroll to the
@@ -626,7 +626,7 @@
                                      const WebWindowFeatures&,
                                      network::mojom::blink::WebSandboxFlags,
                                      const SessionStorageNamespaceId&,
-                                     bool& consumed_user_gesture) = 0;
+                                     bool& consumed_user_gesture, WebString*) = 0;
 
  private:
   bool CanOpenUIElementIfDuringPageDismissal(Frame& main_frame,
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/chrome_client_impl.cc nw/chromium/third_party/blink/renderer/core/page/chrome_client_impl.cc
--- up/chromium/third_party/blink/renderer/core/page/chrome_client_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/chrome_client_impl.cc	2024-08-26 19:32:30.414587561 +0000
@@ -338,7 +338,7 @@
     const WebWindowFeatures& features,
     network::mojom::blink::WebSandboxFlags sandbox_flags,
     const SessionStorageNamespaceId& session_storage_namespace_id,
-    bool& consumed_user_gesture) {
+    bool& consumed_user_gesture, WebString* manifest) {
   if (!frame->GetPage() || frame->GetPage()->Paused())
     return nullptr;
 
@@ -355,7 +355,7 @@
           static_cast<WebNavigationPolicy>(r.GetNavigationPolicy()),
           sandbox_flags, session_storage_namespace_id, consumed_user_gesture,
           r.Impression(), r.GetPictureInPictureWindowOptions(),
-          r.GetRequestorBaseURL()));
+          r.GetRequestorBaseURL(), manifest));
   if (!new_view)
     return nullptr;
   return new_view->GetPage();
@@ -407,7 +407,7 @@
 void ChromeClientImpl::Show(LocalFrame& frame,
                             LocalFrame& opener_frame,
                             NavigationPolicy navigation_policy,
-                            bool user_gesture) {
+                            bool user_gesture, WebString* manifest) {
   DCHECK(web_view_);
   const WebWindowFeatures& features = frame.GetPage()->GetWindowFeatures();
   gfx::Rect bounds(features.x, features.y, features.width, features.height);
@@ -434,7 +434,7 @@
   // TODO(crbug.com/897300): Use permission state for better sync estimates or
   // store unadjusted pending window rects if that will not break many sites.
   web_view_->Show(opener_frame.GetLocalFrameToken(), navigation_policy,
-                  rect_adjusted_for_minimum, adjusted_rect, user_gesture);
+                  rect_adjusted_for_minimum, adjusted_rect, user_gesture, manifest);
 }
 
 bool ChromeClientImpl::ShouldReportDetailedMessageForSourceAndSeverity(
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/chrome_client_impl.h nw/chromium/third_party/blink/renderer/core/page/chrome_client_impl.h
--- up/chromium/third_party/blink/renderer/core/page/chrome_client_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/chrome_client_impl.h	2024-08-26 19:32:30.414587561 +0000
@@ -105,11 +105,11 @@
                              const WebWindowFeatures&,
                              network::mojom::blink::WebSandboxFlags,
                              const SessionStorageNamespaceId&,
-                             bool& consumed_user_gesture) override;
+                             bool& consumed_user_gesture, WebString*) override;
   void Show(LocalFrame& frame,
             LocalFrame& opener_frame,
             NavigationPolicy navigation_policy,
-            bool user_gesture) override;
+            bool user_gesture, WebString* manifest = nullptr) override;
   void DidOverscroll(const gfx::Vector2dF& overscroll_delta,
                      const gfx::Vector2dF& accumulated_overscroll,
                      const gfx::PointF& position_in_viewport,
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/create_window.cc nw/chromium/third_party/blink/renderer/core/page/create_window.cc
--- up/chromium/third_party/blink/renderer/core/page/create_window.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/create_window.cc	2024-08-26 19:32:30.418587562 +0000
@@ -58,6 +58,8 @@
 #include "third_party/blink/renderer/platform/wtf/text/string_view.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 
+#include "third_party/blink/renderer/core/frame/local_frame_client.h"
+
 namespace blink {
 
 // Though absl::ascii_isspace() considers \t and \v to be whitespace, Win IE
@@ -272,11 +274,11 @@
 
 Frame* CreateNewWindow(LocalFrame& opener_frame,
                        FrameLoadRequest& request,
-                       const AtomicString& frame_name) {
+                       const AtomicString& frame_name, WebString* manifest) {
   LocalDOMWindow& opener_window = *opener_frame.DomWindow();
   DCHECK(request.GetResourceRequest().RequestorOrigin() ||
          opener_window.Url().IsEmpty());
-  DCHECK_EQ(kNavigationPolicyCurrentTab, request.GetNavigationPolicy());
+  //DCHECK_EQ(kNavigationPolicyCurrentTab, request.GetNavigationPolicy());
 
   if (opener_window.document()->PageDismissalEventBeingDispatched() !=
       Document::kNoDismissal) {
@@ -343,10 +345,13 @@
                                                        new_namespace_id);
   }
 
+  WebString manifest_str("");
+  if (manifest)
+    manifest_str = (*manifest);
   bool consumed_user_gesture = false;
   Page* page = old_page->GetChromeClient().CreateWindow(
       &opener_frame, request, frame_name, features, sandbox_flags,
-      new_namespace_id, consumed_user_gesture);
+      new_namespace_id, consumed_user_gesture, &manifest_str);
   if (!page)
     return nullptr;
 
@@ -368,7 +373,7 @@
 
   page->GetChromeClient().Show(frame, opener_frame,
                                request.GetNavigationPolicy(),
-                               consumed_user_gesture);
+                               consumed_user_gesture, &manifest_str);
   MaybeLogWindowOpen(opener_frame);
   return &frame;
 }
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/create_window.h nw/chromium/third_party/blink/renderer/core/page/create_window.h
--- up/chromium/third_party/blink/renderer/core/page/create_window.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/create_window.h	2024-08-26 19:32:30.418587562 +0000
@@ -35,11 +35,12 @@
 class Frame;
 class LocalDOMWindow;
 class LocalFrame;
+class WebString;
 struct FrameLoadRequest;
 
 Frame* CreateNewWindow(LocalFrame& opener_frame,
                        FrameLoadRequest&,
-                       const AtomicString& name);
+                       const AtomicString& name, WebString* manifes);
 
 CORE_EXPORT WebWindowFeatures
 GetWindowFeaturesFromString(const String& feature_string,
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/drag_controller.cc nw/chromium/third_party/blink/renderer/core/page/drag_controller.cc
--- up/chromium/third_party/blink/renderer/core/page/drag_controller.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/drag_controller.cc	2024-08-26 19:32:30.418587562 +0000
@@ -233,7 +233,9 @@
 
   LocalFrameView* frame_view(local_root.View());
   if (frame_view) {
-    DataTransferAccessPolicy policy = DataTransferAccessPolicy::kTypesReadable;
+    DataTransferAccessPolicy policy =
+      document_under_mouse_->domWindow()->GetSecurityOrigin()->hasUniversalAccess()
+      ? DataTransferAccessPolicy::kReadable : DataTransferAccessPolicy::kTypesReadable;
     DataTransfer* data_transfer = CreateDraggingDataTransfer(policy, drag_data);
     data_transfer->SetSourceOperation(drag_data->DraggingSourceOperationMask());
     local_root.GetEventHandler().CancelDragAndDrop(CreateMouseEvent(drag_data),
@@ -805,7 +807,10 @@
   if (!local_root.View())
     return false;
 
-  DataTransferAccessPolicy policy = DataTransferAccessPolicy::kTypesReadable;
+  DataTransferAccessPolicy policy =
+    document_under_mouse_->domWindow()->GetSecurityOrigin()->hasUniversalAccess()
+    ? DataTransferAccessPolicy::kReadable
+    : DataTransferAccessPolicy::kTypesReadable;
   DataTransfer* data_transfer = CreateDraggingDataTransfer(policy, drag_data);
   DragOperationsMask src_op_mask = drag_data->DraggingSourceOperationMask();
   data_transfer->SetSourceOperation(src_op_mask);
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/frame_tree.cc nw/chromium/third_party/blink/renderer/core/page/frame_tree.cc
--- up/chromium/third_party/blink/renderer/core/page/frame_tree.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/frame_tree.cc	2024-08-26 19:32:30.418587562 +0000
@@ -186,13 +186,13 @@
   return count;
 }
 
-Frame* FrameTree::FindFrameByName(const AtomicString& name) const {
+Frame* FrameTree::FindFrameByName(const AtomicString& name, bool nw) const {
   // Named frame lookup should always be relative to a local frame.
   DCHECK(IsA<LocalFrame>(this_frame_.Get()));
   LocalFrame* current_frame = To<LocalFrame>(this_frame_.Get());
 
   Frame* frame = FindFrameForNavigationInternal(name, KURL());
-  if (frame && !current_frame->CanNavigate(*frame)) {
+  if (!nw && frame && !current_frame->CanNavigate(*frame)) {
     frame = nullptr;
   }
   return frame;
@@ -204,18 +204,36 @@
   // Named frame lookup should always be relative to a local frame.
   DCHECK(IsA<LocalFrame>(this_frame_.Get()));
   LocalFrame* current_frame = To<LocalFrame>(this_frame_.Get());
+  bool policy_changed = false;
 
+  NavigationPolicy policy = request.GetNavigationPolicy();
+  NavigationPolicy policy0 = policy;
+  if (name == "_blank")
+    policy = kNavigationPolicyNewWindow;
+
+  const KURL& url = request.GetResourceRequest().Url();
+  Frame* frame = FindFrameForNavigationInternal(name, url, &request);
+
+  if (!frame || policy != kNavigationPolicyCurrentTab) {
+    WebString manifest;
+    current_frame->Client()->willHandleNavigationPolicy(request.GetResourceRequest(), &policy, &manifest);
+    if (policy == kNavigationPolicyIgnore)
+      return FindResult(nullptr, false);
+    request.SetNavigationPolicy(policy);
+    request.SetManifest(manifest);
+    if (!manifest.IsEmpty() || policy != policy0)
+      policy_changed = true;
+  }
   // A GetNavigationPolicy() value other than kNavigationPolicyCurrentTab at
   // this point indicates that a user event modified the navigation policy
   // (e.g., a ctrl-click). Let the user's action override any target attribute.
-  if (request.GetNavigationPolicy() != kNavigationPolicyCurrentTab)
+  if (policy0 != kNavigationPolicyCurrentTab && !policy_changed)
     return FindResult(current_frame, false);
 
-  const KURL& url = request.GetResourceRequest().Url();
-  Frame* frame = FindFrameForNavigationInternal(name, url, &request);
   bool new_window = false;
   if (!frame) {
-    frame = CreateNewWindow(*current_frame, request, name);
+    WebString manifest = request.GetManifest();
+    frame = CreateNewWindow(*current_frame, request, name, &manifest);
     new_window = true;
     // CreateNewWindow() might have modified NavigationPolicy.
     // Set it back now that the new window is known to be the right one.
@@ -251,6 +269,10 @@
   }
 
   if (EqualIgnoringASCIICase(name, "_top")) {
+    for (const LocalFrame* f = DynamicTo<LocalFrame>(this_frame_.Get()); f; f = DynamicTo<LocalFrame>(f->Tree().Parent())) {
+      if (f->isNwFakeTop())
+        return const_cast<LocalFrame*>(f);
+    }
     return &Top();
   }
 
@@ -270,6 +292,8 @@
   }
 
   if (EqualIgnoringASCIICase(name, "_parent")) {
+    if (this_frame_->isNwFakeTop())
+      return current_frame;
     return Parent() ? Parent() : current_frame;
   }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/frame_tree.h nw/chromium/third_party/blink/renderer/core/page/frame_tree.h
--- up/chromium/third_party/blink/renderer/core/page/frame_tree.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/frame_tree.h	2024-08-26 19:32:30.418587562 +0000
@@ -68,7 +68,7 @@
   Frame* TraverseNext(const Frame* stay_within = nullptr) const;
 
   // For plugins and tests only.
-  Frame* FindFrameByName(const AtomicString& name) const;
+  Frame* FindFrameByName(const AtomicString& name, bool nw = false) const;
 
   // https://html.spec.whatwg.org/#the-rules-for-choosing-a-browsing-context-given-a-browsing-context-name
   struct FindResult {
diff -r -u --color up/chromium/third_party/blink/renderer/core/paint/timing/text_paint_timing_detector.h nw/chromium/third_party/blink/renderer/core/paint/timing/text_paint_timing_detector.h
--- up/chromium/third_party/blink/renderer/core/paint/timing/text_paint_timing_detector.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/paint/timing/text_paint_timing_detector.h	2024-08-26 19:32:30.450587570 +0000
@@ -16,6 +16,7 @@
 #include "ui/gfx/geometry/rect_conversions.h"
 
 namespace blink {
+class WebString;
 class LayoutBoxModelObject;
 class LocalFrameView;
 class PropertyTreeStateOrAlias;
diff -r -u --color up/chromium/third_party/blink/renderer/core/probe/core_probes.h nw/chromium/third_party/blink/renderer/core/probe/core_probes.h
--- up/chromium/third_party/blink/renderer/core/probe/core_probes.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/probe/core_probes.h	2024-08-26 19:32:30.454587571 +0000
@@ -135,6 +135,26 @@
 }
 
 inline CoreProbeSink* ToCoreProbeSink(Document& document) {
+  LocalFrame* frame = document.GetFrame();
+  if (!frame && document.TemplateDocumentHost())
+    frame = document.TemplateDocumentHost()->GetFrame();
+  // filter out non-jail frame instrumentations
+  if (frame) {
+    Frame* jail_frame = NULL;
+    if ((jail_frame = frame->getDevtoolsJail()) != NULL) {
+      Frame* f = document.GetFrame();
+      bool in_jail_frame = false;
+      while (f) {
+        if (f == jail_frame) {
+          in_jail_frame = true;
+          break;
+        }
+        f = f->Tree().Parent();
+      }
+      if (!in_jail_frame)
+        return NULL;
+    }
+  }
   return ToCoreProbeSink(document.GetExecutionContext());
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/scheduler/scheduled_action.cc nw/chromium/third_party/blink/renderer/core/scheduler/scheduled_action.cc
--- up/chromium/third_party/blink/renderer/core/scheduler/scheduled_action.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/scheduler/scheduled_action.cc	2024-08-26 19:32:30.458587572 +0000
@@ -57,7 +57,9 @@
                                  const HeapVector<ScriptValue>& arguments)
     : script_state_(
           MakeGarbageCollected<ScriptStateProtectingContext>(script_state)) {
+  //NWJS#7554
   if (script_state->World().IsWorkerOrWorkletWorld() ||
+      script_state->GetIsolate()->GetEnteredOrMicrotaskContext()->GetAlignedPointerFromEmbedderData(50) == (void*)0x08110800 ||
       BindingSecurity::ShouldAllowAccessTo(
           EnteredDOMWindow(script_state->GetIsolate()),
           To<LocalDOMWindow>(&target))) {
diff -r -u --color up/chromium/third_party/blink/renderer/core/script/modulator.h nw/chromium/third_party/blink/renderer/core/script/modulator.h
--- up/chromium/third_party/blink/renderer/core/script/modulator.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/script/modulator.h	2024-08-26 19:32:30.462587573 +0000
@@ -114,6 +114,7 @@
   const char* NameInHeapSnapshot() const override { return "Modulator"; }
 
   virtual ModuleRecordResolver* GetModuleRecordResolver() = 0;
+  virtual void AddToMap(const KURL& url, ModuleScript*) = 0;
   virtual base::SingleThreadTaskRunner* TaskRunner() = 0;
 
   virtual ScriptState* GetScriptState() = 0;
diff -r -u --color up/chromium/third_party/blink/renderer/core/script/modulator_impl_base.cc nw/chromium/third_party/blink/renderer/core/script/modulator_impl_base.cc
--- up/chromium/third_party/blink/renderer/core/script/modulator_impl_base.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/script/modulator_impl_base.cc	2024-08-26 19:32:30.462587573 +0000
@@ -60,6 +60,10 @@
   return GetExecutionContext()->GetV8CacheOptions();
 }
 
+void ModulatorImplBase::AddToMap(const KURL& url, ModuleScript* script) {
+  map_->AddToMap(url, script);
+}
+
 // <specdef label="fetch-a-module-script-tree"
 // href="https://html.spec.whatwg.org/C/#fetch-a-module-script-tree">
 // <specdef label="fetch-a-module-worker-script-tree"
diff -r -u --color up/chromium/third_party/blink/renderer/core/script/modulator_impl_base.h nw/chromium/third_party/blink/renderer/core/script/modulator_impl_base.h
--- up/chromium/third_party/blink/renderer/core/script/modulator_impl_base.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/script/modulator_impl_base.h	2024-08-26 19:32:30.462587573 +0000
@@ -46,6 +46,8 @@
 
   bool IsScriptingDisabled() const override;
 
+  void AddToMap(const KURL& url, ModuleScript* script) override;
+
   mojom::blink::V8CacheOptions GetV8CacheOptions() const final;
 
   ModuleRecordResolver* GetModuleRecordResolver() override {
diff -r -u --color up/chromium/third_party/blink/renderer/core/script/module_map.cc nw/chromium/third_party/blink/renderer/core/script/module_map.cc
--- up/chromium/third_party/blink/renderer/core/script/module_map.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/script/module_map.cc	2024-08-26 19:32:30.462587573 +0000
@@ -34,6 +34,8 @@
   ModuleScript* GetModuleScript() const;
 
  private:
+  friend class ModuleMap;
+
   void DispatchFinishedNotificationAsync(SingleModuleClient*);
 
   // Implements ModuleScriptLoaderClient
@@ -52,6 +54,14 @@
   DCHECK(map_);
 }
 
+void ModuleMap::AddToMap(const KURL& url, ModuleScript* script) {
+  MapImpl::AddResult result = map_.insert(std::make_pair(url, ModuleType::kJavaScript), nullptr);
+  Member<Entry>& entry = result.stored_value->value;
+  entry = MakeGarbageCollected<Entry>(this);
+  entry->module_script_ = script;
+  entry->is_fetching_ = false;
+}
+
 void ModuleMap::Entry::Trace(Visitor* visitor) const {
   visitor->Trace(module_script_);
   visitor->Trace(map_);
diff -r -u --color up/chromium/third_party/blink/renderer/core/script/module_map.h nw/chromium/third_party/blink/renderer/core/script/module_map.h
--- up/chromium/third_party/blink/renderer/core/script/module_map.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/script/module_map.h	2024-08-26 19:32:30.462587573 +0000
@@ -51,6 +51,7 @@
   // If the URL wasn't fetched, or is currently being fetched, this returns a
   // nullptr.
   ModuleScript* GetFetchedModuleScript(const KURL&, ModuleType) const;
+  void AddToMap(const KURL&, ModuleScript*);
 
   Modulator* GetModulator() { return modulator_.Get(); }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc nw/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc
--- up/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc	2024-08-26 19:32:30.590587606 +0000
@@ -42,6 +42,17 @@
 
 namespace blink {
 
+ArrayBufferContents::ArrayBufferContents(void* data,
+                                         size_t length,
+                                         bool nodejs,
+                                         DataDeleter deleter) {
+  DCHECK(data || length == 0);
+
+  nodejs_ = nodejs;
+  backing_store_ =
+      v8::ArrayBuffer::NewBackingStore(data, length, deleter, nullptr);
+}
+
 ArrayBufferContents::ArrayBufferContents(
     const base::subtle::PlatformSharedMemoryRegion& region,
     uint64_t offset,
diff -r -u --color up/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h nw/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h
--- up/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h	2024-08-26 19:32:30.590587606 +0000
@@ -77,7 +77,7 @@
                       size_t element_byte_size,
                       SharingType is_shared,
                       InitializationPolicy);
-
+  ArrayBufferContents(void* data, size_t length, bool nodejs, DataDeleter deleter);
   ArrayBufferContents(
       const base::subtle::PlatformSharedMemoryRegion& shared_memory_region,
       uint64_t offset,
@@ -151,6 +151,7 @@
   static void FreeMemory(void*);
 
  private:
+  bool nodejs_;
   template <partition_alloc::AllocFlags flags>
   static void* AllocateMemory(size_t, InitializationPolicy);
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/dedicated_worker.cc nw/chromium/third_party/blink/renderer/core/workers/dedicated_worker.cc
--- up/chromium/third_party/blink/renderer/core/workers/dedicated_worker.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/dedicated_worker.cc	2024-08-26 19:32:30.598587608 +0000
@@ -14,6 +14,19 @@
 #include "base/unguessable_token.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "services/network/public/cpp/cross_origin_embedder_policy.h"
+
+#include "third_party/node-nw/src/node_webkit.h"
+#define BLINK_HOOK_MAP(type, sym, fn) CORE_EXPORT type fn = nullptr;
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+#include "base/command_line.h"
+
 #include "services/network/public/mojom/fetch_api.mojom-blink.h"
 #include "third_party/blink/public/common/blob/blob_utils.h"
 #include "third_party/blink/public/common/features.h"
@@ -536,6 +549,9 @@
         response_content_security_policies) {
   base::UnguessableToken parent_devtools_token;
   std::unique_ptr<WorkerSettings> settings;
+  bool isNodeJS = false;
+  std::string main_script;
+
   ExecutionContext* execution_context = GetExecutionContext();
   scoped_refptr<base::SingleThreadTaskRunner>
       agent_group_scheduler_compositor_task_runner;
@@ -553,6 +569,13 @@
             ->CompositorTaskRunner();
     top_level_frame_security_origin =
         window->GetFrame()->Top()->GetSecurityContext()->GetSecurityOrigin();
+
+    const base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();
+
+    isNodeJS = window->GetFrame() && window->GetFrame()->isNodeJS() && command_line.HasSwitch("enable-node-worker");
+    if (g_web_worker_start_thread_fn) {
+      (*g_web_worker_start_thread_fn)(window->GetFrame(), (void*)script_url.GetPath().Utf8().data(), &main_script, &isNodeJS);
+    }
   } else {
     // When a DedicatedWorker creates another DedicatedWorker (nested worker).
     WorkerGlobalScope* worker_global_scope =
@@ -573,7 +596,7 @@
           ? mojom::blink::ScriptType::kClassic
           : mojom::blink::ScriptType::kModule;
 
-  auto params = std::make_unique<GlobalScopeCreationParams>(
+  auto params = std::make_unique<GlobalScopeCreationParams>(isNodeJS, main_script,
       script_url, script_type, options_->name(), execution_context->UserAgent(),
       execution_context->GetUserAgentMetadata(), CreateWebWorkerFetchContext(),
       mojo::Clone(
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/dedicated_worker_global_scope.cc nw/chromium/third_party/blink/renderer/core/workers/dedicated_worker_global_scope.cc
--- up/chromium/third_party/blink/renderer/core/workers/dedicated_worker_global_scope.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/dedicated_worker_global_scope.cc	2024-08-26 19:32:30.598587608 +0000
@@ -437,6 +437,7 @@
       WorkerThreadDebugger::From(script_state->GetIsolate());
   transferable_message.sender_stack_trace_id =
       debugger->StoreCurrentStackTrace("postMessage");
+  if (GetThread())
   WorkerObjectProxy().PostMessageToWorkerObject(
       std::move(transferable_message));
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.cc nw/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.cc
--- up/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.cc	2024-08-26 19:32:30.598587608 +0000
@@ -16,6 +16,7 @@
 namespace blink {
 
 GlobalScopeCreationParams::GlobalScopeCreationParams(
+    bool isNodeJS, const std::string& main_script,
     const KURL& script_url,
     mojom::blink::ScriptType script_type,
     const String& global_scope_name,
@@ -57,6 +58,7 @@
     : script_url(script_url),
       script_type(script_type),
       global_scope_name(global_scope_name),
+      nodejs_(isNodeJS), main_script_(main_script),
       user_agent(user_agent),
       ua_metadata(ua_metadata.value_or(blink::UserAgentMetadata())),
       web_worker_fetch_context(std::move(web_worker_fetch_context)),
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.h nw/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.h
--- up/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.h	2024-08-26 19:32:30.598587608 +0000
@@ -46,6 +46,7 @@
 
  public:
   GlobalScopeCreationParams(
+      bool isNodeJS, const std::string& main_script,
       const KURL& script_url,
       mojom::blink::ScriptType script_type,
       const String& global_scope_name,
@@ -111,6 +112,8 @@
   mojom::blink::ScriptType script_type;
 
   String global_scope_name;
+  bool nodejs_;
+  std::string main_script_;
   String user_agent;
   UserAgentMetadata ua_metadata;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/shared_worker.cc nw/chromium/third_party/blink/renderer/core/workers/shared_worker.cc
--- up/chromium/third_party/blink/renderer/core/workers/shared_worker.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/shared_worker.cc	2024-08-26 19:32:30.598587608 +0000
@@ -30,6 +30,7 @@
  */
 
 #include "third_party/blink/renderer/core/workers/shared_worker.h"
+#include "base/command_line.h"
 
 #include <optional>
 
@@ -146,6 +147,8 @@
         script_url, blob_url_token.InitWithNewPipeAndPassReceiver());
   }
 
+  const base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();
+  bool isNodeJS = window->GetFrame()->isNodeJS() && command_line.HasSwitch("enable-node-worker");
   auto options = mojom::blink::WorkerOptions::New();
   // The same_site_cookies setting defaults to kAll for first-party contexts
   // (allowing access to SameSite Lax and String cookies) and kNone in
@@ -210,7 +213,7 @@
   SharedWorkerClientHolder::From(*window)->Connect(
       worker, std::move(remote_port), script_url, std::move(blob_url_token),
       std::move(options), same_site_cookies, context->UkmSourceID(),
-      connector_override);
+      connector_override, isNodeJS);
 
   return worker;
 }
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.cc nw/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.cc
--- up/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.cc	2024-08-26 19:32:30.598587608 +0000
@@ -92,7 +92,8 @@
     mojom::blink::SharedWorkerSameSiteCookies same_site_cookies,
     ukm::SourceId client_ukm_source_id,
     const HeapMojoRemote<mojom::blink::SharedWorkerConnector>*
-        connector_override) {
+      connector_override,
+    bool isNodeJS) {
   DCHECK(IsMainThread());
   DCHECK(options);
 
@@ -114,7 +115,7 @@
           ? mojom::InsecureRequestsPolicy::kUpgrade
           : mojom::InsecureRequestsPolicy::kDoNotUpgrade;
 
-  auto info = mojom::blink::SharedWorkerInfo::New(
+  auto info = mojom::blink::SharedWorkerInfo::New(isNodeJS, base::FilePath(),
       url, std::move(options),
       mojo::Clone(worker->GetExecutionContext()
                       ->GetContentSecurityPolicy()
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.h nw/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.h
--- up/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.h	2024-08-26 19:32:30.598587608 +0000
@@ -83,7 +83,7 @@
                mojom::blink::SharedWorkerSameSiteCookies same_site_cookies,
                ukm::SourceId client_ukm_source_id,
                const HeapMojoRemote<mojom::blink::SharedWorkerConnector>*
-                   connector_override);
+   	       connector_override, bool);
 
   void Trace(Visitor* visitor) const override;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/threaded_worklet_messaging_proxy.cc nw/chromium/third_party/blink/renderer/core/workers/threaded_worklet_messaging_proxy.cc
--- up/chromium/third_party/blink/renderer/core/workers/threaded_worklet_messaging_proxy.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/threaded_worklet_messaging_proxy.cc	2024-08-26 19:32:30.598587608 +0000
@@ -78,7 +78,7 @@
     // https://html.spec.whatwg.org/multipage/webappapis.html#secure-context
     bool starter_secure_context = true;
 
-    auto creation_params = std::make_unique<GlobalScopeCreationParams>(
+    auto creation_params = std::make_unique<GlobalScopeCreationParams>(false, std::string(),
         client_provided_global_scope_creation_params->script_url,
         /*script_type=*/mojom::blink::ScriptType::kModule, global_scope_name,
         /*user_agent=*/String(),
@@ -134,7 +134,7 @@
 
   LocalFrameClient* frame_client = window->GetFrame()->Client();
   auto global_scope_creation_params =
-      std::make_unique<GlobalScopeCreationParams>(
+    std::make_unique<GlobalScopeCreationParams>(false, std::string(),
           window->Url(), mojom::blink::ScriptType::kModule, global_scope_name,
           frame_client->UserAgent(), frame_client->UserAgentMetadata(),
           frame_client->CreateWorkerFetchContext(),
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/worker_backing_thread.cc nw/chromium/third_party/blink/renderer/core/workers/worker_backing_thread.cc
--- up/chromium/third_party/blink/renderer/core/workers/worker_backing_thread.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/worker_backing_thread.cc	2024-08-26 19:32:30.602587609 +0000
@@ -9,6 +9,18 @@
 #include "base/location.h"
 #include "base/synchronization/lock.h"
 #include "third_party/blink/public/common/features.h"
+
+#include "third_party/node-nw/src/node_webkit.h"
+#define BLINK_HOOK_MAP(type, sym, fn) extern type fn;
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/web/blink.h"
 #include "third_party/blink/renderer/bindings/core/v8/v8_binding_for_core.h"
@@ -25,6 +37,9 @@
 #include "third_party/blink/renderer/platform/wtf/hash_set.h"
 
 namespace blink {
+void set_web_worker_hooks(void* fn_start) {
+  g_web_worker_start_thread_fn = (VoidPtr4Fn)fn_start;
+}
 
 namespace {
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.cc nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.cc
--- up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.cc	2024-08-26 19:32:30.602587609 +0000
@@ -27,6 +27,7 @@
 
 #include "third_party/blink/renderer/core/workers/worker_global_scope.h"
 
+
 #include "base/memory/scoped_refptr.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/trace_event/typed_macros.h"
@@ -254,6 +255,27 @@
 
 }  // namespace
 
+ScriptValue WorkerGlobalScope::importNWBin(ScriptState* state, DOMArrayBuffer* buffer) {
+  v8::Isolate* isolate = state->GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  uint8_t *data = static_cast<uint8_t*>(buffer->Data());
+  int64_t length = buffer->ByteLength();
+  v8::Handle<v8::String> source_string = v8::String::NewFromUtf8(isolate, "", v8::NewStringType::kNormal).ToLocalChecked();
+  v8::ScriptCompiler::CachedData* cache;
+  cache = new v8::ScriptCompiler::CachedData(
+                                             data, (int)length, v8::ScriptCompiler::CachedData::BufferNotOwned);
+  v8::ScriptCompiler::Source source(source_string, cache);
+  v8::Local<v8::UnboundScript> script;
+  script = v8::ScriptCompiler::CompileUnboundScript(
+                                                    isolate, &source, v8::ScriptCompiler::kConsumeCodeCache).ToLocalChecked();
+  CHECK(!cache->rejected);
+  v8::Local<v8::Value> result;
+  v8::Context::Scope cscope (state->GetContext());
+  v8::FixSourceNWBin(isolate, script);
+  std::ignore = script->BindToCurrentContext()->Run(state->GetContext()).ToLocal(&result);
+  return ScriptValue(isolate, result);
+}
+
 // Implementation of the "import scripts into worker global scope" algorithm:
 // https://html.spec.whatwg.org/C/#import-scripts-into-worker-global-scope
 void WorkerGlobalScope::ImportScriptsInternal(const Vector<String>& urls) {
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.h nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.h
--- up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.h	2024-08-26 19:32:30.602587609 +0000
@@ -62,6 +62,7 @@
 
 struct BlinkTransferableMessage;
 struct GlobalScopeCreationParams;
+class DOMArrayBuffer;
 class ConsoleMessage;
 class FetchClientSettingsObjectSnapshot;
 class FontFaceSet;
@@ -130,6 +131,7 @@
   // This doesn't take an ExceptionState argument, but actually can throw
   // exceptions directly to V8 (crbug/1114610).
   virtual void importScripts(const Vector<String>& urls);
+  ScriptValue importNWBin(ScriptState* state, DOMArrayBuffer* buffer);
 
   // ExecutionContext
   const KURL& Url() const final;
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.idl nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.idl
--- up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.idl	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.idl	2024-08-26 19:32:30.602587609 +0000
@@ -43,6 +43,7 @@
     // Although RaisesException is not specified, importScripts() can actually
     // throw exceptions directly to V8.
     void importScripts(ScriptURLString... urls);
+    [CallWith=ScriptState] any importNWBin(ArrayBuffer buffer);
     readonly attribute WorkerNavigator navigator;
 
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/worker_thread.cc nw/chromium/third_party/blink/renderer/core/workers/worker_thread.cc
--- up/chromium/third_party/blink/renderer/core/workers/worker_thread.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/worker_thread.cc	2024-08-26 19:32:30.602587609 +0000
@@ -71,6 +71,17 @@
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 #include "third_party/blink/renderer/platform/wtf/threading.h"
 
+
+#include "third_party/node-nw/src/node_webkit.h"
+
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
 namespace blink {
 
 using ExitCode = WorkerThread::ExitCode;
@@ -604,6 +615,10 @@
   base::ElapsedTimer timer;
   DCHECK(IsCurrentThread());
   backing_thread_weak_factory_.emplace(this);
+
+  bool isNodeJS = global_scope_creation_params->nodejs_;
+  std::string main_script = global_scope_creation_params->main_script_;
+
   worker_reporting_proxy_.WillInitializeWorkerContext();
   {
     TRACE_EVENT0("blink.worker", "WorkerThread::InitializeWorkerContext");
@@ -651,7 +666,7 @@
     GlobalScope()->WillBeginLoading();
     v8::HandleScope handle_scope(GetIsolate());
     Platform::Current()->WorkerContextCreated(
-        GlobalScope()->ScriptController()->GetContext());
+          GlobalScope()->ScriptController()->GetContext(), isNodeJS, main_script);
 
     inspector_task_runner_->InitIsolate(GetIsolate());
     SetThreadState(ThreadState::kRunning);
@@ -766,6 +781,7 @@
 
   if (WorkerThreadDebugger* debugger = WorkerThreadDebugger::From(GetIsolate()))
     debugger->WorkerThreadDestroyed(this);
+  ::g_stop_nw_instance_fn();
 
   GetWorkerReportingProxy().WillDestroyWorkerGlobalScope();
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc nw/chromium/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc
--- up/chromium/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc	2024-08-26 19:32:30.610587611 +0000
@@ -725,11 +725,13 @@
     // exception thrown.
     // Refer : https://xhr.spec.whatwg.org/#sync-warning
     // Use count for XHR synchronous requests on main thread only.
+#if 0
     if (!window->document()->ProcessingBeforeUnload()) {
       Deprecation::CountDeprecation(
           GetExecutionContext(),
           WebFeature::kXMLHttpRequestSynchronousInNonWorkerOutsideBeforeUnload);
     }
+#endif
   }
 
   method_ = FetchUtils::NormalizeMethod(method);
diff -r -u --color up/chromium/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc nw/chromium/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc
--- up/chromium/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc	2024-08-26 19:32:30.642587619 +0000
@@ -52,6 +52,9 @@
 #include "third_party/blink/public/mojom/frame/color_scheme.mojom-blink.h"
 #include "third_party/blink/public/mojom/scroll/scroll_enums.mojom-blink.h"
 #include "third_party/blink/public/mojom/scroll/scroll_into_view_params.mojom-blink.h"
+
+#include "third_party/blink/renderer/core/frame/local_frame.h"
+
 #include "third_party/blink/public/platform/task_type.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_canvas_rendering_context_2d_settings.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_canvas_will_read_frequently.h"
@@ -629,6 +632,8 @@
 }
 
 bool CanvasRenderingContext2D::OriginClean() const {
+  if (canvas()->GetDocument().GetFrame() && canvas()->GetDocument().GetFrame()->isNodeJS())
+    return true;
   return Host()->OriginClean();
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/modules/csspaint/paint_worklet_global_scope_proxy.cc nw/chromium/third_party/blink/renderer/modules/csspaint/paint_worklet_global_scope_proxy.cc
--- up/chromium/third_party/blink/renderer/modules/csspaint/paint_worklet_global_scope_proxy.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/csspaint/paint_worklet_global_scope_proxy.cc	2024-08-26 19:32:30.670587626 +0000
@@ -38,7 +38,7 @@
       StringView("PaintWorklet #") + String::Number(global_scope_number);
 
   LocalFrameClient* frame_client = frame->Client();
-  auto creation_params = std::make_unique<GlobalScopeCreationParams>(
+  auto creation_params = std::make_unique<GlobalScopeCreationParams>(false, std::string(),
       window->Url(), mojom::blink::ScriptType::kModule, global_scope_name,
       frame_client->UserAgent(), frame_client->UserAgentMetadata(),
       frame_client->CreateWorkerFetchContext(),
diff -r -u --color up/chromium/third_party/blink/renderer/modules/exported/web_embedded_worker_impl.cc nw/chromium/third_party/blink/renderer/modules/exported/web_embedded_worker_impl.cc
--- up/chromium/third_party/blink/renderer/modules/exported/web_embedded_worker_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/exported/web_embedded_worker_impl.cc	2024-08-26 19:32:30.682587629 +0000
@@ -43,6 +43,20 @@
 #include "third_party/blink/public/platform/modules/service_worker/web_service_worker_network_provider.h"
 #include "third_party/blink/public/platform/modules/service_worker/web_service_worker_provider.h"
 #include "third_party/blink/public/platform/platform.h"
+
+#include "third_party/node-nw/src/node_webkit.h"
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#define BLINK_HOOK_MAP(type, sym, fn) CORE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#define BLINK_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+#include "base/command_line.h"
+
 #include "third_party/blink/public/platform/task_type.h"
 #include "third_party/blink/public/platform/web_url_request.h"
 #include "third_party/blink/public/platform/web_worker_fetch_context.h"
@@ -157,6 +171,10 @@
     scoped_refptr<base::SingleThreadTaskRunner> initiator_thread_task_runner) {
   DCHECK(!asked_to_terminate_);
 
+  //Document* document = shadow_page_->GetDocument();
+  const base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();
+  bool isNodeJS = command_line.HasSwitch("enable-node-worker");
+
   // For now we don't use global scope name for service workers.
   const String global_scope_name = g_empty_string;
 
@@ -190,6 +208,11 @@
       false /* strictly_block_blockable_mixed_content */,
       GenericFontFamilySettings());
 
+  std::string main_script;
+  KURL script_url = worker_start_data->script_url;
+  if (g_web_worker_start_thread_fn) {
+    (*g_web_worker_start_thread_fn)(nullptr, (void*)script_url.GetPath().Utf8().data(), &main_script, &isNodeJS);
+  }
   std::unique_ptr<GlobalScopeCreationParams> global_scope_creation_params;
   String source_code;
   std::unique_ptr<Vector<uint8_t>> cached_meta_data;
@@ -197,7 +220,7 @@
   // We don't have to set ContentSecurityPolicy and ReferrerPolicy. They're
   // served by the worker script loader or the installed scripts manager on the
   // worker thread.
-  global_scope_creation_params = std::make_unique<GlobalScopeCreationParams>(
+  global_scope_creation_params = std::make_unique<GlobalScopeCreationParams>(isNodeJS, main_script,
       worker_start_data->script_url, worker_start_data->script_type,
       global_scope_name, worker_start_data->user_agent,
       worker_start_data->ua_metadata, std::move(web_worker_fetch_context),
diff -r -u --color up/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.cc nw/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.cc
--- up/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.cc	2024-08-26 19:32:30.690587632 +0000
@@ -50,7 +50,18 @@
 #include "third_party/blink/renderer/platform/privacy_budget/identifiability_digest_helpers.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
 
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_frame.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/renderer/core/dom/document.h"
+
 namespace blink {
+void fix_gamepad_nw(WebLocalFrame* frame) {
+  Document* doc = frame->GetDocument();
+  NavigatorGamepad* gamepad = &NavigatorGamepad::From(*(doc->domWindow()->navigator()));
+  gamepad->SetWindow(doc->domWindow());
+  gamepad->SampleAndCompareGamepadState();
+}
 
 namespace {
 
diff -r -u --color up/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.h nw/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.h
--- up/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.h	2024-08-26 19:32:30.690587632 +0000
@@ -49,6 +49,9 @@
 class GamepadDispatcher;
 class GamepadHapticActuator;
 class Navigator;
+class WebLocalFrame;
+
+MODULES_EXPORT void fix_gamepad_nw(WebLocalFrame*);
 
 class MODULES_EXPORT NavigatorGamepad final
     : public GarbageCollected<NavigatorGamepad>,
@@ -70,7 +73,7 @@
 
   void Trace(Visitor*) const override;
 
- private:
+ public:
   void SampleGamepads();
 
   void DidRemoveGamepadEventListeners();
diff -r -u --color up/chromium/third_party/blink/renderer/modules/storage/cached_storage_area.cc nw/chromium/third_party/blink/renderer/modules/storage/cached_storage_area.cc
--- up/chromium/third_party/blink/renderer/modules/storage/cached_storage_area.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/storage/cached_storage_area.cc	2024-08-26 19:32:30.810587662 +0000
@@ -29,6 +29,8 @@
 #include "third_party/blink/renderer/platform/wtf/text/unicode.h"
 #include "third_party/blink/renderer/platform/wtf/text/utf8.h"
 
+BLINK_EXPORT int g_nw_dom_storage_quota = 10485760;
+
 namespace blink {
 
 namespace {
@@ -90,11 +92,13 @@
 
   // A quick check to reject obviously overbudget items to avoid priming the
   // cache.
+#if 0
   if ((key.length() + value.length()) * 2 >
       mojom::blink::StorageArea::kPerStorageAreaQuota) {
     return false;
   }
 
+#endif
   EnsureLoaded();
   String old_value;
   if (!map_->SetItem(key, value, &old_value))
@@ -192,8 +196,7 @@
     new_observer = receiver_.BindNewPipeAndPassRemote();
   }
 
-  map_ = std::make_unique<StorageAreaMap>(
-      mojom::blink::StorageArea::kPerStorageAreaQuota);
+  map_ = std::make_unique<StorageAreaMap>(g_nw_dom_storage_quota);
 
   KURL page_url = source->GetPageUrl();
   String source_id = areas_->at(source);
@@ -485,8 +488,7 @@
   // that case because we needed to know whether the StorageArea was actually
   // non-empty prior to the call.
   if (!local_mutation) {
-    map_ = std::make_unique<StorageAreaMap>(
-        mojom::blink::StorageArea::kPerStorageAreaQuota);
+    map_ = std::make_unique<StorageAreaMap>(g_nw_dom_storage_quota);
 
     // Re-apply the most recent local mutations for each key. These must have
     // occurred after the deletion, because we haven't observed events for them
@@ -649,8 +651,7 @@
   const FormatOption key_format = GetKeyFormat();
   const FormatOption value_format = GetValueFormat();
 
-  map_ = std::make_unique<StorageAreaMap>(
-      mojom::blink::StorageArea::kPerStorageAreaQuota);
+  map_ = std::make_unique<StorageAreaMap>(g_nw_dom_storage_quota);
   for (const auto& item : data) {
     map_->SetItemIgnoringQuota(Uint8VectorToString(item->key, key_format),
                                Uint8VectorToString(item->value, value_format));
diff -r -u --color up/chromium/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc nw/chromium/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc
--- up/chromium/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc	2024-08-26 19:32:30.878587680 +0000
@@ -1048,7 +1048,7 @@
     base::span<const uint8_t> buffer;
     const MojoResult begin_result =
         readable_->BeginReadData(MOJO_READ_DATA_FLAG_NONE, buffer);
-    if (begin_result == MOJO_RESULT_SHOULD_WAIT) {
+    if (begin_result == MOJO_RESULT_SHOULD_WAIT || begin_result == MOJO_RESULT_BUSY) {
       readable_watcher_.ArmOrNotify();
       return;
     }
diff -r -u --color up/chromium/third_party/blink/renderer/platform/BUILD.gn nw/chromium/third_party/blink/renderer/platform/BUILD.gn
--- up/chromium/third_party/blink/renderer/platform/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/BUILD.gn	2024-08-26 19:32:30.894587684 +0000
@@ -269,7 +269,7 @@
   visibility = []
   visibility = [ "./*" ]
   if (enable_precompiled_headers) {
-    if (is_win) {
+    if (is_win && false) {
       # This is a string rather than a file GN knows about. It has to match
       # exactly what's in the /FI flag below, and what might appear in the
       # source code in quotes for an #include directive.
diff -r -u --color up/chromium/third_party/blink/renderer/platform/bindings/script_state.cc nw/chromium/third_party/blink/renderer/platform/bindings/script_state.cc
--- up/chromium/third_party/blink/renderer/platform/bindings/script_state.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/bindings/script_state.cc	2024-08-26 19:32:30.918587690 +0000
@@ -39,6 +39,10 @@
   context->SetAlignedPointerInEmbedderData(kV8ContextPerContextDataIndex, this);
   RendererResourceCoordinator::Get()->OnScriptStateCreated(this,
                                                            execution_context);
+  for (int i = 32; i <= 36; i++) { //node_context_data.h
+    context->SetAlignedPointerInEmbedderData(i, nullptr);
+  }
+  context->SetAlignedPointerInEmbedderData(50, nullptr);
 }
 
 ScriptState::~ScriptState() {
diff -r -u --color up/chromium/third_party/blink/renderer/platform/bindings/script_state.h nw/chromium/third_party/blink/renderer/platform/bindings/script_state.h
--- up/chromium/third_party/blink/renderer/platform/bindings/script_state.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/bindings/script_state.h	2024-08-26 19:32:30.918587690 +0000
@@ -169,7 +169,7 @@
     // ScriptState::From() must not be called for a context that does not have
     // valid embedder data in the embedder field.
     DCHECK(script_state);
-    SECURITY_CHECK(script_state->context_ == context);
+    SECURITY_CHECK(script_state->context_ == context || context->GetAlignedPointerFromEmbedderData(50) == (void*)0x08110800);
     return script_state;
   }
 
@@ -190,7 +190,8 @@
     ScriptState* script_state =
         static_cast<ScriptState*>(context->GetAlignedPointerFromEmbedderData(
             isolate, kV8ContextPerContextDataIndex));
-    SECURITY_CHECK(!script_state || script_state->context_ == context);
+    SECURITY_CHECK(!script_state || script_state->context_ == context ||
+		   context->GetAlignedPointerFromEmbedderData(50) == (void*)0x08110800);
     return script_state;
   }
 
diff -r -u --color up/chromium/third_party/blink/renderer/platform/exported/web_security_origin.cc nw/chromium/third_party/blink/renderer/platform/exported/web_security_origin.cc
--- up/chromium/third_party/blink/renderer/platform/exported/web_security_origin.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/exported/web_security_origin.cc	2024-08-26 19:32:30.930587693 +0000
@@ -141,4 +141,9 @@
 }
 #endif
 
-}  // namespace blink
+void WebSecurityOrigin::grantUniversalAccess()
+{
+  const_cast<SecurityOrigin*>(private_.Get())->GrantUniversalAccess();
+}
+
+} // namespace blink
diff -r -u --color up/chromium/third_party/blink/renderer/platform/heap/thread_local.h nw/chromium/third_party/blink/renderer/platform/heap/thread_local.h
--- up/chromium/third_party/blink/renderer/platform/heap/thread_local.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/heap/thread_local.h	2024-08-26 19:32:30.986587707 +0000
@@ -28,7 +28,7 @@
 
 // The call is still cheaper than multiple calls through WTF/base/pthread*
 // layers.
-#if BUILDFLAG(BLINK_HEAP_INSIDE_SHARED_LIBRARY)
+#if 1 //BUILDFLAG(BLINK_HEAP_INSIDE_SHARED_LIBRARY)
 #define BLINK_HEAP_HIDE_THREAD_LOCAL_IN_LIBRARY 1
 #else
 #define BLINK_HEAP_HIDE_THREAD_LOCAL_IN_LIBRARY 0
diff -r -u --color up/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.cc nw/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.cc
--- up/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.cc	2024-08-26 19:32:31.054587725 +0000
@@ -30,6 +30,18 @@
 #include "third_party/blink/renderer/platform/scheduler/worker/worker_scheduler_proxy.h"
 #include "third_party/blink/renderer/platform/scheduler/worker/worker_thread_scheduler.h"
 
+#include "v8.h"
+
+#include "third_party/node-nw/src/node_webkit.h"
+#define PLATFORM_HOOK_MAP(type, sym, fn) PLATFORM_EXPORT type fn = nullptr;
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
 namespace blink {
 
 std::unique_ptr<NonMainThread> NonMainThread::CreateThread(
@@ -51,6 +63,9 @@
                                         params.frame_or_worker_scheduler)
                                   : nullptr),
       supports_gc_(params.supports_gc) {
+  bool is_node = false;
+  if (g_web_worker_thread_new_fn)
+    (*g_web_worker_thread_new_fn)((void*)params.name, &is_node);
   base::SimpleThread::Options options;
   options.thread_type = params.base_thread_type;
 
@@ -61,7 +76,7 @@
     message_pump_type = base::MessagePumpType::IO;
   }
   thread_ = std::make_unique<SimpleThreadImpl>(
-      params.name ? params.name : String(), options, params.realtime_period,
+      params.name ? params.name : String(), options, params.realtime_period, is_node,
       supports_gc_, const_cast<scheduler::NonMainThreadImpl*>(this),
       message_pump_type);
   if (supports_gc_) {
@@ -111,6 +126,7 @@
     const WTF::String& name_prefix,
     const base::SimpleThread ::Options& options,
     base::TimeDelta realtime_period,
+    bool is_node,
     bool supports_gc,
     NonMainThreadImpl* worker_thread,
     base::MessagePumpType message_pump_type)
@@ -120,8 +136,9 @@
                            ? realtime_period
                            : base::TimeDelta()),
 #endif
-      message_pump_type_(message_pump_type),
+      message_pump_type_(is_node ? base::MessagePumpType::NODE : message_pump_type),
       thread_(worker_thread),
+      nodejs_(is_node),
       supports_gc_(supports_gc) {
   // TODO(alexclarke): Do we need to unify virtual time for workers and the main
   // thread?
diff -r -u --color up/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.h nw/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.h
--- up/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.h	2024-08-26 19:32:31.054587725 +0000
@@ -76,6 +76,7 @@
     explicit SimpleThreadImpl(const WTF::String& name_prefix,
                               const base::SimpleThread::Options& options,
                               base::TimeDelta realtime_period,
+                              bool is_node,
                               bool supports_gc,
                               NonMainThreadImpl* worker_thread,
                               base::MessagePumpType message_pump_type);
@@ -132,6 +133,7 @@
         non_main_thread_scheduler_;
     scoped_refptr<base::SingleThreadTaskRunner> default_task_runner_;
     raw_ptr<base::RunLoop> run_loop_;
+    bool nodejs_;
     bool supports_gc_;
     std::unique_ptr<GCSupport> gc_support_;
   };
diff -r -u --color up/chromium/third_party/blink/renderer/platform/weborigin/security_origin.h nw/chromium/third_party/blink/renderer/platform/weborigin/security_origin.h
--- up/chromium/third_party/blink/renderer/platform/weborigin/security_origin.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/weborigin/security_origin.h	2024-08-26 19:32:31.094587735 +0000
@@ -135,6 +135,7 @@
   String Protocol() const { return protocol_; }
   String Host() const { return host_; }
   String Domain() const { return domain_; }
+  bool hasUniversalAccess() const { return universal_access_; }
 
   // Returns the registrable domain if available.
   // For non-tuple origin, IP address URL, and public suffixes, this returns a
diff -r -u --color up/chromium/third_party/blink/renderer/platform/wtf/BUILD.gn nw/chromium/third_party/blink/renderer/platform/wtf/BUILD.gn
--- up/chromium/third_party/blink/renderer/platform/wtf/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/wtf/BUILD.gn	2024-08-26 19:32:31.102587737 +0000
@@ -17,6 +17,7 @@
   "//:gn_all",
   "//mojo/public/cpp/bindings/*",
   "//third_party/blink/*",
+  "//content/nw/*",
 ]
 
 config("wtf_config") {
diff -r -u --color up/chromium/third_party/blink/renderer/platform/wtf/allocator/partitions.cc nw/chromium/third_party/blink/renderer/platform/wtf/allocator/partitions.cc
--- up/chromium/third_party/blink/renderer/platform/wtf/allocator/partitions.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/wtf/allocator/partitions.cc	2024-08-26 19:32:31.102587737 +0000
@@ -213,8 +213,9 @@
     scoped_refptr<base::SequencedTaskRunner> task_runner) {
   CHECK(IsMainThread());
   DCHECK(initialized_);
-
+#if PA_BUILDFLAG(USE_PARTITION_ALLOC_AS_MALLOC)
   base::allocator::StartMemoryReclaimer(task_runner);
+#endif
 }
 
 // static
diff -r -u --color up/chromium/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc nw/chromium/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc
--- up/chromium/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc	2024-08-26 19:32:42.590591936 +0000
@@ -14,6 +14,7 @@
 
 #include "handler/crash_report_upload_thread.h"
 
+#include "base/strings/stringprintf.h"
 #include <errno.h>
 #include <time.h>
 
@@ -103,7 +104,7 @@
               this),
       known_pending_report_uuids_(),
       database_(database) {
-  DCHECK(!url_.empty());
+  //DCHECK(!url_.empty());
 }
 
 CrashReportUploadThread::~CrashReportUploadThread() {
@@ -303,6 +304,9 @@
     return UploadResult::kPermanentFailure;
   }
 
+  std::string upload_url;
+  if (parameters.find("url-nwjs") != parameters.end())
+    upload_url = parameters["url-nwjs"];
   HTTPMultipartBuilder http_multipart_builder;
   http_multipart_builder.SetGzipEnabled(options_.upload_gzip);
 
@@ -341,7 +345,8 @@
   // TODO(mark): The timeout should be configurable by the client.
   http_transport->SetTimeout(internal::kUploadReportTimeoutSeconds);
 
-  std::string url = url_;
+#if 0
+  std::string url = upload_url;
   if (options_.identify_client_via_url) {
     // Add parameters to the URL which identify the client to the server.
     static constexpr struct {
@@ -364,7 +369,10 @@
       }
     }
   }
-  http_transport->SetURL(url);
+  if (!url.empty())
+    upload_url = url;
+#endif
+  http_transport->SetURL(upload_url);
 
   if (!http_transport->ExecuteSynchronously(response_body)) {
     return UploadResult::kRetry;
@@ -390,7 +398,7 @@
       // If the most recent upload attempt occurred within the past hour,
       // dont attempt to upload the new report. If it happened longer ago,
       // attempt to upload the report.
-      constexpr int kUploadAttemptIntervalSeconds = 60 * 60;  // 1 hour
+      constexpr int kUploadAttemptIntervalSeconds = 0;  // 1 hour
       if (now - last_upload_attempt_time < kUploadAttemptIntervalSeconds) {
         database_->SkipReportUpload(
             report.uuid, Metrics::CrashSkippedReason::kUploadThrottled);
diff -r -u --color up/chromium/third_party/crashpad/crashpad/handler/handler_main.cc nw/chromium/third_party/crashpad/crashpad/handler/handler_main.cc
--- up/chromium/third_party/crashpad/crashpad/handler/handler_main.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/crashpad/crashpad/handler/handler_main.cc	2024-08-26 19:32:42.590591936 +0000
@@ -1017,7 +1017,7 @@
   }
 
   ScopedStoppable upload_thread;
-  if (!options.url.empty()) {
+  if (true) {
     // TODO(scottmg): options.rate_limit should be removed when we have a
     // configurable database setting to control upload limiting.
     // See https://crashpad.chromium.org/bug/23.
diff -r -u --color up/chromium/third_party/node/node.py nw/chromium/third_party/node/node.py
--- up/chromium/third_party/node/node.py	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/node/node.py	2024-08-26 19:32:43.674592498 +0000
@@ -7,8 +7,11 @@
 import platform
 import subprocess
 import sys
+import atexit
 import os
+import signal
 
+is_win = (platform.system() == 'Windows')
 
 def GetBinaryPath():
   if platform.machine() == 'arm64':
@@ -23,12 +26,30 @@
     'Windows': ('win', 'node.exe'),
   }[platform.system()])
 
-
 def RunNode(cmd_parts, stdout=None):
   cmd = [GetBinaryPath()] + cmd_parts
-  process = subprocess.Popen(
-      cmd, cwd=os.getcwd(), stdout=subprocess.PIPE, stderr=subprocess.PIPE,
-      universal_newlines=True)
+  process = None
+  if is_win:
+    process = subprocess.Popen(
+        cmd, cwd=os.getcwd(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
+  else:
+    process = subprocess.Popen(
+      cmd, cwd=os.getcwd(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, preexec_fn=os.setsid)
+  pgid = None
+  if not is_win:
+    pgid = os.getpgid(process.pid)
+  @atexit.register
+  def kill_process(*args):
+      try:
+        if is_win:
+          os.popen('taskkill /T /F /PID %d' % process.pid)
+        else:
+          os.kill(process.pid, signal.SIGTERM)
+          os.killpg(pgid, signal.SIGTERM)
+        process.wait()
+      except OSError:
+        pass
+  signal.signal(signal.SIGTERM, kill_process)
   stdout, stderr = process.communicate()
 
   if process.returncode != 0:
diff -r -u --color up/chromium/third_party/widevine/cdm/widevine.gni nw/chromium/third_party/widevine/cdm/widevine.gni
--- up/chromium/third_party/widevine/cdm/widevine.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/widevine/cdm/widevine.gni	2024-08-26 19:32:45.638593516 +0000
@@ -12,8 +12,8 @@
   # Google Chrome for Testing and Android. For Fuchsia, see crbug.com/1354347.
   # Can be optionally enabled in Chromium on non-Android platforms. Please see
   # //src/third_party/widevine/LICENSE file for details.
-  enable_widevine = ((is_chrome_branded || is_chrome_for_testing_branded) &&
-                     !is_fuchsia) || is_android
+  enable_widevine = true #((is_chrome_branded || is_chrome_for_testing_branded) &&
+                     #!is_fuchsia) || is_android
 }
 
 # Disable Widevine when running linux-chromeos.
diff -r -u --color up/chromium/third_party/zlib/google/zip.cc nw/chromium/third_party/zlib/google/zip.cc
--- up/chromium/third_party/zlib/google/zip.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/zlib/google/zip.cc	2024-08-26 19:32:45.746593572 +0000
@@ -199,7 +199,7 @@
   reader.SetPassword(std::move(options.password));
 
   if (!reader.OpenFromPlatformFile(src_file)) {
-    LOG(ERROR) << "Cannot open ZIP from file handle " << src_file;
+    VLOG(1) << "Cannot open ZIP from file handle " << src_file;
     return false;
   }
 
diff -r -u --color up/chromium/third_party/zlib/google/zip_reader.cc nw/chromium/third_party/zlib/google/zip_reader.cc
--- up/chromium/third_party/zlib/google/zip_reader.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/third_party/zlib/google/zip_reader.cc	2024-08-26 19:32:45.746593572 +0000
@@ -150,7 +150,7 @@
   zip_file_ = internal::OpenHandleForUnzipping(zip_fd);
 #endif
   if (!zip_file_) {
-    LOG(ERROR) << "Cannot open ZIP from file handle " << zip_fd;
+    VLOG(1) << "Cannot open ZIP from file handle " << zip_fd;
     return false;
   }
 
diff -r -u --color up/chromium/tools/clang/raw_ptr_plugin/RawPtrManualPathsToIgnore.h nw/chromium/tools/clang/raw_ptr_plugin/RawPtrManualPathsToIgnore.h
--- up/chromium/tools/clang/raw_ptr_plugin/RawPtrManualPathsToIgnore.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/tools/clang/raw_ptr_plugin/RawPtrManualPathsToIgnore.h	2024-08-26 19:32:45.826593612 +0000
@@ -23,6 +23,7 @@
 //   (i.e. hopefully just the paths under out/.../gen/... directory)
 //   via the isInGeneratedLocation AST matcher in RewriteRawPtrFields.cpp.
 constexpr const char* const kRawPtrManualPathsToIgnore[] = {
+    "content/nw/",
     // Exclude to prevent PartitionAlloc<->raw_ptr<T> cyclical dependency.
     "base/allocator/",
 
diff -r -u --color up/chromium/tools/grit/grit_args.gni nw/chromium/tools/grit/grit_args.gni
--- up/chromium/tools/grit/grit_args.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/tools/grit/grit_args.gni	2024-08-26 19:32:45.918593629 +0000
@@ -36,6 +36,7 @@
 
   # Mac and iOS want Title Case strings.
   "use_titlecase=${is_apple}",
+  "nwjs_sdk=${nwjs_sdk}",
 ]
 
 # Must match `enable_hidpi` in ui/base/ui_features.gni.
@@ -43,6 +44,11 @@
   _grit_defines += [ "scale_factors=2x" ]
 }
 
+if (nwjs_sdk) {
+  _grit_defines += [ "nwjs_sdk" ]
+}
+
+
 # Environment variables to be used by grit and its subproceses.
 
 _grit_environment_vars = [
diff -r -u --color up/chromium/tools/gritsettings/resource_ids.spec nw/chromium/tools/gritsettings/resource_ids.spec
--- up/chromium/tools/gritsettings/resource_ids.spec	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/tools/gritsettings/resource_ids.spec	2024-08-26 19:32:45.918593629 +0000
@@ -32,6 +32,7 @@
   #
   # chrome/ and ios/chrome/ must start at the same id.
   # App only use one file depending on whether it is iOS or other platform.
+
   # Chromium strings and Google Chrome strings must start at the same id.
   # We only use one file depending on whether we're building Chromium or
   # Google Chrome.
@@ -1347,4 +1348,10 @@
 
   # Thinking about appending to the end?
   # Please read the header and find the right section above instead.
+
+  # Resource ids starting at 31000 are reserved for projects built on Chromium.
+  "chrome/browser/nwjs_resources.grd": {
+    "includes": [32000],
+    "structures": [32450],
+  },
 }
diff -r -u --color up/chromium/tools/licenses/licenses.py nw/chromium/tools/licenses/licenses.py
--- up/chromium/tools/licenses/licenses.py	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/tools/licenses/licenses.py	2024-08-26 19:32:45.934593633 +0000
@@ -140,6 +140,7 @@
 #   - Directories that contain example code, or build tooling.
 #   - Nested third_party code inside other third_party libraries.
 ADDITIONAL_PATHS = (
+    os.path.join('content', 'nw'),
     os.path.join('chrome', 'test', 'chromeos', 'autotest'),
     os.path.join('chrome', 'test', 'data'),
     os.path.join('native_client'),
@@ -165,6 +166,16 @@
 # any metadata files with errors and if you encounter a parsing issue,
 # please file a bug.
 SPECIAL_CASES = {
+    os.path.join('content', 'nw'): {
+        "Name": "NW.js",
+        "URL": "http://nwjs.io",
+        "License": "MIT",
+    },
+    os.path.join('third_party', 'node'): {
+        "Name": "IO.js",
+        "URL": "https://iojs.org",
+        "License": "MIT",
+    },
     os.path.join('native_client'): {
         "Name": "native client",
         "URL": "https://code.google.com/p/nativeclient",
diff -r -u --color up/chromium/tools/v8_context_snapshot/BUILD.gn nw/chromium/tools/v8_context_snapshot/BUILD.gn
--- up/chromium/tools/v8_context_snapshot/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/tools/v8_context_snapshot/BUILD.gn	2024-08-26 19:32:46.306593704 +0000
@@ -39,7 +39,7 @@
 if (use_v8_context_snapshot) {
   if (v8_snapshot_toolchain == current_toolchain) {
     action("generate_v8_context_snapshot") {
-      script = "//build/gn_run_binary.py"
+      script = "run.py"
 
       output_file = "$root_build_dir/$v8_context_snapshot_filename"
       output_path = rebase_path(output_file, root_build_dir)
@@ -64,10 +64,10 @@
         # that it's possible that some of the shared libraries are updated
         # without having the executable updated.
         inputs = [
-          "$root_out_dir/${shlib_prefix}blink_core${shlib_extension}",
-          "$root_out_dir/${shlib_prefix}blink_modules${shlib_extension}",
-          "$root_out_dir/${shlib_prefix}blink_platform${shlib_extension}",
-          "$root_out_dir/${shlib_prefix}v8${shlib_extension}",
+          "$root_out_dir/${shlib_subdir}/${shlib_prefix}blink_core${shlib_extension}",
+          "$root_out_dir/${shlib_subdir}/${shlib_prefix}blink_modules${shlib_extension}",
+          "$root_out_dir/${shlib_subdir}/${shlib_prefix}blink_platform${shlib_extension}",
+          "$root_out_dir/${shlib_subdir}/${shlib_prefix}v8${shlib_extension}",
         ]
 
         deps += [
@@ -90,6 +90,21 @@
         "//v8",
       ]
 
+      if ((is_win || is_linux) && is_component_build) {
+      } else {
+        deps += [
+          "//v8:v8_initializers",
+        ]
+      }
+
+      if (is_linux && !is_component_build) {
+        configs += [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
+      }
+      if (is_mac && !is_component_build) {
+        # linking with ffmpeg lib
+        ldflags = [ "-rpath", "@executable_path/." ]
+      }
+
       configs += [
         "//v8:external_startup_data",
         ":disable_icf",
Only in nw/chromium/tools/v8_context_snapshot: run.py
diff -r -u --color up/chromium/ui/accelerated_widget_mac/BUILD.gn nw/chromium/ui/accelerated_widget_mac/BUILD.gn
--- up/chromium/ui/accelerated_widget_mac/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/accelerated_widget_mac/BUILD.gn	2024-08-26 19:32:46.322593708 +0000
@@ -59,6 +59,7 @@
     "//media",
     "//skia",
     "//ui/base",
+    "//ui/display",
     "//ui/events",
     "//ui/events:events_base",
     "//ui/gfx",
diff -r -u --color up/chromium/ui/accelerated_widget_mac/accelerated_widget_mac.mm nw/chromium/ui/accelerated_widget_mac/accelerated_widget_mac.mm
--- up/chromium/ui/accelerated_widget_mac/accelerated_widget_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/accelerated_widget_mac/accelerated_widget_mac.mm	2024-08-26 19:32:46.322593708 +0000
@@ -92,4 +92,5 @@
   }
 }
 
+
 }  // namespace ui
diff -r -u --color up/chromium/ui/accessibility/platform/atk_util_auralinux.cc nw/chromium/ui/accessibility/platform/atk_util_auralinux.cc
--- up/chromium/ui/accessibility/platform/atk_util_auralinux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/accessibility/platform/atk_util_auralinux.cc	2024-08-26 19:32:46.402593723 +0000
@@ -1,6 +1,7 @@
 // Copyright 2015 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunused-function"
 
 #include <atk/atk.h>
 #include <map>
@@ -178,6 +179,7 @@
 }
 
 void AtkUtilAuraLinux::InitializeAsync() {
+#if 0
   static bool initialized = false;
 
   if (initialized || !ShouldEnableAccessibility())
@@ -189,6 +191,7 @@
   g_type_class_unref(g_type_class_ref(atk_util_auralinux_get_type()));
 
   PlatformInitializeAsync();
+#endif
 }
 
 void AtkUtilAuraLinux::InitializeForTesting() {
diff -r -u --color up/chromium/ui/accessibility/platform/inspect/ax_tree_formatter_auralinux.cc nw/chromium/ui/accessibility/platform/inspect/ax_tree_formatter_auralinux.cc
--- up/chromium/ui/accessibility/platform/inspect/ax_tree_formatter_auralinux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/accessibility/platform/inspect/ax_tree_formatter_auralinux.cc	2024-08-26 19:32:46.414593725 +0000
@@ -226,6 +226,7 @@
       DCHECK_GE(index_in_parent, 0);
 #endif
 
+      link = atk_hypertext_get_link(hypertext, link_index);
       int utf8_offset = atk_hyperlink_get_start_index(link);
       gchar* link_start = g_utf8_offset_to_pointer(character_text, utf8_offset);
       int offset = link_start - character_text;
diff -r -u --color up/chromium/ui/aura/window_tree_host.cc nw/chromium/ui/aura/window_tree_host.cc
--- up/chromium/ui/aura/window_tree_host.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/aura/window_tree_host.cc	2024-08-26 19:32:46.462593735 +0000
@@ -214,6 +214,12 @@
                                window_->GetLocalSurfaceId());
 }
 
+#if defined(OS_WIN)
+void WindowTreeHost::SetPositionInPixels(const gfx::Point& pos_in_pixels) {
+
+}
+#endif
+
 void WindowTreeHost::ConvertDIPToScreenInPixels(gfx::Point* point) const {
   ConvertDIPToPixels(point);
   gfx::Point location = GetLocationOnScreenInPixels();
diff -r -u --color up/chromium/ui/aura/window_tree_host.h nw/chromium/ui/aura/window_tree_host.h
--- up/chromium/ui/aura/window_tree_host.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/aura/window_tree_host.h	2024-08-26 19:32:46.462593735 +0000
@@ -225,6 +225,9 @@
   // depending on the platform. The |local_surface_id| takes effect when (and
   // if) the new size is confirmed (potentially asynchronously) by the platform.
   virtual void SetBoundsInPixels(const gfx::Rect& bounds_in_pixels) = 0;
+#if defined(OS_WIN)
+  virtual void SetPositionInPixels(const gfx::Point& pos_in_pixels);
+#endif
   virtual gfx::Rect GetBoundsInPixels() const = 0;
 
   // Gets the bounds in DIP.
diff -r -u --color up/chromium/ui/base/accelerators/accelerator.cc nw/chromium/ui/base/accelerators/accelerator.cc
--- up/chromium/ui/base/accelerators/accelerator.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/accelerators/accelerator.cc	2024-08-26 19:32:46.462593735 +0000
@@ -7,6 +7,7 @@
 #include <stdint.h>
 
 #include <tuple>
+#include "base/strings/stringprintf.h"
 
 #include "base/check_op.h"
 #include "base/i18n/rtl.h"
@@ -183,7 +184,9 @@
   shortcut = KeyCodeToName();
 #endif
 
-  if (shortcut.empty()) {
+  if (shortcut.empty() && key_code_ >= VKEY_F1 && key_code_ <= VKEY_F12)
+    shortcut = base::UTF8ToUTF16(base::StringPrintf("F%d", key_code_ - VKEY_F1 + 1));
+  else if (shortcut.empty()) {
 #if BUILDFLAG(IS_WIN)
     // Our fallback is to try translate the key code to a regular character
     // unless it is one of digits (VK_0 to VK_9). Some keyboard
@@ -399,7 +402,7 @@
   // more information.
   if (IsCtrlDown())
     result = ApplyModifierToAcceleratorString(result, IDS_APP_CTRL_KEY);
-  else if (IsAltDown())
+  if (IsAltDown())
     result = ApplyModifierToAcceleratorString(result, IDS_APP_ALT_KEY);
 
   if (IsCmdDown()) {
@@ -409,6 +412,8 @@
     result = ApplyModifierToAcceleratorString(result, IDS_APP_SEARCH_KEY);
 #elif BUILDFLAG(IS_WIN)
     result = ApplyModifierToAcceleratorString(result, IDS_APP_WINDOWS_KEY);
+#elif defined(OS_LINUX)
+    result = ApplyModifierToAcceleratorString(result, IDS_APP_SUPER_MODIFIER);
 #else
     NOTREACHED_IN_MIGRATION();
 #endif
diff -r -u --color up/chromium/ui/base/base_window.cc nw/chromium/ui/base/base_window.cc
--- up/chromium/ui/base/base_window.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/base_window.cc	2024-08-26 19:32:46.466593735 +0000
@@ -12,5 +12,9 @@
      !window.IsFullscreen();
 }
 
+void BaseWindow::ForceClose() {
+  Close();
+}
+
 }  // namespace ui
 
diff -r -u --color up/chromium/ui/base/base_window.h nw/chromium/ui/base/base_window.h
--- up/chromium/ui/base/base_window.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/base_window.h	2024-08-26 19:32:46.466593735 +0000
@@ -67,6 +67,7 @@
   // Closes the window as soon as possible. The close action may be delayed
   // if an operation is in progress (e.g. a drag operation).
   virtual void Close() = 0;
+  virtual void ForceClose();
 
   // Activates (brings to front) the window. Restores the window from minimized
   // state if necessary.
diff -r -u --color up/chromium/ui/base/clipboard/clipboard.h nw/chromium/ui/base/clipboard/clipboard.h
--- up/chromium/ui/base/clipboard/clipboard.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/clipboard/clipboard.h	2024-08-26 19:32:46.466593735 +0000
@@ -313,7 +313,7 @@
                          const GURL& frame,
                          const GURL& main_frame);
 
- protected:
+ public:
   struct BitmapData {
     SkBitmap bitmap;
   };
diff -r -u --color up/chromium/ui/base/models/simple_menu_model.cc nw/chromium/ui/base/models/simple_menu_model.cc
--- up/chromium/ui/base/models/simple_menu_model.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/models/simple_menu_model.cc	2024-08-26 19:32:46.506593743 +0000
@@ -60,6 +60,10 @@
 
 void SimpleMenuModel::Delegate::OnMenuWillShow(SimpleMenuModel* /*source*/) {}
 
+bool SimpleMenuModel::Delegate::HasIcon(int command_id) {
+  return false;
+}
+
 void SimpleMenuModel::Delegate::MenuClosed(SimpleMenuModel* /*source*/) {
 }
 
diff -r -u --color up/chromium/ui/base/models/simple_menu_model.h nw/chromium/ui/base/models/simple_menu_model.h
--- up/chromium/ui/base/models/simple_menu_model.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/models/simple_menu_model.h	2024-08-26 19:32:46.506593743 +0000
@@ -121,6 +121,8 @@
     bool GetAcceleratorForCommandId(
         int command_id,
         ui::Accelerator* accelerator) const override;
+
+    virtual bool HasIcon(int command_id);
   };
 
   // The Delegate can be NULL, though if it is items can't be checked or
diff -r -u --color up/chromium/ui/base/mojom/ui_base_types.mojom nw/chromium/ui/base/mojom/ui_base_types.mojom
--- up/chromium/ui/base/mojom/ui_base_types.mojom	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/mojom/ui_base_types.mojom	2024-08-26 19:32:46.506593743 +0000
@@ -53,5 +53,6 @@
   SHOW_STATE_MINIMIZED = 2,
   SHOW_STATE_MAXIMIZED = 3,
   SHOW_STATE_INACTIVE = 4,
-  SHOW_STATE_FULLSCREEN = 5
+  SHOW_STATE_FULLSCREEN = 5,
+  SHOW_STATE_HIDDEN = 6
 };
diff -r -u --color up/chromium/ui/base/mojom/ui_base_types_mojom_traits.h nw/chromium/ui/base/mojom/ui_base_types_mojom_traits.h
--- up/chromium/ui/base/mojom/ui_base_types_mojom_traits.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/mojom/ui_base_types_mojom_traits.h	2024-08-26 19:32:46.506593743 +0000
@@ -177,6 +177,8 @@
         return ui::mojom::WindowShowState::SHOW_STATE_MAXIMIZED;
       case ui::SHOW_STATE_NORMAL:
         return ui::mojom::WindowShowState::SHOW_STATE_NORMAL;
+      case ui::SHOW_STATE_HIDDEN:
+        return ui::mojom::WindowShowState::SHOW_STATE_HIDDEN;
       case ui::SHOW_STATE_END:
         NOTREACHED_NORETURN();
     }
@@ -192,6 +194,9 @@
       case ui::mojom::WindowShowState::SHOW_STATE_FULLSCREEN:
         *out = ui::SHOW_STATE_FULLSCREEN;
         return true;
+      case ui::mojom::WindowShowState::SHOW_STATE_HIDDEN:
+        *out = ui::SHOW_STATE_HIDDEN;
+        return true;
       case ui::mojom::WindowShowState::SHOW_STATE_INACTIVE:
         *out = ui::SHOW_STATE_INACTIVE;
         return true;
diff -r -u --color up/chromium/ui/base/resource/resource_bundle.cc nw/chromium/ui/base/resource/resource_bundle.cc
--- up/chromium/ui/base/resource/resource_bundle.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/resource/resource_bundle.cc	2024-08-26 19:32:46.510593744 +0000
@@ -4,6 +4,8 @@
 
 #include "ui/base/resource/resource_bundle.h"
 
+#include "base/strings/string_util.h"
+
 #include <stdint.h>
 
 #include <string>
@@ -98,6 +100,8 @@
 ResourceBundle* g_shared_instance_ = nullptr;
 
 #if !BUILDFLAG(IS_CHROMEOS_LACROS)
+std::u16string *chromium_name, *nwjs_name;
+
 base::FilePath GetResourcesPakFilePath(const std::string& pak_name) {
   base::FilePath path;
   if (base::PathService::Get(base::DIR_ASSETS, &path))
@@ -958,6 +962,8 @@
   DCHECK(g_shared_instance_ == nullptr) << "ResourceBundle initialized twice";
   g_shared_instance_ = new ResourceBundle(delegate);
   std::vector<ResourceScaleFactor> supported_scale_factors;
+  chromium_name = new std::u16string(u"Chromium");
+  nwjs_name     = new std::u16string(u"NW.js");
 #if BUILDFLAG(IS_IOS)
   display::Display display = display::Screen::GetScreen()->GetPrimaryDisplay();
   if (display.device_scale_factor() > 2.0) {
@@ -997,13 +1003,13 @@
   // 2x images. The 1x data pack only has 1x images, thus passes in an accurate
   // scale factor to gfx::ImageSkia::AddRepresentation.
   if (IsScaleFactorSupported(k100Percent)) {
-    AddDataPackFromPath(GetResourcesPakFilePath("chrome_100_percent.pak"),
+    AddDataPackFromPath(GetResourcesPakFilePath("nw_100_percent.pak"),
                         k100Percent);
   }
 
   if (IsScaleFactorSupported(k200Percent)) {
     AddOptionalDataPackFromPath(
-        GetResourcesPakFilePath("chrome_200_percent.pak"), k200Percent);
+        GetResourcesPakFilePath("nw_200_percent.pak"), k200Percent);
   }
 }
 #endif  // !BUILDFLAG(IS_CHROMEOS_LACROS)
@@ -1179,8 +1185,10 @@
 
 std::u16string ResourceBundle::GetLocalizedStringImpl(int resource_id) const {
   std::u16string string;
-  if (delegate_ && delegate_->GetLocalizedString(resource_id, &string))
+  if (delegate_ && delegate_->GetLocalizedString(resource_id, &string)) {
+    base::ReplaceSubstringsAfterOffset(&string, 0, *chromium_name, *nwjs_name);
     return MaybeMangleLocalizedString(string);
+  }
 
   // Ensure that ReloadLocaleResources() doesn't drop the resources while
   // we're using them.
@@ -1237,6 +1245,7 @@
     // Best-effort conversion.
     base::UTF8ToUTF16(data->data(), data->size(), &msg);
   }
+  base::ReplaceSubstringsAfterOffset(&msg, 0, *chromium_name, *nwjs_name);
   return MaybeMangleLocalizedString(msg);
 }
 
diff -r -u --color up/chromium/ui/base/resource/resource_bundle_mac.mm nw/chromium/ui/base/resource/resource_bundle_mac.mm
--- up/chromium/ui/base/resource/resource_bundle_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/resource/resource_bundle_mac.mm	2024-08-26 19:32:46.514593744 +0000
@@ -52,13 +52,13 @@
 }  // namespace
 
 void ResourceBundle::LoadCommonResources() {
-  AddDataPackFromPath(GetResourcesPakFilePath(@"chrome_100_percent", nil),
+  AddDataPackFromPath(GetResourcesPakFilePath(@"nw_100_percent", nil),
                       k100Percent);
 
   // On Mac we load 1x and 2x resources and we let the UI framework decide
   // which one to use.
   if (IsScaleFactorSupported(k200Percent)) {
-    AddDataPackFromPath(GetResourcesPakFilePath(@"chrome_200_percent", nil),
+    AddDataPackFromPath(GetResourcesPakFilePath(@"nw_200_percent", nil),
                         k200Percent);
   }
 }
diff -r -u --color up/chromium/ui/base/ui_base_types.h nw/chromium/ui/base/ui_base_types.h
--- up/chromium/ui/base/ui_base_types.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/ui_base_types.h	2024-08-26 19:32:46.518593745 +0000
@@ -26,7 +26,8 @@
   SHOW_STATE_MAXIMIZED = 3,
   SHOW_STATE_INACTIVE = 4,  // Views only, not persisted.
   SHOW_STATE_FULLSCREEN = 5,
-  SHOW_STATE_END = 6  // The end of show state enum.
+  SHOW_STATE_HIDDEN = 6,
+  SHOW_STATE_END = 7  // The end of show state enum.
 };
 
 // Specifies which edges of the window are tiled.
diff -r -u --color up/chromium/ui/base/x/x11_global_shortcut_listener.cc nw/chromium/ui/base/x/x11_global_shortcut_listener.cc
--- up/chromium/ui/base/x/x11_global_shortcut_listener.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/x/x11_global_shortcut_listener.cc	2024-08-26 19:32:46.522593747 +0000
@@ -31,10 +31,11 @@
 
 x11::ModMask GetNativeModifiers(bool is_alt_down,
                                 bool is_ctrl_down,
-                                bool is_shift_down) {
+                                bool is_shift_down, bool is_cmd_down) {
   constexpr auto kNoMods = x11::ModMask{};
   return (is_shift_down ? x11::ModMask::Shift : kNoMods) |
          (is_ctrl_down ? x11::ModMask::Control : kNoMods) |
+    (is_cmd_down ? x11::ModMask::c_4 : kNoMods) |
          (is_alt_down ? x11::ModMask::c_1 : kNoMods);
 }
 
@@ -81,8 +82,9 @@
 bool XGlobalShortcutListener::RegisterAccelerator(KeyboardCode key_code,
                                                   bool is_alt_down,
                                                   bool is_ctrl_down,
-                                                  bool is_shift_down) {
-  auto modifiers = GetNativeModifiers(is_alt_down, is_ctrl_down, is_shift_down);
+                                                  bool is_shift_down,
+                                                  bool is_cmd_down) {
+  auto modifiers = GetNativeModifiers(is_alt_down, is_ctrl_down, is_shift_down, is_cmd_down);
   auto keysym = XKeysymForWindowsKeyCode(key_code, false);
   auto keycode = connection_->KeysymToKeycode(keysym);
 
@@ -115,8 +117,9 @@
 void XGlobalShortcutListener::UnregisterAccelerator(KeyboardCode key_code,
                                                     bool is_alt_down,
                                                     bool is_ctrl_down,
-                                                    bool is_shift_down) {
-  auto modifiers = GetNativeModifiers(is_alt_down, is_ctrl_down, is_shift_down);
+                                                    bool is_shift_down,
+                                                    bool is_cmd_down) {
+  auto modifiers = GetNativeModifiers(is_alt_down, is_ctrl_down, is_shift_down, is_cmd_down);
   auto keysym = XKeysymForWindowsKeyCode(key_code, false);
   auto keycode = connection_->KeysymToKeycode(keysym);
 
diff -r -u --color up/chromium/ui/base/x/x11_global_shortcut_listener.h nw/chromium/ui/base/x/x11_global_shortcut_listener.h
--- up/chromium/ui/base/x/x11_global_shortcut_listener.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/base/x/x11_global_shortcut_listener.h	2024-08-26 19:32:46.522593747 +0000
@@ -48,11 +48,13 @@
   bool RegisterAccelerator(KeyboardCode key_code,
                            bool is_alt_down,
                            bool is_ctrl_down,
-                           bool is_shift_down);
+                           bool is_shift_down,
+                           bool is_cmd_down);
   void UnregisterAccelerator(KeyboardCode key_code,
                              bool is_alt_down,
                              bool is_ctrl_down,
-                             bool is_shift_down);
+                             bool is_shift_down,
+                             bool is_cmd_down);
 
  private:
   // Due to how system key grabbing works on X11, we have to be a bit greedy and
diff -r -u --color up/chromium/ui/display/display.cc nw/chromium/ui/display/display.cc
--- up/chromium/ui/display/display.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/display/display.cc	2024-08-26 19:32:46.634593768 +0000
@@ -22,6 +22,16 @@
 #include "ui/gfx/geometry/transform.h"
 #include "ui/gfx/icc_profile.h"
 
+namespace content {
+
+// Switch to enable / disable code for window's transparency
+DISPLAY_EXPORT bool g_support_transparency = true;
+
+// Switch to force cpu drawing, is used to enable click through on alpha pixels
+extern bool g_force_cpu_draw;
+bool g_force_cpu_draw = false;
+}
+
 namespace display {
 namespace {
 
diff -r -u --color up/chromium/ui/display/display.h nw/chromium/ui/display/display.h
--- up/chromium/ui/display/display.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/display/display.h	2024-08-26 19:32:46.634593768 +0000
@@ -17,6 +17,11 @@
 #include "ui/gfx/display_color_spaces.h"
 #include "ui/gfx/geometry/rect.h"
 
+namespace content {
+  DISPLAY_EXPORT extern bool g_support_transparency;
+  DISPLAY_EXPORT extern bool g_force_cpu_draw;
+}
+
 namespace display {
 
 namespace mojom {
diff -r -u --color up/chromium/ui/gfx/BUILD.gn nw/chromium/ui/gfx/BUILD.gn
--- up/chromium/ui/gfx/BUILD.gn	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/gfx/BUILD.gn	2024-08-26 19:32:46.742593789 +0000
@@ -432,6 +432,7 @@
   }
   if (is_mac) {
     frameworks += [
+      "ApplicationServices.framework",
       "AppKit.framework",
       "CoreFoundation.framework",
       "CoreGraphics.framework",
diff -r -u --color up/chromium/ui/gfx/icon_util.cc nw/chromium/ui/gfx/icon_util.cc
--- up/chromium/ui/gfx/icon_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/gfx/icon_util.cc	2024-08-26 19:32:46.762593792 +0000
@@ -227,6 +227,21 @@
   return icon;
 }
 
+// NW fix: copied and modified from chrome/browser/ui/views/frame/glass_browser_frame_view.cc
+// Converts the |image| to a Windows icon and returns the corresponding HICON
+// handle. |image| is resized to desired |width| and |height| if needed.
+base::win::ScopedHICON IconUtil::CreateHICONFromSkBitmapSizedTo(
+  const SkBitmap& bitmap,
+  int width,
+  int height) {
+  return CreateHICONFromSkBitmap(
+    width == bitmap.width() && height == bitmap.height()
+    ? bitmap
+    : skia::ImageOperations::Resize(bitmap,
+    skia::ImageOperations::RESIZE_BEST,
+    width, height));
+}
+
 SkBitmap IconUtil::CreateSkBitmapFromHICON(HICON icon, const gfx::Size& s) {
   // We start with validating parameters.
   if (!icon || s.IsEmpty())
diff -r -u --color up/chromium/ui/gfx/icon_util.h nw/chromium/ui/gfx/icon_util.h
--- up/chromium/ui/gfx/icon_util.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/gfx/icon_util.h	2024-08-26 19:32:46.762593792 +0000
@@ -89,6 +89,10 @@
   // icon and returns the corresponding HICON handle if conversion succeeds.
   static base::win::ScopedHICON CreateHICONFromSkBitmap(const SkBitmap& bitmap);
 
+  static base::win::ScopedHICON CreateHICONFromSkBitmapSizedTo(const SkBitmap& bitmap,
+    int width,
+    int height);
+
   // Given a valid HICON handle representing an icon, this function converts
   // the icon into an SkBitmap object containing an ARGB bitmap using the
   // dimensions specified in |s|. |s| must specify valid dimensions (both
diff -r -u --color up/chromium/ui/gfx/mac/nswindow_frame_controls.h nw/chromium/ui/gfx/mac/nswindow_frame_controls.h
--- up/chromium/ui/gfx/mac/nswindow_frame_controls.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/gfx/mac/nswindow_frame_controls.h	2024-08-26 19:32:46.770593795 +0000
@@ -29,6 +29,7 @@
                                              const gfx::Size& max_size,
                                              bool can_resize,
                                              bool can_fullscreen);
+GFX_EXPORT void SetNSWindowShowInTaskbar(NSWindow* window, bool show);
 
 }  // namespace gfx
 
diff -r -u --color up/chromium/ui/gfx/mac/nswindow_frame_controls.mm nw/chromium/ui/gfx/mac/nswindow_frame_controls.mm
--- up/chromium/ui/gfx/mac/nswindow_frame_controls.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/gfx/mac/nswindow_frame_controls.mm	2024-08-26 19:32:46.770593795 +0000
@@ -37,6 +37,22 @@
   window.collectionBehavior = behavior;
 }
 
+void SetNSWindowShowInTaskbar(NSWindow* window, bool show) {
+  ProcessSerialNumber psn = { 0, kCurrentProcess };
+  if (!show) {
+    NSArray* windowList = [[NSArray alloc] init];
+    windowList = [NSWindow windowNumbersWithOptions:NSWindowNumberListAllSpaces];
+    for (unsigned int i = 0; i < [windowList count]; ++i) {
+      NSWindow *win = [NSApp windowWithWindowNumber:[[windowList objectAtIndex:i] integerValue]];
+      [win setCanHide:NO];
+    }
+    TransformProcessType(&psn, kProcessTransformToUIElementApplication);
+  }
+  else {
+    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+  }
+}
+
 void SetNSWindowVisibleOnAllWorkspaces(NSWindow* window, bool always_visible) {
   NSWindowCollectionBehavior behavior = window.collectionBehavior;
   if (always_visible)
diff -r -u --color up/chromium/ui/gfx/x/visual_picker_glx.cc nw/chromium/ui/gfx/x/visual_picker_glx.cc
--- up/chromium/ui/gfx/x/visual_picker_glx.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/gfx/x/visual_picker_glx.cc	2024-08-26 19:32:46.794593799 +0000
@@ -199,6 +199,9 @@
   if (auto configs = connection->glx().GetVisualConfigs(screen).Sync()) {
     system_visual = PickBestSystemVisual(connection, *configs.reply);
     rgba_visual = PickBestRgbaVisual(connection, *configs.reply);
+  } else {
+    system_visual = x11::VisualId{};
+    rgba_visual   = x11::VisualId{};
   }
 }
 
diff -r -u --color up/chromium/ui/gl/gl_features.cc nw/chromium/ui/gl/gl_features.cc
--- up/chromium/ui/gl/gl_features.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/gl/gl_features.cc	2024-08-26 19:32:46.806593801 +0000
@@ -91,7 +91,7 @@
 BASE_FEATURE(kGpuVsync, "GpuVsync", base::FEATURE_ENABLED_BY_DEFAULT);
 #endif
 
-#if BUILDFLAG(ENABLE_VALIDATING_COMMAND_DECODER)
+#if BUILDFLAG(ENABLE_VALIDATING_COMMAND_DECODER) || BUILDFLAG(IS_LINUX)
 // Use the passthrough command decoder by default.  This can be overridden with
 // the --use-cmd-decoder=passthrough or --use-cmd-decoder=validating flags.
 // Feature lives in ui/gl because it affects the GL binding initialization on
diff -r -u --color up/chromium/ui/gtk/select_file_dialog_linux_gtk.cc nw/chromium/ui/gtk/select_file_dialog_linux_gtk.cc
--- up/chromium/ui/gtk/select_file_dialog_linux_gtk.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/gtk/select_file_dialog_linux_gtk.cc	2024-08-26 19:32:46.818593804 +0000
@@ -437,12 +437,12 @@
   std::string title_string = title;
   if (title_string.empty()) {
     title_string =
-        (type == SELECT_UPLOAD_FOLDER)
+      (false)
             ? l10n_util::GetStringUTF8(IDS_SELECT_UPLOAD_FOLDER_DIALOG_TITLE)
             : l10n_util::GetStringUTF8(IDS_SELECT_FOLDER_DIALOG_TITLE);
   }
   std::string accept_button_label =
-      (type == SELECT_UPLOAD_FOLDER)
+    (false)
           ? l10n_util::GetStringUTF8(
                 IDS_SELECT_UPLOAD_FOLDER_DIALOG_UPLOAD_BUTTON)
           : GetOpenLabel();
diff -r -u --color up/chromium/ui/message_center/public/cpp/notification.h nw/chromium/ui/message_center/public/cpp/notification.h
--- up/chromium/ui/message_center/public/cpp/notification.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/message_center/public/cpp/notification.h	2024-08-26 19:32:46.822593804 +0000
@@ -539,8 +539,7 @@
   }
 
   bool should_show_settings_button() const {
-    return optional_fields_.settings_button_handler !=
-           SettingsButtonHandler::NONE;
+    return false;
   }
 
   void set_settings_button_handler(SettingsButtonHandler handler) {
diff -r -u --color up/chromium/ui/native_theme/native_theme_win.cc nw/chromium/ui/native_theme/native_theme_win.cc
--- up/chromium/ui/native_theme/native_theme_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/native_theme/native_theme_win.cc	2024-08-26 19:32:46.830593807 +0000
@@ -62,7 +62,7 @@
 // Windows system color IDs cached and updated by the native theme.
 const int kSysColors[] = {
     COLOR_BTNFACE,       COLOR_BTNTEXT,    COLOR_GRAYTEXT,      COLOR_HIGHLIGHT,
-    COLOR_HIGHLIGHTTEXT, COLOR_HOTLIGHT,   COLOR_MENUHIGHLIGHT, COLOR_SCROLLBAR,
+    COLOR_HIGHLIGHTTEXT, COLOR_HOTLIGHT,   COLOR_MENU, COLOR_MENUHIGHLIGHT, COLOR_SCROLLBAR,
     COLOR_WINDOW,        COLOR_WINDOWTEXT,
 };
 
diff -r -u --color up/chromium/ui/ozone/common/egl_util.cc nw/chromium/ui/ozone/common/egl_util.cc
--- up/chromium/ui/ozone/common/egl_util.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/ozone/common/egl_util.cc	2024-08-26 19:32:46.830593807 +0000
@@ -130,7 +130,7 @@
     if (!base::PathService::Get(base::DIR_MODULE, &module_path))
       return false;
 #endif
-
+    module_path = module_path.Append("lib/");
     glesv2_path = module_path.Append(kAngleGlesSoname);
     egl_path = module_path.Append(kAngleEglSoname);
   } else {
diff -r -u --color up/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.cc nw/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.cc
--- up/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.cc	2024-08-26 19:32:46.874593814 +0000
@@ -26,18 +26,20 @@
 bool X11GlobalShortcutListenerOzone::RegisterAccelerator(KeyboardCode key_code,
                                                          bool is_alt_down,
                                                          bool is_ctrl_down,
-                                                         bool is_shift_down) {
+                                                         bool is_shift_down,
+                                                         bool is_cmd_down) {
   return XGlobalShortcutListener::RegisterAccelerator(
-      key_code, is_alt_down, is_ctrl_down, is_shift_down);
+                                                      key_code, is_alt_down, is_ctrl_down, is_shift_down, is_cmd_down);
 }
 
 void X11GlobalShortcutListenerOzone::UnregisterAccelerator(
     KeyboardCode key_code,
     bool is_alt_down,
     bool is_ctrl_down,
-    bool is_shift_down) {
+    bool is_shift_down,
+    bool is_cmd_down) {
   return XGlobalShortcutListener::UnregisterAccelerator(
-      key_code, is_alt_down, is_ctrl_down, is_shift_down);
+                                                        key_code, is_alt_down, is_ctrl_down, is_shift_down, is_cmd_down);
 }
 
 void X11GlobalShortcutListenerOzone::OnKeyPressed(KeyboardCode key_code,
diff -r -u --color up/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.h nw/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.h
--- up/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.h	2024-08-26 19:32:46.878593816 +0000
@@ -28,11 +28,13 @@
   bool RegisterAccelerator(KeyboardCode key_code,
                            bool is_alt_down,
                            bool is_ctrl_down,
-                           bool is_shift_down) override;
+                           bool is_shift_down,
+                           bool is_cmd_down) override;
   void UnregisterAccelerator(KeyboardCode key_code,
                              bool is_alt_down,
                              bool is_ctrl_down,
-                             bool is_shift_down) override;
+                             bool is_shift_down,
+                             bool is_cmd_down) override;
 
   // ui::XGlobalShortcutListener:
   void OnKeyPressed(KeyboardCode key_code,
diff -r -u --color up/chromium/ui/ozone/public/platform_global_shortcut_listener.h nw/chromium/ui/ozone/public/platform_global_shortcut_listener.h
--- up/chromium/ui/ozone/public/platform_global_shortcut_listener.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/ozone/public/platform_global_shortcut_listener.h	2024-08-26 19:32:46.878593816 +0000
@@ -52,11 +52,13 @@
   virtual bool RegisterAccelerator(KeyboardCode key_code,
                                    bool is_alt_down,
                                    bool is_ctrl_down,
-                                   bool is_shift_down) = 0;
+                                   bool is_shift_down,
+                                   bool is_cmd_down) = 0;
   virtual void UnregisterAccelerator(KeyboardCode key_code,
                                      bool is_alt_down,
                                      bool is_ctrl_down,
-                                     bool is_shift_down) = 0;
+                                     bool is_shift_down,
+                                     bool is_cmd_down) = 0;
 
  protected:
   PlatformGlobalShortcutListenerDelegate* delegate() { return delegate_; }
diff -r -u --color up/chromium/ui/qt/qt.gni nw/chromium/ui/qt/qt.gni
--- up/chromium/ui/qt/qt.gni	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/qt/qt.gni	2024-08-26 19:32:46.882593816 +0000
@@ -9,7 +9,7 @@
 declare_args() {
   # TODO(crbug.com/40260415): Allow QT in MSAN builds once QT is
   # added to the instrumented libraries.
-  use_qt = is_linux && !is_castos && !is_msan
+  use_qt = false #is_linux && !is_castos && !is_msan
 }
 
 declare_args() {
diff -r -u --color up/chromium/ui/shell_dialogs/execute_select_file_win.cc nw/chromium/ui/shell_dialogs/execute_select_file_win.cc
--- up/chromium/ui/shell_dialogs/execute_select_file_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/shell_dialogs/execute_select_file_win.cc	2024-08-26 19:32:46.894593818 +0000
@@ -340,11 +340,12 @@
   }
 
   std::u16string ok_button_label;
+#if 0
   if (type == SelectFileDialog::SELECT_UPLOAD_FOLDER) {
     ok_button_label = l10n_util::GetStringUTF16(
         IDS_SELECT_UPLOAD_FOLDER_DIALOG_UPLOAD_BUTTON);
   }
-
+#endif
   DWORD dialog_options = FOS_PICKFOLDERS;
 
   std::vector<FileFilterSpec> no_filter;
diff -r -u --color up/chromium/ui/strings/ui_strings.grd nw/chromium/ui/strings/ui_strings.grd
--- up/chromium/ui/strings/ui_strings.grd	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/strings/ui_strings.grd	2024-08-26 19:32:46.974593834 +0000
@@ -780,6 +780,12 @@
       <message name="IDS_APP_ACCELERATOR_WITH_MODIFIER" desc="Accelerator with a modifier key">
         <ph name="KEY_MODIFIER_NAME">$1<ex>Ctrl</ex></ph>+<ph name="KEY_COMBO_NAME">$2<ex>C</ex></ph>
       </message>
+      <message name="IDS_APP_WINDOWS_MODIFIER" desc="Command key shortcut modifier">
+        Win+<ph name="KEY_COMBO_NAME">$1<ex>C</ex></ph>
+      </message>
+      <message name="IDS_APP_SUPER_MODIFIER" desc="Command key shortcut modifier">
+        Super+<ph name="KEY_COMBO_NAME">$1<ex>C</ex></ph>
+      </message>
 
       <!-- Byte size units -->
       <message name="IDS_APP_BYTES" desc="Units tag indicating a quantity of bytes">
diff -r -u --color up/chromium/ui/views/accessibility/view_ax_platform_node_delegate_auralinux.cc nw/chromium/ui/views/accessibility/view_ax_platform_node_delegate_auralinux.cc
--- up/chromium/ui/views/accessibility/view_ax_platform_node_delegate_auralinux.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/accessibility/view_ax_platform_node_delegate_auralinux.cc	2024-08-26 19:32:46.982593835 +0000
@@ -4,6 +4,8 @@
 
 #include "ui/views/accessibility/view_ax_platform_node_delegate_auralinux.h"
 
+#include "content/public/browser/browser_thread.h"
+
 #include <memory>
 #include <vector>
 
diff -r -u --color up/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.h nw/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.h
--- up/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.h	2024-08-26 19:32:46.994593838 +0000
@@ -253,6 +253,7 @@
   std::unique_ptr<NativeWidgetMacEventMonitor> AddEventMonitor(
       NativeWidgetMacEventMonitor::Client* client);
   void RemoveEventMonitor(NativeWidgetMacEventMonitor*);
+  bool IsMaximized() const;
 
   // Used by NativeWidgetPrivate::GetGlobalCapture.
   static NSView* GetGlobalCaptureView();
diff -r -u --color up/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.mm nw/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.mm
--- up/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.mm	2024-08-26 19:32:46.994593838 +0000
@@ -589,6 +589,12 @@
     GetNSWindowMojo()->ExitFullscreen();
 }
 
+bool NativeWidgetMacNSWindowHost::IsMaximized() const {
+  bool maximized = false;
+  GetNSWindowMojo()->IsMaximized(&maximized);
+  return maximized && !is_miniaturized_;
+}
+
 void NativeWidgetMacNSWindowHost::SetRootView(views::View* root_view) {
   if (root_view_) {
     DropRootViewReferences();
@@ -721,6 +727,11 @@
 gfx::Rect NativeWidgetMacNSWindowHost::GetRestoredBounds() const {
   if (target_fullscreen_state_ || in_fullscreen_transition_)
     return window_bounds_before_fullscreen_;
+  if (IsMaximized()) {
+    gfx::Rect ret;
+    if (GetNSWindowMojo()->GetRestoredBounds(&ret))
+      return ret;
+  }
   return window_bounds_in_screen_;
 }
 
@@ -1475,6 +1486,10 @@
 bool NativeWidgetMacNSWindowHost::OnWindowCloseRequested(
     bool* can_window_close) {
   *can_window_close = true;
+  if (root_view_ && !root_view_->GetWidget()->NWCanClose()) {
+    *can_window_close = false;
+    return true;
+  }
   views::NonClientView* non_client_view =
       root_view_ ? root_view_->GetWidget()->non_client_view() : nullptr;
   if (non_client_view)
diff -r -u --color up/chromium/ui/views/controls/menu/native_menu_win.cc nw/chromium/ui/views/controls/menu/native_menu_win.cc
--- up/chromium/ui/views/controls/menu/native_menu_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/controls/menu/native_menu_win.cc	2024-08-26 19:32:47.010593841 +0000
@@ -45,7 +45,7 @@
 // NativeMenuWin, public:
 
 NativeMenuWin::NativeMenuWin(ui::MenuModel* model, HWND sysmenu_hwnd)
-    : model_(model), sysmenu_hwnd_(sysmenu_hwnd) {}
+  : model_(model), sysmenu_hwnd_(sysmenu_hwnd), is_popup_menu_(true) {}
 
 NativeMenuWin::~NativeMenuWin() {
   items_.clear();
@@ -211,14 +211,18 @@
     if (menu_) {
       DestroyMenu(menu_);
     }
-    menu_ = CreatePopupMenu();
+    if (is_popup_menu_)
+      menu_ = CreatePopupMenu();
+    else
+      menu_ = CreateMenu();
     // Rather than relying on the return value of TrackPopupMenuEx, which is
     // always a command identifier, instead we tell the menu to notify us via
     // our host window and the WM_MENUCOMMAND message.
     MENUINFO mi = {0};
     mi.cbSize = sizeof(mi);
     mi.fMask = MIM_STYLE | MIM_MENUDATA;
-    mi.dwStyle = MNS_NOTIFYBYPOS;
+    if (is_popup_menu_)
+      mi.dwStyle = MNS_NOTIFYBYPOS;
     mi.dwMenuData = reinterpret_cast<ULONG_PTR>(this);
     SetMenuInfo(menu_, &mi);
   }
diff -r -u --color up/chromium/ui/views/controls/menu/native_menu_win.h nw/chromium/ui/views/controls/menu/native_menu_win.h
--- up/chromium/ui/views/controls/menu/native_menu_win.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/controls/menu/native_menu_win.h	2024-08-26 19:32:47.010593841 +0000
@@ -37,6 +37,9 @@
   void Rebuild(MenuInsertionDelegateWin* delegate);
   void UpdateStates();
 
+  void set_is_popup_menu(bool flag) { is_popup_menu_ = flag; }
+  HMENU menu() const { return menu_; }
+
  private:
   // IMPORTANT: Note about indices.
   //            Functions in this class deal in two index spaces:
@@ -99,6 +102,9 @@
 
   // If we're a submenu, this is our parent.
   raw_ptr<NativeMenuWin> parent_ = nullptr;
+
+  // A flag to indicate whether to create a menubar or popupmenu.
+  bool is_popup_menu_;
 };
 
 }  // namespace views
diff -r -u --color up/chromium/ui/views/view.h nw/chromium/ui/views/view.h
--- up/chromium/ui/views/view.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/view.h	2024-08-26 19:32:47.054593849 +0000
@@ -2174,8 +2174,10 @@
   // Implementation of synchronous layout. DeprecatedLayoutImmediately() is a
   // temporary public accessor to this; this is the access point for the few
   // blessed uses.
-  void LayoutImmediately();
 
+ public:
+  void LayoutImmediately();
+ private:
   // Input ---------------------------------------------------------------------
 
   bool ProcessMousePressed(const ui::MouseEvent& event);
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.cc nw/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.cc
--- up/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.cc	2024-08-26 19:32:47.058593851 +0000
@@ -875,6 +875,14 @@
   desktop_window_tree_host_->SetBoundsInDIP(bounds);
 }
 
+#if defined(OS_WIN)
+void DesktopNativeWidgetAura::SetPosition(const gfx::Point& pos) {
+  if (!content_window_)
+    return;
+  desktop_window_tree_host_->SetPositionInDIP(pos);
+}
+#endif
+
 void DesktopNativeWidgetAura::SetBoundsConstrained(const gfx::Rect& bounds) {
   if (!content_window_)
     return;
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.h nw/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.h
--- up/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.h	2024-08-26 19:32:47.058593851 +0000
@@ -155,6 +155,9 @@
   gfx::Rect GetRestoredBounds() const override;
   std::string GetWorkspace() const override;
   void SetBounds(const gfx::Rect& bounds) override;
+#if defined(OS_WIN)
+  void SetPosition(const gfx::Point& pos) override;
+#endif
   void SetBoundsConstrained(const gfx::Rect& bounds) override;
   void SetSize(const gfx::Size& size) override;
   void StackAbove(gfx::NativeView native_view) override;
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.cc nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.cc
--- up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.cc	2024-08-26 19:32:47.058593851 +0000
@@ -5,6 +5,10 @@
 #include "ui/views/widget/desktop_aura/desktop_window_tree_host.h"
 
 #include "build/build_config.h"
+#if defined(OS_WIN)
+#include "ui/display/win/screen_win.h"
+#endif
+
 #include "ui/aura/window.h"
 #include "ui/aura/window_tree_host.h"
 #include "ui/display/screen.h"
@@ -22,6 +26,14 @@
 
 void DesktopWindowTreeHost::PaintAsActiveChanged() {}
 
+#if defined(OS_WIN)
+void DesktopWindowTreeHost::SetPositionInDIP(const gfx::Point& pos) {
+  const gfx::Point pos_in_pixels =
+    display::win::ScreenWin::DIPToScreenPoint(pos);
+  AsWindowTreeHost()->SetPositionInPixels(pos_in_pixels);
+}
+#endif
+
 std::unique_ptr<aura::client::ScreenPositionClient>
 DesktopWindowTreeHost::CreateScreenPositionClient() {
   return std::make_unique<DesktopScreenPositionClient>(
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.h nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.h
--- up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.h	2024-08-26 19:32:47.058593851 +0000
@@ -222,6 +222,11 @@
   virtual void UpdateWindowShapeIfNeeded(const ui::PaintContext& context);
 
   virtual DesktopNativeCursorManager* GetSingletonDesktopNativeCursorManager();
+
+#if defined(OS_WIN)
+  virtual void SetPositionInDIP(const gfx::Point& pos);
+#endif
+
 };
 
 }  // namespace views
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
--- up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc	2024-08-26 19:32:47.062593851 +0000
@@ -547,7 +547,7 @@
   // but merely of the content Chrome draws, so even when the system titlebars
   // appear opaque (Win 8+), the content above them needs to be transparent, or
   // they'll be covered by a black (undrawn) region.
-  return ShouldUseNativeFrame() && !IsFullscreen();
+  return ShouldUseNativeFrame() && (content::g_support_transparency || !IsFullscreen());
 }
 
 void DesktopWindowTreeHostWin::FrameTypeChanged() {
@@ -658,6 +658,10 @@
   return without_expansion;
 }
 
+void DesktopWindowTreeHostWin::SetPositionInPixels(const gfx::Point& pos) {
+  message_handler_->SetPosition(pos);
+}
+
 void DesktopWindowTreeHostWin::SetBoundsInPixels(const gfx::Rect& bounds) {
   // If the window bounds have to be expanded we need to subtract the
   // window_expansion_top_left_delta_ from the origin and add the
@@ -929,6 +933,15 @@
              : nullptr;
 }
 
+bool DesktopWindowTreeHostWin::ShouldHandleOnSize() const {
+  return GetWidget()->widget_delegate()->ShouldHandleOnSize();
+}
+
+bool DesktopWindowTreeHostWin::HandleSize(UINT param, const gfx::Size& new_size) {
+  return GetWidget()->widget_delegate() &&
+      GetWidget()->widget_delegate()->HandleSize(param, new_size);
+}
+
 void DesktopWindowTreeHostWin::HandleActivationChanged(bool active) {
   // This can be invoked from HWNDMessageHandler::Init(), at which point we're
   // not in a good state and need to ignore it.
@@ -943,7 +956,7 @@
   // We treat APPCOMMAND ids as an extension of our command namespace, and just
   // let the delegate figure out what to do...
   return GetWidget()->widget_delegate() &&
-         GetWidget()->widget_delegate()->ExecuteWindowsCommand(command);
+      GetWidget()->widget_delegate()->ExecuteAppCommand(command);
 }
 
 void DesktopWindowTreeHostWin::HandleCancelMode() {
@@ -956,6 +969,9 @@
 
 void DesktopWindowTreeHostWin::HandleClose() {
   GetWidget()->Close();
+  //bugfix where transparent window size is getting smaller during closing
+  if (content::g_support_transparency && message_handler_->is_translucent())
+    window_enlargement_ = gfx::Vector2d(0, 0);
 }
 
 bool DesktopWindowTreeHostWin::HandleCommand(int command) {
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
--- up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h	2024-08-26 19:32:47.062593851 +0000
@@ -171,6 +171,7 @@
   gfx::Rect GetBoundsInPixels() const override;
   void SetBoundsInPixels(const gfx::Rect& bounds) override;
   gfx::Rect GetBoundsInAcceleratedWidgetPixelCoordinates() override;
+  void SetPositionInPixels(const gfx::Point& pos) override;
   gfx::Point GetLocationOnScreenInPixels() const override;
   void SetCapture() override;
   void ReleaseCapture() override;
@@ -196,6 +197,8 @@
 
   // Overridden from HWNDMessageHandlerDelegate:
   ui::InputMethod* GetHWNDMessageDelegateInputMethod() override;
+  bool ShouldHandleOnSize() const override;
+  bool HandleSize(UINT param, const gfx::Size& new_size) override;
   bool HasNonClientView() const override;
   FrameMode GetFrameMode() const override;
   bool HasFrame() const override;
diff -r -u --color up/chromium/ui/views/widget/native_widget_delegate.h nw/chromium/ui/views/widget/native_widget_delegate.h
--- up/chromium/ui/views/widget/native_widget_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/native_widget_delegate.h	2024-08-26 19:32:47.062593851 +0000
@@ -40,6 +40,7 @@
  public:
   virtual ~NativeWidgetDelegate() = default;
 
+  virtual bool NWCanClose(bool user_force = false) const = 0;
   // Returns true if the window is modal.
   virtual bool IsModal() const = 0;
 
diff -r -u --color up/chromium/ui/views/widget/native_widget_mac.mm nw/chromium/ui/views/widget/native_widget_mac.mm
--- up/chromium/ui/views/widget/native_widget_mac.mm	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/native_widget_mac.mm	2024-08-26 19:32:47.062593851 +0000
@@ -47,6 +47,10 @@
 
 using remote_cocoa::mojom::WindowVisibilityState;
 
+namespace content {
+  extern bool g_support_transparency;
+}
+
 namespace views {
 
 namespace {
@@ -467,6 +471,8 @@
     *show_state = ui::SHOW_STATE_FULLSCREEN;
   else if (IsMinimized())
     *show_state = ui::SHOW_STATE_MINIMIZED;
+  else if (IsMaximized())
+    *show_state = ui::SHOW_STATE_MAXIMIZED;
   else
     *show_state = ui::SHOW_STATE_NORMAL;
 }
@@ -653,8 +659,9 @@
     case ui::SHOW_STATE_NORMAL:
     case ui::SHOW_STATE_INACTIVE:
     case ui::SHOW_STATE_MINIMIZED:
-      break;
+    case ui::SHOW_STATE_HIDDEN:
     case ui::SHOW_STATE_MAXIMIZED:
+      break;
     case ui::SHOW_STATE_FULLSCREEN:
       NOTIMPLEMENTED();
       break;
@@ -672,6 +679,8 @@
                        : WindowVisibilityState::kShowInactive;
   }
   GetNSWindowHost()->SetVisibilityState(window_state);
+  if (show_state == ui::SHOW_STATE_MAXIMIZED)
+    GetNSWindowMojo()->SetRestoredBounds(restore_bounds);
 
   // Ignore the SetInitialFocus() result. BridgedContentView should get
   // firstResponder status regardless.
@@ -729,7 +738,9 @@
 void NativeWidgetMac::Maximize() {
   if (!GetNSWindowMojo())
     return;
-  GetNSWindowMojo()->SetZoomed(true);
+  if (IsFullscreen())
+    return;
+  GetNSWindowMojo()->SetMaximized(true);
 }
 
 void NativeWidgetMac::Minimize() {
@@ -741,7 +752,7 @@
 bool NativeWidgetMac::IsMaximized() const {
   if (!ns_window_host_)
     return false;
-  return ns_window_host_->IsZoomed();
+  return ns_window_host_->IsMaximized();
 }
 
 bool NativeWidgetMac::IsMinimized() const {
@@ -755,7 +766,7 @@
     return;
   GetNSWindowMojo()->ExitFullscreen();
   GetNSWindowMojo()->SetMiniaturized(false);
-  GetNSWindowMojo()->SetZoomed(false);
+  GetNSWindowMojo()->SetMaximized(false);
 }
 
 void NativeWidgetMac::SetFullscreen(bool fullscreen,
diff -r -u --color up/chromium/ui/views/widget/native_widget_private.cc nw/chromium/ui/views/widget/native_widget_private.cc
--- up/chromium/ui/views/widget/native_widget_private.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/native_widget_private.cc	2024-08-26 19:32:47.062593851 +0000
@@ -14,6 +14,11 @@
 
 namespace internal {
 
+#if defined(OS_WIN)
+void NativeWidgetPrivate::SetPosition(const gfx::Point& pos) {
+
+}
+#endif
 // static
 gfx::Rect NativeWidgetPrivate::ConstrainBoundsToDisplayWorkArea(
     const gfx::Rect& bounds) {
diff -r -u --color up/chromium/ui/views/widget/native_widget_private.h nw/chromium/ui/views/widget/native_widget_private.h
--- up/chromium/ui/views/widget/native_widget_private.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/native_widget_private.h	2024-08-26 19:32:47.062593851 +0000
@@ -178,6 +178,9 @@
   virtual gfx::Rect GetRestoredBounds() const = 0;
   virtual std::string GetWorkspace() const = 0;
   virtual void SetBounds(const gfx::Rect& bounds) = 0;
+#if defined(OS_WIN)
+  virtual void SetPosition(const gfx::Point& pos);
+#endif
   virtual void SetBoundsConstrained(const gfx::Rect& bounds) = 0;
   virtual void SetSize(const gfx::Size& size) = 0;
   virtual void StackAbove(gfx::NativeView native_view) = 0;
diff -r -u --color up/chromium/ui/views/widget/widget.cc nw/chromium/ui/views/widget/widget.cc
--- up/chromium/ui/views/widget/widget.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/widget.cc	2024-08-26 19:32:47.066593852 +0000
@@ -511,6 +511,8 @@
     } else if (show_state == ui::SHOW_STATE_MINIMIZED) {
       Minimize();
       saved_show_state_ = ui::SHOW_STATE_MINIMIZED;
+    } else if (show_state == ui::SHOW_STATE_FULLSCREEN) {
+      SetFullscreen(true);
     }
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -699,6 +701,12 @@
     native_widget_->SetBounds(bounds);
 }
 
+#if defined(OS_WIN)
+void Widget::SetPosition(const gfx::Point& pos) {
+  native_widget_->SetPosition(pos);
+}
+#endif
+
 void Widget::SetSize(const gfx::Size& size) {
   if (native_widget_)
     native_widget_->SetSize(size);
@@ -780,13 +788,18 @@
     native_widget_->SetShape(std::move(shape));
 }
 
-void Widget::CloseWithReason(ClosedReason closed_reason) {
+void Widget::CloseWithReason(ClosedReason closed_reason, bool force) {
   if (widget_closed_) {
     // It appears we can hit this code path if you close a modal dialog then
     // close the last browser before the destructor is hit, which triggers
     // invoking Close again.
     return;
   }
+  if (!force && !force_closing_ && !NWCanClose())
+    return;
+  if (force)
+    force_closing_ = true; //for reentering this function after force close
+
   if (block_close_) {
     return;
   }
@@ -794,6 +807,7 @@
                               CloseRequestResult::kCannotClose) {
     return;
   }
+
   // This is the last chance to cancel closing.
   if (widget_delegate_ && !widget_delegate_->OnCloseRequested(closed_reason))
     return;
@@ -827,8 +841,8 @@
     native_widget_->Close();
 }
 
-void Widget::Close() {
-  CloseWithReason(ClosedReason::kUnspecified);
+void Widget::Close(bool force) {
+  CloseWithReason(ClosedReason::kUnspecified, force);
 }
 
 void Widget::CloseNow() {
@@ -1602,6 +1616,10 @@
   return native_widget_initialized_;
 }
 
+bool Widget::NWCanClose(bool user_force) const {
+  return widget_delegate_->NWCanClose(user_force);
+}
+
 bool Widget::OnNativeWidgetActivationChanged(bool active) {
   if (!ShouldHandleNativeWidgetActivationChanged(active))
     return false;
@@ -1751,6 +1769,8 @@
   NotifyCaretBoundsChanged(GetInputMethod());
   SaveWindowPlacementIfInitialized();
 
+  widget_delegate_->OnWidgetResize();
+
   for (WidgetObserver& observer : observers_)
     observer.OnWidgetBoundsChanged(this, GetWindowBoundsInScreen());
 }
diff -r -u --color up/chromium/ui/views/widget/widget.h nw/chromium/ui/views/widget/widget.h
--- up/chromium/ui/views/widget/widget.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/widget.h	2024-08-26 19:32:47.066593852 +0000
@@ -685,6 +685,9 @@
   // Sizes and/or places the widget to the specified bounds, size or position.
   // `bounds` is in screen coordinates.
   void SetBounds(const gfx::Rect& bounds);
+#if defined(OS_WIN)
+  void SetPosition(const gfx::Point& position);
+#endif
   void SetSize(const gfx::Size& size);
 
   // Retrieves the restored size for the window.
@@ -741,13 +744,13 @@
 
   // Equivalent to CloseWithReason(ClosedReason::kUnspecified).
   // DEPRECATED: Please use CloseWithReason() instead.
-  void Close();
+  void Close(bool force = false);
 
   // Hides the widget, then closes it after a return to the message loop,
   // specifying the reason for it having been closed.
   // Note that while you can pass ClosedReason::kUnspecified, it is highly
   // discouraged and only supported for backwards-compatibility with Close().
-  void CloseWithReason(ClosedReason closed_reason);
+  void CloseWithReason(ClosedReason closed_reason, bool force = false);
 
   // A UI test which tries to asynchronously examine a widget (e.g. the pixel
   // tests) will fail if the widget is closed before that.  This can happen
@@ -1151,6 +1154,7 @@
 
   base::WeakPtr<Widget> GetWeakPtr();
 
+  bool NWCanClose(bool user_force = false) const override;
   // Overridden from NativeWidgetDelegate:
   bool IsModal() const override;
   bool IsDialogBox() const override;
@@ -1440,6 +1444,7 @@
   // Note that this may be ClosedReason::kUnspecified if the deprecated Close()
   // method was called rather than CloseWithReason().
   ClosedReason closed_reason_ = ClosedReason::kUnspecified;
+  bool force_closing_ = false;
 
   // The saved "show" state for this window. See note in SetInitialBounds
   // that explains why we save this.
diff -r -u --color up/chromium/ui/views/widget/widget_delegate.cc nw/chromium/ui/views/widget/widget_delegate.cc
--- up/chromium/ui/views/widget/widget_delegate.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/widget_delegate.cc	2024-08-26 19:32:47.066593852 +0000
@@ -64,6 +64,8 @@
 
 void WidgetDelegate::OnWidgetMove() {}
 
+void WidgetDelegate::OnWidgetResize() {}
+
 void WidgetDelegate::OnDisplayChanged() {}
 
 void WidgetDelegate::OnWorkAreaChanged() {}
@@ -108,6 +110,10 @@
   return can_activate_;
 }
 
+bool WidgetDelegate::NWCanClose(bool user_force) const {
+  return true;
+}
+
 ui::ModalType WidgetDelegate::GetModalType() const {
   return params_.modal_type;
 }
@@ -198,6 +204,10 @@
   return params_.show_close_button;
 }
 
+bool WidgetDelegate::ShouldHandleOnSize() const {
+  return false;
+}
+
 ui::ImageModel WidgetDelegate::GetWindowAppIcon() {
   // Prefer app icon if available.
   if (!params_.app_icon.IsEmpty())
@@ -219,6 +229,14 @@
   return false;
 }
 
+bool WidgetDelegate::ExecuteAppCommand(int command_id) {
+  return ExecuteWindowsCommand(command_id);
+}
+
+bool WidgetDelegate::HandleSize(unsigned int param, const gfx::Size& size) {
+  return false;
+}
+
 std::string WidgetDelegate::GetWindowName() const {
   return std::string();
 }
diff -r -u --color up/chromium/ui/views/widget/widget_delegate.h nw/chromium/ui/views/widget/widget_delegate.h
--- up/chromium/ui/views/widget/widget_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/widget_delegate.h	2024-08-26 19:32:47.066593852 +0000
@@ -128,6 +128,7 @@
 
   // Called whenever the widget's position changes.
   virtual void OnWidgetMove();
+  virtual void OnWidgetResize();
 
   // Called with the display changes (color depth or resolution).
   virtual void OnDisplayChanged();
@@ -170,6 +171,7 @@
 
   // Returns true if the window can be activated.
   virtual bool CanActivate() const;
+  virtual bool NWCanClose(bool user_force = false) const;
 
   // Returns the modal type that applies to the widget. Default is
   // ui::MODAL_TYPE_NONE (not modal).
@@ -189,6 +191,8 @@
   // Returns true if the window should show a close button in the title bar.
   virtual bool ShouldShowCloseButton() const;
 
+  virtual bool ShouldHandleOnSize() const;
+
   // Returns the app icon for the window. On Windows, this is the ICON_BIG used
   // in Alt-Tab list and Win7's taskbar.
   virtual ui::ImageModel GetWindowAppIcon();
@@ -203,6 +207,10 @@
   // was handled, false if it was not.
   virtual bool ExecuteWindowsCommand(int command_id);
 
+  virtual bool ExecuteAppCommand(int command_id);
+
+  virtual bool HandleSize(unsigned int param, const gfx::Size& size);
+
   // Returns the window's name identifier. Used to identify this window for
   // state restoration.
   virtual std::string GetWindowName() const;
diff -r -u --color up/chromium/ui/views/widget/widget_hwnd_utils.cc nw/chromium/ui/views/widget/widget_hwnd_utils.cc
--- up/chromium/ui/views/widget/widget_hwnd_utils.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/widget/widget_hwnd_utils.cc	2024-08-26 19:32:47.066593852 +0000
@@ -11,6 +11,7 @@
 #include "ui/base/l10n/l10n_util_win.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/ui_base_switches.h"
+#include "ui/display/display.h"
 #include "ui/views/widget/widget_delegate.h"
 #include "ui/views/win/hwnd_message_handler.h"
 
@@ -82,8 +83,19 @@
           native_widget_delegate->IsDialogBox() ? WS_EX_DLGMODALFRAME : 0;
 
       // See layered window comment below.
-      if (is_translucent)
-        *style &= static_cast<DWORD>(~(WS_THICKFRAME | WS_CAPTION));
+      if (content::g_support_transparency && is_translucent) {
+        if (params.remove_standard_frame) {
+          *style &= static_cast<DWORD>(~(WS_CAPTION));
+        }
+        if (!native_widget_delegate->IsDialogBox() && !native_widget_delegate->IsModal()) {
+          if (content::g_force_cpu_draw)
+            *ex_style |= WS_EX_LAYERED;
+        }
+      } else {
+        if (is_translucent)
+          *style &= static_cast<DWORD>(~(WS_THICKFRAME | WS_CAPTION));
+      }
+
       break;
     }
     case Widget::InitParams::TYPE_CONTROL:
@@ -155,8 +167,9 @@
   //    style.
   //
   // Software composited windows can continue to use WS_EX_LAYERED.
-  bool is_translucent =
-      (params.opacity == Widget::InitParams::WindowOpacity::kTranslucent);
+  bool is_translucent = !content::g_support_transparency ?
+      (params.opacity == Widget::InitParams::WindowOpacity::kTranslucent) :
+      (params.opacity == Widget::InitParams::WindowOpacity::kTranslucent || params.force_software_compositing);
 
   CalculateWindowStylesFromInitParams(params, widget_delegate,
                                       native_widget_delegate, is_translucent,
diff -r -u --color up/chromium/ui/views/win/hwnd_message_handler.cc nw/chromium/ui/views/win/hwnd_message_handler.cc
--- up/chromium/ui/views/win/hwnd_message_handler.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/win/hwnd_message_handler.cc	2024-08-26 19:32:47.070593852 +0000
@@ -400,6 +400,8 @@
   return base::WrapUnique(message_handler);
 }
 
+#define TRANSPARENCY(original, addition) content::g_support_transparency ? original addition : original
+
 HWNDMessageHandler::HWNDMessageHandler(HWNDMessageHandlerDelegate* delegate,
                                        const std::string& debugging_id)
     : WindowImpl(debugging_id),
@@ -447,6 +449,16 @@
 
   // Create the platform window.
   WindowImpl::Init(parent, bounds);
+  if (content::g_support_transparency && is_translucent_ && !content::g_force_cpu_draw) {
+    //WS_CAPTION style is somehow applied, during window creation, needs to update the style
+	  set_window_style((DWORD)GetWindowLong(hwnd(), GWL_STYLE));
+    //copied from WindowImpl::Init, see "First nccalcszie" comment
+    if (window_style() & WS_CAPTION) {
+      SetWindowPos(hwnd(), NULL, 0, 0, 0, 0,
+        SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE |
+        SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW);
+    }
+  }
 
   InitExtras();
 }
@@ -920,13 +932,16 @@
                                         const gfx::ImageSkia& app_icon) {
   if (!window_icon.isNull()) {
     base::win::ScopedHICON previous_icon = std::move(window_icon_);
-    window_icon_ = IconUtil::CreateHICONFromSkBitmap(*window_icon.bitmap());
+    window_icon_ =
+        IconUtil::CreateHICONFromSkBitmapSizedTo(*window_icon.bitmap(),
+          GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON));
     SendMessage(hwnd(), WM_SETICON, ICON_SMALL,
                 reinterpret_cast<LPARAM>(window_icon_.get()));
   }
   if (!app_icon.isNull()) {
     base::win::ScopedHICON previous_icon = std::move(app_icon_);
-    app_icon_ = IconUtil::CreateHICONFromSkBitmap(*app_icon.bitmap());
+    app_icon_ = IconUtil::CreateHICONFromSkBitmapSizedTo(*app_icon.bitmap(),
+          GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON));
     SendMessage(hwnd(), WM_SETICON, ICON_BIG,
                 reinterpret_cast<LPARAM>(app_icon_.get()));
   }
@@ -993,7 +1008,7 @@
 
   // Windows cannot have WS_THICKFRAME set if translucent.
   // See CalculateWindowStylesFromInitParams().
-  if (delegate_->CanResize() && !is_translucent_) {
+  if (delegate_->CanResize() && (content::g_support_transparency || !is_translucent_)) {
     style |= WS_THICKFRAME | WS_MAXIMIZEBOX;
     if (!delegate_->CanMaximize())
       style &= ~WS_MAXIMIZEBOX;
@@ -1005,6 +1020,10 @@
   } else {
     style &= ~WS_MINIMIZEBOX;
   }
+  if (content::g_support_transparency && is_translucent_ && !content::g_force_cpu_draw) {
+    //WS_CAPTION needs to be removed on transparent window, or else the Title bar will be rendered
+    style &= ~WS_CAPTION;
+  }
   SetWindowLong(hwnd(), GWL_STYLE, style);
 }
 
@@ -1559,6 +1578,10 @@
     if (!delegate_->HasFrame())
       frame_thickness -= 1;
     *insets = gfx::Insets(frame_thickness);
+    if (content::g_force_cpu_draw && is_translucent_ && !delegate_->HasFrame()) {
+      //part of maximize_hack code
+      insets->set_top_bottom(0, -1).set_left_right(0, -1);
+    }
     return true;
   }
 
@@ -1575,7 +1598,7 @@
   // allow for a custom hit mask.
   if (!is_translucent_ && !custom_window_region_.is_valid() &&
       (IsFrameSystemDrawn() || !delegate_->HasNonClientView())) {
-    if (force)
+    if (force || content::g_force_cpu_draw)
       SetWindowRgn(hwnd(), nullptr, redraw);
     return;
   }
@@ -1600,6 +1623,10 @@
     RECT work_rect = mi.rcWork;
     OffsetRect(&work_rect, -window_rect.left, -window_rect.top);
     new_region.reset(CreateRectRgnIndirect(&work_rect));
+  } else if (content::g_support_transparency && is_translucent_) {
+    RECT work_rect = window_rect;
+    OffsetRect(&work_rect, -window_rect.left, -window_rect.top);
+    new_region.reset(CreateRectRgnIndirect(&work_rect));
   } else {
     SkPath window_mask;
     delegate_->GetWindowMask(gfx::Size(window_rect.right - window_rect.left,
@@ -1737,7 +1764,7 @@
   SendMessage(hwnd(), WM_CHANGEUISTATE, MAKELPARAM(UIS_CLEAR, UISF_HIDEFOCUS),
               0);
 
-  if (!delegate_->HasFrame()) {
+  if (TRANSPARENCY(!delegate_->HasFrame(), && !(is_translucent_))) {
     SetWindowLong(hwnd(), GWL_STYLE,
                   GetWindowLong(hwnd(), GWL_STYLE) & ~WS_CAPTION);
     SendFrameChanged();
@@ -1912,15 +1939,17 @@
   if (delegate_->WidgetSizeIsClientSize()) {
     RECT client_rect, window_rect;
     GetClientRect(hwnd(), &client_rect);
-    GetWindowRect(hwnd(), &window_rect);
-    CR_DEFLATE_RECT(&window_rect, &client_rect);
-    min_window_size.Enlarge(window_rect.right - window_rect.left,
-                            window_rect.bottom - window_rect.top);
-    // Either axis may be zero, so enlarge them independently.
-    if (max_window_size.width())
-      max_window_size.Enlarge(window_rect.right - window_rect.left, 0);
-    if (max_window_size.height())
-      max_window_size.Enlarge(0, window_rect.bottom - window_rect.top);
+	if (client_rect.right > client_rect.left) {
+		GetWindowRect(hwnd(), &window_rect);
+		CR_DEFLATE_RECT(&window_rect, &client_rect);
+		min_window_size.Enlarge(window_rect.right - window_rect.left,
+			window_rect.bottom - window_rect.top);
+		// Either axis may be zero, so enlarge them independently.
+		if (max_window_size.width())
+			max_window_size.Enlarge(window_rect.right - window_rect.left, 0);
+		if (max_window_size.height())
+			max_window_size.Enlarge(0, window_rect.bottom - window_rect.top);
+	}
   }
   minmax_info->ptMinTrackSize.x = min_window_size.width();
   minmax_info->ptMinTrackSize.y = min_window_size.height();
@@ -2296,9 +2325,11 @@
     }
   }
 
+  const LONG noTitleBar = (is_translucent_) && !delegate_->HasFrame();
   gfx::Insets insets;
   bool got_insets = GetClientAreaInsets(&insets, monitor);
-  if (!got_insets && !IsFullscreen() && !(mode && !delegate_->HasFrame())) {
+  if (TRANSPARENCY(!got_insets && !IsFullscreen() &&
+                   !(mode && !delegate_->HasFrame()), && !noTitleBar)) {
     SetMsgHandled(FALSE);
     return 0;
   }
@@ -2680,6 +2711,8 @@
   // ResetWindowRegion is going to trigger WM_NCPAINT. By doing it after we've
   // invoked OnSize we ensure the RootView has been laid out.
   ResetWindowRegion(false, true);
+  if (delegate_->ShouldHandleOnSize())
+    delegate_->HandleSize(param, size);
 }
 
 void HWNDMessageHandler::OnSizing(UINT param, RECT* rect) {
@@ -2700,6 +2733,15 @@
   *rect = window_rect.ToRECT();
 }
 
+void HWNDMessageHandler::OnStyleChanging(UINT nStyleType, LPSTYLESTRUCT lpStyleStruct) {
+  if (!content::g_support_transparency)
+    return;
+  if (nStyleType == (UINT)GWL_EXSTYLE)
+    set_window_ex_style(lpStyleStruct->styleNew);
+  else if (nStyleType == (UINT)GWL_STYLE)
+    set_window_style(lpStyleStruct->styleNew);
+}
+
 void HWNDMessageHandler::OnSysCommand(UINT notification_code,
                                       const gfx::Point& point) {
   // Windows uses the 4 lower order bits of |notification_code| for type-
@@ -2932,12 +2974,13 @@
           expected_maximized_bounds.Inset(
               gfx::ScaleToCeiledInsets(client_area_insets, -1));
       }
+      const bool maximize_hack = content::g_force_cpu_draw && is_translucent_;
       // Sometimes Windows incorrectly changes bounds of maximized windows after
       // attaching or detaching additional displays. In this case user can see
       // non-client area of the window (that should be hidden in normal case).
       // We should restore window position if problem occurs.
       const bool incorrect_maximized_bounds =
-          IsMaximized() && have_new_window_rect &&
+          IsMaximized() && (maximize_hack || have_new_window_rect) &&
           (expected_maximized_bounds.x() != window_pos->x ||
            expected_maximized_bounds.y() != window_pos->y ||
            expected_maximized_bounds.width() != window_pos->cx ||
@@ -2989,7 +3032,7 @@
         // Now ignore all immediately-following SetWindowPos() changes.  Windows
         // likes to (incorrectly) recalculate what our position/size should be
         // and send us further updates.
-        ignore_window_pos_changes_ = true;
+        ignore_window_pos_changes_ = !maximize_hack;
         base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(
             FROM_HERE,
             base::BindOnce(&HWNDMessageHandler::StopIgnoringPosChanges,
@@ -3498,6 +3541,11 @@
   CHECK(IsFrameSystemDrawn());
 
   dwm_transition_desired_ = false;
+  if (content::g_support_transparency && !content::g_force_cpu_draw && is_translucent_) {
+    const int im = -1;
+    MARGINS m = { im, im, im, im };
+    DwmExtendFrameIntoClientArea(hwnd(), &m);
+  }
   delegate_->HandleFrameChanged();
   SendFrameChanged();
 }
@@ -3619,6 +3667,11 @@
   return handled;
 }
 
+void HWNDMessageHandler::SetPosition(const gfx::Point& pos_in_pixels) {
+  SetWindowPos(hwnd(), nullptr, pos_in_pixels.x(), pos_in_pixels.y(),
+    0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
+}
+
 void HWNDMessageHandler::SetBoundsInternal(const gfx::Rect& bounds_in_pixels,
                                            bool force_size_changed) {
   gfx::Size old_size = GetClientAreaBounds().size();
diff -r -u --color up/chromium/ui/views/win/hwnd_message_handler.h nw/chromium/ui/views/win/hwnd_message_handler.h
--- up/chromium/ui/views/win/hwnd_message_handler.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/win/hwnd_message_handler.h	2024-08-26 19:32:47.070593852 +0000
@@ -482,6 +482,7 @@
     CR_MSG_WM_SETTINGCHANGE(OnSettingChange)
     CR_MSG_WM_SIZE(OnSize)
     CR_MSG_WM_SIZING(OnSizing)
+    CR_MSG_WM_STYLECHANGING(OnStyleChanging)
     CR_MSG_WM_SYSCOMMAND(OnSysCommand)
     CR_MSG_WM_THEMECHANGED(OnThemeChanged)
     CR_MSG_WM_TIMECHANGE(OnTimeChange)
@@ -541,6 +542,7 @@
   void OnSettingChange(UINT flags, const wchar_t* section);
   void OnSize(UINT param, const gfx::Size& size);
   void OnSizing(UINT param, RECT* rect);
+  void OnStyleChanging(UINT nStyleType, LPSTYLESTRUCT lpStyleStruct);
   void OnSysCommand(UINT notification_code, const gfx::Point& point);
   void OnThemeChanged();
   void OnTimeChange();
@@ -618,6 +620,8 @@
                                   WPARAM w_param,
                                   LPARAM l_param);
 
+  void SetPosition(const gfx::Point& pos_in_pixels);
+
   // Checks if there is a full screen window on the same monitor as the
   // |window| which is becoming active. If yes then we reduce the size of the
   // fullscreen window by 1 px to ensure that maximized windows on the same
diff -r -u --color up/chromium/ui/views/win/hwnd_message_handler_delegate.h nw/chromium/ui/views/win/hwnd_message_handler_delegate.h
--- up/chromium/ui/views/win/hwnd_message_handler_delegate.h	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/win/hwnd_message_handler_delegate.h	2024-08-26 19:32:47.070593852 +0000
@@ -114,6 +114,10 @@
 
   virtual gfx::NativeViewAccessible GetNativeViewAccessible() = 0;
 
+  // on windows, maximizing sometime is sent through WM_SIZE, not
+  // WM_SYSCOMMAND, see node-webkit#753
+  virtual bool ShouldHandleOnSize() const = 0;
+
   // TODO(beng): Investigate migrating these methods to On* prefixes once
   // HWNDMessageHandler is the WindowImpl.
 
@@ -138,6 +142,8 @@
   // true if the command was handled.
   virtual bool HandleCommand(int command) = 0;
 
+  virtual bool HandleSize(UINT param, const gfx::Size& size) = 0;
+
   // Called when an accelerator is invoked.
   virtual void HandleAccelerator(const ui::Accelerator& accelerator) = 0;
 
diff -r -u --color up/chromium/ui/views/window/custom_frame_view.cc nw/chromium/ui/views/window/custom_frame_view.cc
--- up/chromium/ui/views/window/custom_frame_view.cc	2024-08-14 00:08:24.000000000 +0000
+++ nw/chromium/ui/views/window/custom_frame_view.cc	2024-08-26 19:32:47.070593852 +0000
@@ -7,6 +7,8 @@
 #include <algorithm>
 #include <utility>
 #include <vector>
+#include "ui/gfx/image/image_skia_operations.h"
+#include "ui/base/models/image_model.h"
 
 #include "base/containers/adapters.h"
 #include "base/strings/utf_string_conversions.h"
@@ -77,7 +79,7 @@
     : frame_(frame), frame_background_(new FrameBackground()) {
   close_button_ = InitWindowCaptionButton(
       base::BindRepeating(&Widget::CloseWithReason, base::Unretained(frame_),
-                          views::Widget::ClosedReason::kCloseButtonClicked),
+                          views::Widget::ClosedReason::kCloseButtonClicked, false),
       IDS_APP_ACCNAME_CLOSE, IDR_CLOSE, IDR_CLOSE_H, IDR_CLOSE_P);
   minimize_button_ = InitWindowCaptionButton(
       base::BindRepeating(&Widget::Minimize, base::Unretained(frame_)),
@@ -90,10 +92,13 @@
       IDS_APP_ACCNAME_RESTORE, IDR_RESTORE, IDR_RESTORE_H, IDR_RESTORE_P);
 
   if (frame_->widget_delegate()->ShouldShowWindowIcon()) {
-    window_icon_ =
-        AddChildView(std::make_unique<ImageButton>(Button::PressedCallback()));
+    ui::ImageModel icon;
+    icon = frame_->widget_delegate()->GetWindowAppIcon();
+    window_icon_ = new ImageButton(Button::PressedCallback());
+    window_icon_->SetImageModel(Button::STATE_NORMAL, ui::ImageModel::FromImage(icon.GetImage()));
     // `window_icon_` does not need to be focusable as it is not used here as a
     // button and is not interactive.
+    AddChildView(window_icon_.get());
     window_icon_->SetFocusBehavior(FocusBehavior::NEVER);
   }
 }
@@ -174,8 +179,16 @@
 }
 
 void CustomFrameView::UpdateWindowIcon() {
-  if (window_icon_)
+  if (window_icon_) {
+    ui::ImageModel icon;
+    icon = frame_->widget_delegate()->GetWindowAppIcon();
+    int size = IconSize();
+    gfx::ImageSkia icon2 = gfx::ImageSkiaOperations::CreateResizedImage(*icon.GetImage().ToImageSkia(),
+                               skia::ImageOperations::RESIZE_BEST,
+                               gfx::Size(size, size));
+    window_icon_->SetImageModel(Button::STATE_NORMAL, ui::ImageModel::FromImageSkia(icon2));
     window_icon_->SchedulePaint();
+  }
 }
 
 void CustomFrameView::UpdateWindowTitle() {
